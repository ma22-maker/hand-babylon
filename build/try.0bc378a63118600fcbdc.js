(()=>{var __webpack_modules__={862:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{F$:()=>Au});function C(W,A){return A.forEach(function(V){V&&typeof V!="string"&&!Array.isArray(V)&&Object.keys(V).forEach(function($){if($!=="default"&&!($ in W)){var ne=Object.getOwnPropertyDescriptor(V,$);Object.defineProperty(W,$,ne.get?ne:{enumerable:!0,get:function(){return V[$]}})}})}),Object.freeze(W)}const N=1e-7,J=1e-4;class f{constructor(A,V){this.backend=A,this.dataMover=V,this.data=new WeakMap,this.dataIdsCount=0}get(A){return this.data.has(A)||this.dataMover.moveData(this.backend,A),this.data.get(A)}set(A,V){this.dataIdsCount++,this.data.set(A,V)}has(A){return this.data.has(A)}delete(A){return this.dataIdsCount--,this.data.delete(A)}numDataIds(){return this.dataIdsCount}}class i{refCount(A){return O("refCount")}incRef(A){return O("incRef")}timerAvailable(){return!0}time(A){return O("time")}read(A){return O("read")}readSync(A){return O("readSync")}readToGPU(A,V){return O("readToGPU")}numDataIds(){return O("numDataIds")}disposeData(A,V){return O("disposeData")}write(A,V,$){return O("write")}move(A,V,$,ne,xe){return O("move")}createTensorFromGPUData(A,V,$){return O("createTensorFromGPUData")}memory(){return O("memory")}floatPrecision(){return O("floatPrecision")}epsilon(){return this.floatPrecision()===32?N:J}dispose(){return O("dispose")}}function O(W){throw new Error("'"+W+"' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen")}function t(W,A,V){return Math.max(W,Math.min(A,V))}function B(W){return W%2===0?W:W+1}function P(W,A,V){const $=W[A];W[A]=W[V],W[V]=$}function o(W){let A=0;for(let V=0;V<W.length;V++)A+=W[V];return A}function e(W,A){if(!W)throw new Error(typeof A=="string"?A:A())}function Q(W,A,V=""){e(X(W,A),()=>V+(" Shapes "+W+" and "+A+" must match"))}function s(W){e(W!=null,()=>"The input to the tensor constructor must be a non-null value.")}function F(W){if(W.length===0)return 1;let A=W[0];for(let V=1;V<W.length;V++)A*=W[V];return A}function X(W,A){if(W===A)return!0;if(W==null||A==null||W.length!==A.length)return!1;for(let V=0;V<W.length;V++)if(W[V]!==A[V])return!1;return!0}function R(W){return W%1===0}function K(W){const A=Math.ceil(Math.sqrt(W));return[A,Math.ceil(W/A)]}function T(W,A){return A<=W.length?W:W+" ".repeat(A-W.length)}function q(W,A=ne=>0,V,$){return new Promise((ne,xe)=>{let le=0;const ce=()=>{if(W()){ne();return}le++;const ue=A(le);if(V!=null&&le>=V){xe();return}$!=null?$(ce,ue):setTimeout(ce,ue)};ce()})}function l(W,A){let V=1,$=-1;for(let xe=0;xe<W.length;++xe)if(W[xe]>=0)V*=W[xe];else if(W[xe]===-1){if($!==-1)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+$+" and dim "+xe);$=xe}else if(W[xe]<0)throw Error("Shapes can not be < 0. Found "+W[xe]+" at dim "+xe);if($===-1){if(A>0&&A!==V)throw Error("Size("+A+") must match the product of shape "+W);return W}if(V===0)throw Error("Cannot infer the missing size in ["+W+"] when there are 0 elements");if(A%V!==0)throw Error("The implicit shape can't be a fractional number. Got "+A+" / "+V);const ne=W.slice();return ne[$]=A/V,ne}function n(W,A){const V=A.length;return W=W==null?A.map(($,ne)=>ne):[].concat(W),e(W.every($=>$>=-V&&$<V),()=>"All values in axis param must be in range [-"+V+", "+V+") but got axis "+W),e(W.every($=>R($)),()=>"All values in axis param must be integers but got axis "+W),W.map($=>$<0?V+$:$)}function L(W,A){const V=[],$=[],ne=A!=null&&Array.isArray(A)&&A.length===0,xe=A==null||ne?null:n(A,W).sort();let le=0;for(let ce=0;ce<W.length;++ce){if(xe!=null){if(xe[le]===ce&&W[ce]!==1)throw new Error("Can't squeeze axis "+ce+" since its dim '"+W[ce]+"' is not 1");(xe[le]==null||xe[le]>ce)&&W[ce]===1&&(V.push(W[ce]),$.push(ce)),xe[le]<=ce&&le++}W[ce]!==1&&(V.push(W[ce]),$.push(ce))}return{newShape:V,keptDims:$}}function H(W,A){return x(W,A)}function x(W,A){let V=null;if(W==null||W==="float32")V=new Float32Array(A);else if(W==="int32")V=new Int32Array(A);else if(W==="bool")V=new Uint8Array(A);else if(W==="string")V=new Array(A);else throw new Error("Unknown data type "+W);return V}function U(W,A){for(let V=0;V<W.length;V++){const $=W[V];if(isNaN($)||!isFinite($))throw Error("A tensor of type "+A+" being uploaded contains "+$+".")}}function G(W){return W==="bool"||W==="complex64"||W==="float32"||W==="int32"||W==="string"}function Y(W,A){return!(A==="complex64"||A==="float32"&&W!=="complex64"||A==="int32"&&W!=="float32"&&W!=="complex64"||A==="bool"&&W==="bool")}function M(W){if(W==="float32"||W==="int32")return 4;if(W==="complex64")return 8;if(W==="bool")return 1;throw new Error("Unknown dtype "+W)}function h(W){if(W==null)return 0;let A=0;return W.forEach(V=>A+=V.length),A}function j(W){return typeof W=="string"||W instanceof String}function C0(W){return typeof W=="boolean"}function C1(W){return typeof W=="number"}function C2(W){return Array.isArray(W)?C2(W[0]):W instanceof Float32Array?"float32":W instanceof Int32Array||W instanceof Uint8Array||W instanceof Uint8ClampedArray?"int32":C1(W)?"float32":j(W)?"string":C0(W)?"bool":"float32"}function C3(W){return!!(W&&W.constructor&&W.call&&W.apply)}function C4(W,A){for(let V=A;V<W;++V)if(W%V===0)return V;return W}function C5(W){const A=W.length;if(A<2)return[];const V=new Array(A-1);V[A-2]=W[A-1];for(let $=A-3;$>=0;--$)V[$]=V[$+1]*W[$+1];return V}function C6(W,A,V,$=!1){const ne=new Array;if(A.length===1){const xe=A[0]*($?2:1);for(let le=0;le<xe;le++)ne[le]=V[W+le]}else{const xe=A[0],le=A.slice(1),ce=le.reduce((ue,Te)=>ue*Te)*($?2:1);for(let ue=0;ue<xe;ue++)ne[ue]=C6(W+ue*ce,le,V,$)}return ne}function C7(W,A,V=!1){if(W.length===0)return A[0];const $=W.reduce((ne,xe)=>ne*xe)*(V?2:1);if($===0)return[];if($!==A.length)throw new Error("["+W+"] does not match the input size "+A.length+(V?" for a complex tensor":"")+".");return C6(0,W,A,V)}function C8(W,A){if(Array.isArray(W))return W;if(A==="float32")return W instanceof Float32Array?W:new Float32Array(W);if(A==="int32")return W instanceof Int32Array?W:new Int32Array(W);if(A==="bool"||A==="string")return Uint8Array.from(new Int32Array(W));throw new Error("Unknown dtype "+A)}function C9(W,A){const V=CC(W,A);for(let $=0;$<V.length;$++)V[$]=1;return V}function CC(W,A){if(A==null||A==="float32"||A==="complex64")return new Float32Array(W);if(A==="int32")return new Int32Array(W);if(A==="bool")return new Uint8Array(W);throw new Error("Unknown data type "+A)}function Cm(W){W.forEach(A=>{e(Number.isInteger(A)&&A>=0,()=>"Tensor must have a shape comprised of positive integers but got shape ["+W+"].")})}function CN(W,A,V){if(A===0)return 0;if(A===1)return W[0];let $=W[W.length-1];for(let ne=0;ne<W.length-1;++ne)$+=V[ne]*W[ne];return $}function CJ(W,A,V){if(A===0)return[];if(A===1)return[W];const $=new Array(A);for(let ne=0;ne<$.length-1;++ne)$[ne]=Math.floor(W/V[ne]),W-=$[ne]*V[ne];return $[$.length-1]=W,$}function Cf(W){return W&&W.then&&typeof W.then=="function"}const Ci="tfjsflags";class CO{constructor(A){this.global=A,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ct,this.populateURLFlags()}setPlatform(A,V){this.platform!=null&&(Cd().getBool("IS_TEST")||Cd().getBool("PROD")||console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+A+".")),this.platformName=A,this.platform=V}registerFlag(A,V,$){if(this.flagRegistry[A]={evaluationFn:V,setHook:$},this.urlFlags[A]!=null){const ne=this.urlFlags[A];Cd().getBool("IS_TEST")||Cd().getBool("PROD")||console.warn("Setting feature override from URL "+A+": "+ne+"."),this.set(A,ne)}}async getAsync(A){return A in this.flags?this.flags[A]:(this.flags[A]=await this.evaluateFlag(A),this.flags[A])}get(A){if(A in this.flags)return this.flags[A];const V=this.evaluateFlag(A);if(Cf(V))throw new Error("Flag "+A+" cannot be synchronously evaluated. Please use getAsync() instead.");return this.flags[A]=V,this.flags[A]}getNumber(A){return this.get(A)}getBool(A){return this.get(A)}getString(A){return this.get(A)}getFlags(){return this.flags}get features(){return this.flags}set(A,V){if(this.flagRegistry[A]==null)throw new Error("Cannot set flag "+A+" as it has not been registered.");this.flags[A]=V,this.flagRegistry[A].setHook!=null&&this.flagRegistry[A].setHook(V)}evaluateFlag(A){if(this.flagRegistry[A]==null)throw new Error("Cannot evaluate flag '"+A+"': no evaluation function found.");return this.flagRegistry[A].evaluationFn()}setFlags(A){this.flags=Object.assign({},A)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const A=this.getQueryParams(this.global.location.search);Ci in A&&A[Ci].split(",").forEach(V=>{const[$,ne]=V.split(":");this.urlFlags[$]=CS($,ne)})}}function Ct(W){const A={};return W.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(V,...$)=>(CB(A,$[0],$[1]),$.join("="))),A}function CB(W,A,V){W[decodeURIComponent(A)]=decodeURIComponent(V||"")}function CS(W,A){const V=A.toLowerCase();return V==="true"||V==="false"?V==="true":""+ +V===V?+V:A}function Cd(){return CV}let CV=null;function Cb(W){CV=W}let CP;function CE(){if(CP==null){let W;if(typeof window<"u")W=window;else if(typeof __webpack_require__.g<"u")W=__webpack_require__.g;else if(typeof process<"u")W=process;else if(typeof self<"u")W=self;else throw new Error("Could not find a global object");CP=W}return CP}function CD(){const W=CE();return W._tfGlobals==null&&(W._tfGlobals=new Map),W._tfGlobals}function Cg(W,A){const V=CD();if(V.has(W))return V.get(W);{const $=A();return V.set(W,$),V.get(W)}}const CZ="Abs",Co="Add",Ce="AddN",CQ="Atan2",Cs="AvgPool",CF="BatchMatMul",CI="BatchToSpaceND",Cy="Bincount",CA="Cast",Cp="ClipByValue",Cw="Complex",CX="ComplexAbs",Cc="Concat",CW="Conv2D",CR="Conv2DBackpropFilter",CK="Conv2DBackpropInput",CT="Cos",Cv="CropAndResize",Cq="DepthToSpace",Cl="DepthwiseConv2dNative",Ca="DepthwiseConv2dNativeBackpropFilter",Cn="DepthwiseConv2dNativeBackpropInput",CL="RealDiv",CH="Einsum",Ck="Elu",Cz="ExpandDims",Cx="Fill",CU="FlipLeftRight",CG="Floor",Cu="FloorDiv",CY="GatherV2",CM="Greater",Ch="GreaterEqual",Cj="Identity",Cr="Imag",m0="LeakyRelu",m1="Less",m2="LessEqual",m3="LogicalAnd",m4="LogicalOr",m5="Max",m6="Maximum",m7="MaxPool",m8="Mean",m9="Min",mC="Minimum",mm="Multiply",mN="Neg",mJ="NonMaxSuppressionV3",mf="NonMaxSuppressionV4",mi="NonMaxSuppressionV5",mO="Pack",mt="PadV2",mB="Pow",mS="Prelu",md="Range",mV="Real",mb="Relu",mP="Reshape",mE="ResizeNearestNeighbor",mD="ResizeBilinear",mg="Relu6",mZ="Round",mo="TensorScatterUpdate",me="Select",mQ="Slice",ms="Sin",mF="Sigmoid",mI="Sqrt",my="Sum",mA="SpaceToBatchND",mp="SplitV",mw="Square",mX="StridedSlice",mc="Sub",mW="Tile",mR="Transform",mK="Transpose",mT="Unpack",mv="ZerosLike",mq="Step",ml="FromPixels",ma="RotateWithOffset",mn="_FusedMatMul",mL="FusedConv2D",mH="FusedDepthwiseConv2D";function mk(...W){Cd().getBool("IS_TEST")||Cd().getBool("PROD")||console.warn(...W)}function mz(...W){Cd().getBool("IS_TEST")||Cd().getBool("PROD")||console.log(...W)}const mx=Cg("kernelRegistry",()=>new Map),mU=Cg("gradRegistry",()=>new Map);function mG(W,A){const V=mh(W,A);return mx.get(V)}function mu(W){return mU.get(W)}function mY(W){const A=mx.entries(),V=[];for(;;){const{done:$,value:ne}=A.next();if($)break;const[xe,le]=ne,[ce]=xe.split("_");ce===W&&V.push(le)}return V}function mM(W){const{kernelName:A,backendName:V}=W,$=mh(A,V);mx.has($)&&mk("The kernel '"+A+"' for backend '"+V+"' is already registered"),mx.set($,W)}function mh(W,A){return A+"_"+W}function mj(W){return W instanceof Float32Array||W instanceof Int32Array||W instanceof Uint8Array||W instanceof Uint8ClampedArray}var mr=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof __webpack_require__.g<"u"?__webpack_require__.g:typeof self<"u"?self:{};function N0(W){return W&&W.__esModule&&Object.prototype.hasOwnProperty.call(W,"default")?W.default:W}var N1=N3,N2=null;try{N2=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(W){}function N3(W,A,V){this.low=W|0,this.high=A|0,this.unsigned=!!V}N3.prototype.__isLong__,Object.defineProperty(N3.prototype,"__isLong__",{value:!0});function N4(W){return(W&&W.__isLong__)===!0}N3.isLong=N4;var N5={},N6={};function N7(W,A){var V,$,ne;return A?(W>>>=0,(ne=0<=W&&W<256)&&($=N6[W],$)?$:(V=N9(W,(W|0)<0?-1:0,!0),ne&&(N6[W]=V),V)):(W|=0,(ne=-128<=W&&W<128)&&($=N5[W],$)?$:(V=N9(W,W<0?-1:0,!1),ne&&(N5[W]=V),V))}N3.fromInt=N7;function N8(W,A){if(isNaN(W))return A?NV:Nd;if(A){if(W<0)return NV;if(W>=NO)return Ng}else{if(W<=-NB)return NZ;if(W+1>=NB)return ND}return W<0?N8(-W,A).neg():N9(W%Ni|0,W/Ni|0,A)}N3.fromNumber=N8;function N9(W,A,V){return new N3(W,A,V)}N3.fromBits=N9;var NC=Math.pow;function Nm(W,A,V){if(W.length===0)throw Error("empty string");if(W==="NaN"||W==="Infinity"||W==="+Infinity"||W==="-Infinity")return Nd;if(typeof A=="number"?(V=A,A=!1):A=!!A,V=V||10,V<2||36<V)throw RangeError("radix");var $;if(($=W.indexOf("-"))>0)throw Error("interior hyphen");if($===0)return Nm(W.substring(1),A,V).neg();for(var ne=N8(NC(V,8)),xe=Nd,le=0;le<W.length;le+=8){var ce=Math.min(8,W.length-le),ue=parseInt(W.substring(le,le+ce),V);if(ce<8){var Te=N8(NC(V,ce));xe=xe.mul(Te).add(N8(ue))}else xe=xe.mul(ne),xe=xe.add(N8(ue))}return xe.unsigned=A,xe}N3.fromString=Nm;function NN(W,A){return typeof W=="number"?N8(W,A):typeof W=="string"?Nm(W,A):N9(W.low,W.high,typeof A=="boolean"?A:W.unsigned)}N3.fromValue=NN;var NJ=65536,Nf=1<<24,Ni=NJ*NJ,NO=Ni*Ni,NB=NO/2,NS=N7(Nf),Nd=N7(0);N3.ZERO=Nd;var NV=N7(0,!0);N3.UZERO=NV;var Nb=N7(1);N3.ONE=Nb;var NP=N7(1,!0);N3.UONE=NP;var NE=N7(-1);N3.NEG_ONE=NE;var ND=N9(-1,2147483647,!1);N3.MAX_VALUE=ND;var Ng=N9(-1,-1,!0);N3.MAX_UNSIGNED_VALUE=Ng;var NZ=N9(0,-2147483648,!1);N3.MIN_VALUE=NZ;var No=N3.prototype;No.toInt=function(){return this.unsigned?this.low>>>0:this.low},No.toNumber=function(){return this.unsigned?(this.high>>>0)*Ni+(this.low>>>0):this.high*Ni+(this.low>>>0)},No.toString=function(W){if(W=W||10,W<2||36<W)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(NZ)){var A=N8(W),V=this.div(A),$=V.mul(A).sub(this);return V.toString(W)+$.toInt().toString(W)}else return"-"+this.neg().toString(W);for(var ne=N8(NC(W,6),this.unsigned),xe=this,le="";;){var ce=xe.div(ne),ue=xe.sub(ce.mul(ne)).toInt()>>>0,Te=ue.toString(W);if(xe=ce,xe.isZero())return Te+le;for(;Te.length<6;)Te="0"+Te;le=""+Te+le}},No.getHighBits=function(){return this.high},No.getHighBitsUnsigned=function(){return this.high>>>0},No.getLowBits=function(){return this.low},No.getLowBitsUnsigned=function(){return this.low>>>0},No.getNumBitsAbs=function(){if(this.isNegative())return this.eq(NZ)?64:this.neg().getNumBitsAbs();for(var W=this.high!=0?this.high:this.low,A=31;A>0&&!(W&1<<A);A--);return this.high!=0?A+33:A+1},No.isZero=function(){return this.high===0&&this.low===0},No.eqz=No.isZero,No.isNegative=function(){return!this.unsigned&&this.high<0},No.isPositive=function(){return this.unsigned||this.high>=0},No.isOdd=function(){return(this.low&1)===1},No.isEven=function(){return(this.low&1)===0},No.equals=function(W){return N4(W)||(W=NN(W)),this.unsigned!==W.unsigned&&this.high>>>31===1&&W.high>>>31===1?!1:this.high===W.high&&this.low===W.low},No.eq=No.equals,No.notEquals=function(W){return!this.eq(W)},No.neq=No.notEquals,No.ne=No.notEquals,No.lessThan=function(W){return this.comp(W)<0},No.lt=No.lessThan,No.lessThanOrEqual=function(W){return this.comp(W)<=0},No.lte=No.lessThanOrEqual,No.le=No.lessThanOrEqual,No.greaterThan=function(W){return this.comp(W)>0},No.gt=No.greaterThan,No.greaterThanOrEqual=function(W){return this.comp(W)>=0},No.gte=No.greaterThanOrEqual,No.ge=No.greaterThanOrEqual,No.compare=function(W){if(N4(W)||(W=NN(W)),this.eq(W))return 0;var A=this.isNegative(),V=W.isNegative();return A&&!V?-1:!A&&V?1:this.unsigned?W.high>>>0>this.high>>>0||W.high===this.high&&W.low>>>0>this.low>>>0?-1:1:this.sub(W).isNegative()?-1:1},No.comp=No.compare,No.negate=function(){return!this.unsigned&&this.eq(NZ)?NZ:this.not().add(Nb)},No.neg=No.negate,No.add=function(W){N4(W)||(W=NN(W));var A=this.high>>>16,V=this.high&65535,$=this.low>>>16,ne=this.low&65535,xe=W.high>>>16,le=W.high&65535,ce=W.low>>>16,ue=W.low&65535,Te=0,Me=0,Re=0,we=0;return we+=ne+ue,Re+=we>>>16,we&=65535,Re+=$+ce,Me+=Re>>>16,Re&=65535,Me+=V+le,Te+=Me>>>16,Me&=65535,Te+=A+xe,Te&=65535,N9(Re<<16|we,Te<<16|Me,this.unsigned)},No.subtract=function(W){return N4(W)||(W=NN(W)),this.add(W.neg())},No.sub=No.subtract,No.multiply=function(W){if(this.isZero())return Nd;if(N4(W)||(W=NN(W)),N2){var A=N2.mul(this.low,this.high,W.low,W.high);return N9(A,N2.get_high(),this.unsigned)}if(W.isZero())return Nd;if(this.eq(NZ))return W.isOdd()?NZ:Nd;if(W.eq(NZ))return this.isOdd()?NZ:Nd;if(this.isNegative())return W.isNegative()?this.neg().mul(W.neg()):this.neg().mul(W).neg();if(W.isNegative())return this.mul(W.neg()).neg();if(this.lt(NS)&&W.lt(NS))return N8(this.toNumber()*W.toNumber(),this.unsigned);var V=this.high>>>16,$=this.high&65535,ne=this.low>>>16,xe=this.low&65535,le=W.high>>>16,ce=W.high&65535,ue=W.low>>>16,Te=W.low&65535,Me=0,Re=0,we=0,ke=0;return ke+=xe*Te,we+=ke>>>16,ke&=65535,we+=ne*Te,Re+=we>>>16,we&=65535,we+=xe*ue,Re+=we>>>16,we&=65535,Re+=$*Te,Me+=Re>>>16,Re&=65535,Re+=ne*ue,Me+=Re>>>16,Re&=65535,Re+=xe*ce,Me+=Re>>>16,Re&=65535,Me+=V*Te+$*ue+ne*ce+xe*le,Me&=65535,N9(we<<16|ke,Me<<16|Re,this.unsigned)},No.mul=No.multiply,No.divide=function(W){if(N4(W)||(W=NN(W)),W.isZero())throw Error("division by zero");if(N2){if(!this.unsigned&&this.high===-2147483648&&W.low===-1&&W.high===-1)return this;var A=(this.unsigned?N2.div_u:N2.div_s)(this.low,this.high,W.low,W.high);return N9(A,N2.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?NV:Nd;var V,$,ne;if(this.unsigned){if(W.unsigned||(W=W.toUnsigned()),W.gt(this))return NV;if(W.gt(this.shru(1)))return NP;ne=NV}else{if(this.eq(NZ)){if(W.eq(Nb)||W.eq(NE))return NZ;if(W.eq(NZ))return Nb;var xe=this.shr(1);return V=xe.div(W).shl(1),V.eq(Nd)?W.isNegative()?Nb:NE:($=this.sub(W.mul(V)),ne=V.add($.div(W)),ne)}else if(W.eq(NZ))return this.unsigned?NV:Nd;if(this.isNegative())return W.isNegative()?this.neg().div(W.neg()):this.neg().div(W).neg();if(W.isNegative())return this.div(W.neg()).neg();ne=Nd}for($=this;$.gte(W);){V=Math.max(1,Math.floor($.toNumber()/W.toNumber()));for(var le=Math.ceil(Math.log(V)/Math.LN2),ce=le<=48?1:NC(2,le-48),ue=N8(V),Te=ue.mul(W);Te.isNegative()||Te.gt($);)V-=ce,ue=N8(V,this.unsigned),Te=ue.mul(W);ue.isZero()&&(ue=Nb),ne=ne.add(ue),$=$.sub(Te)}return ne},No.div=No.divide,No.modulo=function(W){if(N4(W)||(W=NN(W)),N2){var A=(this.unsigned?N2.rem_u:N2.rem_s)(this.low,this.high,W.low,W.high);return N9(A,N2.get_high(),this.unsigned)}return this.sub(this.div(W).mul(W))},No.mod=No.modulo,No.rem=No.modulo,No.not=function(){return N9(~this.low,~this.high,this.unsigned)},No.and=function(W){return N4(W)||(W=NN(W)),N9(this.low&W.low,this.high&W.high,this.unsigned)},No.or=function(W){return N4(W)||(W=NN(W)),N9(this.low|W.low,this.high|W.high,this.unsigned)},No.xor=function(W){return N4(W)||(W=NN(W)),N9(this.low^W.low,this.high^W.high,this.unsigned)},No.shiftLeft=function(W){return N4(W)&&(W=W.toInt()),(W&=63)===0?this:W<32?N9(this.low<<W,this.high<<W|this.low>>>32-W,this.unsigned):N9(0,this.low<<W-32,this.unsigned)},No.shl=No.shiftLeft,No.shiftRight=function(W){return N4(W)&&(W=W.toInt()),(W&=63)===0?this:W<32?N9(this.low>>>W|this.high<<32-W,this.high>>W,this.unsigned):N9(this.high>>W-32,this.high>=0?0:-1,this.unsigned)},No.shr=No.shiftRight,No.shiftRightUnsigned=function(W){if(N4(W)&&(W=W.toInt()),W&=63,W===0)return this;var A=this.high;if(W<32){var V=this.low;return N9(V>>>W|A<<32-W,A>>>W,this.unsigned)}else return W===32?N9(A,0,this.unsigned):N9(A>>>W-32,0,this.unsigned)},No.shru=No.shiftRightUnsigned,No.shr_u=No.shiftRightUnsigned,No.toSigned=function(){return this.unsigned?N9(this.low,this.high,!1):this},No.toUnsigned=function(){return this.unsigned?this:N9(this.low,this.high,!0)},No.toBytes=function(W){return W?this.toBytesLE():this.toBytesBE()},No.toBytesLE=function(){var W=this.high,A=this.low;return[A&255,A>>>8&255,A>>>16&255,A>>>24,W&255,W>>>8&255,W>>>16&255,W>>>24]},No.toBytesBE=function(){var W=this.high,A=this.low;return[W>>>24,W>>>16&255,W>>>8&255,W&255,A>>>24,A>>>16&255,A>>>8&255,A&255]},N3.fromBytes=function(W,A,V){return V?N3.fromBytesLE(W,A):N3.fromBytesBE(W,A)},N3.fromBytesLE=function(W,A){return new N3(W[0]|W[1]<<8|W[2]<<16|W[3]<<24,W[4]|W[5]<<8|W[6]<<16|W[7]<<24,A)},N3.fromBytesBE=function(W,A){return new N3(W[4]<<24|W[5]<<16|W[6]<<8|W[7],W[0]<<24|W[1]<<16|W[2]<<8|W[3],A)};var Ne=N0(N1),NQ=C({__proto__:null,default:Ne},[N1]);const Ns=Ne||NQ;function NF(W){return Ns.fromString(W,!0,16)}const NI=NF("c3a5c85c97cb3127"),Ny=NF("b492b66fbe98f273"),NA=NF("9ae16a3b2f90404f");function Np(W){return W.xor(W.shru(47))}function Nw(W,A,V){const $=W.slice(A,A+V);return Ns.fromBytes(Array.from($),!0,!0)}function NX(W,A){return Nw(W,A,8)}function Nc(W,A){return Nw(W,A,4)}function NW(W,A){return A===0?W:W.shru(A).or(W.shl(64-A))}function NR(W,A,V=NF("9ddfea08eb382d69")){let $=W.xor(A).mul(V);$=$.xor($.shru(47));let ne=A.xor($).mul(V);return ne=ne.xor(ne.shru(47)),ne=ne.mul(V),ne}function NK(W,A,V,$,ne,xe){ne=ne.add(W),xe=NW(xe.add(ne).add($),21);const le=ne;return ne=ne.add(A),ne=ne.add(V),xe=xe.add(NW(ne,44)),[ne.add($),xe.add(le)]}function NT(W,A,V,$){return NK(NX(W,A),NX(W,A+8),NX(W,A+16),NX(W,A+24),V,$)}function Nv(W,A=W.length){if(A>=8){const V=NA.add(A*2),$=NX(W,0).add(NA),ne=NX(W,A-8),xe=NW(ne,37).mul(V).add($),le=NW($,25).add(ne).mul(V);return NR(xe,le,V)}if(A>=4){const V=NA.add(A*2),$=Nc(W,0);return NR($.shl(3).add(A),Nc(W,A-4),V)}if(A>0){const V=W[0],$=W[A>>1],ne=W[A-1],xe=V+($<<8),le=A+(ne<<2);return Np(NA.mul(xe).xor(NI.mul(le))).mul(NA)}return NA}function Nq(W,A=W.length){const V=NA.add(A*2),$=NX(W,0).mul(Ny),ne=NX(W,8),xe=NX(W,A-8).mul(V),le=NX(W,A-16).mul(NA);return NR(NW($.add(ne),43).add(NW(xe,30)).add(le),$.add(NW(ne.add(NA),18)).add(xe),V)}function Nl(W,A=W.length){const V=NA.add(A*2),$=NX(W,0).mul(NA),ne=NX(W,8),xe=NX(W,A-8).mul(V),le=NX(W,A-16).mul(NA),ce=NW($.add(ne),43).add(NW(xe,30)).add(le),ue=NR(ce,$.add(NW(ne.add(NA),18)).add(xe),V),Te=NX(W,16).mul(V),Me=NX(W,24),Re=ce.add(NX(W,A-32)).mul(V),we=ue.add(NX(W,A-24)).mul(V);return NR(NW(Te.add(Me),43).add(NW(Re,30)).add(we),Te.add(NW(Me.add($),18)).add(Re),V)}function Na(W,A=W.length){const V=Ns.fromNumber(81,!0);if(A<=32)return A<=16?Nv(W,A):Nq(W,A);if(A<=64)return Nl(W,A);let $=V,ne=V.mul(Ny).add(113),xe=Np(ne.mul(NA).add(113)).mul(NA),le=[Ns.UZERO,Ns.UZERO],ce=[Ns.UZERO,Ns.UZERO];$=$.mul(NA).add(NX(W,0));let ue=0;const Te=(A-1>>6)*64,Me=Te+(A-1&63)-63;do $=NW($.add(ne).add(le[0]).add(NX(W,ue+8)),37).mul(Ny),ne=NW(ne.add(le[1]).add(NX(W,ue+48)),42).mul(Ny),$=$.xor(ce[1]),ne=ne.add(le[0]).add(NX(W,ue+40)),xe=NW(xe.add(ce[0]),33).mul(Ny),le=NT(W,ue,le[1].mul(Ny),$.add(ce[0])),ce=NT(W,ue+32,xe.add(ce[1]),ne.add(NX(W,ue+16))),[xe,$]=[$,xe],ue+=64;while(ue!==Te);const Re=Ny.add(xe.and(255).shl(1));return ue=Me,ce[0]=ce[0].add(A-1&63),le[0]=le[0].add(ce[0]),ce[0]=ce[0].add(le[0]),$=NW($.add(ne).add(le[0]).add(NX(W,ue+8)),37).mul(Re),ne=NW(ne.add(le[1]).add(NX(W,ue+48)),42).mul(Re),$=$.xor(ce[1].mul(9)),ne=ne.add(le[0].mul(9).add(NX(W,ue+40))),xe=NW(xe.add(ce[0]),33).mul(Re),le=NT(W,ue,le[1].mul(Re),$.add(ce[0])),ce=NT(W,ue+32,xe.add(ce[1]),ne.add(NX(W,ue+16))),[xe,$]=[$,xe],NR(NR(le[0],ce[0],Re).add(Np(ne).mul(NI)).add(xe),NR(le[1],ce[1],Re).add($),Re)}function Nn(W,A){return A==="string"?Nz(W):NH([W],A)}function NL(W,A){return W instanceof Float32Array&&A==="float32"||W instanceof Int32Array&&A==="int32"||W instanceof Uint8Array&&A==="bool"}function NH(W,A){if(A==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(W)&&(W=NG(W)),Cd().getBool("DEBUG")&&U(W,A),NL(W,A))return W;if(A==null||A==="float32"||A==="complex64")return new Float32Array(W);if(A==="int32")return new Int32Array(W);if(A==="bool"){const V=new Uint8Array(W.length);for(let $=0;$<V.length;++$)Math.round(W[$])!==0&&(V[$]=1);return V}else throw new Error("Unknown data type "+A)}function Nk(){return Cd().platform.now()}function Nz(W,A="utf-8"){return A=A||"utf-8",Cd().platform.encode(W,A)}function Nx(W,A="utf-8"){return A=A||"utf-8",Cd().platform.decode(W,A)}function NU(W){return Cd().platform.isTypedArray!=null?Cd().platform.isTypedArray(W):mj(W)}function NG(W,A=[],V=!1){if(A==null&&(A=[]),typeof W=="boolean"||typeof W=="number"||typeof W=="string"||Cf(W)||W==null||NU(W)&&V)A.push(W);else if(Array.isArray(W)||NU(W))for(let $=0;$<W.length;++$)NG(W[$],A,V);else{let $=-1;for(const ne of Object.keys(W))/^([1-9]+[0-9]*|0)$/.test(ne)&&($=Math.max($,Number(ne)));for(let ne=0;ne<=$;ne++)NG(W[ne],A,V)}return A}class Nu{constructor(A,V){this.backendTimer=A,this.logger=V,V==null&&(this.logger=new NM)}profileKernel(A,V,$){let ne;const xe=()=>{ne=$()};let le;const ce=Nk();if(this.backendTimer.timerAvailable())le=this.backendTimer.time(xe);else{xe();for(const ue of ne)ue.dataSync();le=Promise.resolve({kernelMs:Nk()-ce})}if(Cd().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let ue=0;ue<ne.length;ue++){const Te=ne[ue];Te.data().then(Me=>{NY(Me,Te.dtype,A)})}return{kernelName:A,outputs:ne,inputs:V,timeMs:le.then(ue=>ue.kernelMs),extraInfo:le.then(ue=>ue.getExtraProfileInfo!=null?ue.getExtraProfileInfo():"")}}logKernelProfile(A){const{kernelName:V,outputs:$,timeMs:ne,inputs:xe,extraInfo:le}=A;$.forEach(ce=>{Promise.all([ce.data(),ne,le]).then(ue=>{this.logger.logKernelProfile(V,ce,ue[0],ue[1],xe,ue[2])})})}}function NY(W,A,V){if(A!=="float32")return!1;for(let $=0;$<W.length;$++){const ne=W[$];if(isNaN(ne)||!isFinite(ne))return console.warn("Found "+ne+" in the result of '"+V+"'"),!0}return!1}class NM{logKernelProfile(A,V,$,ne,xe,le){const ce=typeof ne=="number"?T(ne+"ms",9):ne.error,ue=T(A,25),Te=V.rank,Me=V.size,Re=T(V.shape.toString(),14);let we="";for(const ke in xe){const Ue=xe[ke];if(Ue!=null){const Ge=Ue.shape||V.shape,We=Ge.length;we+=ke+": "+We+"D "+(We>0?Ge:"")+" "}}console.log("%c"+ue+"	%c"+ce+"	%c"+Te+"D "+Re+"	%c"+Me+"	%c"+we+"	%c"+le,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Nh(W,A,V){const $={},ne={};for(let ue=0;ue<A.length;ue++)$[A[ue].id]=!0;for(let ue=0;ue<W.length;ue++){const Te=W[ue],Me=Te.inputs;for(const Re in Me){const we=Me[Re];let ke=!1;for(let Ue=0;Ue<A.length;Ue++)if($[we.id]){Te.outputs.forEach(Ge=>$[Ge.id]=!0),ke=!0,ne[Te.id]=!0;break}if(ke)break}}const xe={};xe[V.id]=!0;const le={};for(let ue=W.length-1;ue>=0;ue--){const Te=W[ue],Me=Te.inputs;for(let Re=0;Re<Te.outputs.length;Re++)if(xe[Te.outputs[Re].id]){for(const we in Me)xe[Me[we].id]=!0,le[Te.id]=!0;break}}const ce=[];for(let ue=0;ue<W.length;ue++){const Te=W[ue];if(ne[Te.id]&&le[Te.id]){const Me={};for(const we in Te.inputs){const ke=Te.inputs[we];$[ke.id]&&(Me[we]=ke)}const Re=Object.assign({},Te);Re.inputs=Me,Re.outputs=Te.outputs,ce.push(Re)}}return ce}function Nj(W,A,V,$){for(let ne=A.length-1;ne>=0;ne--){const xe=A[ne],le=[];if(xe.outputs.forEach(ue=>{const Te=W[ue.id];Te!=null?le.push(Te):le.push(null)}),xe.gradient==null)throw new Error("Cannot compute gradient: gradient function not found for "+xe.kernelName+".");const ce=xe.gradient(le);for(const ue in xe.inputs){if(!(ue in ce))throw new Error("Cannot backprop through input "+ue+". Available gradients found: "+Object.keys(ce)+".");const Te=V(()=>ce[ue]());if(Te.dtype!=="float32")throw new Error("Error in gradient for op "+xe.kernelName+". The gradient of input "+ue+" must have 'float32' dtype, but has '"+Te.dtype+"'");const Me=xe.inputs[ue];if(!X(Te.shape,Me.shape))throw new Error("Error in gradient for op "+xe.kernelName+". The gradient of input '"+ue+"' has shape '"+Te.shape+"', which does not match the shape of the input '"+Me.shape+"'");if(W[Me.id]==null)W[Me.id]=Te;else{const Re=W[Me.id];W[Me.id]=$(Re,Te),Re.dispose()}}}}const Nr=20,J0=3,J1=7;function J2(W,A,V,$){const ne=C5(A),xe=J3(W,A,V,ne),le=A.length,ce=J6(W,A,V,ne,xe),ue=["Tensor"];return $&&(ue.push("  dtype: "+V),ue.push("  rank: "+le),ue.push("  shape: ["+A+"]"),ue.push("  values:")),ue.push(ce.map(Te=>"    "+Te).join(`
`)),ue.join(`
`)}function J3(W,A,V,$){const ne=F(A),xe=$[$.length-1],le=new Array(xe).fill(0),ce=A.length,ue=V==="complex64"?J7(W):W;if(ce>1)for(let Te=0;Te<ne/xe;Te++){const Me=Te*xe;for(let Re=0;Re<xe;Re++)le[Re]=Math.max(le[Re],J4(ue[Me+Re],0,V).length)}return le}function J4(W,A,V){let $;return Array.isArray(W)?$=parseFloat(W[0].toFixed(J1))+" + "+parseFloat(W[1].toFixed(J1))+"j":j(W)?$="'"+W+"'":V==="bool"?$=J5(W):$=parseFloat(W.toFixed(J1)).toString(),T($,A)}function J5(W){return W===0?"false":"true"}function J6(W,A,V,$,ne,xe=!0){const le=V==="complex64"?2:1,ce=A[0],ue=A.length;if(ue===0){if(V==="complex64"){const Ge=J7(W);return[J4(Ge[0],0,V)]}return V==="bool"?[J5(W[0])]:[W[0].toString()]}if(ue===1){if(ce>Nr){const Ge=J0*le;let We=Array.from(W.slice(0,Ge)),Xe=Array.from(W.slice((ce-J0)*le,ce*le));return V==="complex64"&&(We=J7(We),Xe=J7(Xe)),["["+We.map((Ye,je)=>J4(Ye,ne[je],V)).join(", ")+", ..., "+Xe.map((Ye,je)=>J4(Ye,ne[ce-J0+je],V)).join(", ")+"]"]}return["["+(V==="complex64"?J7(W):Array.from(W)).map((Ge,We)=>J4(Ge,ne[We],V)).join(", ")+"]"]}const Te=A.slice(1),Me=$.slice(1),Re=$[0]*le,we=[];if(ce>Nr){for(let Ge=0;Ge<J0;Ge++){const We=Ge*Re,Xe=We+Re;we.push(...J6(W.slice(We,Xe),Te,V,Me,ne,!1))}we.push("...");for(let Ge=ce-J0;Ge<ce;Ge++){const We=Ge*Re,Xe=We+Re;we.push(...J6(W.slice(We,Xe),Te,V,Me,ne,Ge===ce-1))}}else for(let Ge=0;Ge<ce;Ge++){const We=Ge*Re,Xe=We+Re;we.push(...J6(W.slice(We,Xe),Te,V,Me,ne,Ge===ce-1))}const ke=ue===2?",":"";we[0]="["+(ce>0?we[0]+ke:"");for(let Ge=1;Ge<we.length-1;Ge++)we[Ge]=" "+we[Ge]+ke;let Ue=`,
`;for(let Ge=2;Ge<ue;Ge++)Ue+=`
`;return we[we.length-1]=" "+we[we.length-1]+"]"+(xe?"":Ue),we}function J7(W){const A=[];for(let V=0;V<W.length;V+=2)A.push([W[V],W[V+1]]);return A}class J8{constructor(A,V,$){if(this.dtype=V,this.shape=A.slice(),this.size=F(A),$!=null){const ne=$.length;e(ne===this.size,()=>"Length of values '"+ne+"' does not match the size inferred by the shape '"+this.size+"'.")}if(V==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=$||x(V,this.size),this.strides=C5(A)}set(A,...V){V.length===0&&(V=[0]),e(V.length===this.rank,()=>"The number of provided coordinates ("+V.length+") must match the rank ("+this.rank+")");const $=this.locToIndex(V);this.values[$]=A}get(...A){A.length===0&&(A=[0]);let V=0;for(const ne of A){if(ne<0||ne>=this.shape[V]){const xe="Requested out of range element at "+A+".   Buffer shape="+this.shape;throw new Error(xe)}V++}let $=A[A.length-1];for(let ne=0;ne<A.length-1;++ne)$+=this.strides[ne]*A[ne];return this.values[$]}locToIndex(A){if(this.rank===0)return 0;if(this.rank===1)return A[0];let V=A[A.length-1];for(let $=0;$<A.length-1;++$)V+=this.strides[$]*A[$];return V}indexToLoc(A){if(this.rank===0)return[];if(this.rank===1)return[A];const V=new Array(this.shape.length);for(let $=0;$<V.length-1;++$)V[$]=Math.floor(A/this.strides[$]),A-=V[$]*this.strides[$];return V[V.length-1]=A,V}get rank(){return this.shape.length}toTensor(){return J9().makeTensor(this.values,this.shape,this.dtype)}}let J9=null,JC=null;function Jm(W){J9=W}function JN(W){JC=W}class JJ{constructor(A,V,$,ne){this.kept=!1,this.isDisposedInternal=!1,this.shape=A.slice(),this.dtype=V||"float32",this.size=F(A),this.strides=C5(A),this.dataId=$,this.id=ne,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const A=await this.data();return JC.buffer(this.shape,this.dtype,A)}bufferSync(){return JC.buffer(this.shape,this.dtype,this.dataSync())}async array(){const A=await this.data();return C7(this.shape,A,this.dtype==="complex64")}arraySync(){return C7(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const A=J9().read(this.dataId);if(this.dtype==="string"){const V=await A;try{return V.map($=>Nx($))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return A}dataToGPU(A){return this.throwIfDisposed(),J9().readToGPU(this.dataId,A)}dataSync(){this.throwIfDisposed();const A=J9().readSync(this.dataId);if(this.dtype==="string")try{return A.map(V=>Nx(V))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return A}async bytes(){this.throwIfDisposed();const A=await J9().read(this.dataId);return this.dtype==="string"?A:new Uint8Array(A.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),J9().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(A=!1){return JC.print(this,A)}clone(){return this.throwIfDisposed(),JC.clone(this)}toString(A=!1){const V=this.dataSync();return J2(V,this.shape,this.dtype,A)}cast(A){return this.throwIfDisposed(),JC.cast(this,A)}variable(A=!0,V,$){return this.throwIfDisposed(),J9().makeVariable(this,A,V,$)}}Object.defineProperty(JJ,Symbol.hasInstance,{value:W=>!!W&&W.data!=null&&W.dataSync!=null&&W.throwIfDisposed!=null});function Jf(){return Cg("Tensor",()=>JJ)}Jf();class Ji extends JJ{constructor(A,V,$,ne){super(A.shape,A.dtype,A.dataId,ne),this.trainable=V,this.name=$}assign(A){if(A.dtype!==this.dtype)throw new Error("dtype of the new value ("+A.dtype+") and previous value ("+this.dtype+") must match");if(!X(A.shape,this.shape))throw new Error("shape of the new value ("+A.shape+") and previous value ("+this.shape+") must match");J9().disposeTensor(this),this.dataId=A.dataId,J9().incRef(this,null)}dispose(){J9().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ji,Symbol.hasInstance,{value:W=>W instanceof JJ&&W.assign!=null&&W.assign instanceof Function});var JO;(function(W){W.R0="R0",W.R1="R1",W.R2="R2",W.R3="R3",W.R4="R4",W.R5="R5",W.R6="R6"})(JO||(JO={}));var Jt;(function(W){W.float32="float32",W.int32="int32",W.bool="int32",W.complex64="complex64"})(Jt||(Jt={}));var JB;(function(W){W.float32="float32",W.int32="int32",W.bool="bool",W.complex64="complex64"})(JB||(JB={}));var JS;(function(W){W.float32="float32",W.int32="float32",W.bool="float32",W.complex64="complex64"})(JS||(JS={}));var Jd;(function(W){W.float32="complex64",W.int32="complex64",W.bool="complex64",W.complex64="complex64"})(Jd||(Jd={}));const JV={float32:JS,int32:Jt,bool:JB,complex64:Jd};function Jb(W,A){if(W==="string"||A==="string"){if(W==="string"&&A==="string")return"string";throw new Error("Can not upcast "+W+" with "+A)}return JV[W][A]}function JP(W){return Jb(W,"int32")}function JE(W){return W!=null&&typeof W=="object"&&"texture"in W&&W.texture instanceof WebGLTexture}function JD(W){return typeof GPUBuffer<"u"&&W!=null&&typeof W=="object"&&"buffer"in W&&W.buffer instanceof GPUBuffer}function Jg(W,A){if(W.dtype===A.dtype)return[W,A];const V=Jb(W.dtype,A.dtype);return[W.cast(V),A.cast(V)]}function JZ(W){const A=[];return Jo(W,A,new Set),A}function Jo(W,A,V){if(W==null)return;if(W instanceof JJ){A.push(W);return}if(!Je(W))return;const $=W;for(const ne in $){const xe=$[ne];V.has(xe)||(V.add(xe),Jo(xe,A,V))}}function Je(W){return Array.isArray(W)||typeof W=="object"}function JQ(W){return W.kernelName!=null}class Js{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(A=>A.name)))}}}dispose(){for(const A in this.registeredVariables)this.registeredVariables[A].dispose()}}class JF{constructor(A){this.ENV=A,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Js}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const A=this.getSortedBackends();for(let V=0;V<A.length;V++){const $=A[V];if(await this.initializeBackend($).success){await this.setBackend($);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(this.backendInstance==null){const{name:A,asyncInit:V}=this.initializeBackendsAndReturnBest();if(V)throw new Error("The highest priority backend '"+A+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(A)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(A){if(!(A in this.registry))if(A in this.registryFactory){const{asyncInit:V}=this.initializeBackend(A);if(V)return null}else return null;return this.registry[A]}findBackendFactory(A){return A in this.registryFactory?this.registryFactory[A].factory:null}registerBackend(A,V,$=1){return A in this.registryFactory?(mk(A+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[A]={factory:V,priority:$},!0)}async setBackend(A){if(this.registryFactory[A]==null)throw new Error("Backend name '"+A+"' not found in registry");if(this.backendName=A,this.registry[A]==null){this.backendInstance=null;const{success:V,asyncInit:$}=this.initializeBackend(A);if(!($?await V:V))return!1}return this.backendInstance=this.registry[A],this.setupRegisteredKernels(),this.profiler=new Nu(this.backendInstance),!0}setupRegisteredKernels(){mY(this.backendName).forEach(A=>{A.setupFunc!=null&&A.setupFunc(this.backendInstance)})}disposeRegisteredKernels(A){mY(A).forEach(V=>{V.disposeFunc!=null&&V.disposeFunc(this.registry[A])})}initializeBackend(A){const V=this.registryFactory[A];if(V==null)throw new Error("Cannot initialize backend "+A+", no registration found.");try{const $=V.factory();if($&&!($ instanceof i)&&typeof $.then=="function"){const ne=++this.pendingBackendInitId,xe=$.then(le=>ne<this.pendingBackendInitId?!1:(this.registry[A]=le,this.pendingBackendInit=null,!0)).catch(le=>(ne<this.pendingBackendInitId||(this.pendingBackendInit=null,mk("Initialization of backend "+A+" failed"),mk(le.stack||le.message)),!1));return this.pendingBackendInit=xe,{success:xe,asyncInit:!0}}else return this.registry[A]=$,{success:!0,asyncInit:!1}}catch($){return mk("Initialization of backend "+A+" failed"),mk($.stack||$.message),{success:!1,asyncInit:!1}}}removeBackend(A){if(!(A in this.registryFactory))throw new Error(A+" backend not found in registry");this.backendName===A&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,A in this.registry&&(this.disposeRegisteredKernels(A),this.registry[A].dispose(),delete this.registry[A]),delete this.registryFactory[A],this.backendName===A&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((A,V)=>this.registryFactory[V].priority-this.registryFactory[A].priority)}initializeBackendsAndReturnBest(){const A=this.getSortedBackends();for(let V=0;V<A.length;V++){const $=A[V],{success:ne,asyncInit:xe}=this.initializeBackend($);if(xe||ne)return{name:$,asyncInit:xe}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(A,V){const $=this.state.tensorInfo.get(V),ne=$.backend,xe=this.readSync(V),le=ne.refCount(V);ne.disposeData(V,!0),$.backend=A,A.move(V,xe,$.shape,$.dtype,le),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(A,V){let $=null;if(V==null){if(typeof A!="function")throw new Error("Please provide a function to tidy()");V=A}else{if(typeof A!="string"&&!(A instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof V!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");$=A}let ne;return this.scopedRun(()=>this.startScope($),()=>this.endScope(ne),()=>(ne=V(),ne instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),ne))}scopedRun(A,V,$){A();try{const ne=$();return V(),ne}catch(ne){throw V(),ne}}nextTensorId(){return JF.nextTensorId++}nextVariableId(){return JF.nextVariableId++}clone(A){const V=JA.runKernel(Cj,{x:A}),$={x:A},ne=le=>({x:()=>{const ce="float32",ue={x:le},Te={dtype:ce};return JA.runKernel(CA,ue,Te)}}),xe=[];return this.addTapeNode(this.state.activeScope.name,$,[V],ne,xe,{}),V}runKernel(A,V,$){if(this.backendName==null&&this.backend,mG(A,this.backendName)==null)throw new Error("Kernel '"+A+"' not registered for backend '"+this.backendName+"'");return this.runKernelFunc({kernelName:A,inputs:V,attrs:$})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(A,V,$){const ne=this.backend.numDataIds();let xe=0;$.forEach(ue=>{xe+=ue.dtype==="complex64"?3:1});const le=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],ce=ne-V-xe-le;if(ce>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak ("+ce+" data ids) after running '"+A+"'")}runKernelFunc(A){let V,$=[];const ne=this.isTapeOn(),xe=this.state.numBytes,le=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let ce;this.backendName==null&&this.backend;let ue;const Te=JQ(A)?A.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(JQ(A)){const{kernelName:Ue,inputs:Ge,attrs:We}=A;this.backendName==null&&this.backend;const Xe=mG(Ue,this.backendName);e(Xe!=null,()=>"Cannot find registered kernel '"+Ue+"' for backend '"+this.backendName+"'"),ce=()=>{const Ye=this.backend.numDataIds();ue=Xe.kernelFunc({inputs:Ge,attrs:We,backend:this.backend});const je=Array.isArray(ue)?ue:[ue];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Ue,Ye,je);const Ke=je.map(qe=>qe.rank!=null?qe:this.makeTensorFromTensorInfo(qe));if(ne){const qe=this.getTensorsForGradient(Ue,Ge,Ke);$=this.saveTensorsForBackwardMode(qe)}return Ke}}else{const{forwardFunc:Ue}=A,Ge=We=>{ne&&($=We.map(Xe=>this.keep(this.clone(Xe))))};ce=()=>{const We=this.backend.numDataIds();ue=this.tidy(()=>Ue(this.backend,Ge));const Xe=Array.isArray(ue)?ue:[ue];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Te,We,Xe),Xe}}const{inputs:Me,attrs:Re}=A,we=JQ(A)?null:A.backwardsFunc;let ke;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?V=ce():(ke=this.profiler.profileKernel(Te,Me,()=>ce()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(ke),V=ke.outputs)}),ne&&this.addTapeNode(Te,Me,V,we,$,Re),this.state.profiling&&this.state.activeProfile.kernels.push({name:Te,bytesAdded:this.state.numBytes-xe,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-le,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(Me).map(Ue=>Me[Ue]!=null?Me[Ue].shape:null),outputShapes:V.map(Ue=>Ue.shape),kernelTimeMs:ke.timeMs,extraInfo:ke.extraInfo}),Array.isArray(ue)?V:V[0]}saveTensorsForBackwardMode(A){return A.map(V=>this.keep(this.clone(V)))}getTensorsForGradient(A,V,$){const ne=mu(A);if(ne!=null){const xe=ne.inputsToSave||[],le=ne.outputsToSave||[];let ce;ne.saveAllInputs?(e(Array.isArray(V),()=>"saveAllInputs is true, expected inputs to be an array."),ce=Object.keys(V).map(Te=>V[Te])):ce=xe.map(Te=>V[Te]);const ue=$.filter((Te,Me)=>le[Me]);return ce.concat(ue)}return[]}makeTensor(A,V,$,ne){if(A==null)throw new Error("Values passed to engine.makeTensor() are null");$=$||"float32",ne=ne||this.backend;let xe=A;$==="string"&&j(A[0])&&(xe=A.map(ue=>Nz(ue)));const le=ne.write(xe,V,$),ce=new JJ(V,$,le,this.nextTensorId());if(this.trackTensor(ce,ne),$==="string"){const ue=this.state.tensorInfo.get(le),Te=h(xe);this.state.numBytes+=Te-ue.bytes,ue.bytes=Te}return ce}makeTensorFromDataId(A,V,$,ne){$=$||"float32";const xe={dataId:A,shape:V,dtype:$};return this.makeTensorFromTensorInfo(xe,ne)}makeTensorFromTensorInfo(A,V){const{dataId:$,shape:ne,dtype:xe}=A,le=new JJ(ne,xe,$,this.nextTensorId());return this.trackTensor(le,V),le}makeVariable(A,V=!0,$,ne){$=$||this.nextVariableId().toString(),ne!=null&&ne!==A.dtype&&(A=A.cast(ne));const xe=new Ji(A,V,$,this.nextTensorId());if(this.state.registeredVariables[xe.name]!=null)throw new Error("Variable with name "+xe.name+" was already registered");return this.state.registeredVariables[xe.name]=xe,this.incRef(xe,this.backend),xe}trackTensor(A,V){this.state.numTensors++,A.dtype==="string"&&this.state.numStringTensors++;let $=0;A.dtype!=="complex64"&&A.dtype!=="string"&&($=A.size*M(A.dtype)),this.state.numBytes+=$,this.state.tensorInfo.has(A.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(A.dataId,{backend:V||this.backend,dtype:A.dtype,shape:A.shape,bytes:$})),A instanceof Ji||this.track(A)}incRef(A,V){this.trackTensor(A,V),this.backend.incRef(A.dataId)}removeDataId(A,V){this.state.tensorInfo.has(A)&&this.state.tensorInfo.get(A).backend===V&&(this.state.tensorInfo.delete(A),this.state.numDataBuffers--)}disposeTensor(A){if(!this.state.tensorInfo.has(A.dataId))return;const V=this.state.tensorInfo.get(A.dataId);if(this.state.numTensors--,A.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=V.bytes),A.dtype!=="complex64"&&A.dtype!=="string"){const $=A.size*M(A.dtype);this.state.numBytes-=$}V.backend.disposeData(A.dataId)&&this.removeDataId(A.dataId,V.backend)}disposeVariables(){for(const A in this.state.registeredVariables){const V=this.state.registeredVariables[A];this.disposeVariable(V)}}disposeVariable(A){this.disposeTensor(A),this.state.registeredVariables[A.name]!=null&&delete this.state.registeredVariables[A.name]}memory(){const A=this.backend.memory();return A.numTensors=this.state.numTensors,A.numDataBuffers=this.state.numDataBuffers,A.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(A.unreliable=!0,A.reasons==null&&(A.reasons=[]),A.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),A}async profile(A){this.state.profiling=!0;const V=this.state.numBytes,$=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await A(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(ne=>ne.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-V,this.state.activeProfile.newTensors=this.state.numTensors-$;for(const ne of this.state.activeProfile.kernels)ne.kernelTimeMs=await ne.kernelTimeMs,ne.extraInfo=await ne.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(A,V,$,ne,xe,le){const ce={id:this.state.nextTapeNodeId++,kernelName:A,inputs:V,outputs:$,saved:xe},ue=mu(A);ue!=null&&(ne=ue.gradFunc),ne!=null&&(ce.gradient=Te=>(Te=Te.map((Me,Re)=>{if(Me==null){const we=$[Re],ke=CC(we.size,we.dtype);return this.makeTensor(ke,we.shape,we.dtype)}return Me}),ne(Te.length>1?Te:Te[0],xe,le))),this.state.activeTape.push(ce)}keep(A){return A.kept=!0,A}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(A){const V={track:[],name:"unnamed scope",id:this.state.nextScopeId++};A&&(V.name=A),this.state.scopeStack.push(V),this.state.activeScope=V}endScope(A){const V=JZ(A),$=new Set(V.map(xe=>xe.id));for(let xe=0;xe<this.state.activeScope.track.length;xe++){const le=this.state.activeScope.track[xe];!le.kept&&!$.has(le.id)&&le.dispose()}const ne=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],V.forEach(xe=>{!xe.kept&&xe.scopeId===ne.id&&this.track(xe)})}gradients(A,V,$,ne=!1){if(e(V.length>0,()=>"gradients() received an empty list of xs."),$!=null&&$.dtype!=="float32")throw new Error("dy must have 'float32' dtype, but has '"+$.dtype+"'");const xe=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",A));e(xe instanceof JJ,()=>"The result y returned by f() must be a tensor.");const le=Nh(this.state.activeTape,V,xe);if(!ne&&le.length===0&&V.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const ce={};ce[xe.id]=$??JI(xe.shape),Nj(ce,le,Te=>this.tidy(Te),Jp);const ue=V.map(Te=>ce[Te.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(Te=>{for(const Me of Te.saved)Me.dispose()}),this.state.activeTape=null),{value:xe,grads:ue}})}customGrad(A){return e(C3(A),()=>"The f passed in customGrad(f) must be a function."),(...V)=>{e(V.every(ce=>ce instanceof JJ),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let $;const ne={};V.forEach((ce,ue)=>{ne[ue]=ce});const xe=(ce,ue)=>($=A(...V,ue),e($.value instanceof JJ,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),e(C3($.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),$.value),le=(ce,ue)=>{const Te=$.gradFunc(ce,ue),Me=Array.isArray(Te)?Te:[Te];e(Me.length===V.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),e(Me.every(we=>we instanceof JJ),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const Re={};return Me.forEach((we,ke)=>{Re[ke]=()=>we}),Re};return this.runKernelFunc({forwardFunc:xe,backwardsFunc:le,inputs:ne})}}readSync(A){return this.state.tensorInfo.get(A).backend.readSync(A)}read(A){return this.state.tensorInfo.get(A).backend.read(A)}readToGPU(A,V){return this.state.tensorInfo.get(A).backend.readToGPU(A,V)}async time(A){const V=Nk(),$=await this.backend.time(A);return $.wallMs=Nk()-V,$}track(A){return this.state.activeScope!=null&&(A.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(A)),A}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Js;for(const A in this.registry)this.disposeRegisteredKernels(A),this.registry[A].dispose(),delete this.registry[A];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}JF.nextTensorId=0,JF.nextVariableId=0;function JI(W){const A=C9(F(W),"float32");return JA.makeTensor(A,W,"float32")}function Jy(){const W=CE();if(W._tfengine==null){const A=new CO(W);W._tfengine=new JF(A)}return Cb(W._tfengine.ENV),Jm(()=>W._tfengine),W._tfengine}const JA=Jy();function Jp(W,A){const V={a:W,b:A};return JA.runKernel(Co,V)}function Jw(){return typeof navigator<"u"&&navigator!=null}function JX(W){if(W||Jw()){if(W||(W=navigator),W.product==="ReactNative")return!0;const A=W.userAgent||W.vendor||(typeof window<"u"?window.opera:"");if(!A){const V=W;return V.userAgentData&&V.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(A)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(A.substr(0,4))}return!1}function Jc(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const JW=Cd();JW.registerFlag("DEBUG",()=>!1,W=>{W&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),JW.registerFlag("IS_BROWSER",()=>Jc()),JW.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),JW.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),JW.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),JW.registerFlag("PROD",()=>!1),JW.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>JW.getBool("DEBUG")),JW.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),JW.registerFlag("IS_TEST",()=>!1),JW.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>JW.getBool("DEBUG")),JW.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),JW.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),JW.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function JR(W,A){let V=W;if(NU(W))return A==="string"?[]:[W.length];if(JE(W)){const ne=W.channels||"RGBA";return[W.height,W.width*ne.length]}else if(JD(W))return[W.buffer.size/(A==null?4:M(A))];if(!Array.isArray(W))return[];const $=[];for(;Array.isArray(V)||NU(V)&&A!=="string";)$.push(V.length),V=V[0];return Array.isArray(W)&&Cd().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&JK(W,$,[]),$}function JK(W,A,V){if(V=V||[],!Array.isArray(W)&&!NU(W)){e(A.length===0,()=>"Element arr["+V.join("][")+"] is a primitive, but should be an array/TypedArray of "+A[0]+" elements");return}e(A.length>0,()=>"Element arr["+V.join("][")+"] should be a primitive, but is an array of "+W.length+" elements"),e(W.length===A[0],()=>"Element arr["+V.join("][")+"] should have "+A[0]+" elements, but has "+W.length+" elements");const $=A.slice(1);for(let ne=0;ne<W.length;++ne)JK(W[ne],$,V.concat(ne))}function JT(W,A,V,$){if(W!=="string_or_numeric"){if(W==null)throw new Error("Expected dtype cannot be null.");if(W!=="numeric"&&W!==A||W==="numeric"&&A==="string")throw new Error("Argument '"+V+"' passed to '"+$+"' must be "+W+" tensor, but got "+A+" tensor")}}function Jv(W,A,V,$="numeric"){if(W instanceof Jf())return JT($,W.dtype,A,V),W;let ne=C2(W);if(ne!=="string"&&["bool","int32","float32"].indexOf($)>=0&&(ne=$),JT($,ne,A,V),W==null||!NU(W)&&!Array.isArray(W)&&typeof W!="number"&&typeof W!="boolean"&&typeof W!="string"){const ce=W==null?"null":W.constructor.name;throw new Error("Argument '"+A+"' passed to '"+V+"' must be a Tensor or TensorLike, but got '"+ce+"'")}const xe=JR(W,ne);!NU(W)&&!Array.isArray(W)&&(W=[W]);const le=ne!=="string"?NH(W,ne):NG(W,[],!0);return JA.makeTensor(le,xe,ne)}function Jq(W,A,V,$="numeric"){if(!Array.isArray(W))throw new Error("Argument "+A+" passed to "+V+" must be a `Tensor[]` or `TensorLike[]`");return W.map((ne,xe)=>Jv(ne,A+"["+xe+"]",V,$))}const Jl="__op";function Ja(W){const A=Object.keys(W);if(A.length!==1)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+A.length+" keys.");let V=A[0];const $=W[V];V.endsWith("_")&&(V=V.substring(0,V.length-1)),V=V+Jl;const ne=(...xe)=>{JA.startScope(V);try{const le=$(...xe);return Cf(le)&&console.error("Cannot return a Promise inside of tidy."),JA.endScope(le),le}catch(le){throw JA.endScope(null),le}};return Object.defineProperty(ne,"name",{value:V,configurable:!0}),ne}function Jn(W,A){const V=Jv(W,"real","complex"),$=Jv(A,"imag","complex");Q(V.shape,$.shape,"real and imag shapes, "+V.shape+" and "+$.shape+", must match in call to tf.complex().");const ne={real:V,imag:$};return JA.runKernel(Cw,ne)}const JL=Ja({complex_:Jn});function JH(W,A,V,$){if($==null)$=C2(W);else if($==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(JD(W)||JE(W)){if($!=="float32"&&$!=="int32")throw new Error("Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is "+$+".");return JA.backend.createTensorFromGPUData(W,A||V,$)}if(!NU(W)&&!Array.isArray(W)&&typeof W!="number"&&typeof W!="boolean"&&typeof W!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(A!=null){Cm(A);const ne=F(A),xe=F(V);e(ne===xe,()=>"Based on the provided shape, ["+A+"], the tensor should have "+ne+" values but has "+xe);for(let le=0;le<V.length;++le){const ce=V[le],ue=le===V.length-1?ce!==F(A.slice(le)):!0;e(V[le]===A[le]||!ue,()=>"Error creating a new Tensor. Inferred shape ("+V+") does not match the provided shape ("+A+"). ")}}return!NU(W)&&!Array.isArray(W)&&(W=[W]),A=A||V,W=$!=="string"?NH(W,$):NG(W,[],!0),JA.makeTensor(W,A,$)}function Jk(W,A,V){const $=JR(W,V);return JH(W,A,$,V)}const Jz={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Jx{static join(A){return new Jx(A).slice()}constructor(A){if(this.shards=[],this.previousShardIndex=0,A==null||(A instanceof Array||(A=[A]),A=A.map($=>NU($)?$.buffer:$),A.length===0))return;this.bufferUniformSize=A[0].byteLength;let V=0;for(let $=0;$<A.length;$++){const ne=A[$];$!==A.length-1&&ne.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const xe=V+ne.byteLength;this.shards.push({buffer:ne,start:V,end:xe}),V=xe}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(A=0,V=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(A=isNaN(Number(A))?0:A,V=isNaN(Number(V))?0:V,A=Math.max(0,A),V=Math.min(this.byteLength,V),V<=A)return new ArrayBuffer(0);const $=this.findShardForByte(A);if($===-1)throw new Error("Could not find start shard for byte "+A);const ne=V-A,xe=new ArrayBuffer(ne),le=new Uint8Array(xe);let ce=0;for(let ue=$;ue<this.shards.length;ue++){const Te=this.shards[ue],Me=A+ce-Te.start,Re=ce,we=Math.min(V,Te.end)-Te.start,ke=new Uint8Array(Te.buffer,Me,we-Me);if(le.set(ke,Re),ce+=ke.length,V<Te.end)break}return xe}findShardForByte(A){if(this.shards.length===0||A<0||A>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(A/this.bufferUniformSize),this.previousShardIndex;function V(ne){return A<ne.start?-1:A>=ne.end?1:0}if(V(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const $=JU(this.shards,V);return $===-1?-1:(this.previousShardIndex=$,this.previousShardIndex)}}function JU(W,A){let V=0,$=W.length;for(;V<=$;){const ne=Math.floor(($-V)/2)+V,xe=A(W[ne]);if(xe===0)return ne;xe<0?$=ne:V=ne+1}return-1}function JG(){Cd().set("PROD",!0)}function Ju(){return JA}function JY(W,A){return JA.tidy(W,A)}function JM(W){JZ(W).forEach(A=>A.dispose())}function Jh(W){return JA.keep(W)}function Jj(W){return JA.setBackend(W)}function Jr(){return JA.backendName}function f0(W,A,V=1){return JA.registerBackend(W,A,V)}function f1(){return JA.backend}const f2=4;async function f3(W,A){const V=[],$=[],ne=Array.isArray(W)?W.map(le=>le.name):Object.keys(W);for(let le=0;le<ne.length;++le){const ce=ne[le],ue=Array.isArray(W)?W[le].tensor:W[ce];if(ue.dtype!=="float32"&&ue.dtype!=="int32"&&ue.dtype!=="bool"&&ue.dtype!=="string"&&ue.dtype!=="complex64")throw new Error("Unsupported dtype in weight '"+ce+"': "+ue.dtype);const Te={name:ce,shape:ue.shape,dtype:ue.dtype};if(ue.dtype==="string"){const Me=new Promise(async Re=>{const we=await ue.bytes(),ke=we.reduce((We,Xe)=>We+Xe.length,0)+f2*we.length,Ue=new Uint8Array(ke);let Ge=0;for(let We=0;We<we.length;We++){const Xe=we[We],Ye=new Uint8Array(new Uint32Array([Xe.length]).buffer);Ue.set(Ye,Ge),Ge+=f2,Ue.set(Xe,Ge),Ge+=Xe.length}Re(Ue)});$.push(Me)}else $.push(ue.data());A!=null&&(Te.group=A),V.push(Te)}const xe=await Promise.all($);return{data:fC(xe),specs:V}}function f4(W,A){const V=new Jx(W),$={};let ne=0;for(const xe of A){const le=f5(xe,(ce,ue)=>V.slice(ne+ce,ne+ue));$[xe.name]=f7(xe,V.slice(ne,ne+le)),ne+=le}return $}function f5(W,A){const V=F(W.shape);let $;if("quantization"in W){const ne=W.quantization;$=Jz[ne.dtype]}else if(W.dtype==="string"){let ne=0;for(let xe=0;xe<V;xe++)ne+=f2+new Uint32Array(A(ne,ne+f2))[0];return ne}else $=Jz[W.dtype];return V*$}async function f6(W,A){const V=F(W.shape);let $;if("quantization"in W){const ne=W.quantization;$=Jz[ne.dtype]}else if(W.dtype==="string"){let ne=0;for(let xe=0;xe<V;xe++)ne+=f2+new Uint32Array(await A(ne,ne+f2))[0];return ne}else $=Jz[W.dtype];return V*$}function f7(W,A){const V=W.name,$=W.dtype,ne=W.shape,xe=F(ne);let le,ce=0;if("quantization"in W){const ue=W.quantization;if(ue.dtype==="uint8"||ue.dtype==="uint16"){if(!("min"in ue&&"scale"in ue))throw new Error("Weight "+W.name+" with quantization "+ue.dtype+" doesn't have corresponding metadata min and scale.")}else if(ue.dtype==="float16"){if($!=="float32")throw new Error("Weight "+W.name+" is quantized with "+ue.dtype+" which only supports weights of type float32 not "+$+".")}else throw new Error("Weight "+W.name+" has unknown quantization dtype "+ue.dtype+". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");const Te=Jz[ue.dtype],Me=ue.dtype==="uint8"?new Uint8Array(A):new Uint16Array(A);if($==="float32")if(ue.dtype==="uint8"||ue.dtype==="uint16"){le=new Float32Array(Me.length);for(let Re=0;Re<Me.length;Re++){const we=Me[Re];le[Re]=we*ue.scale+ue.min}}else if(ue.dtype==="float16")le=fD()(Me);else throw new Error("Unsupported quantization type "+ue.dtype+" for weight type float32.");else if($==="int32"){if(ue.dtype!=="uint8"&&ue.dtype!=="uint16")throw new Error("Unsupported quantization type "+ue.dtype+" for weight type int32.");le=new Int32Array(Me.length);for(let Re=0;Re<Me.length;Re++){const we=Me[Re];le[Re]=Math.round(we*ue.scale+ue.min)}}else throw new Error("Unsupported dtype in weight '"+V+"': "+$);ce+=xe*Te}else if($==="string"){const ue=F(W.shape);le=[];for(let Te=0;Te<ue;Te++){const Me=new Uint32Array(A.slice(ce,ce+f2))[0];ce+=f2;const Re=new Uint8Array(A.slice(ce,ce+Me));le.push(Re),ce+=Me}}else{const ue=Jz[$];if($==="float32")le=new Float32Array(A);else if($==="int32")le=new Int32Array(A);else if($==="bool")le=new Uint8Array(A);else if($==="complex64"){le=new Float32Array(A);const Te=new Float32Array(le.length/2),Me=new Float32Array(le.length/2);for(let Ue=0;Ue<Te.length;Ue++)Te[Ue]=le[Ue*2],Me[Ue]=le[Ue*2+1];const Re=Jk(Te,ne,"float32"),we=Jk(Me,ne,"float32"),ke=JL(Re,we);return Re.dispose(),we.dispose(),ke}else throw new Error("Unsupported dtype in weight '"+V+"': "+$);ce+=xe*ue}return Jk(le,ne,$)}async function f8(W,A,V){let $=new Uint8Array(A);for(;$.byteLength<V;){const{done:ne,value:xe}=await W.read();if(ne&&xe==null){const ce=V-$.byteLength;throw new Error("Reader is done but "+ce+" bytes are still expected")}const le=new Uint8Array($.length+xe.byteLength);le.set($,0),le.set(new Uint8Array(xe),$.length),$=le}return $.buffer}async function f9(W,A){const V={},$=W.getReader();let ne=new ArrayBuffer(0);for(const xe of A){const le=await f6(xe,async(Te,Me)=>(ne=await f8($,ne,Me),ne.slice(Te,Me)));ne=await f8($,ne,le);const ce=ne.slice(0,le);ne=ne.slice(le);const ue=f7(xe,ce);if(V[xe.name]=ue,Jr()==="webgpu"){const Te=f1();"uploadToGPU"in Te&&F(ue.shape)>=Cd().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&Te.uploadToGPU(ue.dataId)}}return V}function fC(W){if(W===null)throw new Error("Invalid input value: "+JSON.stringify(W));let A=0;const V=[];W.forEach(xe=>{if(A+=xe.byteLength,V.push(xe.byteLength===xe.buffer.byteLength?xe:new xe.constructor(xe)),!(xe instanceof Float32Array||xe instanceof Int32Array||xe instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+xe.constructor.name)});const $=new Uint8Array(A);let ne=0;return V.forEach(xe=>{$.set(new Uint8Array(xe.buffer),ne),ne+=xe.byteLength}),$.buffer}const fm=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function fN(W){return fm?Buffer.byteLength(W,"utf8"):new Blob([W]).size}function fJ(W){if(fm)return Buffer.from(W).toString("base64");const A=new Uint8Array(W);let V="";for(let $=0,ne=A.length;$<ne;$++)V+=String.fromCharCode(A[$]);return btoa(V)}function ff(W){if(fm){const $=Buffer.from(W,"base64");return $.buffer.slice($.byteOffset,$.byteOffset+$.byteLength)}const A=atob(W),V=new Uint8Array(A.length);for(let $=0;$<A.length;++$)V.set([A.charCodeAt($)],$);return V.buffer}function fi(W){return Jx.join(W)}function fO(W){const A="/";for(W=W.trim();W.endsWith(A);)W=W.slice(0,W.length-1);const V=W.split(A);return V[V.length-1]}function ft(W,A){const V={modelTopology:W.modelTopology,format:W.format,generatedBy:W.generatedBy,convertedBy:W.convertedBy,weightsManifest:A};return W.signature!=null&&(V.signature=W.signature),W.userDefinedMetadata!=null&&(V.userDefinedMetadata=W.userDefinedMetadata),W.modelInitializer!=null&&(V.modelInitializer=W.modelInitializer),W.initializerSignature!=null&&(V.initializerSignature=W.initializerSignature),W.trainingConfig!=null&&(V.trainingConfig=W.trainingConfig),V}function fB(W,A,V){const $={modelTopology:W.modelTopology,format:W.format,generatedBy:W.generatedBy,convertedBy:W.convertedBy};if(W.trainingConfig!=null&&($.trainingConfig=W.trainingConfig),W.weightsManifest!=null){if(!A)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!V)throw new Error("modelJSON has weightsManifest but weightData is null");$.weightSpecs=A,$.weightData=V}return W.signature!=null&&($.signature=W.signature),W.userDefinedMetadata!=null&&($.userDefinedMetadata=W.userDefinedMetadata),W.modelInitializer!=null&&($.modelInitializer=W.modelInitializer),W.initializerSignature!=null&&($.initializerSignature=W.initializerSignature),$}async function fS(W,A){let V,$;return W.weightsManifest!=null&&([V,$]=await A(W.weightsManifest)),fB(W,V,$)}function fd(W){if(W.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:W.modelTopology==null?0:fN(JSON.stringify(W.modelTopology)),weightSpecsBytes:W.weightSpecs==null?0:fN(JSON.stringify(W.weightSpecs)),weightDataBytes:W.weightData==null?0:new Jx(W.weightData).byteLength}}function fV(W){const A=[];for(const V of W)A.push(...V.weights);return A}function fb(){const W=V=>{let $=V<<13,ne=0;for(;!($&8388608);)ne-=8388608,$<<=1;return $&=-8388609,ne+=947912704,$|ne},A=new Uint32Array(2048);A[0]=0;for(let V=1;V<1024;V++)A[V]=W(V);for(let V=1024;V<2048;V++)A[V]=939524096+(V-1024<<13);return A}function fP(){const W=new Uint32Array(64);W[0]=0,W[31]=1199570944,W[32]=2147483648,W[63]=3347054592;for(let A=1;A<31;A++)W[A]=A<<23;for(let A=33;A<63;A++)W[A]=2147483648+(A-32<<23);return W}function fE(){const W=new Uint32Array(64);for(let A=0;A<64;A++)W[A]=1024;return W[0]=W[32]=0,W}function fD(){const W=fb(),A=fP(),V=fE();return $=>{const ne=new ArrayBuffer(4*$.length),xe=new Uint32Array(ne);for(let le=0;le<$.length;le++){const ce=$[le],ue=W[V[ce>>10]+(ce&1023)]+A[ce>>10];xe[le]=ue}return new Float32Array(ne)}}class fg{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return fg.instance==null&&(fg.instance=new fg),fg.instance}static registerSaveRouter(A){fg.getInstance().saveRouters.push(A)}static registerLoadRouter(A){fg.getInstance().loadRouters.push(A)}static getSaveHandlers(A){return fg.getHandlers(A,"save")}static getLoadHandlers(A,V){return fg.getHandlers(A,"load",V)}static getHandlers(A,V,$){const ne=[];return(V==="load"?fg.getInstance().loadRouters:fg.getInstance().saveRouters).forEach(xe=>{const le=xe(A,$);le!==null&&ne.push(le)}),ne}}const fZ=W=>fg.registerSaveRouter(W),fo=W=>fg.registerLoadRouter(W),fe=W=>fg.getSaveHandlers(W),fQ=(W,A)=>fg.getLoadHandlers(W,A),fs="tensorflowjs",fF=1,fI="models_store",fy="model_info_store";function fA(){if(!Cd().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const W=typeof window>"u"?self:window,A=W.indexedDB||W.mozIndexedDB||W.webkitIndexedDB||W.msIndexedDB||W.shimIndexedDB;if(A==null)throw new Error("The current browser does not appear to support IndexedDB.");return A}function fp(W){const A=W.result;A.createObjectStore(fI,{keyPath:"modelPath"}),A.createObjectStore(fy,{keyPath:"modelPath"})}class fw{constructor(A){if(this.indexedDB=fA(),A==null||!A)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=A}async save(A){if(A.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,A)}async load(){return this.databaseAction(this.modelPath)}databaseAction(A,V){return new Promise(($,ne)=>{const xe=this.indexedDB.open(fs,fF);xe.onupgradeneeded=()=>fp(xe),xe.onsuccess=()=>{const le=xe.result;if(V==null){const ce=le.transaction(fI,"readonly"),ue=ce.objectStore(fI).get(this.modelPath);ue.onsuccess=()=>{if(ue.result==null)return le.close(),ne(new Error("Cannot find model with path '"+this.modelPath+"' in IndexedDB."));$(ue.result.modelArtifacts)},ue.onerror=Te=>(le.close(),ne(ue.error)),ce.oncomplete=()=>le.close()}else{V.weightData=Jx.join(V.weightData);const ce=fd(V),ue=le.transaction(fy,"readwrite");let Te=ue.objectStore(fy),Me;try{Me=Te.put({modelPath:this.modelPath,modelArtifactsInfo:ce})}catch(we){return ne(we)}let Re;Me.onsuccess=()=>{Re=le.transaction(fI,"readwrite");const we=Re.objectStore(fI);let ke;try{ke=we.put({modelPath:this.modelPath,modelArtifacts:V,modelArtifactsInfo:ce})}catch(Ue){return ne(Ue)}ke.onsuccess=()=>$({modelArtifactsInfo:ce}),ke.onerror=Ue=>{Te=ue.objectStore(fy);const Ge=Te.delete(this.modelPath);Ge.onsuccess=()=>(le.close(),ne(ke.error)),Ge.onerror=We=>(le.close(),ne(ke.error))}},Me.onerror=we=>(le.close(),ne(Me.error)),ue.oncomplete=()=>{Re==null?le.close():Re.oncomplete=()=>le.close()}}},xe.onerror=le=>ne(xe.error)})}}fw.URL_SCHEME="indexeddb://";const fX=W=>Cd().getBool("IS_BROWSER")&&!Array.isArray(W)&&W.startsWith(fw.URL_SCHEME)?fc(W.slice(fw.URL_SCHEME.length)):null;fg.registerSaveRouter(fX),fg.registerLoadRouter(fX);function fc(W){return new fw(W)}function fW(W){return W.startsWith(fw.URL_SCHEME)?W.slice(fw.URL_SCHEME.length):W}class fR{constructor(){this.indexedDB=fA()}async listModels(){return new Promise((A,V)=>{const $=this.indexedDB.open(fs,fF);$.onupgradeneeded=()=>fp($),$.onsuccess=()=>{const ne=$.result,xe=ne.transaction(fy,"readonly"),le=xe.objectStore(fy).getAll();le.onsuccess=()=>{const ce={};for(const ue of le.result)ce[ue.modelPath]=ue.modelArtifactsInfo;A(ce)},le.onerror=ce=>(ne.close(),V(le.error)),xe.oncomplete=()=>ne.close()},$.onerror=ne=>V($.error)})}async removeModel(A){return A=fW(A),new Promise((V,$)=>{const ne=this.indexedDB.open(fs,fF);ne.onupgradeneeded=()=>fp(ne),ne.onsuccess=()=>{const xe=ne.result,le=xe.transaction(fy,"readwrite"),ce=le.objectStore(fy),ue=ce.get(A);let Te;ue.onsuccess=()=>{if(ue.result==null)return xe.close(),$(new Error("Cannot find model with path '"+A+"' in IndexedDB."));{const Me=ce.delete(A),Re=()=>{Te=xe.transaction(fI,"readwrite");const we=Te.objectStore(fI).delete(A);we.onsuccess=()=>V(ue.result.modelArtifactsInfo),we.onerror=ke=>$(ue.error)};Me.onsuccess=Re,Me.onerror=we=>(Re(),xe.close(),$(ue.error))}},ue.onerror=Me=>(xe.close(),$(ue.error)),le.oncomplete=()=>{Te==null?xe.close():Te.oncomplete=()=>xe.close()}},ne.onerror=xe=>$(ne.error)})}}const fK="/",fT="tensorflowjs_models",fv="info",fq="model_topology",fl="weight_specs",fa="weight_data",fn="model_metadata";function fL(W){return{info:[fT,W,fv].join(fK),topology:[fT,W,fq].join(fK),weightSpecs:[fT,W,fl].join(fK),weightData:[fT,W,fa].join(fK),modelMetadata:[fT,W,fn].join(fK)}}function fH(W){for(const A of Object.values(W))window.localStorage.removeItem(A)}function fk(W){const A=W.split(fK);if(A.length<3)throw new Error("Invalid key format: "+W);return A.slice(1,A.length-1).join(fK)}function fz(W){return W.startsWith(fx.URL_SCHEME)?W.slice(fx.URL_SCHEME.length):W}class fx{constructor(A){if(!Cd().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,A==null||!A)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=A,this.keys=fL(this.modelPath)}async save(A){if(A.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const V=JSON.stringify(A.modelTopology),$=JSON.stringify(A.weightSpecs),ne=fd(A),xe=Jx.join(A.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(ne)),this.LS.setItem(this.keys.topology,V),this.LS.setItem(this.keys.weightSpecs,$),this.LS.setItem(this.keys.weightData,fJ(xe));const le={format:A.format,generatedBy:A.generatedBy,convertedBy:A.convertedBy,signature:A.signature!=null?A.signature:void 0,userDefinedMetadata:A.userDefinedMetadata!=null?A.userDefinedMetadata:void 0,modelInitializer:A.modelInitializer!=null?A.modelInitializer:void 0,initializerSignature:A.initializerSignature!=null?A.initializerSignature:void 0,trainingConfig:A.trainingConfig!=null?A.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(le)),{modelArtifactsInfo:ne}}catch{throw fH(this.keys),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+ne.modelTopologyBytes+", weightSpecsBytes="+ne.weightSpecsBytes+", weightDataBytes="+ne.weightDataBytes+".")}}}async load(){const A=JSON.parse(this.LS.getItem(this.keys.info));if(A==null)throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if(A.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const V={},$=JSON.parse(this.LS.getItem(this.keys.topology));if($==null)throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");V.modelTopology=$;const ne=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(ne==null)throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");V.weightSpecs=ne;const xe=this.LS.getItem(this.keys.modelMetadata);if(xe!=null){const ce=JSON.parse(xe);V.format=ce.format,V.generatedBy=ce.generatedBy,V.convertedBy=ce.convertedBy,ce.signature!=null&&(V.signature=ce.signature),ce.userDefinedMetadata!=null&&(V.userDefinedMetadata=ce.userDefinedMetadata),ce.modelInitializer!=null&&(V.modelInitializer=ce.modelInitializer),ce.initializerSignature!=null&&(V.initializerSignature=ce.initializerSignature),ce.trainingConfig!=null&&(V.trainingConfig=ce.trainingConfig)}const le=this.LS.getItem(this.keys.weightData);if(le==null)throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return V.weightData=ff(le),V}}fx.URL_SCHEME="localstorage://";const fU=W=>Cd().getBool("IS_BROWSER")&&!Array.isArray(W)&&W.startsWith(fx.URL_SCHEME)?fG(W.slice(fx.URL_SCHEME.length)):null;fg.registerSaveRouter(fU),fg.registerLoadRouter(fU);function fG(W){return new fx(W)}class fu{constructor(){e(Cd().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),e(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const A={},V=fT+fK,$=fK+fv;for(let ne=0;ne<this.LS.length;++ne){const xe=this.LS.key(ne);if(xe.startsWith(V)&&xe.endsWith($)){const le=fk(xe);A[le]=JSON.parse(this.LS.getItem(xe))}}return A}async removeModel(A){A=fz(A);const V=fL(A);if(this.LS.getItem(V.info)==null)throw new Error("Cannot find model at path '"+A+"'");const $=JSON.parse(this.LS.getItem(V.info));return fH(V),$}}const fY="model",fM=".json",fh=".weights.bin";function fj(W){return new Promise(A=>setTimeout(A)).then(W)}class fr{constructor(A){if(!Cd().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");A.startsWith(fr.URL_SCHEME)&&(A=A.slice(fr.URL_SCHEME.length)),(A==null||A.length===0)&&(A=fY),this.modelJsonFileName=A+fM,this.weightDataFileName=A+fh}async save(A){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const V=Jx.join(A.weightData),$=window.URL.createObjectURL(new Blob([V],{type:"application/octet-stream"}));if(A.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const ne=[{paths:["./"+this.weightDataFileName],weights:A.weightSpecs}],xe=ft(A,ne),le=window.URL.createObjectURL(new Blob([JSON.stringify(xe)],{type:"application/json"})),ce=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(ce.download=this.modelJsonFileName,ce.href=le,await fj(()=>ce.dispatchEvent(new MouseEvent("click"))),A.weightData!=null){const ue=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;ue.download=this.weightDataFileName,ue.href=$,await fj(()=>ue.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:fd(A)}}}}fr.URL_SCHEME="downloads://";class i0{constructor(A){if(A==null||A.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+A);this.jsonFile=A[0],this.weightsFiles=A.slice(1)}async load(){return new Promise((A,V)=>{const $=new FileReader;$.onload=ne=>{const xe=JSON.parse(ne.target.result),le=xe.modelTopology;if(le==null){V(new Error("modelTopology field is missing from file "+this.jsonFile.name));return}if(xe.weightsManifest==null){V(new Error("weightManifest field is missing from file "+this.jsonFile.name));return}if(this.weightsFiles.length===0){A({modelTopology:le});return}const ce=fS(xe,ue=>this.loadWeights(ue));A(ce)},$.onerror=ne=>V("Failed to read model topology and weights manifest JSON from file '"+this.jsonFile.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only."),$.readAsText(this.jsonFile)})}loadWeights(A){const V=[],$=[];for(const le of A)V.push(...le.weights),$.push(...le.paths);const ne=this.checkManifestAndWeightFiles(A),xe=$.map(le=>this.loadWeightsFile(le,ne[le]));return Promise.all(xe).then(le=>[V,le])}loadWeightsFile(A,V){return new Promise(($,ne)=>{const xe=new FileReader;xe.onload=le=>{const ce=le.target.result;$(ce)},xe.onerror=le=>ne("Failed to weights data from file of path '"+A+"'."),xe.readAsArrayBuffer(V)})}checkManifestAndWeightFiles(A){const V=[],$=this.weightsFiles.map(xe=>fO(xe.name)),ne={};for(const xe of A)xe.paths.forEach(le=>{const ce=fO(le);if(V.indexOf(ce)!==-1)throw new Error("Duplicate file basename found in weights manifest: '"+ce+"'");if(V.push(ce),$.indexOf(ce)===-1)throw new Error("Weight file with basename '"+ce+"' is not provided.");ne[le]=this.weightsFiles[$.indexOf(ce)]});if(V.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest ("+V.length+") and the number of weight files provided ("+this.weightsFiles.length+").");return ne}}const i1=W=>Cd().getBool("IS_BROWSER")&&!Array.isArray(W)&&W.startsWith(fr.URL_SCHEME)?i2(W.slice(fr.URL_SCHEME.length)):null;fg.registerSaveRouter(i1);function i2(W="model"){return new fr(W)}function i3(W){return new i0(W)}function i4(W,A,V,$){le(W),V=V??0,$=$??1,ce(V,$);let ne=0;const xe=ue=>(ue.then(Te=>{const Me=V+ ++ne/W.length*($-V);return A(Me),Te}),ue);function le(ue){e(ue!=null&&Array.isArray(ue)&&ue.length>0,()=>"promises must be a none empty array")}function ce(ue,Te){e(ue>=0&&ue<=1,()=>"Progress fraction must be in range [0, 1], but got startFraction "+ue),e(Te>=0&&Te<=1,()=>"Progress fraction must be in range [0, 1], but got endFraction "+Te),e(Te>=ue,()=>"startFraction must be no more than endFraction, but got startFraction "+ue+" and endFraction "+Te)}return Promise.all(W.map(xe))}async function i5(W,A){A==null&&(A={});const V=A.fetchFunc==null?Cd().platform.fetch:A.fetchFunc,$=W.map(Te=>V(Te,A.requestInit,{isBinary:!0})),ne=0,xe=.5,le=(A.onProgress==null?await Promise.all($):await i4($,A.onProgress,ne,xe)).map(Te=>Te.arrayBuffer()),ce=.5,ue=1;return A.onProgress==null?await Promise.all(le):await i4(le,A.onProgress,ce,ue)}function i6(W,A){var V;const $=A.fetchFunc==null?Cd().platform.fetch:A.fetchFunc;let ne=0,xe;return(V=A.onProgress)===null||V===void 0||V.call(A,0),new ReadableStream({pull:async le=>{for(var ce;ne<W.length;){xe||(xe=(await $(W[ne],A.requestInit,{isBinary:!0})).body.getReader());const{done:ue,value:Te}=await xe.read();if(ue){ne++,xe=void 0,(ce=A.onProgress)===null||ce===void 0||ce.call(A,ne/W.length);continue}le.enqueue(Te);return}le.close()}})}async function i7(W,A="",V,$){return i8(ne=>i5(ne,{requestInit:$}))(W,A,V)}function i8(W){return async(A,V="",$)=>{const ne=A.map(()=>!1),xe={},le=$!=null?$.map(()=>!1):[],ce=[];if(A.forEach((ke,Ue)=>{let Ge=0;ke.weights.forEach(We=>{const Xe="quantization"in We?We.quantization.dtype:We.dtype,Ye=Jz[Xe]*F(We.shape),je=()=>{ne[Ue]=!0,xe[Ue]==null&&(xe[Ue]=[]),xe[Ue].push({manifestEntry:We,groupOffset:Ge,sizeBytes:Ye})};$!=null?$.forEach((Ke,qe)=>{Ke===We.name&&(je(),le[qe]=!0)}):je(),ce.push(We.name),Ge+=Ye})}),!le.every(ke=>ke)){const ke=$.filter((Ue,Ge)=>!le[Ge]);throw new Error("Could not find weights in manifest with names: "+ke.join(", ")+`. 
Manifest JSON has weights with names: `+ce.join(", ")+".")}const ue=ne.reduce((ke,Ue,Ge)=>(Ue&&ke.push(Ge),ke),[]),Te=[];ue.forEach(ke=>{A[ke].paths.forEach(Ue=>{const Ge=V+(V.endsWith("/")?"":"/")+Ue;Te.push(Ge)})});const Me=await W(Te),Re={};let we=0;return ue.forEach(ke=>{const Ue=A[ke].paths.length,Ge=new Jx(Me.slice(we,we+Ue));xe[ke].forEach(We=>{const Xe=Ge.slice(We.groupOffset,We.groupOffset+We.sizeBytes),Ye=f4(Xe,[We.manifestEntry]);for(const je in Ye)Re[je]=Ye[je]}),we+=Ue}),Re}}const i9="application/octet-stream",iC="application/json";class im{constructor(A,V){if(this.DEFAULT_METHOD="POST",V==null&&(V={}),this.weightPathPrefix=V.weightPathPrefix,this.weightUrlConverter=V.weightUrlConverter,V.fetchFunc!=null?(e(typeof V.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=V.fetchFunc):this.fetch=Cd().platform.fetch,e(A!=null&&A.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(A)&&e(A.length===2,()=>"URL paths for http must have a length of 2, (actual length is "+A.length+")."),this.path=A,V.requestInit!=null&&V.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=V.requestInit||{},this.loadOptions=V}async save(A){if(A.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const V=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);V.body=new FormData;const $=[{paths:["./model.weights.bin"],weights:A.weightSpecs}],ne=ft(A,$);if(V.body.append("model.json",new Blob([JSON.stringify(ne)],{type:iC}),"model.json"),A.weightData!=null){const le=Jx.join(A.weightData);V.body.append("model.weights.bin",new Blob([le],{type:i9}),"model.weights.bin")}const xe=await this.fetch(this.path,V);if(xe.ok)return{modelArtifactsInfo:fd(A),responses:[xe]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+xe.status+".")}async loadModelJSON(){const A=await this.fetch(this.path,this.requestInit);if(!A.ok)throw new Error("Request to "+this.path+" failed with status code "+A.status+". Please verify this URL points to the model JSON of the model to load.");let V;try{V=await A.json()}catch{let le="Failed to parse model JSON of response from "+this.path+".";throw this.path.endsWith(".pb")?le+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":le+=" Please make sure the server is serving valid JSON for this request.",new Error(le)}const $=V.modelTopology,ne=V.weightsManifest;if($==null&&ne==null)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return V}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const A=await this.loadModelJSON();return fS(A,V=>this.loadWeights(V))}async loadStream(){const A=await this.loadModelJSON(),V=await this.getWeightUrls(A.weightsManifest),$=fV(A.weightsManifest),ne=()=>i6(V,this.loadOptions);return Object.assign(Object.assign({},A),{weightSpecs:$,getWeightStream:ne})}async getWeightUrls(A){const V=Array.isArray(this.path)?this.path[1]:this.path,[$,ne]=iN(V),xe=this.weightPathPrefix||$,le=[],ce=[];for(const ue of A)for(const Te of ue.paths)this.weightUrlConverter!=null?ce.push(this.weightUrlConverter(Te)):le.push(xe+Te+ne);return this.weightUrlConverter&&le.push(...await Promise.all(ce)),le}async loadWeights(A){const V=await this.getWeightUrls(A),$=fV(A),ne=await i5(V,this.loadOptions);return[$,ne]}}im.URL_SCHEME_REGEX=/^https?:\/\//;function iN(W){const A=W.lastIndexOf("/"),V=W.lastIndexOf("?"),$=W.substring(0,A),ne=V>A?W.substring(V):"";return[$+"/",ne]}function iJ(W){return W.match(im.URL_SCHEME_REGEX)!=null}const ii=(W,A)=>{if(typeof fetch>"u"&&(A==null||A.fetchFunc==null))return null;{let V=!0;if(Array.isArray(W)?V=W.every($=>iJ($)):V=iJ(W),V)return iO(W,A)}return null};fg.registerSaveRouter(ii),fg.registerLoadRouter(ii);function iO(W,A){return new im(W,A)}function it(W,A){return iO(W,A)}class iB{constructor(A){this.modelArtifacts=A}load(){return this.modelArtifacts}}class iS{constructor(A){this.saveHandler=A}save(A){return this.saveHandler(A)}}class id{constructor(A){A.load&&(this.load=()=>Promise.resolve(A.load())),A.save&&(this.save=V=>Promise.resolve(A.save(V)))}}function iV(W,A,V,$){const ne=arguments;return new id(ib(...ne))}function ib(W,A,V,$){return arguments.length===1?W.modelTopology!=null||W.weightSpecs!=null?new iB(W):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new iB({modelTopology:W})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new iB({modelTopology:W,weightSpecs:A,weightData:V,trainingConfig:$}))}function iP(W){return new iS(W)}function iE(W){return new iS(W)}const iD="://";class ig{constructor(){this.managers={}}static getInstance(){return ig.instance==null&&(ig.instance=new ig),ig.instance}static registerManager(A,V){e(A!=null,()=>"scheme must not be undefined or null."),A.endsWith(iD)&&(A=A.slice(0,A.indexOf(iD))),e(A.length>0,()=>"scheme must not be an empty string.");const $=ig.getInstance();e($.managers[A]==null,()=>"A model store manager is already registered for scheme '"+A+"'."),$.managers[A]=V}static getManager(A){const V=ig.getInstance().managers[A];if(V==null)throw new Error("Cannot find model manager for scheme '"+A+"'");return V}static getSchemes(){return Object.keys(ig.getInstance().managers)}}function iZ(W){if(W.indexOf(iD)===-1)throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+ig.getSchemes().join(","));return{scheme:W.split(iD)[0],path:W.split(iD)[1]}}async function ie(W,A,V=!1){e(W!==A,()=>"Old path and new path are the same: '"+W+"'");const $=fg.getLoadHandlers(W);e($.length>0,()=>"Copying failed because no load handler is found for source URL "+W+"."),e($.length<2,()=>"Copying failed because more than one ("+$.length+") load handlers for source URL "+W+".");const ne=$[0],xe=fg.getSaveHandlers(A);e(xe.length>0,()=>"Copying failed because no save handler is found for destination URL "+A+"."),e(xe.length<2,()=>"Copying failed because more than one ("+$.length+") save handlers for destination URL "+A+".");const le=xe[0],ce=iZ(W).scheme,ue=iZ(W).path,Te=ce===iZ(W).scheme,Me=await ne.load();V&&Te&&await ig.getManager(ce).removeModel(ue);const Re=await le.save(Me);return V&&!Te&&await ig.getManager(ce).removeModel(ue),Re.modelArtifactsInfo}async function iQ(){const W=ig.getSchemes(),A={};for(const V of W){const $=await ig.getManager(V).listModels();for(const ne in $){const xe=V+iD+ne;A[xe]=$[ne]}}return A}async function is(W){const A=iZ(W);return ig.getManager(A.scheme).removeModel(A.path)}async function iF(W,A){return ie(W,A,!1)}async function iI(W,A){return ie(W,A,!0)}var iy=Object.freeze({__proto__:null,CompositeArrayBuffer:Jx,browserFiles:i3,browserHTTPRequest:it,concatenateArrayBuffers:fi,copyModel:iF,decodeWeights:f4,decodeWeightsStream:f9,encodeWeights:f3,fromMemory:iV,fromMemorySync:ib,getLoadHandlers:fQ,getModelArtifactsForJSON:fS,getModelArtifactsForJSONSync:fB,getModelArtifactsInfoForJSON:fd,getSaveHandlers:fe,getWeightSpecs:fV,http:iO,isHTTPScheme:iJ,listModels:iQ,loadWeights:i7,moveModel:iI,registerLoadRouter:fo,registerSaveRouter:fZ,removeModel:is,weightsLoaderFactory:i8,withSaveHandler:iP,withSaveHandlerSync:iE});function iA(W,A){const V=Jv(W,"x","cast");if(!G(A))throw new Error("Failed to cast to unknown dtype "+A);if(A==="string"&&V.dtype!=="string"||A!=="string"&&V.dtype==="string")throw new Error("Only strings can be casted to strings");const $={x:V},ne={dtype:A};return JA.runKernel(CA,$,ne)}const ip=Ja({cast_:iA});function iw(W,A,V=!1,$=!1){let ne=Jv(W,"a","matMul"),xe=Jv(A,"b","matMul");[ne,xe]=Jg(ne,xe);const le={a:ne,b:xe},ce={transposeA:V,transposeB:$};return JA.runKernel(CF,le,ce)}const iX=Ja({matMul_:iw});function ic(W){const A={input:Jv(W,"input","imag")};return JA.runKernel(Cr,A)}const iW=Ja({imag_:ic});function iR(W){const A={x:Jv(W,"x","neg")};return JA.runKernel(mN,A)}const iK=Ja({neg_:iR});function iT(W){const A={input:Jv(W,"input","real")};return JA.runKernel(mV,A)}const iv=Ja({real_:iT});function iq(W,A,V){const $=Jv(W,"x","transpose");if(A==null&&(A=$.shape.map((le,ce)=>ce).reverse()),e($.rank===A.length,()=>"Error in transpose: rank of input "+$.rank+" must match length of perm "+A+"."),A.forEach(le=>{e(le>=0&&le<$.rank,()=>"All entries in 'perm' must be between 0 and "+($.rank-1)+" but got "+A)}),$.rank<=1)return $.clone();const ne={x:$},xe={perm:A};return $.dtype==="complex64"?JY(()=>{let le=iv($),ce=iW($);return le=JA.runKernel(mK,{x:le},xe),ce=JA.runKernel(mK,{x:ce},xe),V&&(ce=iK(ce)),JL(le,ce)}):JA.runKernel(mK,ne,xe)}const il=Ja({transpose_:iq});function ia(W,A){const V=W.length,$=[];for(let ne=0;ne<V;ne++){const xe=V-1-ne,le=W[xe]||1;(A[A.length-1-ne]||1)>1&&le===1&&$.unshift(xe)}return $}function iL(W,A){const V=[];for(let $=0;$<A.length;$++){const ne=W[W.length-$-1],xe=A.length-$-1,le=A[xe];(ne==null||ne===1&&le>1)&&V.unshift(xe)}return V}function iH(W,A){const V=Math.max(W.length,A.length),$=new Array(V);for(let ne=0;ne<V;ne++){let xe=W[W.length-ne-1];xe==null&&(xe=1);let le=A[A.length-ne-1];if(le==null&&(le=1),xe===1)$[V-ne-1]=le;else if(le===1)$[V-ne-1]=xe;else if(xe!==le){const ce="Operands could not be broadcast together with shapes "+W+" and "+A+".";throw Error(ce)}else $[V-ne-1]=xe}return $}function ik(W,A,V){if(s(W),A!=null&&A.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const $=JR(W,V);if($.length!==3&&$.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if($.length===1&&A==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return JH(W,A,$,V)}let iz;function ix(W,A=3){if(A>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(W==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let V=!1,$=!1,ne=!1,xe=!1,le=!1,ce=!1;if(W.data instanceof Uint8Array)V=!0;else if(typeof ImageData<"u"&&W instanceof ImageData)$=!0;else if(typeof HTMLVideoElement<"u"&&W instanceof HTMLVideoElement)ne=!0;else if(typeof HTMLImageElement<"u"&&W instanceof HTMLImageElement)xe=!0;else if(W.getContext!=null)le=!0;else if(typeof ImageBitmap<"u"&&W instanceof ImageBitmap)ce=!0;else throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+W.constructor.name);if(mG(ml,JA.backendName)!=null){const we={pixels:W},ke={numChannels:A};return JA.runKernel(ml,we,ke)}const[ue,Te]=ne?[W.videoWidth,W.videoHeight]:[W.width,W.height];let Me;if(le)Me=W.getContext("2d").getImageData(0,0,ue,Te).data;else if($||V)Me=W.data;else if(xe||ne||ce){if(iz==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")iz=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else iz=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});iz.canvas.width=ue,iz.canvas.height=Te,iz.drawImage(W,0,0,ue,Te),Me=iz.getImageData(0,0,ue,Te).data}let Re;if(A===4)Re=new Int32Array(Me);else{const we=ue*Te;Re=new Int32Array(we*A);for(let ke=0;ke<we;ke++)for(let Ue=0;Ue<A;++Ue)Re[ke*A+Ue]=Me[ke*4+Ue]}return ik(Re,[Te,ue,A],"int32")}const iU=Ja({fromPixels_:ix});function iG(W,A){const V=W.shape.length,$=A.shape.length;if(V<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+V+".");if($<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+$+".");if(A.dtype!=="int32")throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+A.dtype+".");if(A.shape[$-1]>V)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+A.shape[$-1]+" vs. "+V);if(F(W.shape)===0)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+W.shape+".");const ne=A.shape,xe=ne[ne.length-1];let le=1;for(let Re=0;Re<ne.length-1;++Re)le*=ne[Re];const ce=W.shape,ue=ne.slice();ue.pop();let Te=1;for(let Re=xe;Re<V;++Re)Te*=ce[Re],ue.push(ce[Re]);const Me=[...C5(W.shape).map(Re=>Re/Te),1].slice(0,xe);return[ue,le,Te,Me]}function iu(W,A,V){const $=A.rank>1?A.shape[A.rank-1]:1,ne=A.rank>1?A.rank-1:1,xe="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+V.shape+", indices.shape: "+A.shape+", shape: "+W+", sliceDim: "+$+", and batchDim: "+ne+".";if(V.rank<ne)throw new Error(xe+(" update.rank < "+ne+". "));if(W.length<$+(V.rank-ne))throw new Error(xe+(" Output shape length < "+($+(V.rank-ne))));if(V.rank!==ne+W.length-$)throw new Error(xe+(" update.rank != "+(ne+W.length-$)));for(let le=0;le<ne;++le)if(V.shape[le]!==A.shape[le])throw new Error(xe+(" updates.shape["+le+"] ("+V.shape[le]+") != indices.shape["+le+"] ("+A.shape[le]+")."));for(let le=0;le<V.rank-ne;++le)if(V.shape[le+ne]!==W[le+$])throw new Error(xe+(" updates.shape["+(le+ne)+"] ("+V.shape[le+ne]+") != shape["+(le+ne)+"] ("+W[le+ne]+")"))}function iY(W,A,V){if(A.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+A.rank+".");if(W.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+W.rank+".");if(A.dtype!=="int32")throw new Error("The dtype of 'indices' should be int32, but got dtype: "+A.dtype);if(V.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+V);if(V.length===0){if(A.size===0)throw new Error("Indices specified for empty output. indices shape: "+A.shape);if(W.size===0)throw new Error("Updates specified for empty output. updates shape: "+W.shape)}iu(V,A,W)}function iM(W,A,V){const $=A.shape.length,ne=$>1?A.shape[$-1]:1,xe=V.length;let le=1;for(let Re=ne;Re<xe;++Re)le*=V[Re];const ce=ne<1?1:ne,ue=F(A.shape)/ce,Te=[...C5(V.slice(0,ne)),1],Me=F(V);return{sliceRank:ne,numUpdates:ue,sliceSize:le,strides:Te,outputSize:Me}}const ih=-2,ij=-1;function ir(W,A,V){const $=W.shape.length;e($===A.length,()=>"Error in slice"+$+"D: Length of begin "+A+" must match the rank of the array ("+$+")."),e($===V.length,()=>"Error in slice"+$+"D: Length of size "+V+" must match the rank of the array ("+$+").");for(let ne=0;ne<$;++ne)e(A[ne]+V[ne]<=W.shape[ne],()=>"Error in slice"+$+"D: begin["+ne+"] + size["+ne+"] ("+(A[ne]+V[ne])+") would overflow input.shape["+ne+"] ("+W.shape[ne]+")")}function O0(W){const A=[];let V=0;for(;W>0;)W&1&&A.push(V),W/=2,V++;return A}function O1(W,A,V){const $=[];for(let ne=0;ne<W.length;ne++)$[ne]=Math.ceil((A[ne]-W[ne])/V[ne]);return $}function O2(W,A,V,$){const ne=[...W];for(let xe=ne.length;xe<$.length;xe++)ne.push(1);for(let xe=0;xe<V;xe++)xe===0?ne[A]=1:(ne.splice(A,0,1),ne.pop());return ne}function O3(W,A,V){return V<=W?V:V-(A-1)}function O4(W,A){const V=[];for(let $=0;$<W;$++)V.push(A+$);return V}function O5(W,A,V,$,ne,xe,le,ce,ue){const Te=W.length;let Me=new Array(Te),Re=new Array(Te),we=new Array(Te);if(A.length&&V>0){const ke=A[0],Ue=V+1;Me=O6(le,ke,Ue,$,W),Re=O7(ce,ke,Ue,ne,W),we=O2(xe,ke,Ue,W)}else for(let ke=0;ke<Te;ke++)Me[ke]=O9(le,$,xe,W,ke,ue),Re[ke]=OC(ce,ne,xe,W,ke,ue),we[ke]=O8(xe,ke,ue);return{begin:Me,end:Re,strides:we}}function O6(W,A,V,$,ne){const xe=[...ne],le=O4(V,A);for(let ce=0;ce<xe.length;ce++)if(le.indexOf(ce)>-1)xe[ce]=0;else{const ue=O3(A,V,ce);let Te=$[ue];W&1<<ue&&(Te=0),xe[ce]=Te}return xe}function O7(W,A,V,$,ne){const xe=[...ne],le=O4(V,A);for(let ce=0;ce<xe.length;ce++)if(le.indexOf(ce)>-1)xe[ce]=Number.MAX_SAFE_INTEGER;else{const ue=O3(A,V,ce);let Te=$[ue];W&1<<ue&&(Te=Number.MAX_SAFE_INTEGER),xe[ce]=Te}for(let ce=0;ce<xe.length;ce++){const ue=ne[ce];xe[ce]<0&&(xe[ce]+=ue),xe[ce]=t(0,xe[ce],ne[ce])}return xe}function O8(W,A,V){let $=W[A];return(V&1<<A||$==null)&&($=1),$}function O9(W,A,V,$,ne,xe){let le=A[ne];const ce=V[ne]||1;(W&1<<ne||xe&1<<ne||le==null)&&(ce>0?le=Number.MIN_SAFE_INTEGER:le=Number.MAX_SAFE_INTEGER);const ue=$[ne];return le<0&&(le+=ue),le=t(0,le,ue-1),le}function OC(W,A,V,$,ne,xe){let le=A[ne];const ce=V[ne]||1;(W&1<<ne||xe&1<<ne||le==null)&&(ce>0?le=Number.MAX_SAFE_INTEGER:le=Number.MIN_SAFE_INTEGER);const ue=$[ne];return le<0&&(le+=ue),ce>0?le=t(0,le,ue):le=t(-1,le,ue-1),le}function Om(W,A,V){let $=V.length;for(let ne=0;ne<V.length;ne++)if(V[ne]>1){$=ne;break}for(let ne=$+1;ne<V.length;ne++)if(A[ne]>0||V[ne]!==W[ne])return!1;return!0}function ON(W,A){let V=W.length>0?W[W.length-1]:1;for(let $=0;$<W.length-1;$++)V+=W[$]*A[$];return V}function OJ(W,A,V){let $;const ne=W.shape.length;typeof A=="number"?$=[A,...new Array(ne-1).fill(0)]:A.length<ne?$=A.concat(new Array(ne-A.length).fill(0)):$=A.slice(),$.forEach(le=>{e(le!==-1,()=>"slice() does not support negative begin indexing.")});let xe;return V==null?xe=new Array(ne).fill(-1):typeof V=="number"?xe=[V,...new Array(ne-1).fill(-1)]:V.length<ne?xe=V.concat(new Array(ne-V.length).fill(-1)):xe=V,xe=xe.map((le,ce)=>le>=0?le:(e(le===-1,()=>"Negative size values should be exactly -1 but got "+le+" for the slice() size at index "+ce+"."),W.shape[ce]-$[ce])),[$,xe]}function Of(W,A,V,$,ne,xe,le,ce,ue){let Te;if($==null?(Te=new Array(A.length),Te.fill(1)):Te=$,le!=null&&le&le-1)throw new Error("Multiple ellipses in slice is not allowed.");let Me=!1;const Re={dims:Te.length,numAddAxisAfterEllipsis:0,begin:A.slice(),end:V.slice(),strides:Te.slice(),beginMask:ne,endMask:xe,ellipsisMask:le,newAxisMask:ce,shrinkAxisMask:ue};for(let Ye=0;Ye<Re.dims;Ye++)Me&&1<<Ye&ce&&Re.numAddAxisAfterEllipsis++,1<<Ye&le&&(Me=!0);Me||(Re.ellipsisMask|=1<<Re.dims,Re.dims++);const we={dims:W.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Oi(Re,we);let ke=!0,Ue=!0,Ge=!0;const We=[],Xe=[];for(let Ye=0;Ye<W.length;++Ye){if(we.strides[Ye]===0)throw Error("strides["+Ye+"] must be non-zero");const je=!!(we.shrinkAxisMask&1<<Ye),Ke=W[Ye];if(Ke===-1){We.push(je?1:-1);continue}const qe=[we.beginMask&1<<Ye,we.endMask&1<<Ye],$e=[we.strides[Ye]>0?0:-1,we.strides[Ye]>0?Ke:Ke-1];if(je&&we.strides[Ye]<=0)throw Error("only stride 1 allowed on non-range indexing.");Ge=Ge&&we.strides[Ye]===1;const vt=!!(we.beginMask&1<<Ye&&we.endMask&1<<Ye);if(we.beginValid&&we.endValid){if(je){const Ht=we.begin[Ye]<0?Ke+we.begin[Ye]:we.begin[Ye];if(we.begin[Ye]=Ht,we.end[Ye]=we.begin[Ye]+1,Ht<0||Ht>=Ke)throw Error("slice index "+we.begin[Ye]+" of dimension "+Ye+" out of bounds.")}else we.begin[Ye]=OO(we.begin[Ye],0,we.strides[Ye],Ke,qe,$e),we.end[Ye]=OO(we.end[Ye],1,we.strides[Ye],Ke,qe,$e);const Kt=we.strides[Ye]===1&&we.begin[Ye]===0&&we.end[Ye]===Ke;ke=ke&&Kt,Ue=Ue&&(Ye===0&&we.strides[Ye]===1||Kt)}else ke=ke&&we.strides[Ye]===1&&vt,Ue=Ue&&(Ye===0&&we.strides[Ye]===1||vt);let nt,wt=!1;if(we.beginValid&&we.endValid?(nt=we.end[Ye]-we.begin[Ye],wt=!0):je?(nt=1,wt=!0):vt&&Ke>=0&&(we.strides[Ye]<0?nt=-Ke:nt=Ke,wt=!0),wt){let Kt;nt===0||nt<0!=we.strides[Ye]<0?Kt=0:Kt=Math.trunc(nt/we.strides[Ye])+(nt%we.strides[Ye]!==0?1:0),We.push(Kt)}else We.push(-1)}for(let Ye=0;Ye<we.finalShapeGatherIndices.length;++Ye){const je=we.finalShapeGatherIndices[Ye];je>=0?Xe.push(We[je]):je===ih&&Xe.push(1)}return{finalShapeSparse:Xe.filter((Ye,je)=>we.finalShapeGatherIndices[je]!==ih),finalShape:Xe,isIdentity:ke,sliceDim0:Ue,isSimpleSlice:Ge,begin:we.begin,end:we.end,strides:we.strides}}function Oi(W,A){A.beginMask=0,A.endMask=0,A.shrinkAxisMask=0;let V=0;A.beginValid=W.begin!=null,A.endValid=W.end!=null,A.begin=new Array(A.dims),A.end=new Array(A.dims),A.strides=new Array(A.dims),A.finalShapeGatherIndices=[],A.finalShapeGatherIndicesSparse=[],A.inputShapeGatherIndicesSparse=new Array(A.dims);for(let $=0;$<W.dims;$++)if(1<<$&W.ellipsisMask){const ne=Math.min(A.dims-(W.dims-$)+1+W.numAddAxisAfterEllipsis,A.dims);for(;V<ne;V++)A.begin[V]=0,A.end[V]=0,A.strides[V]=1,A.beginMask|=1<<V,A.endMask|=1<<V,A.finalShapeGatherIndices.push(V),A.finalShapeGatherIndicesSparse.push(-1),A.inputShapeGatherIndicesSparse[V]=$}else if(1<<$&W.newAxisMask)A.finalShapeGatherIndices.push(ih),A.finalShapeGatherIndicesSparse.push(-1);else{if(V===A.begin.length)throw Error("Index out of range using input dim "+V+"; input has only "+A.dims+" dims, "+A.begin.length+".");W.begin!=null&&(A.begin[V]=W.begin[$]),W.end!=null&&(A.end[V]=W.end[$]),A.strides[V]=W.strides[$],W.beginMask&1<<$&&(A.beginMask|=1<<V),W.endMask&1<<$&&(A.endMask|=1<<V),W.shrinkAxisMask&1<<$?(A.finalShapeGatherIndices.push(ij),A.finalShapeGatherIndicesSparse.push(-1),A.shrinkAxisMask|=1<<V):(A.finalShapeGatherIndices.push(V),A.finalShapeGatherIndicesSparse.push($)),A.inputShapeGatherIndicesSparse[V]=$,V++}}function OO(W,A,V,$,ne,xe){if(ne[A])return V>0?xe[A]:xe[A+1&1];{const le=W<0?$+W:W;return le<xe[0]?xe[0]:le>xe[1]?xe[1]:le}}var Ot=Object.freeze({__proto__:null,assertParamsValid:ir,computeFlatOffset:ON,computeOutShape:O1,getNormalizedAxes:O5,isSliceContinous:Om,maskToAxes:O0,parseSliceParams:OJ,sliceInfo:Of,startForAxis:O9,startIndicesWithElidedDims:O6,stopForAxis:OC,stopIndicesWithElidedDims:O7,stridesForAxis:O8,stridesWithElidedDims:O2});function OB(W,A){let V=Jv(W,"a","add"),$=Jv(A,"b","add");[V,$]=Jg(V,$);const ne={a:V,b:$};return JA.runKernel(Co,ne)}const OS=Ja({add_:OB});function Od(W,A){let V=Jv(W,"a","floorDiv"),$=Jv(A,"b","floorDiv");[V,$]=Jg(V,$);const ne={a:V,b:$};return JA.runKernel(Cu,ne)}const OV=Ja({floorDiv_:Od});function Ob(W,A){let V=Jv(W,"a","div"),$=Jv(A,"b","div");if([V,$]=Jg(V,$),V.dtype==="int32"&&$.dtype==="int32")return OV(V,$);const ne={a:V,b:$},xe={};return JA.runKernel(CL,ne,xe)}const OP=Ja({div_:Ob});function OE(W,A){let V=Jv(W,"a","mul"),$=Jv(A,"b","mul");[V,$]=Jg(V,$);const ne={a:V,b:$};return JA.runKernel(mm,ne)}const OD=Ja({mul_:OE});function Og(W){const A=Jv(W,"x","abs");if(A.dtype==="complex64"){const V={x:A};return JA.runKernel(CX,V)}else{const V={x:A};return JA.runKernel(CZ,V)}}const OZ=Ja({abs_:Og});function Oo(W){e(Array.isArray(W),()=>"The argument passed to tf.addN() must be a list of tensors"),e(W.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+W.length);const A=W.map((ne,xe)=>Jv(ne,"tensors"+xe,"addN")),V=A[0];A.forEach(ne=>{if(ne.dtype!==V.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),A.forEach(ne=>{if(!X(ne.shape,V.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const $=A;return JA.runKernel(Ce,$)}const Oe=Ja({addN_:Oo});function OQ(W,A){let V=Jv(W,"a","atan2"),$=Jv(A,"b","atan2");[V,$]=Jg(V,$);const ne={a:V,b:$};return JA.runKernel(CQ,ne)}const Os=Ja({atan2_:OQ});function OF(W,A,V,$,ne="NHWC",xe){const le=W[3],ce=[...A,le],ue=OL(ne);return OA(W,ce,V,xe,$,null,null,ue)}function OI(W,A,V,$,ne,xe,le="channelsLast"){const[ce,ue]=OW(A);let Te;if(le==="channelsLast")Te=[ce,ue,W[3],W[3]];else if(le==="channelsFirst")Te=[ce,ue,W[1],W[1]];else throw new Error("Unknown dataFormat "+le);return OA(W,Te,V,$,ne,xe,!1,le)}function Oy(W,A,V,$,ne,xe,le="NDHWC"){const[ce,ue,Te]=OR(A);let Me,Re;if(le==="NDHWC")Re="channelsLast",Me=[ce,ue,Te,W[4],W[4]];else if(le==="NCDHW")Re="channelsFirst",Me=[ce,ue,Te,W[1],W[1]];else throw new Error("Unknown dataFormat "+le);return Op(W,Me,V,$,ne,!1,Re,xe)}function OA(W,A,V,$,ne,xe,le=!1,ce="channelsLast"){let[ue,Te,Me,Re]=[-1,-1,-1,-1];if(ce==="channelsLast")[ue,Te,Me,Re]=W;else if(ce==="channelsFirst")[ue,Re,Te,Me]=W;else throw new Error("Unknown dataFormat "+ce);const[we,ke,,Ue]=A,[Ge,We]=OW(V),[Xe,Ye]=OW($),je=OK(we,Xe),Ke=OK(ke,Ye),{padInfo:qe,outHeight:$e,outWidth:vt}=OT(ne,Te,Me,Ge,We,je,Ke,xe,ce),nt=le?Ue*Re:Ue;let wt;return ce==="channelsFirst"?wt=[ue,nt,$e,vt]:ce==="channelsLast"&&(wt=[ue,$e,vt,nt]),{batchSize:ue,dataFormat:ce,inHeight:Te,inWidth:Me,inChannels:Re,outHeight:$e,outWidth:vt,outChannels:nt,padInfo:qe,strideHeight:Ge,strideWidth:We,filterHeight:we,filterWidth:ke,effectiveFilterHeight:je,effectiveFilterWidth:Ke,dilationHeight:Xe,dilationWidth:Ye,inShape:W,outShape:wt,filterShape:A}}function Op(W,A,V,$,ne,xe=!1,le="channelsLast",ce){let[ue,Te,Me,Re,we]=[-1,-1,-1,-1,-1];if(le==="channelsLast")[ue,Te,Me,Re,we]=W;else if(le==="channelsFirst")[ue,we,Te,Me,Re]=W;else throw new Error("Unknown dataFormat "+le);const[ke,Ue,Ge,,We]=A,[Xe,Ye,je]=OR(V),[Ke,qe,$e]=OR($),vt=OK(ke,Ke),nt=OK(Ue,qe),wt=OK(Ge,$e),{padInfo:Kt,outDepth:Ht,outHeight:pi,outWidth:hi}=Ov(ne,Te,Me,Re,Xe,Ye,je,vt,nt,wt,ce),ai=xe?We*we:We;let Yi;return le==="channelsFirst"?Yi=[ue,ai,Ht,pi,hi]:le==="channelsLast"&&(Yi=[ue,Ht,pi,hi,ai]),{batchSize:ue,dataFormat:le,inDepth:Te,inHeight:Me,inWidth:Re,inChannels:we,outDepth:Ht,outHeight:pi,outWidth:hi,outChannels:ai,padInfo:Kt,strideDepth:Xe,strideHeight:Ye,strideWidth:je,filterDepth:ke,filterHeight:Ue,filterWidth:Ge,effectiveFilterDepth:vt,effectiveFilterHeight:nt,effectiveFilterWidth:wt,dilationDepth:Ke,dilationHeight:qe,dilationWidth:$e,inShape:W,outShape:Yi,filterShape:A}}function Ow(W,A,V,$,ne){$==null&&($=Oc(W,A,V));const xe=W[0],le=W[1],ce=Oq((xe-A+2*$)/V+1,ne),ue=Oq((le-A+2*$)/V+1,ne);return[ce,ue]}function OX(W,A,V,$,ne,xe){ne==null&&(ne=Oc(W,A[0],$[0]));const le=[0,0,0,V];for(let ce=0;ce<3;ce++)W[ce]+2*ne>=A[ce]&&(le[ce]=Oq((W[ce]-A[ce]+2*ne)/$[ce]+1,xe));return le}function Oc(W,A,V,$=1){const ne=OK(A,$);return Math.floor((W[0]*(V-1)-V+ne)/2)}function OW(W){return typeof W=="number"?[W,W,W]:W.length===2?[W[0],W[1],1]:W}function OR(W){return typeof W=="number"?[W,W,W]:W}function OK(W,A){return A<=1?W:W+(W-1)*(A-1)}function OT(W,A,V,$,ne,xe,le,ce,ue){let Te,Me,Re;if(typeof W=="number"){Te={top:W,bottom:W,left:W,right:W,type:W===0?"VALID":"NUMBER"};const we=Ow([A,V],xe,$,W,ce);Me=we[0],Re=we[1]}else if(W==="same"){Me=Math.ceil(A/$),Re=Math.ceil(V/ne);const we=Math.max(0,(Me-1)*$+xe-A),ke=Math.max(0,(Re-1)*ne+le-V),Ue=Math.floor(we/2),Ge=we-Ue,We=Math.floor(ke/2),Xe=ke-We;Te={top:Ue,bottom:Ge,left:We,right:Xe,type:"SAME"}}else if(W==="valid")Te={top:0,bottom:0,left:0,right:0,type:"VALID"},Me=Math.ceil((A-xe+1)/$),Re=Math.ceil((V-le+1)/ne);else if(typeof W=="object"){const we=ue==="channelsLast"?W[1][0]:W[2][0],ke=ue==="channelsLast"?W[1][1]:W[2][1],Ue=ue==="channelsLast"?W[2][0]:W[3][0],Ge=ue==="channelsLast"?W[2][1]:W[3][1];Te={top:we,bottom:ke,left:Ue,right:Ge,type:we===0&&ke===0&&Ue===0&&Ge===0?"VALID":"EXPLICIT"},Me=Oq((A-xe+we+ke)/$+1,ce),Re=Oq((V-le+Ue+Ge)/ne+1,ce)}else throw Error("Unknown padding parameter: "+W);return{padInfo:Te,outHeight:Me,outWidth:Re}}function Ov(W,A,V,$,ne,xe,le,ce,ue,Te,Me){let Re,we,ke,Ue;if(W==="valid"&&(W=0),typeof W=="number"){Re={top:W,bottom:W,left:W,right:W,front:W,back:W,type:W===0?"VALID":"NUMBER"};const Ge=OX([A,V,$,1],[ce,ue,Te],1,[ne,xe,le],W,Me);we=Ge[0],ke=Ge[1],Ue=Ge[2]}else if(W==="same"){we=Math.ceil(A/ne),ke=Math.ceil(V/xe),Ue=Math.ceil($/le);const Ge=(we-1)*ne+ce-A,We=(ke-1)*xe+ue-V,Xe=(Ue-1)*le+Te-$,Ye=Math.floor(Ge/2),je=Ge-Ye,Ke=Math.floor(We/2),qe=We-Ke,$e=Math.floor(Xe/2),vt=Xe-$e;Re={top:Ke,bottom:qe,left:$e,right:vt,front:Ye,back:je,type:"SAME"}}else throw Error("Unknown padding parameter: "+W);return{padInfo:Re,outDepth:we,outHeight:ke,outWidth:Ue}}function Oq(W,A){if(!A)return Math.trunc(W);switch(A){case"round":return Math.round(W);case"ceil":return Math.ceil(W);case"floor":return Math.floor(W);default:throw new Error("Unknown roundingMode "+A)}}function Ol(W){const[A,V,$]=OW(W);return A===1&&V===1&&$===1}function Oa(W,A){return Ol(W)||Ol(A)}function On(W){return OW(W).every(A=>A>0)}function OL(W){if(W==="NHWC")return"channelsLast";if(W==="NCHW")return"channelsFirst";throw new Error("Unknown dataFormat "+W)}function OH(W,A,V){if(V!=null){if(typeof A=="string")throw Error("Error in "+W+": pad must be an integer when using dimRoundingMode "+V+" but got pad "+A+".");if(typeof A=="number")e(R(A),()=>"Error in "+W+": pad must be an integer when using dimRoundingMode "+V+" but got pad "+A+".");else if(typeof A=="object")A.forEach($=>{$.forEach(ne=>{e(R(ne),()=>"Error in "+W+": pad must be an integer when using dimRoundingMode "+V+" but got pad "+ne+".")})});else throw Error("Error in "+W+": Unknown padding parameter: "+A)}}function Ok(W,A){const V={x:Jv(W,"x","reshape","string_or_numeric")},$={shape:A};return JA.runKernel(mP,V,$)}const Oz=Ja({reshape_:Ok});function Ox(W,A,V,$,ne){const xe=Jv(W,"x","avgPool","float32"),le=1;e(Oa(V,le),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+V+" and dilations '"+le+"'");let ce=xe,ue=!1;xe.rank===3&&(ue=!0,ce=Oz(xe,[1,xe.shape[0],xe.shape[1],xe.shape[2]])),e(ce.rank===4,()=>"Error in avgPool: x must be rank 4 but got rank "+ce.rank+"."),OH("avgPool",$,ne);const Te={x:ce},Me={filterSize:A,strides:V,pad:$,dimRoundingMode:ne};let Re=JA.runKernel(Cs,Te,Me);return Re=ip(Re,xe.dtype),ue?Oz(Re,[Re.shape[1],Re.shape[2],Re.shape[3]]):Re}const OU=Ja({avgPool_:Ox});function OG(W){const A={x:Jv(W,"x","clone","string_or_numeric")};return JA.runKernel(Cj,A)}const Ou=Ja({clone_:OG});function OY(W,A=0){e(W.length>=1,()=>"Pass at least one tensor to concat");const V=Jq(W,"tensors","concat","string_or_numeric");if(V[0].dtype==="complex64"&&V.forEach(xe=>{if(xe.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype `+xe.dtype+". ")}),V.length===1)return Ou(V[0]);const $=V,ne={axis:A};return JA.runKernel(Cc,$,ne)}const OM=Ja({concat_:OY});function Oh(W){const A={x:Jv(W,"x","sigmoid","float32")};return JA.runKernel(mF,A)}const Oj=Ja({sigmoid_:Oh});function Or(W,A,V){const $=Jv(W,"x","slice","string_or_numeric");if($.rank===0)throw new Error("Slicing scalar is not possible");const ne={x:$},xe={begin:A,size:V};return JA.runKernel(mQ,ne,xe)}const t0=Ja({slice_:Or});function t1(W,A,V){const $=Jv(W,"x","batchToSpaceND"),ne=A.reduce((ce,ue)=>ce*ue);e($.rank>=1+A.length,()=>"input rank is "+$.rank+" but should be > than blockShape.length "+A.length),e(V.length===A.length,()=>"crops.length is "+V.length+" but should be equal to blockShape.length  "+A.length),e($.shape[0]%ne===0,()=>"input tensor batch is "+$.shape[0]+" but is not divisible by the product of the elements of blockShape "+A.join(" * ")+" === "+ne);const xe={x:$},le={blockShape:A,crops:V};return JA.runKernel(CI,xe,le)}const t2=Ja({batchToSpaceND_:t1});function t3(W,A,V){const $=Jv(W,"x","bincount"),ne=Jv(A,"weights","bincount");e($.dtype==="int32",()=>"Error in bincount: input dtype must be int32, but got "+$.dtype),e(V>=0,()=>"size must be non-negative, but got "+V+"."),e(ne.size===$.size||ne.size===0,()=>"Error in bincount: weights must have the same size as input or0-length, but got input shape: "+$.shape+", weights shape: "+ne.shape+".");const xe={x:$,weights:ne},le={size:V};return JA.runKernel(Cy,xe,le)}const t4=Ja({bincount_:t3});function t5(W,A){let V=Jv(W,"broadcastTo","x");const $=V.shape;if(Cm(A),A.length<V.rank)throw new Error("broadcastTo(): shape.length="+A.length+" < input.rank="+V.rank+".");if(A.length>V.rank){const ue=V.shape.slice();for(;ue.length<A.length;)ue.unshift(1);V=Oz(V,ue)}const ne=V.shape,xe=Array.from(A);for(let ue=A.length-1;ue>=0;ue--)if(ne[ue]===A[ue])xe[ue]=1;else if(V.shape[ue]!==1)throw new Error("broadcastTo(): ["+$+"] cannot be broadcast to ["+A+"].");if(xe.map((ue,Te)=>ue>1?Te:-1).filter(ue=>ue>=0).length===0)return Ou(V);const le={x:V},ce={reps:xe};return JA.runKernel(mW,le,ce)}const t6=Ja({broadcastTo_:t5});function t7(W,A="float32",V){return A=A||"float32",Cm(W),new J8(W,A,V)}function t8(W,A,V){Cm(W),V=V||C2(A);const $={shape:W,value:A,dtype:V};return JA.runKernel(Cx,{},$)}function t9(W,A,V){const $=Jv(W,"x","clipByValue");if(e(A<=V,()=>"Error in clip: min ("+A+") must be less than or equal to max ("+V+")."),A===V)return t8($.shape,A,$.dtype);const ne={x:$},xe={clipValueMin:A,clipValueMax:V};return JA.runKernel(Cp,ne,xe)}const tC=Ja({clipByValue_:t9});function tm(W,A){return OM(W,A)}const tN=Ja({concat2d_:tm});function tJ(W,A){return OM(W,A)}const tf=Ja({concat3d_:tJ});function ti(W,A,V,$,ne="NHWC",xe=[1,1],le){const ce=Jv(W,"x","conv2d","float32"),ue=Jv(A,"filter","conv2d","float32");let Te=ce,Me=!1;ce.rank===3&&(Me=!0,Te=Oz(ce,[1,ce.shape[0],ce.shape[1],ce.shape[2]])),e(Te.rank===4,()=>"Error in conv2d: input must be rank 4, but got rank "+Te.rank+"."),e(ue.rank===4,()=>"Error in conv2d: filter must be rank 4, but got rank "+ue.rank+"."),OH("conv2d",$,le);const Re=ne==="NHWC"?Te.shape[3]:Te.shape[1];e(Re===ue.shape[2],()=>"Error in conv2d: depth of input ("+Re+") must match input depth for filter "+ue.shape[2]+"."),e(Oa(V,xe),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+V+" and dilations '"+xe+"'"),e(On(xe),()=>"Error in conv2D: Dilated rates should be larger than 0."),e(On(V),()=>"Error in conv2D: Strides should be larger than 0.");const we={x:Te,filter:ue},ke={strides:V,pad:$,dataFormat:ne,dilations:xe,dimRoundingMode:le},Ue=JA.runKernel(CW,we,ke);return Me?Oz(Ue,[Ue.shape[1],Ue.shape[2],Ue.shape[3]]):Ue}const tO=Ja({conv2d_:ti});function tt(W,A,V,$,ne,xe="NHWC",le){e(W.length===A.rank,()=>"Length of inShape ("+W.length+") and rank of dy ("+A.rank+") must match");let ce=W,ue=A,Te=!1;A.rank===3&&(Te=!0,ue=Oz(A,[1,A.shape[0],A.shape[1],A.shape[2]]),ce=[1,W[0],W[1],W[2]]),e(ce.length===4,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+ce.length+"."),e(ue.rank===4,()=>"Error in conv2dDerInput: dy must be rank 4, but got rank "+ue.rank),e(V.rank===4,()=>"Error in conv2dDerInput: filter must be rank 4, but got rank "+V.rank);const Me=xe==="NHWC"?ce[3]:ce[1],Re=xe==="NHWC"?ue.shape[3]:ue.shape[1];e(Me===V.shape[2],()=>"Error in conv2dDerInput: depth of input ("+Me+") must match input depth for filter "+V.shape[2]+"."),e(Re===V.shape[3],()=>"Error in conv2dDerInput: depth of output ("+Re+") must match output depth for filter "+V.shape[3]+"."),OH("conv2dDerInput",ne,le);const we={dy:ue,filter:V},ke={strides:$,pad:ne,dataFormat:xe,dimRoundingMode:le,inputShape:ce},Ue=JA.runKernel(CK,we,ke);return Te?Oz(Ue,[Ue.shape[1],Ue.shape[2],Ue.shape[3]]):Ue}const tB=Ja({conv2DBackpropInput_:tt});function tS(W,A,V,$,ne,xe){const le=Jv(W,"x","conv2dTranspose"),ce=Jv(A,"filter","conv2dTranspose");return tB(V,le,ce,$,ne,"NHWC",xe)}const td=Ja({conv2dTranspose_:tS});function tV(W){const A={x:Jv(W,"x","cos","float32")};return JA.runKernel(CT,A)}const tb=Ja({cos_:tV});function tP(W,A,V="NHWC"){const $=Jv(W,"x","depthToSpace","float32"),ne=V==="NHWC"?$.shape[1]:$.shape[2],xe=V==="NHWC"?$.shape[2]:$.shape[3],le=V==="NHWC"?$.shape[3]:$.shape[1];e(A>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+A),e(ne*A>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+ne+" and "+A+`  for depthToSpace with input shape
    `+$.shape),e(xe*A>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+xe+" and "+A+` for depthToSpace with input shape
        `+$.shape),e(le%(A*A)===0,()=>"Dimension size must be evenly divisible by "+A*A+" but is "+le+" for depthToSpace with input shape "+$.shape);const ce={x:$},ue={blockSize:A,dataFormat:V};return JA.runKernel(Cq,ce,ue)}const tE=Ja({depthToSpace_:tP});function tD(W,A,V,$,ne="NHWC",xe=[1,1],le){const ce=Jv(W,"x","depthwiseConv2d","float32"),ue=Jv(A,"filter","depthwiseConv2d","float32");let Te=ce,Me=!1;ce.rank===3&&(Me=!0,Te=Oz(ce,[1,ce.shape[0],ce.shape[1],ce.shape[2]])),e(Te.rank===4,()=>"Error in depthwiseConv2d: input must be rank 4, but got rank "+Te.rank+"."),e(ue.rank===4,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+ue.rank+".");const Re=ne==="NHWC"?Te.shape[3]:Te.shape[1];e(Re===ue.shape[2],()=>"Error in depthwiseConv2d: number of input channels ("+Re+") must match the inChannels dimension in filter "+ue.shape[2]+"."),OH("depthwiseConv2d",$,le);const we={x:Te,filter:ue},ke={strides:V,pad:$,dataFormat:ne,dilations:xe,dimRoundingMode:le},Ue=JA.runKernel(Cl,we,ke);return Me?Oz(Ue,[Ue.shape[1],Ue.shape[2],Ue.shape[3]]):Ue}const tg=Ja({depthwiseConv2d_:tD});function tZ(W,A,V){const $=Jv(A,"a","where"),ne=Jv(V,"b","where"),xe=Jv(W,"condition","where","bool"),le=iH(iH(xe.shape,$.shape),ne.shape),ce=t6(xe,le),ue=t6($,le),Te=t6(ne,le),Me={condition:ce,t:ue,e:Te};return JA.runKernel(me,Me)}const to=Ja({where_:tZ});function te(W){const A={x:Jv(W,"x","zerosLike")};return JA.runKernel(mv,A)}const tQ=Ja({zerosLike_:te});function ts(W,...A){const V=A.map((ne,xe)=>Jv(ne,"tensors"+xe,"einsum")),$={equation:W};return JA.runKernel(CH,V,$)}const tF=Ja({einsum_:ts});function tI(W){const A={x:Jv(W,"x","elu","float32")};return JA.runKernel(Ck,A)}const ty=Ja({elu_:tI});function tA(W,A){for(let V=0;V<W.length;++V)if(W[W.length-V-1]!==A-1-V)return!1;return!0}function tp(W,A,V){const $=W.length+A.length,ne=[];let xe=0,le=0;for(let ce=0;ce<$;ce++)V.indexOf(ce)===-1?ne.push(W[xe++]):ne.push(A[le++]);return ne}function tw(W,A){const V=[],$=W.length;for(let xe=0;xe<$;xe++)A.indexOf(xe)===-1&&V.push(W[xe]);const ne=A.map(xe=>W[xe]);return[V,ne]}function tX(W,A){const V=A.map($=>1);return tp(W,V,A)}function tc(W,A,V){e(tA(A,V),()=>W+" supports only inner-most axes for now. Got axes "+A+" and rank-"+V+" input.")}function tW(W,A){if(tA(W,A))return null;const V=[];for(let $=0;$<A;++$)W.indexOf($)===-1&&V.push($);return W.forEach($=>V.push($)),V}function tR(W){return W.map((A,V)=>[V,A]).sort((A,V)=>A[1]-V[1]).map(A=>A[0])}function tK(W,A){const V=[];for(let $=A-W;$<A;++$)V.push($);return V}function tT(W,A=null,V=!1){const $={x:Jv(W,"x","max")},ne={reductionIndices:A,keepDims:V};return JA.runKernel(m5,$,ne)}const tv=Ja({max_:tT});function tq(W,A=null,V=!1){const $={x:Jv(W,"x","min")},ne={axis:A,keepDims:V};return JA.runKernel(m9,$,ne)}const tl=Ja({min_:tq});function ta(W,A){let V=Jv(W,"base","pow"),$=Jv(A,"exp","pow");[V,$]=Jg(V,$);const ne={a:V,b:$};return JA.runKernel(mB,ne)}const tn=Ja({pow_:ta});function tL(W,A){if((NU(W)&&A!=="string"||Array.isArray(W))&&A!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(A==="string"&&NU(W)&&!(W instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return JH(W,[],[],A)}function tH(W){const A={x:Jv(W,"x","sqrt","float32")};return JA.runKernel(mI,A)}const tk=Ja({sqrt_:tH});function tz(W){const A=Jv(W,"x","square"),V={};return JA.runKernel("Square",{x:A},V)}const tx=Ja({square_:tz});function tU(W,A=null,V=!1){let $=Jv(W,"x","sum");$.dtype==="bool"&&($=ip($,"int32"));const ne={x:$},xe={axis:A,keepDims:V};return JA.runKernel(my,ne,xe)}const tG=Ja({sum_:tU});function tu(W,A="euclidean",V=null,$=!1){W=Jv(W,"x","norm");const ne=tY(W,A,V);let xe=ne.shape;if($){const le=n(V,W.shape);xe=tX(ne.shape,le)}return Oz(ne,xe)}function tY(W,A,V=null){if(W.rank===0)return OZ(W);if(W.rank!==1&&V===null)return tY(Oz(W,[-1]),A,V);if(W.rank===1||typeof V=="number"||Array.isArray(V)&&V.length===1){if(A===1)return tG(OZ(W),V);if(A===1/0)return tv(OZ(W),V);if(A===-1/0)return tl(OZ(W),V);if(A==="euclidean"||A===2)return tk(tG(tn(OZ(W),tL(2,"int32")),V));throw new Error("Error in norm: invalid ord value: "+A)}if(Array.isArray(V)&&V.length===2){if(A===1)return tv(tG(OZ(W),V[0]),V[1]-1);if(A===1/0)return tv(tG(OZ(W),V[1]),V[0]);if(A===-1/0)return tl(tG(OZ(W),V[1]),V[0]);if(A==="fro"||A==="euclidean")return tk(tG(tx(W),V));throw new Error("Error in norm: invalid ord value: "+A)}throw new Error("Error in norm: invalid axis: "+V)}const tM=Ja({norm_:tu});function th(W,A=null,V=!1){return tM(W,"euclidean",A,V)}const tj=Ja({euclideanNorm_:th});function tr(W,A=0){const V=Jv(W,"x","expandDims","string_or_numeric");e(A<=V.rank,()=>"Axis must be <= rank of the tensor");const $={input:V},ne={dim:A};return JA.runKernel(Cz,$,ne)}const B0=Ja({expandDims_:tr});function B1(W,A){const V=Jv(W,"x","tile","string_or_numeric");e(V.rank===A.length,()=>"Error in transpose: rank of input "+V.rank+" must match length of reps "+A+".");const $={x:V},ne={reps:A};return JA.runKernel(mW,$,ne)}const B2=Ja({tile_:B1});function B3(W){const A={x:Jv(W,"x","floor","float32")};return JA.runKernel(CG,A)}const B4=Ja({floor_:B3});function B5(W,A,V=0,$=0){const ne=Jv(W,"x","gather"),xe=Jv(A,"indices","gather","int32"),le={x:ne,indices:xe},ce={axis:V,batchDims:$};return JA.runKernel(CY,le,ce)}const B6=Ja({gather_:B5});function B7(W,A){let V=Jv(W,"a","greater","string_or_numeric"),$=Jv(A,"b","greater","string_or_numeric");[V,$]=Jg(V,$),iH(V.shape,$.shape);const ne={a:V,b:$};return JA.runKernel(CM,ne)}const B8=Ja({greater_:B7});function B9(W,A){let V=Jv(W,"a","greaterEqual","string_or_numeric"),$=Jv(A,"b","greaterEqual","string_or_numeric");[V,$]=Jg(V,$),iH(V.shape,$.shape);const ne={a:V,b:$};return JA.runKernel(Ch,ne)}const BC=Ja({greaterEqual_:B9});function Bm(W,A=.2){const V={x:Jv(W,"x","leakyRelu")},$={alpha:A};return JA.runKernel(m0,V,$)}const BN=Ja({leakyRelu_:Bm});function BJ(W,A){let V=Jv(W,"a","less","string_or_numeric"),$=Jv(A,"b","less","string_or_numeric");[V,$]=Jg(V,$),iH(V.shape,$.shape);const ne={a:V,b:$};return JA.runKernel(m1,ne)}const Bf=Ja({less_:BJ});function Bi(W,A){let V=Jv(W,"a","lessEqual","string_or_numeric"),$=Jv(A,"b","lessEqual","string_or_numeric");[V,$]=Jg(V,$),iH(V.shape,$.shape);const ne={a:V,b:$};return JA.runKernel(m2,ne)}const BO=Ja({lessEqual_:Bi});function Bt(W){return JA.customGrad(W)}function BB(W,A){let V=Jv(W,"a","sub"),$=Jv(A,"b","sub");[V,$]=Jg(V,$);const ne={a:V,b:$};return JA.runKernel(mc,ne)}const BS=Ja({sub_:BB});function Bd(W,A){const V=Jv(W,"a","logicalAnd","bool"),$=Jv(A,"b","logicalAnd","bool");iH(V.shape,$.shape);const ne={a:V,b:$};return JA.runKernel(m3,ne)}const BV=Ja({logicalAnd_:Bd});function Bb(W,A){const V=Jv(W,"a","logicalOr","bool"),$=Jv(A,"b","logicalOr","bool");iH(V.shape,$.shape);const ne={a:V,b:$};return JA.runKernel(m4,ne)}const BP=Ja({logicalOr_:Bb});function BE(W,A,V,$,ne){const xe=Jv(W,"x","maxPool"),le=1;let ce=xe,ue=!1;xe.rank===3&&(ue=!0,ce=Oz(xe,[1,xe.shape[0],xe.shape[1],xe.shape[2]])),e(ce.rank===4,()=>"Error in maxPool: input must be rank 4 but got rank "+ce.rank+"."),e(Oa(V,le),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+V+" and dilations '"+le+"'"),OH("maxPool",$,ne);const Te={x:ce},Me={filterSize:A,strides:V,pad:$,dimRoundingMode:ne},Re=JA.runKernel(m7,Te,Me);return ue?Oz(Re,[Re.shape[1],Re.shape[2],Re.shape[3]]):Re}const BD=Ja({maxPool_:BE});function Bg(W,A){let V=Jv(W,"a","maximum"),$=Jv(A,"b","maximum");[V,$]=Jg(V,$),V.dtype==="bool"&&(V=ip(V,"int32"),$=ip($,"int32")),iH(V.shape,$.shape);const ne={a:V,b:$};return JA.runKernel(m6,ne)}const BZ=Ja({maximum_:Bg});function Bo(W,A=null,V=!1){const $={x:Jv(W,"x","mean")},ne={axis:A,keepDims:V};return JA.runKernel(m8,$,ne)}const Be=Ja({mean_:Bo});function BQ(W,A="float32"){if(Cm(W),A==="complex64"){const $=BQ(W,"float32"),ne=BQ(W,"float32");return JL($,ne)}const V=CC(F(W),A);return JA.makeTensor(V,W,A)}function Bs(W,A="float32"){if(Cm(W),A==="complex64"){const $=Bs(W,"float32"),ne=BQ(W,"float32");return JL($,ne)}const V=C9(F(W),A);return JA.makeTensor(V,W,A)}function BF(W,A){let V=Jv(W,"a","minimum"),$=Jv(A,"b","minimum");[V,$]=Jg(V,$),V.dtype==="bool"&&(V=ip(V,"int32"),$=ip($,"int32")),iH(V.shape,$.shape);const ne={a:V,b:$};return JA.runKernel(mC,ne)}const BI=Ja({minimum_:BF});function By(W,A,V=0){const $=Jv(W,"x","pad");if($.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const ne={paddings:A,constantValue:V},xe={x:$};return JA.runKernel(mt,xe,ne)}const BA=Ja({pad_:By});function Bp(W,A,V){const $=Jv(W,"x","spaceToBatchND");e($.rank>=1+A.length,()=>"input rank "+$.rank+" should be > than [blockShape] "+A.length),e(V.length===A.length,()=>"paddings.shape[0] "+V.length+" must be equal to [blockShape] "+A.length),e($.shape.reduce((le,ce,ue)=>ue>0&&ue<=A.length?le&&(ce+V[ue-1][0]+V[ue-1][1])%A[ue-1]===0:le,!0),()=>"input spatial dimensions "+$.shape.slice(1)+" with paddings "+V.toString()+" must be divisible by blockShapes "+A.toString());const ne={x:$},xe={blockShape:A,paddings:V};return JA.runKernel(mA,ne,xe)}const Bw=Ja({spaceToBatchND_:Bp});function BX(W,A,V,$,ne,xe,le){ne==null&&(ne=[1,1]),xe==null&&(xe=1),$===0&&($="valid");const ce=Jv(W,"x","maxPool");let ue=ce,Te=!1;ce.rank===3&&(Te=!0,ue=Oz(ce,[1,ce.shape[0],ce.shape[1],ce.shape[2]])),e(Oa(xe,ne),()=>"Error in pool: Either strides or dilations must be 1. Got strides "+xe+" and dilations '"+ne+"'");const Me=OI(ue.shape,A,xe,ne,$),Re=[Me.dilationHeight,Me.dilationWidth];let we;$==="same"?we=BW([Me.filterHeight,Me.filterWidth],Re):we=[[0,0],[0,0]];const ke=Re[0]===1&&Re[1]===1,[Ue,Ge]=Bc([Me.inHeight,Me.inWidth],Re,we),We=ke?$:"valid",Xe=ke?ue:Bw(ue,Re,Ue),Ye=(V==="avg"?()=>OU(Xe,A,xe,We,le):()=>BD(Xe,A,xe,We,le))(),je=ke?Ye:t2(Ye,Re,Ge);return Te?Oz(je,[je.shape[1],je.shape[2],je.shape[3]]):je}function Bc(W,A,V){const $=V.map(Me=>Me[0]),ne=V.map(Me=>Me[1]),xe=W.concat($,ne),le=A.map((Me,Re)=>(Me-xe[Re]%Me)%Me),ce=ne.map((Me,Re)=>Me+le[Re]),ue=A.map((Me,Re)=>[$[Re],ce[Re]]),Te=A.map((Me,Re)=>[0,le[Re]]);return[ue,Te]}function BW(W,A){const V=W.map((xe,le)=>xe+(xe-1)*(A[le]-1)).map(xe=>xe-1),$=V.map(xe=>Math.floor(xe/2)),ne=V.map((xe,le)=>xe-$[le]);return V.map((xe,le)=>[$[le],ne[le]])}const BR=Ja({pool_:BX});function BK(W,A){const V=Jv(W,"x","prelu"),$=Jv(A,"alpha","prelu"),ne={x:V,alpha:$};return JA.runKernel(mS,ne)}const BT=Ja({prelu_:BK});function Bv(W,A=!1){console.log(W.toString(A))}var Bq={exports:{}};Bq.exports,function(W){(function(A,V,$){function ne(ue){var Te=this,Me=ce();Te.next=function(){var Re=2091639*Te.s0+Te.c*23283064365386963e-26;return Te.s0=Te.s1,Te.s1=Te.s2,Te.s2=Re-(Te.c=Re|0)},Te.c=1,Te.s0=Me(" "),Te.s1=Me(" "),Te.s2=Me(" "),Te.s0-=Me(ue),Te.s0<0&&(Te.s0+=1),Te.s1-=Me(ue),Te.s1<0&&(Te.s1+=1),Te.s2-=Me(ue),Te.s2<0&&(Te.s2+=1),Me=null}function xe(ue,Te){return Te.c=ue.c,Te.s0=ue.s0,Te.s1=ue.s1,Te.s2=ue.s2,Te}function le(ue,Te){var Me=new ne(ue),Re=Te&&Te.state,we=Me.next;return we.int32=function(){return Me.next()*4294967296|0},we.double=function(){return we()+(we()*2097152|0)*11102230246251565e-32},we.quick=we,Re&&(typeof Re=="object"&&xe(Re,Me),we.state=function(){return xe(Me,{})}),we}function ce(){var ue=4022871197,Te=function(Me){Me=String(Me);for(var Re=0;Re<Me.length;Re++){ue+=Me.charCodeAt(Re);var we=.02519603282416938*ue;ue=we>>>0,we-=ue,we*=ue,ue=we>>>0,we-=ue,ue+=we*4294967296}return(ue>>>0)*23283064365386963e-26};return Te}V&&V.exports?V.exports=le:$&&$.amd?$(function(){return le}):this.alea=le})(mr,W,!1)}(Bq);var Bl=Bq.exports,Ba={exports:{}};Ba.exports,function(W){(function(A,V,$){function ne(ce){var ue=this,Te="";ue.x=0,ue.y=0,ue.z=0,ue.w=0,ue.next=function(){var Re=ue.x^ue.x<<11;return ue.x=ue.y,ue.y=ue.z,ue.z=ue.w,ue.w^=ue.w>>>19^Re^Re>>>8},ce===(ce|0)?ue.x=ce:Te+=ce;for(var Me=0;Me<Te.length+64;Me++)ue.x^=Te.charCodeAt(Me)|0,ue.next()}function xe(ce,ue){return ue.x=ce.x,ue.y=ce.y,ue.z=ce.z,ue.w=ce.w,ue}function le(ce,ue){var Te=new ne(ce),Me=ue&&ue.state,Re=function(){return(Te.next()>>>0)/4294967296};return Re.double=function(){do var we=Te.next()>>>11,ke=(Te.next()>>>0)/4294967296,Ue=(we+ke)/(1<<21);while(Ue===0);return Ue},Re.int32=Te.next,Re.quick=Re,Me&&(typeof Me=="object"&&xe(Me,Te),Re.state=function(){return xe(Te,{})}),Re}V&&V.exports?V.exports=le:$&&$.amd?$(function(){return le}):this.xor128=le})(mr,W,!1)}(Ba);var Bn=Ba.exports,BL={exports:{}};BL.exports,function(W){(function(A,V,$){function ne(ce){var ue=this,Te="";ue.next=function(){var Re=ue.x^ue.x>>>2;return ue.x=ue.y,ue.y=ue.z,ue.z=ue.w,ue.w=ue.v,(ue.d=ue.d+362437|0)+(ue.v=ue.v^ue.v<<4^(Re^Re<<1))|0},ue.x=0,ue.y=0,ue.z=0,ue.w=0,ue.v=0,ce===(ce|0)?ue.x=ce:Te+=ce;for(var Me=0;Me<Te.length+64;Me++)ue.x^=Te.charCodeAt(Me)|0,Me==Te.length&&(ue.d=ue.x<<10^ue.x>>>4),ue.next()}function xe(ce,ue){return ue.x=ce.x,ue.y=ce.y,ue.z=ce.z,ue.w=ce.w,ue.v=ce.v,ue.d=ce.d,ue}function le(ce,ue){var Te=new ne(ce),Me=ue&&ue.state,Re=function(){return(Te.next()>>>0)/4294967296};return Re.double=function(){do var we=Te.next()>>>11,ke=(Te.next()>>>0)/4294967296,Ue=(we+ke)/(1<<21);while(Ue===0);return Ue},Re.int32=Te.next,Re.quick=Re,Me&&(typeof Me=="object"&&xe(Me,Te),Re.state=function(){return xe(Te,{})}),Re}V&&V.exports?V.exports=le:$&&$.amd?$(function(){return le}):this.xorwow=le})(mr,W,!1)}(BL);var BH=BL.exports,Bk={exports:{}};Bk.exports,function(W){(function(A,V,$){function ne(ce){var ue=this;ue.next=function(){var Me=ue.x,Re=ue.i,we,ke;return we=Me[Re],we^=we>>>7,ke=we^we<<24,we=Me[Re+1&7],ke^=we^we>>>10,we=Me[Re+3&7],ke^=we^we>>>3,we=Me[Re+4&7],ke^=we^we<<7,we=Me[Re+7&7],we=we^we<<13,ke^=we^we<<9,Me[Re]=ke,ue.i=Re+1&7,ke};function Te(Me,Re){var we,ke=[];if(Re===(Re|0))ke[0]=Re;else for(Re=""+Re,we=0;we<Re.length;++we)ke[we&7]=ke[we&7]<<15^Re.charCodeAt(we)+ke[we+1&7]<<13;for(;ke.length<8;)ke.push(0);for(we=0;we<8&&ke[we]===0;++we);for(we==8?ke[7]=-1:ke[we],Me.x=ke,Me.i=0,we=256;we>0;--we)Me.next()}Te(ue,ce)}function xe(ce,ue){return ue.x=ce.x.slice(),ue.i=ce.i,ue}function le(ce,ue){ce==null&&(ce=+new Date);var Te=new ne(ce),Me=ue&&ue.state,Re=function(){return(Te.next()>>>0)/4294967296};return Re.double=function(){do var we=Te.next()>>>11,ke=(Te.next()>>>0)/4294967296,Ue=(we+ke)/(1<<21);while(Ue===0);return Ue},Re.int32=Te.next,Re.quick=Re,Me&&(Me.x&&xe(Me,Te),Re.state=function(){return xe(Te,{})}),Re}V&&V.exports?V.exports=le:$&&$.amd?$(function(){return le}):this.xorshift7=le})(mr,W,!1)}(Bk);var Bz=Bk.exports,Bx={exports:{}};Bx.exports,function(W){(function(A,V,$){function ne(ce){var ue=this;ue.next=function(){var Me=ue.w,Re=ue.X,we=ue.i,ke,Ue;return ue.w=Me=Me+1640531527|0,Ue=Re[we+34&127],ke=Re[we=we+1&127],Ue^=Ue<<13,ke^=ke<<17,Ue^=Ue>>>15,ke^=ke>>>12,Ue=Re[we]=Ue^ke,ue.i=we,Ue+(Me^Me>>>16)|0};function Te(Me,Re){var we,ke,Ue,Ge,We,Xe=[],Ye=128;for(Re===(Re|0)?(ke=Re,Re=null):(Re=Re+"\0",ke=0,Ye=Math.max(Ye,Re.length)),Ue=0,Ge=-32;Ge<Ye;++Ge)Re&&(ke^=Re.charCodeAt((Ge+32)%Re.length)),Ge===0&&(We=ke),ke^=ke<<10,ke^=ke>>>15,ke^=ke<<4,ke^=ke>>>13,Ge>=0&&(We=We+1640531527|0,we=Xe[Ge&127]^=ke+We,Ue=we==0?Ue+1:0);for(Ue>=128&&(Xe[(Re&&Re.length||0)&127]=-1),Ue=127,Ge=512;Ge>0;--Ge)ke=Xe[Ue+34&127],we=Xe[Ue=Ue+1&127],ke^=ke<<13,we^=we<<17,ke^=ke>>>15,we^=we>>>12,Xe[Ue]=ke^we;Me.w=We,Me.X=Xe,Me.i=Ue}Te(ue,ce)}function xe(ce,ue){return ue.i=ce.i,ue.w=ce.w,ue.X=ce.X.slice(),ue}function le(ce,ue){ce==null&&(ce=+new Date);var Te=new ne(ce),Me=ue&&ue.state,Re=function(){return(Te.next()>>>0)/4294967296};return Re.double=function(){do var we=Te.next()>>>11,ke=(Te.next()>>>0)/4294967296,Ue=(we+ke)/(1<<21);while(Ue===0);return Ue},Re.int32=Te.next,Re.quick=Re,Me&&(Me.X&&xe(Me,Te),Re.state=function(){return xe(Te,{})}),Re}V&&V.exports?V.exports=le:$&&$.amd?$(function(){return le}):this.xor4096=le})(mr,W,!1)}(Bx);var BU=Bx.exports,BG={exports:{}};BG.exports,function(W){(function(A,V,$){function ne(ce){var ue=this,Te="";ue.next=function(){var Re=ue.b,we=ue.c,ke=ue.d,Ue=ue.a;return Re=Re<<25^Re>>>7^we,we=we-ke|0,ke=ke<<24^ke>>>8^Ue,Ue=Ue-Re|0,ue.b=Re=Re<<20^Re>>>12^we,ue.c=we=we-ke|0,ue.d=ke<<16^we>>>16^Ue,ue.a=Ue-Re|0},ue.a=0,ue.b=0,ue.c=-1640531527,ue.d=1367130551,ce===Math.floor(ce)?(ue.a=ce/4294967296|0,ue.b=ce|0):Te+=ce;for(var Me=0;Me<Te.length+20;Me++)ue.b^=Te.charCodeAt(Me)|0,ue.next()}function xe(ce,ue){return ue.a=ce.a,ue.b=ce.b,ue.c=ce.c,ue.d=ce.d,ue}function le(ce,ue){var Te=new ne(ce),Me=ue&&ue.state,Re=function(){return(Te.next()>>>0)/4294967296};return Re.double=function(){do var we=Te.next()>>>11,ke=(Te.next()>>>0)/4294967296,Ue=(we+ke)/(1<<21);while(Ue===0);return Ue},Re.int32=Te.next,Re.quick=Re,Me&&(typeof Me=="object"&&xe(Me,Te),Re.state=function(){return xe(Te,{})}),Re}V&&V.exports?V.exports=le:$&&$.amd?$(function(){return le}):this.tychei=le})(mr,W,!1)}(BG);var Bu=BG.exports,BY={exports:{}};(function(W){(function(A,V,$){var ne=256,xe=6,le=52,ce="random",ue=$.pow(ne,xe),Te=$.pow(2,le),Me=Te*2,Re=ne-1,we;function ke(Ke,qe,$e){var vt=[];qe=qe==!0?{entropy:!0}:qe||{};var nt=Xe(We(qe.entropy?[Ke,je(V)]:Ke??Ye(),3),vt),wt=new Ue(vt),Kt=function(){for(var Ht=wt.g(xe),pi=ue,hi=0;Ht<Te;)Ht=(Ht+hi)*ne,pi*=ne,hi=wt.g(1);for(;Ht>=Me;)Ht/=2,pi/=2,hi>>>=1;return(Ht+hi)/pi};return Kt.int32=function(){return wt.g(4)|0},Kt.quick=function(){return wt.g(4)/4294967296},Kt.double=Kt,Xe(je(wt.S),V),(qe.pass||$e||function(Ht,pi,hi,ai){return ai&&(ai.S&&Ge(ai,wt),Ht.state=function(){return Ge(wt,{})}),hi?($[ce]=Ht,pi):Ht})(Kt,nt,"global"in qe?qe.global:this==$,qe.state)}function Ue(Ke){var qe,$e=Ke.length,vt=this,nt=0,wt=vt.i=vt.j=0,Kt=vt.S=[];for($e||(Ke=[$e++]);nt<ne;)Kt[nt]=nt++;for(nt=0;nt<ne;nt++)Kt[nt]=Kt[wt=Re&wt+Ke[nt%$e]+(qe=Kt[nt])],Kt[wt]=qe;(vt.g=function(Ht){for(var pi,hi=0,ai=vt.i,Yi=vt.j,Wi=vt.S;Ht--;)pi=Wi[ai=Re&ai+1],hi=hi*ne+Wi[Re&(Wi[ai]=Wi[Yi=Re&Yi+pi])+(Wi[Yi]=pi)];return vt.i=ai,vt.j=Yi,hi})(ne)}function Ge(Ke,qe){return qe.i=Ke.i,qe.j=Ke.j,qe.S=Ke.S.slice(),qe}function We(Ke,qe){var $e=[],vt=typeof Ke,nt;if(qe&&vt=="object")for(nt in Ke)try{$e.push(We(Ke[nt],qe-1))}catch{}return $e.length?$e:vt=="string"?Ke:Ke+"\0"}function Xe(Ke,qe){for(var $e=Ke+"",vt,nt=0;nt<$e.length;)qe[Re&nt]=Re&(vt^=qe[Re&nt]*19)+$e.charCodeAt(nt++);return je(qe)}function Ye(){try{var Ke;return we&&(Ke=we.randomBytes)?Ke=Ke(ne):(Ke=new Uint8Array(ne),(A.crypto||A.msCrypto).getRandomValues(Ke)),je(Ke)}catch{var qe=A.navigator,$e=qe&&qe.plugins;return[+new Date,A,$e,A.screen,je(V)]}}function je(Ke){return String.fromCharCode.apply(0,Ke)}if(Xe($.random(),V),W.exports){W.exports=ke;try{we=__webpack_require__(653)}catch{}}else $["seed"+ce]=ke})(typeof self<"u"?self:mr,[],Math)})(BY);var BM=BY.exports,Bh=Bl,Bj=Bn,Br=BH,S0=Bz,S1=BU,S2=Bu,S3=BM;S3.alea=Bh,S3.xor128=Bj,S3.xorwow=Br,S3.xorshift7=S0,S3.xor4096=S1,S3.tychei=S2;function S4(W,A,V=1,$="float32"){if(V===0)throw new Error("Cannot have a step of zero");const ne={start:W,stop:A,step:V,dtype:$};return JA.runKernel(md,{},ne)}function S5(W){const A={x:Jv(W,"x","relu")};return JA.runKernel(mb,A)}const S6=Ja({relu_:S5});function S7(W){const A={x:Jv(W,"x","relu6")};return JA.runKernel(mg,A)}const S8=Ja({relu6_:S7});function S9(W){const A={x:Jv(W,"x","round")};return JA.runKernel(mZ,A)}const SC=Ja({round_:S9});function Sm(W){const A={x:Jv(W,"x","sin","float32")};return JA.runKernel(ms,A)}const SN=Ja({sin_:Sm});function SJ(W,A,V){const $=Jv(W,"x","slice3d");return e($.rank===3,()=>"slice3d expects a rank-3 tensor, but got a rank-"+$.rank+" tensor"),t0($,A,V)}const Sf=Ja({slice3d_:SJ});function Si(W,A,V=0){const $={x:Jv(W,"x","split")},ne={numOrSizeSplits:A,axis:V};return JA.runKernel(mp,$,ne)}const SO=Ja({split_:Si});function St(W,A){const V=Jv(W,"x","squeeze","string_or_numeric");return Oz(V,L(V.shape,A).newShape)}const SB=Ja({squeeze_:St});function SS(W,A=0){const V=Jq(W,"tensors","stack","string_or_numeric");e(V.length>=1,()=>"Pass at least one tensor to tf.stack"),V.length>0&&e(A<=V[0].rank,()=>"Axis must be <= rank of the tensor");const $=V,ne={axis:A};return JA.runKernel(mO,$,ne)}const Sd=Ja({stack_:SS});function SV(W,A=0){const V={x:Jv(W,"x","step")},$={alpha:A};return JA.runKernel(mq,V,$)}const Sb=Ja({step_:SV});function SP(W,A,V,$,ne=0,xe=0,le=0,ce=0,ue=0){const Te={x:Jv(W,"x","stridedSlice","string_or_numeric")},Me={begin:A,end:V,strides:$,beginMask:ne,endMask:xe,ellipsisMask:le,newAxisMask:ce,shrinkAxisMask:ue};return JA.runKernel(mX,Te,Me)}const SE=Ja({stridedSlice_:SP});function SD(W,A){s(W);const V=JR(W,A);if(V.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return JH(W,null,V,A)}function Sg(W,A,V){if(s(W),A!=null&&A.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const $=JR(W,V);if($.length!==2&&$.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if($.length===1&&A==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return JH(W,A,$,V)}function SZ(W,A,V){const $=Jv(W,"tensor","tensorScatterupdate"),ne=Jv(A,"indices","tensorScatterupdate","int32"),xe=Jv(V,"updates","tensorScatterupdate");if(iY(xe,ne,$.shape),$.dtype!==xe.dtype)throw new Error("tensor and updates must have the same dtype, instead they are "+$.dtype+" and "+xe.dtype+".");const le={tensor:$,indices:ne,updates:xe},ce={};return JA.runKernel(mo,le,ce)}Ja({tensorScatterUpdate_:SZ});function So(W,A=0){const V=Jv(W,"x","unstack","string_or_numeric");e(A>=-V.shape.length&&A<V.shape.length,()=>"Axis = "+A+" is not in [-"+V.shape.length+", "+V.shape.length+")");const $={value:V},ne={axis:A};return JA.runKernel(mT,$,ne)}const Se=Ja({unstack_:So});function SQ(W,A){const V=[];for(let xe=0;xe<A.length;xe++)A[xe]&&V.push(xe);const $=t7(W,"int32"),ne=t7([V.length,W.length],"int32");for(let xe=0;xe<V.length;xe++){const le=$.indexToLoc(V[xe]),ce=xe*W.length;ne.values.set(le,ce)}return ne.toTensor()}function Ss(W,A,V,$,ne,xe="NHWC",le){let ce=W;W.rank===3&&(ce=Oz(W,[1,W.shape[0],W.shape[1],W.shape[2]]));let ue=A;ue.rank===3&&(ue=Oz(A,[1,A.shape[0],A.shape[1],A.shape[2]])),e(ce.rank===4,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+ce.shape+"."),e(ue.rank===4,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+ue.shape+"."),e(V.length===4,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+V+".");const Te=xe==="NHWC"?ce.shape[3]:ce.shape[1],Me=xe==="NHWC"?ue.shape[3]:ue.shape[1];e(Te===V[2],()=>"Error in conv2dDerFilter: depth of input "+Te+") must match input depth in filter ("+V[2]+"."),e(Me===V[3],()=>"Error in conv2dDerFilter: depth of dy ("+Me+") must match output depth for filter ("+V[3]+")."),OH("conv2dDerFilter",ne,le);const Re={x:ce,dy:ue},we={strides:$,pad:ne,dataFormat:xe,dimRoundingMode:le,filterShape:V};return JA.runKernel(CR,Re,we)}const SF=Ja({conv2DBackpropFilter_:Ss});function SI(W,A,V){if(V==null||V==="linear")return W;if(V==="relu")return OD(W,Sb(A));throw new Error("Cannot compute gradient for fused activation "+V+".")}function Sy(W,A){let V=A;const $=iL(W.shape,A.shape);return $.length>0&&(V=tG(V,$)),Oz(V,W.shape)}function SA(W,A,V,$){if(A==="linear")return W;if(A==="relu")return S6(W);if(A==="elu")return ty(W);if(A==="relu6")return S8(W);if(A==="prelu")return BT(W,V);if(A==="leakyrelu")return BN(W,$);if(A==="sigmoid")return Oj(W);throw new Error("Unknown fused activation "+A+".")}const Sp=(W,A)=>!(W>0)||A==="linear";function Sw({x:W,filter:A,strides:V,pad:$,dataFormat:ne="NHWC",dilations:xe=[1,1],dimRoundingMode:le,bias:ce,activation:ue="linear",preluActivationWeights:Te,leakyreluAlpha:Me}){if(ue=ue||"linear",Sp(JA.state.gradientDepth,ue)===!1){e(ne==="NHWC",()=>"Error in fused conv2d: got dataFormat of "+ne+" but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");let $e=tO(W,A,V,$,ne,xe,le);return ce!=null&&($e=OS($e,ce)),SA($e,ue,Te,Me)}const Re=Jv(W,"x","conv2d","float32"),we=Jv(A,"filter","conv2d","float32");let ke=Re,Ue=!1;Re.rank===3&&(Ue=!0,ke=Oz(Re,[1,Re.shape[0],Re.shape[1],Re.shape[2]])),e(ke.rank===4,()=>"Error in fused conv2d: input must be rank 4, but got rank "+ke.rank+"."),e(we.rank===4,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+we.rank+"."),OH("fused conv2d",$,le);const Ge=ne==="NHWC"?ke.shape[3]:ke.shape[1];e(we.shape[2]===Ge,()=>"Error in conv2d: depth of input ("+Ge+") must match input depth for filter "+we.shape[2]+"."),e(Oa(V,xe),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+V+" and dilations '"+xe+"'");const We=OA(ke.shape,we.shape,V,xe,$,le);let Xe;ce!=null&&(Xe=Jv(ce,"bias","fused conv2d"),[Xe]=Jg(Xe,Re),ne==="NHWC"?iH(We.outShape,Xe.shape):(e(Xe.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-"+Xe.shape.length+"."),e(Xe.shape.length===0||Xe.shape[0]===We.outChannels||Xe.shape[0]===1,()=>"Error in fused conv2d: bias shape ("+Xe.shape+") is not compatible with the number of output channels ("+We.outChannels+")")));let Ye;if(Te!=null){const $e=Te.shape;if(e($e.length<=1||$e.length===3,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-"+$e.length+"."),$e.length===1)e($e[0]===1||$e[0]===We.outChannels,()=>"Error in fused conv2d: PReLU activation weights ("+$e+") is not compatible with the number of output channels ("+We.outChannels+").");else if($e.length===3)try{iH($e,We.outShape)}catch{const nt="Error in fused conv2d: PReLU activation weights ("+$e+") is not compatible with the output shape of the conv2d ("+We.outShape+").";throw Error(nt)}Ye=Jv(Te,"prelu weights","fused conv2d")}const je=($e,vt)=>{e(ne==="NHWC",()=>"Error in gradient of fused conv2D: got dataFormat of "+ne+" but only NHWC is currently supported.");const[nt,wt,Kt,Ht]=vt,pi=SI($e,Kt,ue);e(Ol(xe),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+xe+"'");const hi=tB(wt.shape,pi,nt,V,$),ai=SF(wt,pi,nt.shape,V,$),Yi=[hi,ai];if(Ht!=null){const Wi=Sy(Ht,pi);Yi.push(Wi)}return Yi},Ke={x:ke,filter:we,bias:Xe,preluActivationWeights:Ye},qe={strides:V,pad:$,dataFormat:ne,dilations:xe,dimRoundingMode:le,activation:ue,leakyreluAlpha:Me};return ce==null?Bt(($e,vt,nt)=>{let wt=JA.runKernel(mL,Ke,qe);return nt([vt,$e,wt]),Ue&&(wt=Oz(wt,[wt.shape[1],wt.shape[2],wt.shape[3]])),{value:wt,gradFunc:je}})(ke,we):Bt(($e,vt,nt,wt)=>{let Kt=JA.runKernel(mL,Ke,qe);return wt([vt,$e,Kt,nt]),Ue&&(Kt=Oz(Kt,[Kt.shape[1],Kt.shape[2],Kt.shape[3]])),{value:Kt,gradFunc:je}})(ke,we,Xe)}const SX=Ja({fusedConv2d_:Sw});function Sc(W,A,V,$,ne,xe=[1,1],le){let ce=W;W.rank===3&&(ce=Oz(W,[1,W.shape[0],W.shape[1],W.shape[2]]));let ue=A;ue.rank===3&&(ue=Oz(A,[1,A.shape[0],A.shape[1],A.shape[2]]));const Te={x:ce,dy:ue},Me={strides:$,pad:ne,dimRoundingMode:le,dilations:xe,filterShape:V};return JA.runKernel(Ca,Te,Me)}const SW=Ja({depthwiseConv2dNativeBackpropFilter_:Sc});function SR(W,A,V,$,ne,xe=[1,1],le){let ce=A,ue=!1;A.rank===3&&(ue=!0,ce=Oz(A,[1,A.shape[0],A.shape[1],A.shape[2]]));const Te={dy:ce,filter:V},Me={strides:$,pad:ne,dimRoundingMode:le,dilations:xe,inputShape:W},Re=JA.runKernel(Cn,Te,Me);return ue?Oz(Re,[Re.shape[1],Re.shape[2],Re.shape[3]]):Re}const SK=Ja({depthwiseConv2dNativeBackpropInput_:SR});function ST({x:W,filter:A,strides:V,pad:$,dataFormat:ne="NHWC",dilations:xe=[1,1],dimRoundingMode:le,bias:ce,activation:ue="linear",preluActivationWeights:Te,leakyreluAlpha:Me}){if(Sp(JA.state.gradientDepth,ue)===!1){let qe=tg(W,A,V,$,ne,xe,le);return ce!=null&&(qe=OS(qe,ce)),SA(qe,ue,Te,Me)}const Re=Jv(W,"x","depthwiseConv2d","float32"),we=Jv(A,"filter","depthwiseConv2d","float32");let ke=Re,Ue=!1;Re.rank===3&&(Ue=!0,ke=Oz(Re,[1,Re.shape[0],Re.shape[1],Re.shape[2]])),e(ke.rank===4,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+ke.rank+"."),e(we.rank===4,()=>"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+we.rank+"."),e(ke.shape[3]===we.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels ("+ke.shape[3]+") must match the inChannels dimension in filter "+we.shape[2]+"."),xe==null&&(xe=[1,1]),e(Oa(V,xe),()=>"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+V+" and dilations '"+xe+"'"),OH("fused depthwiseConv2d",$,le);const Ge=OA(ke.shape,we.shape,V,xe,$,le,!0);let We;ce!=null&&(We=Jv(ce,"bias","fused conv2d"),[We]=Jg(We,Re),iH(Ge.outShape,We.shape));let Xe;Te!=null&&(Xe=Jv(Te,"prelu weights","fused depthwiseConv2d"));const Ye=(qe,$e)=>{e(Ol(xe),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+xe+"'");const[vt,nt,wt,Kt]=$e,Ht=SI(qe,wt,ue),pi=SK(nt.shape,Ht,vt,V,$,xe,le),hi=SW(nt,Ht,vt.shape,V,$,xe,le);if(Kt!=null){const ai=Sy(We,Ht);return[pi,hi,ai]}return[pi,hi]},je={x:ke,filter:we,bias:We,preluActivationWeights:Xe},Ke={strides:V,pad:$,dataFormat:ne,dilations:xe,dimRoundingMode:le,activation:ue,leakyreluAlpha:Me};return ce==null?Bt((qe,$e,vt)=>{let nt=JA.runKernel(mH,je,Ke);return vt([$e,qe,nt]),Ue&&(nt=Oz(nt,[nt.shape[1],nt.shape[2],nt.shape[3]])),{value:nt,gradFunc:Ye}})(ke,we):Bt((qe,$e,vt,nt)=>{let wt=JA.runKernel(mH,je,Ke);return nt([$e,qe,wt,vt]),Ue&&(wt=Oz(wt,[wt.shape[1],wt.shape[2],wt.shape[3]])),{value:wt,gradFunc:Ye}})(ke,we,We)}const Sv=Ja({fusedDepthwiseConv2d_:ST});function Sq({a:W,b:A,transposeA:V=!1,transposeB:$=!1,bias:ne,activation:xe="linear",preluActivationWeights:le,leakyreluAlpha:ce=.2}){if(Sp(JA.state.gradientDepth,xe)===!1){let Kt=iX(W,A,V,$);return ne!=null&&(Kt=OS(Kt,ne)),SA(Kt,xe,le,ce)}let ue=Jv(W,"a","fused matMul"),Te=Jv(A,"b","fused matMul");[ue,Te]=Jg(ue,Te);const Me=V?ue.shape[ue.rank-2]:ue.shape[ue.rank-1],Re=$?Te.shape[Te.rank-1]:Te.shape[Te.rank-2],we=V?ue.shape[ue.rank-1]:ue.shape[ue.rank-2],ke=$?Te.shape[Te.rank-2]:Te.shape[Te.rank-1],Ue=ue.shape.slice(0,-2),Ge=Te.shape.slice(0,-2),We=F(Ue),Xe=F(Ge);e(Me===Re,()=>"Error in fused matMul: inner shapes ("+Me+") and ("+Re+") of Tensors with shapes "+ue.shape+" and "+Te.shape+" and transposeA="+V+" and transposeB="+$+" must match.");const Ye=iH(ue.shape.slice(0,-2),Te.shape.slice(0,-2)).concat([we,ke]),je=V?Oz(ue,[We,Me,we]):Oz(ue,[We,we,Me]),Ke=$?Oz(Te,[Xe,ke,Re]):Oz(Te,[Xe,Re,ke]);let qe;ne!=null&&(qe=Jv(ne,"bias","fused matMul"),[qe]=Jg(qe,ue),iH(Ye,qe.shape));let $e;le!=null&&($e=Jv(le,"prelu weights","fused matMul"));const vt=(Kt,Ht)=>{const[pi,hi,ai,Yi]=Ht,Wi=SI(Oz(Kt,ai.shape),ai,xe);let ls,Hi;if(!V&&!$?(ls=iX(Wi,hi,!1,!0),Hi=iX(pi,Wi,!0,!1)):!V&&$?(ls=iX(Wi,hi,!1,!1),Hi=iX(Wi,pi,!0,!1)):V&&!$?(ls=iX(hi,Wi,!1,!0),Hi=iX(pi,Wi,!1,!1)):(ls=iX(hi,Wi,!0,!0),Hi=iX(Wi,pi,!0,!0)),ne!=null){const rs=Sy(Yi,Wi);return[ls,Hi,rs]}else return[ls,Hi]},nt={a:je,b:Ke,bias:qe,preluActivationWeights:$e},wt={transposeA:V,transposeB:$,activation:xe,leakyreluAlpha:ce};return ne==null?Bt((Kt,Ht,pi)=>{const hi=JA.runKernel(mn,nt,wt);return pi([Kt,Ht,hi]),{value:Oz(hi,Ye),gradFunc:vt}})(je,Ke):Bt((Kt,Ht,pi,hi)=>{const ai=JA.runKernel(mn,nt,wt);return hi([Kt,Ht,ai,pi]),{value:Oz(ai,Ye),gradFunc:vt}})(je,Ke,qe)}const Sl=Ja({fusedMatMul_:Sq});function Sa(W,A,V,$,ne="bilinear",xe=0){const le=Jv(W,"image","cropAndResize"),ce=Jv(A,"boxes","cropAndResize","float32"),ue=Jv(V,"boxInd","cropAndResize","int32"),Te=ce.shape[0];e(le.rank===4,()=>"Error in cropAndResize: image must be rank 4,but got rank "+le.rank+"."),e(ce.rank===2&&ce.shape[1]===4,()=>"Error in cropAndResize: boxes must be have size ["+Te+",4] but had shape "+ce.shape+"."),e(ue.rank===1&&ue.shape[0]===Te,()=>"Error in cropAndResize: boxInd must be have size ["+Te+"] but had shape "+ce.shape+"."),e($.length===2,()=>"Error in cropAndResize: cropSize must be of length 2, but got length "+$.length+"."),e($[0]>=1&&$[1]>=1,()=>"cropSize must be atleast [1,1], but was "+$),e(ne==="bilinear"||ne==="nearest",()=>"method must be bilinear or nearest, but was "+ne);const Me={image:le,boxes:ce,boxInd:ue},Re={method:ne,extrapolationValue:xe,cropSize:$};return JA.runKernel(Cv,Me,Re)}const Sn=Ja({cropAndResize_:Sa});function SL(W){const A=Jv(W,"image","flipLeftRight","float32");e(A.rank===4,()=>"Error in flipLeftRight: image must be rank 4,but got rank "+A.rank+".");const V={image:A};return JA.runKernel(CU,V,{})}const SH=Ja({flipLeftRight_:SL});function Sk(W){const A=Jv(W,"image","grayscaleToRGB"),V=A.rank-1,$=A.shape[V];e(A.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, but got rank "+A.rank+"."),e($===1,()=>"Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size "+$+".");const ne=new Array(A.rank);return ne.fill(1,0,V),ne[V]=3,B2(A,ne)}const Sz=Ja({grayscaleToRGB_:Sk});function Sx(W){const A=Jv(W,"image","RGBToGrayscale"),V=A.rank-1,$=A.shape[V];e(A.rank>=2,()=>"Error in RGBToGrayscale: images must be at least rank 2, but got rank "+A.rank+"."),e($===3,()=>"Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size "+$+".");const ne=A.dtype,xe=ip(A,"float32"),le=SD([.2989,.587,.114]);let ce;switch(A.rank){case 2:ce=tF("ij,j->i",xe,le);break;case 3:ce=tF("ijk,k->ij",xe,le);break;case 4:ce=tF("ijkl,l->ijk",xe,le);break;case 5:ce=tF("ijklm,m->ijkl",xe,le);break;case 6:ce=tF("ijklmn,n->ijklm",xe,le);break;default:throw new Error("Not a valid tensor rank.")}return ce=B0(ce,-1),ip(ce,ne)}const SU=Ja({rgbToGrayscale_:Sx});function SG(W,A,V=0,$=.5){const ne=Jv(W,"image","rotateWithOffset","float32");e(ne.rank===4,()=>"Error in rotateWithOffset: image must be rank 4,but got rank "+ne.rank+".");const xe={image:ne},le={radians:A,fillValue:V,center:$};return JA.runKernel(ma,xe,le)}const Su=Ja({rotateWithOffset_:SG});function SY(W,A,V,$,ne,xe){$==null&&($=.5),ne==null&&(ne=Number.NEGATIVE_INFINITY),xe==null&&(xe=0);const le=W.shape[0];return V=Math.min(V,le),e(0<=$&&$<=1,()=>"iouThreshold must be in [0, 1], but was '"+$+"'"),e(W.rank===2,()=>"boxes must be a 2D tensor, but was of rank '"+W.rank+"'"),e(W.shape[1]===4,()=>"boxes must have 4 columns, but 2nd dimension was "+W.shape[1]),e(A.rank===1,()=>"scores must be a 1D tensor"),e(A.shape[0]===le,()=>"scores has incompatible shape with boxes. Expected "+le+", but was "+A.shape[0]),e(0<=xe&&xe<=1,()=>"softNmsSigma must be in [0, 1], but was '"+xe+"'"),{maxOutputSize:V,iouThreshold:$,scoreThreshold:ne,softNmsSigma:xe}}function SM(W,A,V,$=.5,ne=Number.NEGATIVE_INFINITY){const xe=Jv(W,"boxes","nonMaxSuppression","float32"),le=Jv(A,"scores","nonMaxSuppression","float32"),ce=SY(xe,le,V,$,ne);V=ce.maxOutputSize,$=ce.iouThreshold,ne=ce.scoreThreshold;const ue={maxOutputSize:V,iouThreshold:$,scoreThreshold:ne};return JA.runKernel(mJ,{boxes:xe,scores:le},ue)}const Sh=Ja({nonMaxSuppression_:SM});function Sj(W,A,V){const $=Sr(W,A,V),ne=$<0?-($+1):$;W.splice(ne,0,A)}function Sr(W,A,V){return d1(W,A,V||d0)}function d0(W,A){return W>A?1:W<A?-1:0}function d1(W,A,V){let $=0,ne=W.length,xe=0,le=!1;for(;$<ne;){xe=$+(ne-$>>>1);const ce=V(A,W[xe]);ce>0?$=xe+1:(ne=xe,le=!ce)}return le?$:-$-1}function d2(W,A,V,$,ne){return d5(W,A,V,$,ne,0)}function d3(W,A,V,$,ne,xe){return d5(W,A,V,$,ne,0,!1,xe,!0)}function d4(W,A,V,$,ne,xe){return d5(W,A,V,$,ne,xe,!0)}function d5(W,A,V,$,ne,xe,le=!1,ce=!1,ue=!1){const Te=[];for(let We=0;We<A.length;We++)A[We]>ne&&Te.push({score:A[We],boxIndex:We,suppressBeginIndex:0});Te.sort(d8);const Me=xe>0?-.5/xe:0,Re=[],we=[];for(;Re.length<V&&Te.length>0;){const We=Te.pop(),{score:Xe,boxIndex:Ye,suppressBeginIndex:je}=We;if(Xe<ne)break;let Ke=!1;for(let qe=Re.length-1;qe>=je;--qe){const $e=d6(W,Ye,Re[qe]);if($e>=$){Ke=!0;break}if(We.score=We.score*d7($,Me,$e),We.score<=ne)break}We.suppressBeginIndex=Re.length,Ke||(We.score===Xe?(Re.push(Ye),we.push(We.score)):We.score>ne&&Sj(Te,We,d8))}const ke=Re.length,Ue=V-ke;ce&&Ue>0&&(Re.push(...new Array(Ue).fill(0)),we.push(...new Array(Ue).fill(0)));const Ge={selectedIndices:Re};return le&&(Ge.selectedScores=we),ue&&(Ge.validOutputs=ke),Ge}function d6(W,A,V){const $=W.subarray(A*4,A*4+4),ne=W.subarray(V*4,V*4+4),xe=Math.min($[0],$[2]),le=Math.min($[1],$[3]),ce=Math.max($[0],$[2]),ue=Math.max($[1],$[3]),Te=Math.min(ne[0],ne[2]),Me=Math.min(ne[1],ne[3]),Re=Math.max(ne[0],ne[2]),we=Math.max(ne[1],ne[3]),ke=(ce-xe)*(ue-le),Ue=(Re-Te)*(we-Me);if(ke<=0||Ue<=0)return 0;const Ge=Math.max(xe,Te),We=Math.max(le,Me),Xe=Math.min(ce,Re),Ye=Math.min(ue,we),je=Math.max(Xe-Ge,0)*Math.max(Ye-We,0);return je/(ke+Ue-je)}function d7(W,A,V){const $=Math.exp(A*V*V);return V<=W?$:0}function d8(W,A){return W.score-A.score||W.score===A.score&&A.boxIndex-W.boxIndex}async function d9(W,A,V,$=.5,ne=Number.NEGATIVE_INFINITY){const xe=Jv(W,"boxes","nonMaxSuppressionAsync"),le=Jv(A,"scores","nonMaxSuppressionAsync"),ce=SY(xe,le,V,$,ne);V=ce.maxOutputSize,$=ce.iouThreshold,ne=ce.scoreThreshold;const ue=await Promise.all([xe.data(),le.data()]),Te=ue[0],Me=ue[1],{selectedIndices:Re}=d2(Te,Me,V,$,ne);return xe!==W&&xe.dispose(),le!==A&&le.dispose(),SD(Re,"int32")}const dC=d9;function dm(W,A,V,$=.5,ne=Number.NEGATIVE_INFINITY,xe=0){const le=Jv(W,"boxes","nonMaxSuppression"),ce=Jv(A,"scores","nonMaxSuppression"),ue=SY(le,ce,V,$,ne,xe);V=ue.maxOutputSize,$=ue.iouThreshold,ne=ue.scoreThreshold,xe=ue.softNmsSigma;const Te={boxes:le,scores:ce},Me={maxOutputSize:V,iouThreshold:$,scoreThreshold:ne,softNmsSigma:xe},Re=JA.runKernel(mi,Te,Me);return{selectedIndices:Re[0],selectedScores:Re[1]}}const dN=Ja({nonMaxSuppressionWithScore_:dm});async function dJ(W,A,V,$=.5,ne=Number.NEGATIVE_INFINITY,xe=0){const le=Jv(W,"boxes","nonMaxSuppressionAsync"),ce=Jv(A,"scores","nonMaxSuppressionAsync"),ue=SY(le,ce,V,$,ne,xe);V=ue.maxOutputSize,$=ue.iouThreshold,ne=ue.scoreThreshold,xe=ue.softNmsSigma;const Te=await Promise.all([le.data(),ce.data()]),Me=Te[0],Re=Te[1],{selectedIndices:we,selectedScores:ke}=d4(Me,Re,V,$,ne,xe);return le!==W&&le.dispose(),ce!==A&&ce.dispose(),{selectedIndices:SD(we,"int32"),selectedScores:SD(ke)}}const df=dJ;function di(W,A,V,$=.5,ne=Number.NEGATIVE_INFINITY,xe=!1){const le=Jv(W,"boxes","nonMaxSuppression"),ce=Jv(A,"scores","nonMaxSuppression"),ue=SY(le,ce,V,$,ne,null),Te=ue.maxOutputSize,Me=ue.iouThreshold,Re=ue.scoreThreshold,we={boxes:le,scores:ce},ke={maxOutputSize:Te,iouThreshold:Me,scoreThreshold:Re,padToMaxOutputSize:xe},Ue=JA.runKernel(mf,we,ke);return{selectedIndices:Ue[0],validOutputs:Ue[1]}}const dO=Ja({nonMaxSuppressionPadded_:di});async function dt(W,A,V,$=.5,ne=Number.NEGATIVE_INFINITY,xe=!1){const le=Jv(W,"boxes","nonMaxSuppressionAsync"),ce=Jv(A,"scores","nonMaxSuppressionAsync"),ue=SY(le,ce,V,$,ne,null),Te=ue.maxOutputSize,Me=ue.iouThreshold,Re=ue.scoreThreshold,[we,ke]=await Promise.all([le.data(),ce.data()]),{selectedIndices:Ue,validOutputs:Ge}=d3(we,ke,Te,Me,Re,xe);return le!==W&&le.dispose(),ce!==A&&ce.dispose(),{selectedIndices:SD(Ue,"int32"),validOutputs:tL(Ge,"int32")}}const dB=dt;function dS(W,A,V=!1,$=!1){const ne=Jv(W,"images","resizeBilinear");e(ne.rank===3||ne.rank===4,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+ne.rank+"."),e(A.length===2,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+A+"."),e($===!1||V===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let xe=ne,le=!1;ne.rank===3&&(le=!0,xe=Oz(ne,[1,ne.shape[0],ne.shape[1],ne.shape[2]]));const ce={images:xe},ue={alignCorners:V,halfPixelCenters:$,size:A},Te=JA.runKernel(mD,ce,ue);return le?Oz(Te,[Te.shape[1],Te.shape[2],Te.shape[3]]):Te}const dd=Ja({resizeBilinear_:dS});function dV(W,A,V=!1,$=!1){const ne=Jv(W,"images","resizeNearestNeighbor");e(ne.rank===3||ne.rank===4,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+ne.rank+"."),e(A.length===2,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+A+"."),e(ne.dtype==="float32"||ne.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),e($===!1||V===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let xe=ne,le=!1;ne.rank===3&&(le=!0,xe=Oz(ne,[1,ne.shape[0],ne.shape[1],ne.shape[2]]));const ce={images:xe},ue={alignCorners:V,halfPixelCenters:$,size:A},Te=JA.runKernel(mE,ce,ue);return le?Oz(Te,[Te.shape[1],Te.shape[2],Te.shape[3]]):Te}const db=Ja({resizeNearestNeighbor_:dV});function dP(W,A="binary",V=!1,$=.5){const ne=Jv(W,"image","threshold"),xe=.2989,le=.587,ce=.114,ue=ne.shape[0]*ne.shape[1];let Te=OD(SD([$]),255),Me,Re,we,ke;if(e(ne.rank===3,()=>"Error in threshold: image must be rank 3,but got rank "+ne.rank+"."),e(ne.shape[2]===3||ne.shape[2]===1,()=>"Error in threshold: image color channel must be equal to 3 or 1but got "+ne.shape[2]+"."),e(ne.dtype==="int32"||ne.dtype==="float32",()=>"Error in dtype: image dtype must be int32 or float32,but got dtype "+ne.dtype+"."),e(A==="otsu"||A==="binary",()=>"Method must be binary or otsu, but was "+A),ne.shape[2]===3){[Me,Re,we]=SO(ne,[1,1,1],-1);const Ge=OD(Me,xe),We=OD(Re,le),Xe=OD(we,ce);ke=OS(OS(Ge,We),Xe)}else ke=W;if(A==="otsu"){const Ge=t4(ip(SC(ke),"int32"),Jk([]),256);Te=dE(Ge,ue)}const Ue=V?BO(ke,Te):B8(ke,Te);return ip(OD(Ue,255),"int32")}function dE(W,A){let V=SD([-1]),$=SD([0]),ne=SD([0]),xe,le,ce,ue,Te,Me;for(let Re=0;Re<W.size-1;Re++){xe=t0(W,0,Re+1),le=t0(W,Re+1),Te=OP(tG(xe),A),Me=OP(tG(le),A);const we=tG(OD(xe,S4(0,xe.size)));ce=OP(we,tG(xe));const ke=t8(le.shape,xe.size),Ue=OS(S4(0,le.size),ke),Ge=OD(le,Ue);ue=OP(tG(Ge),tG(le));const We=BS(ce,ue),Xe=BS(ce,ue),Ye=OD(Te,Me);ne=OD(OD(Ye,We),Xe);const je=B8(ne,$);$=to(je,ne,$),V=to(je,SD([Re]),V)}return V}const dD=Ja({threshold_:dP});function dg(W,A,V="nearest",$="constant",ne=0,xe){const le=Jv(W,"image","transform","float32"),ce=Jv(A,"transforms","transform","float32");e(le.rank===4,()=>"Error in transform: image must be rank 4,but got rank "+le.rank+"."),e(ce.rank===2&&(ce.shape[0]===le.shape[0]||ce.shape[0]===1)&&ce.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),e(xe==null||xe.length===2,()=>"Error in transform: outputShape must be [height, width] or null, but got "+xe+".");const ue={image:le,transforms:ce},Te={interpolation:V,fillMode:$,fillValue:ne,outputShape:xe};return JA.runKernel(mR,ue,Te)}const dZ=Ja({transform_:dg});var de;(function(W){W[W.NONE=0]="NONE",W[W.MEAN=1]="MEAN",W[W.SUM=2]="SUM",W[W.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(de||(de={}));const dQ={flipLeftRight:SH,grayscaleToRGB:Sz,resizeNearestNeighbor:db,resizeBilinear:dd,rgbToGrayscale:SU,rotateWithOffset:Su,cropAndResize:Sn,nonMaxSuppression:Sh,nonMaxSuppressionAsync:dC,nonMaxSuppressionWithScore:dN,nonMaxSuppressionWithScoreAsync:df,nonMaxSuppressionPadded:dO,nonMaxSuppressionPaddedAsync:dB,threshold:dD,transform:dZ},ds=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:W=>W())();function dF(){return new Promise(W=>ds(()=>W()))}function dI(W,A){const V=W[0].length;W.forEach((ne,xe)=>{e(ne.length===V,()=>"Error in concat"+V+"D: rank of tensors["+xe+"] must be the same as the rank of the rest ("+V+")")}),e(A>=0&&A<V,()=>"Error in concat"+V+"D: axis must be between 0 and "+(V-1)+".");const $=W[0];W.forEach((ne,xe)=>{for(let le=0;le<V;le++)e(le===A||ne[le]===$[le],()=>"Error in concat"+V+"D: Shape of tensors["+xe+"] ("+ne+") does not match the shape of the rest ("+$+") along the non-concatenated axis "+xe+".")})}function dy(W,A){const V=W[0].slice();for(let $=1;$<W.length;$++)V[A]+=W[$][A];return V}var dA;(function(W){W[W.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",W[W.VALUE_ROWIDS=1]="VALUE_ROWIDS",W[W.ROW_LENGTHS=2]="ROW_LENGTHS",W[W.ROW_SPLITS=3]="ROW_SPLITS",W[W.ROW_LIMITS=4]="ROW_LIMITS",W[W.ROW_STARTS=5]="ROW_STARTS"})(dA||(dA={}));function dp(W,A,V){let $=new Array;if(V==null&&A==null)return $;if(A==null)for(;$.length<W+V.length;)$.push(-1);else $=A.slice();if(V==null)return $;if(W+V.length!==$.length)throw new Error("rt input.shape and shape="+A+" are incompatible: rt input.rank = "+(W+V.length)+", but shape.rank = "+$.length);for(let ne=1;ne<V.length;++ne){const xe=V[ne],le=$[$.length-V.length+ne],ce=$[le];if(xe>=0)if(ce>=0){if(ce!==xe)throw new Error("rt input.shape and shape="+A+" are incompatible: rt input.shape["+(ne+W)+"] = "+xe+" but shape["+(ne+W)+"] = "+ce)}else $[le]=xe}return $}function dw(W){const A={FIRST_DIM_SIZE:dA.FIRST_DIM_SIZE,VALUE_ROWIDS:dA.VALUE_ROWIDS,ROW_LENGTHS:dA.ROW_LENGTHS,ROW_SPLITS:dA.ROW_SPLITS,ROW_LIMITS:dA.ROW_LIMITS,ROW_STARTS:dA.ROW_STARTS},V=[];for(const $ of W)if($ in A)V.push(A[$]);else break;return V}function dX(W){return W.length===0?0:W[0]===dA.FIRST_DIM_SIZE?W.length-1:W.length}function dc(W,A){if(W==null||A==null)return;const V=W.length,$=A.length;if(V>=$)throw new Error("defaultValue.shape="+W+" and ragged tensor flatValues.shape="+A+", are incompatible: defaultValue.rank = "+V+" must be less than ragged tensor input flatValues.rank = "+$+")");for(let ne=0;ne<Math.min(V,$-1);++ne){const xe=W[ne],le=A[ne+1];if(xe>=0&&le>=0&&xe!==1&&xe!==le)throw new Error("defaultValue.shape="+W+", and ragged tensor input flatValues.shape="+A+" are incompatible: defaultValue.shape["+(ne-W.length)+"] = "+xe+" but ragged tensor input.flatValues.shape["+(ne-W.length)+"] = "+le)}}const dW=30;function dR(W){return W<=dW?W:C4(W,Math.floor(Math.sqrt(W)))}function dK(W,A,V){const $=V*(typeof W=="number"?W:W[0]),ne=A*(typeof W=="number"?W:W[1]);return[$,ne]}function dT(W,A,V,$=!0){let ne=[];if($)ne=ne.concat(A.slice(0)),ne.push(W[0]/V),ne=ne.concat(W.slice(1));else{ne=ne.concat(W[0]);const xe=A.length;for(let le=0;le<xe;++le)ne=ne.concat([W[le+1]/A[le],A[le]]);ne=ne.concat(W.slice(xe+1))}return ne}function dv(W,A,V=!0){const $=[];if(V){$.push(A);for(let ne=A+1;ne<W;++ne)ne<=2*A?($.push(ne),$.push(ne-(A+1))):$.push(ne)}else{const ne=[],xe=[];for(let le=1;le<W;++le)le>=A*2+1||le%2===1?xe.push(le):ne.push(le);$.push(...ne),$.push(0),$.push(...xe)}return $}function dq(W,A,V,$=!0){const ne=[];$?ne.push(W[0]/V):ne.push(W[0]*V);for(let xe=1;xe<W.length;++xe)xe<=A.length?$?ne.push(A[xe-1]*W[xe]):ne.push(W[xe]/A[xe-1]):ne.push(W[xe]);return ne}function dl(W,A){const V=[0];for(let $=0;$<A;++$)V.push(W[$][0]);return V}function da(W,A,V){const $=W.slice(0,1);for(let ne=0;ne<V;++ne)$.push(W[ne+1]-A[ne][0]-A[ne][1]);return $}const dn=1.7580993408473768,dL=1.0507009873554805,dH=.3275911,dk=.254829592,dz=-.284496736,dx=1.421413741,dU=-1.453152027,dG=1.061405429;function du(W,A){if(W.length!==A.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+W.length+", imag: "+A.length+".");const V=new Float32Array(W.length*2);for(let $=0;$<V.length;$+=2)V[$]=W[$/2],V[$+1]=A[$/2];return V}function dY(W){const A=new Float32Array(W.length/2),V=new Float32Array(W.length/2);for(let $=0;$<W.length;$+=2)A[$/2]=W[$],V[$/2]=W[$+1];return{real:A,imag:V}}function dM(W){const A=Math.ceil(W.length/4),V=new Float32Array(A),$=new Float32Array(A);for(let ne=0;ne<W.length;ne+=4)V[Math.floor(ne/4)]=W[ne],$[Math.floor(ne/4)]=W[ne+1];return{real:V,imag:$}}function dh(W){const A=Math.floor(W.length/4),V=new Float32Array(A),$=new Float32Array(A);for(let ne=2;ne<W.length;ne+=4)V[Math.floor(ne/4)]=W[ne],$[Math.floor(ne/4)]=W[ne+1];return{real:V,imag:$}}function dj(W,A){const V=W[A*2],$=W[A*2+1];return{real:V,imag:$}}function dr(W,A,V,$){W[$*2]=A,W[$*2+1]=V}function V0(W,A){const V=new Float32Array(W/2),$=new Float32Array(W/2);for(let ne=0;ne<Math.ceil(W/2);ne++){const xe=(A?2:-2)*Math.PI*(ne/W);V[ne]=Math.cos(xe),$[ne]=Math.sin(xe)}return{real:V,imag:$}}function V1(W,A,V){const $=(V?2:-2)*Math.PI*(W/A),ne=Math.cos($),xe=Math.sin($);return{real:ne,imag:xe}}const V2="->",V3=/->/g,V4=",",V5="...";function V6(W,A){W=W.replace(/\s/g,"");const V=(W.length-W.replace(V3,"").length)/V2.length;if(V<1)throw new Error("Equations without an arrow are not supported.");if(V>1)throw new Error('Equation must contain exactly one arrow ("'+V2+'").');const[$,ne]=W.split(V2);e($.indexOf(V5)===-1,()=>'The ellipsis notation ("'+V5+'") is not supported yet.');const xe=$.split(V4),le=xe.length;if(A!==le)throw new Error("Expected "+le+" input tensors, received "+A);if(le>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const ce=[];for(let we=0;we<ne.length;++we){const ke=ne[we];if(!xe.some(Ue=>Ue.indexOf(ke)!==-1))throw new Error("Output subscripts contain the label "+ke+" not present in the input subscripts.");ce.indexOf(ke)===-1&&ce.push(ke)}for(let we=0;we<$.length;++we){const ke=$[we];ce.indexOf(ke)===-1&&ke!==V4&&ce.push(ke)}const ue=new Array(xe.length);for(let we=0;we<le;++we){if(new Set(xe[we].split("")).size!==xe[we].length)throw new Error("Found duplicate axes in input component "+xe[we]+". Support for duplicate axes in input is not implemented yet.");ue[we]=[];for(let ke=0;ke<xe[we].length;++ke)ue[we].push(ce.indexOf(xe[we][ke]))}const Te=ce.length,Me=ne.length,Re=[];for(let we=Me;we<Te;++we)Re.push(we);return{allDims:ce,summedDims:Re,idDims:ue}}function V7(W,A){let V=new Array(W);V.fill(-1);for(let ne=0;ne<A.length;++ne)V[A[ne]]=ne;const $=[];for(let ne=0;ne<W;++ne)V[ne]===-1&&$.push(ne);return V=V.filter(ne=>ne!==-1),{permutationIndices:V,expandDims:$}}function V8(W,A,V){const $=new Array(W);for(let ne=0;ne<V.length;++ne){const xe=V[ne].shape;for(let le=0;le<A[ne].length;++le)$[A[ne][le]]===void 0?$[A[ne][le]]=xe[le]:e($[A[ne][le]]===xe[le],()=>"Expected dimension "+$[A[ne][le]]+" at axis "+le+" of input shaped "+JSON.stringify(xe)+", but got dimension "+xe[le])}}function V9(W,A){const V=W,$=[];let ne=0;W.length===0&&V.push(-1),ne=W.length+1;for(let le=0;le<ne;++le)$.push([]);const xe=[];for(let le=0;le<V.length;++le){const ce=V[le],ue=Vm(A,ce);for(const Te of ue)xe.indexOf(Te)===-1&&($[le].push(Te),xe.push(Te))}return{path:V,steps:$}}function VC(W){return W.every((A,V)=>A===V)}function Vm(W,A){const V=[];for(let $=0;$<W.length;++$)(W[$].length===0||W[$].indexOf(A)!==-1||A===-1)&&V.push($);return V}function VN(W,A,V=0){let $=[];if(typeof A=="number")e(W.shape[V]%A===0,()=>"Number of splits must evenly divide the axis."),$=new Array(A).fill(W.shape[V]/A);else{const ne=A.reduce((le,ce)=>(ce===-1&&(le+=1),le),0);e(ne<=1,()=>"There should be only one negative value in split array.");const xe=A.indexOf(-1);if(xe!==-1){const le=A.reduce((ce,ue)=>ue>0?ce+ue:ce);A[xe]=W.shape[V]-le}e(W.shape[V]===A.reduce((le,ce)=>le+ce),()=>"The sum of sizes must match the size of the axis dimension."),$=A}return $}function VJ(W){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = `+W}function Vf(W,A){return"indices("+W+", 0) is invalid: "+A+" < 0"}function Vi(W,A,V){return"indices("+W+", 0) is invalid: "+A+" >= "+V}function VO(W,A){return"only one output dimension may be -1, not both "+W+" and "+A}function Vt(W,A){return"size "+W+" must be non-negative, not "+A}function VB(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function VS(W,A){const V=F(W),$=F(A);return"Input to reshape is a SparseTensor with "+V+`
  dense values, but the requested shape requires a multiple of `+$+". inputShape="+W+" outputShape= "+A}function Vd(W,A){const V=F(W),$=F(A);return"Input to reshape is a tensor with "+V+" dense values, but the requested shape has "+$+". inputShape="+W+" outputShape="+A}function VV(){return"segment ids must be >= 0"}function Vb(){return"segment ids are not increasing"}function VP(W,A){return"Segment id "+W+" out of range [0, "+A+"), possibly because segmentIds input is not sorted."}function VE(W,A,V){return"Bad: indices["+W+"] == "+A+" out of range [0, "+V+")"}function VD(W,A){let V=!1,$;for(W<=dW?($=W,V=!0):$=C4(W,Math.floor(Math.sqrt(W)));!V;)$>A||$===W?V=!0:$=C4(W,$+1);return $}function Vg(W,A,V){const $=[],ne=W.length;for(let xe=0;xe<ne;xe++)xe!==A?$.push(W[xe]):$.push(V);return $}function VZ(W,A,V,$){const ne=A.shape.length,xe=W.shape.length;if($!==0&&($<-ne||$>ne))throw new Error("Expect batchDims in the range of [-"+ne+", "+ne+"], but got "+$);if($<0&&($+=ne),$>xe)throw new Error("batchDims ("+$+`) must be less than rank(x) (
    `+xe+").");if(V<$)throw new Error("batchDims ("+$+") must be less than or equal to axis ("+V+").");for(let Re=0;Re<$;++Re)if(W.shape[Re]!==A.shape[Re])throw new Error("x.shape["+Re+"]: "+W.shape[Re]+" should be equal to indices.shape["+Re+"]: "+A.shape[Re]+".");const le=W.shape[V],ce=[];let ue=1,Te=1,Me=1;for(let Re=0;Re<$;++Re)ce.push(W.shape[Re]),ue*=W.shape[Re];for(let Re=$;Re<V;Re++)ce.push(W.shape[Re]),Te*=W.shape[Re];for(let Re=$;Re<ne;Re++)ce.push(A.shape[Re]);for(let Re=V+1;Re<xe;Re++)ce.push(W.shape[Re]),Me*=W.shape[Re];return{batchSize:ue,sliceSize:Me,outerSize:Te,dimSize:le,outputShape:ce}}var Vo=Object.freeze({__proto__:null,collectGatherOpShapeInfo:VZ,computeOutShape:Vg,segOpComputeOptimalWindowSize:VD});function Ve(W){try{return W.map(A=>Nx(A))}catch(A){throw new Error("Failed to decode encoded string bytes into utf-8, error: "+A)}}function VQ(W){return W.map(A=>Nz(A))}var Vs=Object.freeze({__proto__:null,ERF_A1:dk,ERF_A2:dz,ERF_A3:dx,ERF_A4:dU,ERF_A5:dG,ERF_P:dH,PARALLELIZE_THRESHOLD:dW,get RowPartitionType(){return dA},SELU_SCALE:dL,SELU_SCALEALPHA:dn,applyActivation:SA,assertAndGetBroadcastShape:iH,assertAxesAreInnerMostDims:tc,assertParamsConsistent:dI,assignToTypedArray:dr,axesAreInnerMostDims:tA,calculateShapes:iM,checkEinsumDimSizes:V8,checkPadOnDimRoundingMode:OH,combineLocations:tp,combineRaggedTensorToTensorShapes:dp,complexWithEvenIndex:dM,complexWithOddIndex:dh,computeConv2DInfo:OA,computeConv3DInfo:Op,computeDefaultPad:Oc,computeDilation2DInfo:OF,computeOptimalWindowSize:dR,computeOutAndReduceShapes:tw,computeOutShape:dy,computePool2DInfo:OI,computePool3DInfo:Oy,convertConv2DDataFormat:OL,decodeEinsumEquation:V6,eitherStridesOrDilationsAreOne:Oa,expandShapeToKeepDim:tX,exponent:V1,exponents:V0,fromStringArrayToUint8:VQ,fromUint8ToStringArray:Ve,getAxesPermutation:tW,getBroadcastDims:ia,getComplexWithIndex:dj,getEinsumComputePath:V9,getEinsumPermutation:V7,getFusedBiasGradient:Sy,getFusedDyActivation:SI,getImageCenter:dK,getInnerMostAxes:tK,getPermuted:dv,getRaggedRank:dX,getReductionAxes:iL,getReshaped:dT,getReshapedPermuted:dq,getRowPartitionTypesHelper:dw,getSliceBeginCoords:dl,getSliceSize:da,getSparseFillEmptyRowsIndicesDenseShapeMismatch:VJ,getSparseFillEmptyRowsNegativeIndexErrorMessage:Vf,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Vi,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:VB,getSparseReshapeInputOutputMismatchErrorMessage:Vd,getSparseReshapeInputOutputMultipleErrorMessage:VS,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:VO,getSparseReshapeNegativeOutputDimErrorMessage:Vt,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:VE,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:VV,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Vb,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:VP,getUndoAxesPermutation:tR,isIdentityPermutation:VC,log:mz,mergeRealAndImagArrays:du,prepareAndValidate:iG,prepareSplitSize:VN,segment_util:Vo,shouldFuse:Sp,slice_util:Ot,splitRealAndImagArrays:dY,stridesOrDilationsArePositive:On,tupleValuesAreOne:Ol,upcastType:Jb,validateDefaultValueShape:dc,validateInput:iY,validateUpdateShape:iu,warn:mk});class VF{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(A,V){return fetch(A,V)}now(){return performance.now()}encode(A,V){if(V!=="utf-8"&&V!=="utf8")throw new Error("Browser's encoder only supports utf-8, but got "+V);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(A)}decode(A,V){return new TextDecoder(V).decode(A)}setTimeoutCustom(A,V){if(typeof window>"u"||!Cd().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(A,V);return}this.functionRefs.push(A),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},V),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",$=>{if($.source===window&&$.data.name===this.messageName){$.stopPropagation();const ne=this.functionRefs[$.data.index];ne(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(A){return mj(A)}}if(Cd().get("IS_BROWSER")){Cd().setPlatform("browser",new VF);try{ig.registerManager(fx.URL_SCHEME,new fu)}catch{}try{ig.registerManager(fw.URL_SCHEME,new fR)}catch{}}const VI={importFetch:()=>__webpack_require__(300)};let Vy;class VA{constructor(){this.util=__webpack_require__(539),this.textEncoder=new this.util.TextEncoder}fetch(A,V){return Cd().global.fetch!=null?Cd().global.fetch(A,V):(Vy==null&&(Vy=VI.importFetch()),Vy(A,V))}now(){const A=process.hrtime();return A[0]*1e3+A[1]/1e6}encode(A,V){if(V!=="utf-8"&&V!=="utf8")throw new Error("Node built-in encoder only supports utf-8, but got "+V);return this.textEncoder.encode(A)}decode(A,V){return A.length===0?"":new this.util.TextDecoder(V).decode(A)}isTypedArray(A){return this.util.types.isFloat32Array(A)||this.util.types.isInt32Array(A)||this.util.types.isUint8Array(A)||this.util.types.isUint8ClampedArray(A)}}Cd().get("IS_NODE")&&!Cd().get("IS_BROWSER")&&Cd().setPlatform("node",new VA),Jy();const Vp={buffer:t7,cast:ip,clone:Ou,print:Bv};JN(Vp);var Vw=Object.defineProperty,VX=Object.getOwnPropertySymbols,Vc=Object.prototype.hasOwnProperty,VW=Object.prototype.propertyIsEnumerable,VR=(W,A,V)=>A in W?Vw(W,A,{enumerable:!0,configurable:!0,writable:!0,value:V}):W[A]=V,VK=(W,A)=>{for(var V in A||(A={}))Vc.call(A,V)&&VR(W,V,A[V]);if(VX)for(var V of VX(A))VW.call(A,V)&&VR(W,V,A[V]);return W};class VT{constructor(A){this.model=A,this.posesMax=1,this.iouThresh=.3,this.scoreThresh=.5,this.model=A,this.modelSize=A.inputs[0].shape?{width:A.inputs[0].shape[2],height:A.inputs[0].shape[1]}:{width:224,height:224},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchorsX=SD(this.anchorsData.map(V=>V.x)),this.anchorsY=SD(this.anchorsData.map(V=>V.y))}async process(A){let V={x:0,y:0};const[$,ne]=JY(()=>{const Te={width:A.shape[2],height:A.shape[1]},Me=Te.width/Te.height;let Re=VK({},Te),we={x:0,y:0};Me>this.modelRatio?(Re.height=A.shape[2]/this.modelRatio,we.y=Math.floor((Re.height-A.shape[1])*.5),V.y=we.y/Re.height):Me<this.modelRatio&&(Re.width=A.shape[1]*this.modelRatio,we.x=Math.floor((Re.width-A.shape[2])*.5),V.x=we.x/Re.width);const ke=BA(A,[[0,0],[we.y,we.y],[we.x,we.x],[0,0]],0),Ue=dQ.resizeBilinear(ke,[this.modelSize.height,this.modelSize.width]),Ge=this.model.execute(Ue,"person"),We=SB(t0(Ge,[0,0,1],[1,-1,-1])),Xe=SB(t0(Ge,[0,0,0],[1,-1,1])),Ye=Oj(tC(Xe,-100,100));return[this.decodeBoxes(We,[this.anchorsX,this.anchorsY],this.modelSize),Ye]}),xe=await $.data(),le=await ne.data();let ce=[];for(let Te=0;Te<le.length;Te++){if(le[Te]<this.scoreThresh)continue;const Me=xe[Te*12+2]-xe[Te*12+0],Re=xe[Te*12+3]-xe[Te*12+1];Me<0||Re<0||ce.push({box:[[xe[Te*12+0],xe[Te*12+1]],[xe[Te*12+2],xe[Te*12+3]]],points:[[xe[Te*12+4],xe[Te*12+5]],[xe[Te*12+6],xe[Te*12+7]],[xe[Te*12+8],xe[Te*12+9]],[xe[Te*12+10],xe[Te*12+11]]],score:le[Te]})}if($.dispose(),ne.dispose(),ce.length<1)return[];if(ce.length>1){const Te=Sg(ce.map(Ue=>[Ue.box[0][1],Ue.box[0][0],Ue.box[1][1],Ue.box[1][0]])),Me=SD(ce.map(Ue=>Ue.score)),Re=await dQ.nonMaxSuppressionAsync(Te,Me,this.posesMax,this.iouThresh,this.scoreThresh),we=await Re.data();Re.dispose();const ke=[];for(let Ue=0;Ue<we.length;Ue++)ke.push(ce[we[Ue]]);ce=ke}if(ce.length<1)return[];const ue={width:1-2*V.x,height:1-2*V.y};return ce.map(Te=>({box:Te.box.map(Me=>[(Me[0]-V.x)/ue.width,(Me[1]-V.y)/ue.height]),points:Te.points.map(Me=>[(Me[0]-V.x)/ue.width,(Me[1]-V.y)/ue.height]),score:Te.score}))}decodeBoxes(A,V,$){let ne=SB(t0(A,[0,0],[-1,1])),xe=SB(t0(A,[0,1],[-1,1])),le=SB(t0(A,[0,2],[-1,1])),ce=SB(t0(A,[0,3],[-1,1]));ne=OS(OP(ne,$.width),V[0]),xe=OS(OP(xe,$.height),V[1]),le=OP(le,$.width*2),ce=OP(ce,$.height*2);const ue=Oz(BS(ne,le),[2254,1]),Te=Oz(BS(xe,ce),[2254,1]),Me=Oz(OS(ne,le),[2254,1]),Re=Oz(OS(xe,ce),[2254,1]);let we=tN([ue,Te,Me,Re],1);for(let ke=0;ke<4;ke++){let Ue=SB(t0(A,[0,4+ke*2],[-1,1])),Ge=SB(t0(A,[0,4+ke*2+1],[-1,1]));Ue=Oz(OS(OP(Ue,$.width),V[0]),[2254,1]),Ge=Oz(OS(OP(Ge,$.height),V[1]),[2254,1]),we=tN([we,Ue,Ge],1)}return we}buildAnchors(A){const V=[8,16,32,32,32],$=[];let ne=0;for(;ne<5;){let xe=0,le=ne;for(;le<V.length&&V[le]===V[ne];)xe+=2,le++;const ce=V[ne],ue=Math.ceil(A.height/ce),Te=Math.ceil(A.width/ce);for(let Me=0;Me<ue;++Me)for(let Re=0;Re<Te;++Re)for(let we=0;we<xe;++we)$.push({x:(Re+.5)/Te,y:(Me+.5)/ue});ne=le}return $}async prepare(){const{width:A,height:V}=this.modelSize,$=BQ([1,V,A,3]),ne=this.model.execute($,"person");await ne.data(),$.dispose(),ne.dispose()}dispose(){this.model.dispose(),this.anchorsX.dispose(),this.anchorsY.dispose()}}class Vv{constructor(A){if(this.size=A,Jr()!=="webgl")return;const{width:V,height:$}=A;this.backend=f1(),this.prog={variableNames:["maskT","prevT"],outputShape:[$,V],userCode:`
                void main() {
                    ivec2 c = getOutputCoords();
                    float mask = getMaskT(c[0], c[1]);
                    float prev = getPrevT(c[0], c[1]);
                    float t = mask - 0.5;
                    float x = t * t;
                    float alpha = 1.0 - min(
                        x * (5.74062006 + x * (-2.90180189 + x * (-30.34594285 +
                        x * (153.83657925 + x * (-387.53530186))))), 1.0);
                    float smoothed = mask + (prev - mask) * (alpha * 0.9);
                    setOutput(smoothed);
                }
        `}}process(A){var V;if(!this.backend||!this.prog)return;const $=this.backend.compileAndRun(this.prog,[A,this.prev||A]),ne=Ju().makeTensorFromTensorInfo($);return(V=this.prev)==null||V.dispose(),this.prev=ne,ne}reset(){var A;(A=this.prev)==null||A.dispose(),delete this.prev}async prepare(){if(!this.backend||!this.prog)return;const{width:A,height:V}=this.size,$=BQ([V,A]),ne=Bs([V,A]),xe=this.backend.compileAndRun(this.prog,[$,ne]),le=Ju().makeTensorFromTensorInfo(xe);await le.data(),$.dispose(),ne.dispose(),le.dispose()}dispose(){this.reset(),delete this.prog,delete this.backend}}class Vq{constructor(A,V=!1){this.model=A,this.mask=V,this.sizeFactor=1.2,this.model=A,this.modelSize=A.inputs[0].shape?{width:A.inputs[0].shape[2],height:A.inputs[0].shape[1]}:{width:256,height:256},typeof V=="object"&&V.smooth&&(this.maskFilter=new Vv(this.modelSize))}process(A,V){const[$,ne]=[A.shape[1],A.shape[2]],{modelSize:xe}=this;return V.map(le=>{var ce;const ue=[le.center[0]*ne,le.center[1]*$],Te=[le.top[0]*ne,le.top[1]*$],Me=[Te[0]-ue[0],Te[1]-ue[1]],Re=Math.sqrt(Me[0]*Me[0]+Me[1]*Me[1])*this.sizeFactor,we=Math.atan2(Me[0],-Me[1]),ke=[ue[1]-Re,ue[0]-Re,ue[1]+Re,ue[0]+Re],Ue=JY(()=>{const Kt=this.rotatedRect(A,ke,we,xe);return OS(OD(Kt,.5),.5)}),Ge=["ld_3d","world_3d","output_poseflag","activation_heatmap"];this.mask&&Ge.push("activation_segmentation");const[We,Xe,Ye,je,Ke]=this.model.execute(Ue,Ge),qe=We.dataSync(),$e=Xe.dataSync(),vt=Ye.dataSync()[0];let nt=[];for(let Kt=0;Kt<39;Kt++)nt.push([qe[Kt*5+0]/xe.width,qe[Kt*5+1]/xe.height,qe[Kt*5+2]/xe.width]);let wt;if(Ke){const Kt=dQ.rotateWithOffset(Ke,-we),Ht=SB(Kt),pi=((ce=this.maskFilter)==null?void 0:ce.process(Ht))||Ht,hi=OD(pi,255);wt=new Uint8Array(hi.dataSync()),Ke.dispose(),Kt.dispose(),Ht.dispose(),hi.dispose()}return Ue.dispose(),We.dispose(),Xe.dispose(),Ye.dispose(),nt=this.refinePoints(nt,je),je.dispose(),{points:nt,pointsData:qe,metricData:$e,maskData:wt,score:vt,center:ue,top:Te,radius:Re,angle:we}}).map(le=>{const{points:ce,pointsData:ue,metricData:Te,maskData:Me,score:Re,center:we,top:ke,radius:Ue,angle:Ge}=le;let We=ce.map((vt,nt)=>({pixel:vt,metric:[Te[nt*3+0],Te[nt*3+1],Te[nt*3+2]],norm:[Te[nt*3+0],Te[nt*3+1],Te[nt*3+2]],score:1/(1+Math.exp(-ue[nt*5+3])),visibility:1/(1+Math.exp(-ue[nt*5+4]))}));We.forEach(vt=>{vt.pixel[0]=(vt.pixel[0]-.5)*2*Ue,vt.pixel[1]=(vt.pixel[1]-.5)*2*Ue,vt.pixel[2]*=2*Ue});const Xe=Math.sin(Ge),Ye=Math.cos(Ge);We.forEach(vt=>{const nt=vt.pixel[0],wt=vt.pixel[1];vt.pixel[0]=(nt*Ye-wt*Xe+we[0])/ne,vt.pixel[1]=(nt*Xe+wt*Ye+we[1])/$,vt.pixel[2]/=ne;const Kt=vt.metric[0],Ht=vt.metric[1];vt.metric[0]=Kt*Ye-Ht*Xe,vt.metric[1]=Kt*Xe+Ht*Ye});const je=We.map(vt=>vt.pixel[0]),Ke=We.map(vt=>vt.pixel[1]),qe=[[Math.min(...je),Math.min(...Ke)],[Math.max(...je),Math.max(...Ke)]],$e=Me&&{buffer:Me,size:{width:256,height:256},box:[[(we[0]-Ue)/ne,(we[1]-Ue)/$],[(we[0]+Ue)/ne,(we[1]+Ue)/$]]};return{keypoints:We,score:Re,mask:$e,center:[We[33].pixel[0],We[33].pixel[1]],top:[We[34].pixel[0],We[34].pixel[1]],debug:{center:we,top:ke,box:qe,radius:Ue,angle:Ge}}})}refinePoints(A,V){const $=SB(V,[0]),ne=$.bufferSync(),[xe,le,ce]=$.shape;return A.map((ue,Te)=>{const Me=ue,Re=Math.trunc(Me[0]*le),we=Math.trunc(Me[1]*xe);if(Re<0||Re>=le||we<0||we>=xe)return ue;const ke=Math.trunc((7-1)/2),Ue=Math.max(Re-ke,0),Ge=Math.min(Re+ke+1,le),We=Math.max(we-ke,0),Xe=Math.min(we+ke+1,xe);let Ye=0,je=0,Ke=0,qe=0;for(let $e=We;$e<Xe;$e++)for(let vt=Ue;vt<Ge;vt++){const nt=ne.get($e,vt,Te);Ye+=nt,je=Math.max(nt,je),Ke+=vt*nt,qe+=$e*nt}return $.dispose(),je>=.5&&Ye>0?[Ke/Ye/le,qe/Ye/xe,Me[2]]:ue})}rotatedRect(A,V,$,ne){const[xe,le]=[V[2]-V[0],V[3]-V[1]],[ce,ue]=[(V[2]+V[0])*.5,(V[3]+V[1])*.5],[Te,Me]=[xe/ne.height,le/ne.width],[Re,we]=[Math.cos($),Math.sin($)],ke=[Re*Me,-we*Te,(-Re*le+we*xe)*.5+ue,we*Me,Re*Te,(-we*le-Re*xe)*.5+ce,0,0];return dQ.transform(A,[ke],"bilinear","constant",0,[ne.height,ne.width])}reset(){var A;(A=this.maskFilter)==null||A.reset()}async prepare(){var A;const{width:V,height:$}=this.modelSize,ne=BQ([1,$,V,3]),xe=this.model.execute(ne);await Promise.all(xe.map(async le=>{await le.data(),le.dispose()})),await((A=this.maskFilter)==null?void 0:A.prepare()),ne.dispose()}async dispose(){var A,V;(A=this.model)==null||A.dispose(),(V=this.maskFilter)==null||V.dispose(),delete this.maskFilter}}var Vl=Object.defineProperty,Va=Object.getOwnPropertySymbols,Vn=Object.prototype.hasOwnProperty,VL=Object.prototype.propertyIsEnumerable,VH=(W,A,V)=>A in W?Vl(W,A,{enumerable:!0,configurable:!0,writable:!0,value:V}):W[A]=V,Vk=(W,A)=>{for(var V in A||(A={}))Vn.call(A,V)&&VH(W,V,A[V]);if(Va)for(var V of Va(A))VL.call(A,V)&&VH(W,V,A[V]);return W};class Vz{constructor(){this.freq=30,this.pixelParams={minCutOff:1,minCutOffD:1,beta:50},this.metricParams={minCutOff:.5,minCutOffD:1,beta:30},this.boxParams={minCutOff:1,minCutOffD:1,beta:50},this.scoreCutOff=1,this.visibilityCutOff=1,this.time=0}filter(A,V,$=1){return this.time>=V?A:(this.time!==0&&(this.freq=1/(V-this.time)),this.time=V,!this.raw||!this.smooth||!this.der?(this.raw=this.clonePose(A),this.smooth=this.clonePose(A),this.der={keypoints:A.keypoints.map(()=>({pixel:[0,0,0],metric:[0,0,0],norm:[0,0,0],score:0,visibility:0})),score:0,center:[0,0],top:[0,0],debug:{box:[[0,0],[0,0]],center:[0,0],top:[0,0],radius:0,angle:0}},this.clonePose(this.smooth)):(this.filterKeypoints(A.keypoints,this.raw.keypoints,this.der.keypoints,this.smooth.keypoints,$),this.filterCoord2D(A.center,this.raw.center,this.der.center,this.smooth.center,$,this.boxParams),this.filterCoord2D(A.top,this.raw.top,this.der.top,this.smooth.top,$,this.boxParams),this.smooth.score=A.score,this.smooth.mask=A.mask&&{buffer:A.mask.buffer,size:Vk({},A.mask.size),box:[[...A.mask.box[0]],[...A.mask.box[1]]]},this.smooth.debug=A.debug&&{center:[...A.debug.center],top:[...A.debug.top],box:[[...A.debug.box[0]],[...A.debug.box[1]]],radius:A.debug.radius,angle:A.debug.angle},this.clonePose(this.smooth)))}filterKeypoints(A,V,$,ne,xe){const le=this.alpha(this.visibilityCutOff),ce=this.alpha(this.scoreCutOff);for(let ue=0;ue<A.length;ue++)this.filterCoord3D(A[ue].pixel,V[ue].pixel,$[ue].pixel,ne[ue].pixel,xe,this.pixelParams),this.filterCoord3D(A[ue].metric,V[ue].metric,$[ue].metric,ne[ue].metric,xe,this.metricParams),this.filterCoord3D(A[ue].norm,V[ue].norm,$[ue].norm,ne[ue].norm,xe,this.metricParams),ne[ue].score=ne[ue].score+ce*(A[ue].score-ne[ue].score),ne[ue].visibility=ne[ue].visibility+le*(A[ue].visibility-ne[ue].visibility)}filterCoord3D(A,V,$,ne,xe,le){const ce=[(A[0]-ne[0])*xe*this.freq,(A[1]-ne[1])*xe*this.freq,(A[2]-ne[2])*xe*this.freq],ue=this.alpha(le.minCutOffD);$[0]=$[0]+ue*(ce[0]-$[0]),$[1]=$[1]+ue*(ce[1]-$[1]),$[2]=$[2]+ue*(ce[2]-$[2]);const Te=[this.alpha(le.minCutOff+le.beta*Math.abs($[0])),this.alpha(le.minCutOff+le.beta*Math.abs($[1])),this.alpha(le.minCutOff+le.beta*Math.abs($[2]))];ne[0]=ne[0]+Te[0]*(A[0]-ne[0]),ne[1]=ne[1]+Te[1]*(A[1]-ne[1]),ne[2]=ne[2]+Te[2]*(A[2]-ne[2]),V[0]=A[0],V[1]=A[1],V[2]=A[2]}filterCoord2D(A,V,$,ne,xe,le){const ce=[(A[0]-ne[0])*xe*this.freq,(A[1]-ne[1])*xe*this.freq],ue=this.alpha(le.minCutOffD);$[0]=$[0]+ue*(ce[0]-$[0]),$[1]=$[1]+ue*(ce[1]-$[1]);const Te=[this.alpha(le.minCutOff+le.beta*Math.abs($[0])),this.alpha(le.minCutOff+le.beta*Math.abs($[1]))];ne[0]=ne[0]+Te[0]*(A[0]-ne[0]),ne[1]=ne[1]+Te[1]*(A[1]-ne[1]),V[0]=A[0],V[1]=A[1]}reset(){delete this.raw,delete this.smooth,delete this.der}alpha(A){return 1/(1+this.freq/(2*Math.PI*A))}clonePose(A){return{keypoints:A.keypoints.map(V=>({pixel:[...V.pixel],metric:[...V.metric],norm:[...V.norm],score:V.score,visibility:V.visibility})),score:A.score,center:[...A.center],top:[...A.top],mask:A.mask&&{buffer:A.mask.buffer,size:Vk({},A.mask.size),box:[[...A.mask.box[0]],[...A.mask.box[1]]]},debug:A.debug&&{box:[[...A.debug.box[0]],[...A.debug.box[1]]],center:[...A.debug.center],top:[...A.debug.top],radius:A.debug.radius,angle:A.debug.angle}}}}function Vx(W,A){const V=[Math.max(W.xy.x,A.xy.x),Math.max(W.xy.y,A.xy.y)],$=[Math.min(W.xy.x+W.size.width,W.xy.x+W.size.width),Math.min(W.xy.y+W.size.height,W.xy.y+W.size.height)],ne=($[0]-V[0])*($[1]-V[1]);return ne/(W.size.width*W.size.height+A.size.width*A.size.height-ne)}function VU(W,A){const V=[[Math.max(W[0][0],A[0][0]),Math.max(W[0][1],A[0][1])],[Math.min(W[1][0],A[1][0]),Math.min(W[1][1],A[1][1])]],$=(V[1][0]-V[0][0])*(V[1][1]-V[0][1]);return $/((W[1][0]-W[0][0])*(W[1][1]-W[0][1])+(A[1][0]-A[0][0])*(A[1][1]-A[0][1])-$)}function VG(W){return{xy:{x:W[0][0],y:W[0][1]},size:{width:W[1][0]-W[0][0],height:W[1][1]-W[0][1]}}}function Vu(W){return[[W.xy.x,W.xy.y],[W.xy.x+W.size.width,W.xy.y+W.size.height]]}var VY=(()=>{var W=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(A={}){var V=A,$,ne;V.ready=new Promise((pt,ht)=>{$=pt,ne=ht});var xe=Object.assign({},V),le="./this.program",ce=(pt,ht)=>{throw ht},ue=!0,Te=!1,Me="";function Re(pt){return V.locateFile?V.locateFile(pt,Me):Me+pt}typeof document<"u"&&document.currentScript&&(Me=document.currentScript.src),W&&(Me=W),Me.startsWith("blob:")?Me="":Me=Me.substr(0,Me.replace(/[?#].*/,"").lastIndexOf("/")+1),V.print||console.log.bind(console);var we=V.printErr||console.error.bind(console);Object.assign(V,xe),xe=null,V.arguments&&V.arguments,V.thisProgram&&(le=V.thisProgram),V.quit&&(ce=V.quit);var ke;V.wasmBinary&&(ke=V.wasmBinary);var Ue,Ge=!1,We,Xe,Ye,je,Ke,qe,$e,vt,nt;function wt(){var pt=Ue.buffer;V.HEAP8=Xe=new Int8Array(pt),V.HEAP16=je=new Int16Array(pt),V.HEAPU8=Ye=new Uint8Array(pt),V.HEAPU16=Ke=new Uint16Array(pt),V.HEAP32=qe=new Int32Array(pt),V.HEAPU32=$e=new Uint32Array(pt),V.HEAPF32=vt=new Float32Array(pt),V.HEAPF64=nt=new Float64Array(pt)}var Kt=[],Ht=[],pi=[];function hi(){if(V.preRun)for(typeof V.preRun=="function"&&(V.preRun=[V.preRun]);V.preRun.length;)Wi(V.preRun.shift());rn(Kt)}function ai(){rn(Ht)}function Yi(){if(V.postRun)for(typeof V.postRun=="function"&&(V.postRun=[V.postRun]);V.postRun.length;)Hi(V.postRun.shift());rn(pi)}function Wi(pt){Kt.unshift(pt)}function ls(pt){Ht.unshift(pt)}function Hi(pt){pi.unshift(pt)}var rs=0,Us=null;function Hs(pt){var ht;rs++,(ht=V.monitorRunDependencies)==null||ht.call(V,rs)}function qi(pt){var ht;if(rs--,(ht=V.monitorRunDependencies)==null||ht.call(V,rs),rs==0&&Us){var Wt=Us;Us=null,Wt()}}function as(pt){var ht;(ht=V.onAbort)==null||ht.call(V,pt),pt="Aborted("+pt+")",we(pt),Ge=!0,We=1,pt+=". Build with -sASSERTIONS for more info.";var Wt=new WebAssembly.RuntimeError(pt);throw ne(Wt),Wt}var li="data:application/octet-stream;base64,",vi=pt=>pt.startsWith(li),Ui;Ui="bodyutils.wasm",vi(Ui)||(Ui=Re(Ui));function hs(pt){if(pt==Ui&&ke)return new Uint8Array(ke);throw"both async and sync fetching of the wasm failed"}function Xs(pt){return!ke&&ue&&typeof fetch=="function"?fetch(pt,{credentials:"same-origin"}).then(ht=>{if(!ht.ok)throw"failed to load wasm binary file at '"+pt+"'";return ht.arrayBuffer()}).catch(()=>hs(pt)):Promise.resolve().then(()=>hs(pt))}function cr(pt,ht,Wt){return Xs(pt).then(_i=>WebAssembly.instantiate(_i,ht)).then(Wt,_i=>{we("failed to asynchronously prepare wasm: "+_i),as(_i)})}function Ks(pt,ht,Wt,_i){return!pt&&typeof WebAssembly.instantiateStreaming=="function"&&!vi(ht)&&typeof fetch=="function"?fetch(ht,{credentials:"same-origin"}).then(Xi=>{var $i=WebAssembly.instantiateStreaming(Xi,Wt);return $i.then(_i,function(ps){return we("wasm streaming compile failed: "+ps),we("falling back to ArrayBuffer instantiation"),cr(ht,Wt,_i)})}):cr(ht,Wt,_i)}function $s(){var pt={a:Ly};function ht(_i,Xi){return Xx=_i.exports,Ue=Xx.E,wt(),Gl=Xx.H,ls(Xx.F),qi(),Xx}Hs();function Wt(_i){ht(_i.instance)}if(V.instantiateWasm)try{return V.instantiateWasm(pt,ht)}catch(_i){we("Module.instantiateWasm callback failed with error: "+_i),ne(_i)}return Ks(ke,Ui,pt,Wt).catch(ne),{}}function hr(pt){this.name="ExitStatus",this.message="Program terminated with exit("+pt+")",this.status=pt}var rn=pt=>{for(;pt.length>0;)pt.shift()(V)},Rr=V.noExitRuntime||!0;class Yr{constructor(ht){this.excPtr=ht,this.ptr=ht-24}set_type(ht){$e[this.ptr+4>>2]=ht}get_type(){return $e[this.ptr+4>>2]}set_destructor(ht){$e[this.ptr+8>>2]=ht}get_destructor(){return $e[this.ptr+8>>2]}set_caught(ht){ht=ht?1:0,Xe[this.ptr+12]=ht}get_caught(){return Xe[this.ptr+12]!=0}set_rethrown(ht){ht=ht?1:0,Xe[this.ptr+13]=ht}get_rethrown(){return Xe[this.ptr+13]!=0}init(ht,Wt){this.set_adjusted_ptr(0),this.set_type(ht),this.set_destructor(Wt)}set_adjusted_ptr(ht){$e[this.ptr+16>>2]=ht}get_adjusted_ptr(){return $e[this.ptr+16>>2]}get_exception_ptr(){var ht=Ug(this.get_type());if(ht)return $e[this.excPtr>>2];var Wt=this.get_adjusted_ptr();return Wt!==0?Wt:this.excPtr}}var Tn=0,Mn=(pt,ht,Wt)=>{var _i=new Yr(pt);throw _i.init(ht,Wt),Tn=pt,Tn},Un=(pt,ht,Wt,_i,Xi)=>{},qn=()=>{for(var pt=new Array(256),ht=0;ht<256;++ht)pt[ht]=String.fromCharCode(ht);$n=pt},$n,cs=pt=>{for(var ht="",Wt=pt;Ye[Wt];)ht+=$n[Ye[Wt++]];return ht},a0={},ux={},Yx={},ka,cn=pt=>{throw new ka(pt)},Kr,px=pt=>{throw new Kr(pt)},xn=(pt,ht,Wt)=>{pt.forEach(function(xs){Yx[xs]=ht});function _i(xs){var nr=Wt(xs);nr.length!==pt.length&&px("Mismatched type converter count");for(var pr=0;pr<pt.length;++pr)l0(pt[pr],nr[pr])}var Xi=new Array(ht.length),$i=[],ps=0;ht.forEach((xs,nr)=>{ux.hasOwnProperty(xs)?Xi[nr]=ux[xs]:($i.push(xs),a0.hasOwnProperty(xs)||(a0[xs]=[]),a0[xs].push(()=>{Xi[nr]=ux[xs],++ps,ps===$i.length&&_i(Xi)}))}),$i.length===0&&_i(Xi)};function Kx(pt,ht,Wt={}){var _i=ht.name;if(pt||cn('type "'+_i+'" must have a positive integer typeid pointer'),ux.hasOwnProperty(pt)){if(Wt.ignoreDuplicateRegistrations)return;cn("Cannot register type '"+_i+"' twice")}if(ux[pt]=ht,delete Yx[pt],a0.hasOwnProperty(pt)){var Xi=a0[pt];delete a0[pt],Xi.forEach($i=>$i())}}function l0(pt,ht,Wt={}){if(!("argPackAdvance"in ht))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Kx(pt,ht,Wt)}var h0=8,wl=(pt,ht,Wt,_i)=>{ht=cs(ht),l0(pt,{name:ht,fromWireType:function(Xi){return!!Xi},toWireType:function(Xi,$i){return $i?Wt:_i},argPackAdvance:h0,readValueFromPointer:function(Xi){return this.fromWireType(Ye[Xi])},destructorFunction:null})},vh=pt=>({count:pt.count,deleteScheduled:pt.deleteScheduled,preservePointerOnDelete:pt.preservePointerOnDelete,ptr:pt.ptr,ptrType:pt.ptrType,smartPtr:pt.smartPtr,smartPtrType:pt.smartPtrType}),Xo=pt=>{function ht(Wt){return Wt.$$.ptrType.registeredClass.name}cn(ht(pt)+" instance already deleted")},h2=!1,Ri=pt=>{},Rh=pt=>{pt.smartPtr?pt.smartPtrType.rawDestructor(pt.smartPtr):pt.ptrType.registeredClass.rawDestructor(pt.ptr)},kn=pt=>{pt.count.value-=1;var ht=pt.count.value===0;ht&&Rh(pt)},c0=(pt,ht,Wt)=>{if(ht===Wt)return pt;if(Wt.baseClass===void 0)return null;var _i=c0(pt,ht,Wt.baseClass);return _i===null?null:Wt.downcast(_i)},va={},Ux=()=>Object.keys(Ti).length,no=()=>{var pt=[];for(var ht in Ti)Ti.hasOwnProperty(ht)&&pt.push(Ti[ht]);return pt},H0=[],j2=()=>{for(;H0.length;){var pt=H0.pop();pt.$$.deleteScheduled=!1,pt.delete()}},Mr,Yo=pt=>{Mr=pt,H0.length&&Mr&&Mr(j2)},ur=()=>{V.getInheritedInstanceCount=Ux,V.getLiveInheritedInstances=no,V.flushPendingDeletes=j2,V.setDelayFunction=Yo},Ti={},q2=(pt,ht)=>{for(ht===void 0&&cn("ptr should not be undefined");pt.baseClass;)ht=pt.upcast(ht),pt=pt.baseClass;return ht},xc=(pt,ht)=>(ht=q2(pt,ht),Ti[ht]),X0=(pt,ht)=>{(!ht.ptrType||!ht.ptr)&&px("makeClassHandle requires ptr and ptrType");var Wt=!!ht.smartPtrType,_i=!!ht.smartPtr;return Wt!==_i&&px("Both smartPtrType and smartPtr must be specified"),ht.count={value:1},K0(Object.create(pt,{$$:{value:ht,writable:!0}}))};function lc(pt){var ht=this.getPointee(pt);if(!ht)return this.destructor(pt),null;var Wt=xc(this.registeredClass,ht);if(Wt!==void 0){if(Wt.$$.count.value===0)return Wt.$$.ptr=ht,Wt.$$.smartPtr=pt,Wt.clone();var _i=Wt.clone();return this.destructor(pt),_i}function Xi(){return this.isSmartPointer?X0(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:ht,smartPtrType:this,smartPtr:pt}):X0(this.registeredClass.instancePrototype,{ptrType:this,ptr:pt})}var $i=this.registeredClass.getActualType(ht),ps=va[$i];if(!ps)return Xi.call(this);var xs;this.isConst?xs=ps.constPointerType:xs=ps.pointerType;var nr=c0(ht,this.registeredClass,xs.registeredClass);return nr===null?Xi.call(this):this.isSmartPointer?X0(xs.registeredClass.instancePrototype,{ptrType:xs,ptr:nr,smartPtrType:this,smartPtr:pt}):X0(xs.registeredClass.instancePrototype,{ptrType:xs,ptr:nr})}var K0=pt=>typeof FinalizationRegistry>"u"?(K0=ht=>ht,pt):(h2=new FinalizationRegistry(ht=>{kn(ht.$$)}),K0=ht=>{var Wt=ht.$$,_i=!!Wt.smartPtr;if(_i){var Xi={$$:Wt};h2.register(ht,Xi,ht)}return ht},Ri=ht=>h2.unregister(ht),K0(pt)),Ll=()=>{Object.assign(Gn.prototype,{isAliasOf(pt){if(!(this instanceof Gn)||!(pt instanceof Gn))return!1;var ht=this.$$.ptrType.registeredClass,Wt=this.$$.ptr;pt.$$=pt.$$;for(var _i=pt.$$.ptrType.registeredClass,Xi=pt.$$.ptr;ht.baseClass;)Wt=ht.upcast(Wt),ht=ht.baseClass;for(;_i.baseClass;)Xi=_i.upcast(Xi),_i=_i.baseClass;return ht===_i&&Wt===Xi},clone(){if(this.$$.ptr||Xo(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var pt=K0(Object.create(Object.getPrototypeOf(this),{$$:{value:vh(this.$$)}}));return pt.$$.count.value+=1,pt.$$.deleteScheduled=!1,pt},delete(){this.$$.ptr||Xo(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&cn("Object already scheduled for deletion"),Ri(this),kn(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||Xo(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&cn("Object already scheduled for deletion"),H0.push(this),H0.length===1&&Mr&&Mr(j2),this.$$.deleteScheduled=!0,this}})};function Gn(){}var ao=(pt,ht)=>Object.defineProperty(ht,"name",{value:pt}),kl=(pt,ht,Wt)=>{if(pt[ht].overloadTable===void 0){var _i=pt[ht];pt[ht]=function(...Xi){return pt[ht].overloadTable.hasOwnProperty(Xi.length)||cn("Function '"+Wt+"' called with an invalid number of arguments ("+Xi.length+") - expects one of ("+pt[ht].overloadTable+")!"),pt[ht].overloadTable[Xi.length].apply(this,Xi)},pt[ht].overloadTable=[],pt[ht].overloadTable[_i.argCount]=_i}},hc=(pt,ht,Wt)=>{V.hasOwnProperty(pt)?((Wt===void 0||V[pt].overloadTable!==void 0&&V[pt].overloadTable[Wt]!==void 0)&&cn("Cannot register public name '"+pt+"' twice"),kl(V,pt,pt),V.hasOwnProperty(Wt)&&cn("Cannot register multiple overloads of a function with the same number of arguments ("+Wt+")!"),V[pt].overloadTable[Wt]=ht):(V[pt]=ht,Wt!==void 0&&(V[pt].numArguments=Wt))},cc=48,Wa=57,$2=pt=>{if(pt===void 0)return"_unknown";pt=pt.replace(/[^a-zA-Z0-9_]/g,"$");var ht=pt.charCodeAt(0);return ht>=cc&&ht<=Wa?"_"+pt:pt};function Ul(pt,ht,Wt,_i,Xi,$i,ps,xs){this.name=pt,this.constructor=ht,this.instancePrototype=Wt,this.rawDestructor=_i,this.baseClass=Xi,this.getActualType=$i,this.upcast=ps,this.downcast=xs,this.pureVirtualFunctions=[]}var Ro=(pt,ht,Wt)=>{for(;ht!==Wt;)ht.upcast||cn("Expected null or instance of "+Wt.name+", got an instance of "+ht.name),pt=ht.upcast(pt),ht=ht.baseClass;return pt};function uc(pt,ht){if(ht===null)return this.isReference&&cn("null is not a valid "+this.name),0;ht.$$||cn('Cannot pass "'+Wx(ht)+'" as a '+this.name),ht.$$.ptr||cn("Cannot pass deleted object as a pointer of type "+this.name);var Wt=ht.$$.ptrType.registeredClass,_i=Ro(ht.$$.ptr,Wt,this.registeredClass);return _i}function Mh(pt,ht){var Wt;if(ht===null)return this.isReference&&cn("null is not a valid "+this.name),this.isSmartPointer?(Wt=this.rawConstructor(),pt!==null&&pt.push(this.rawDestructor,Wt),Wt):0;(!ht||!ht.$$)&&cn('Cannot pass "'+Wx(ht)+'" as a '+this.name),ht.$$.ptr||cn("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&ht.$$.ptrType.isConst&&cn("Cannot convert argument of type "+(ht.$$.smartPtrType?ht.$$.smartPtrType.name:ht.$$.ptrType.name)+" to parameter type "+this.name);var _i=ht.$$.ptrType.registeredClass;if(Wt=Ro(ht.$$.ptr,_i,this.registeredClass),this.isSmartPointer)switch(ht.$$.smartPtr===void 0&&cn("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:ht.$$.smartPtrType===this?Wt=ht.$$.smartPtr:cn("Cannot convert argument of type "+(ht.$$.smartPtrType?ht.$$.smartPtrType.name:ht.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:Wt=ht.$$.smartPtr;break;case 2:if(ht.$$.smartPtrType===this)Wt=ht.$$.smartPtr;else{var Xi=ht.clone();Wt=this.rawShare(Wt,T0.toHandle(()=>Xi.delete())),pt!==null&&pt.push(this.rawDestructor,Wt)}break;default:cn("Unsupporting sharing policy")}return Wt}function c2(pt,ht){if(ht===null)return this.isReference&&cn("null is not a valid "+this.name),0;ht.$$||cn('Cannot pass "'+Wx(ht)+'" as a '+this.name),ht.$$.ptr||cn("Cannot pass deleted object as a pointer of type "+this.name),ht.$$.ptrType.isConst&&cn("Cannot convert argument of type "+ht.$$.ptrType.name+" to parameter type "+this.name);var Wt=ht.$$.ptrType.registeredClass,_i=Ro(ht.$$.ptr,Wt,this.registeredClass);return _i}function Mo(pt){return this.fromWireType($e[pt>>2])}var xx=()=>{Object.assign(ji.prototype,{getPointee(pt){return this.rawGetPointee&&(pt=this.rawGetPointee(pt)),pt},destructor(pt){var ht;(ht=this.rawDestructor)==null||ht.call(this,pt)},argPackAdvance:h0,readValueFromPointer:Mo,fromWireType:lc})};function ji(pt,ht,Wt,_i,Xi,$i,ps,xs,nr,pr,ar){this.name=pt,this.registeredClass=ht,this.isReference=Wt,this.isConst=_i,this.isSmartPointer=Xi,this.pointeeType=$i,this.sharingPolicy=ps,this.rawGetPointee=xs,this.rawConstructor=nr,this.rawShare=pr,this.rawDestructor=ar,!Xi&&ht.baseClass===void 0?_i?(this.toWireType=uc,this.destructorFunction=null):(this.toWireType=c2,this.destructorFunction=null):this.toWireType=Mh}var _a=(pt,ht,Wt)=>{V.hasOwnProperty(pt)||px("Replacing nonexistent public symbol"),V[pt].overloadTable!==void 0&&Wt!==void 0?V[pt].overloadTable[Wt]=ht:(V[pt]=ht,V[pt].argCount=Wt)},u2=(pt,ht,Wt)=>{var _i=V["dynCall_"+pt];return _i(ht,...Wt)},lx=[],Gl,$a=pt=>{var ht=lx[pt];return ht||(pt>=lx.length&&(lx.length=pt+1),lx[pt]=ht=Gl.get(pt)),ht},pc=(pt,ht,Wt=[])=>{if(pt.includes("j"))return u2(pt,ht,Wt);var _i=$a(ht)(...Wt);return _i},u0=(pt,ht)=>(...Wt)=>pc(pt,ht,Wt),hx=(pt,ht)=>{pt=cs(pt);function Wt(){return pt.includes("j")?u0(pt,ht):$a(ht)}var _i=Wt();return typeof _i!="function"&&cn("unknown function pointer with signature "+pt+": "+ht),_i},Gx=(pt,ht)=>{var Wt=ao(ht,function(_i){this.name=ht,this.message=_i;var Xi=new Error(_i).stack;Xi!==void 0&&(this.stack=this.toString()+`
`+Xi.replace(/^Error(:[^\n]*)?\n/,""))});return Wt.prototype=Object.create(pt.prototype),Wt.prototype.constructor=Wt,Wt.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},Wt},zl,aa=pt=>{var ht=Lm(pt),Wt=cs(ht);return Lo(ht),Wt},Ko=(pt,ht)=>{var Wt=[],_i={};function Xi($i){if(!_i[$i]&&!ux[$i]){if(Yx[$i]){Yx[$i].forEach(Xi);return}Wt.push($i),_i[$i]=!0}}throw ht.forEach(Xi),new zl(pt+": "+Wt.map(aa).join([", "]))},xo=(pt,ht,Wt,_i,Xi,$i,ps,xs,nr,pr,ar,ln,an)=>{ar=cs(ar),$i=hx(Xi,$i),xs&&(xs=hx(ps,xs)),pr&&(pr=hx(nr,pr)),an=hx(ln,an);var Ln=$2(ar);hc(Ln,function(){Ko("Cannot construct "+ar+" due to unbound types",[_i])}),xn([pt,ht,Wt],_i?[_i]:[],xa=>{var Rs;xa=xa[0];var Tr,jn;_i?(Tr=xa.registeredClass,jn=Tr.instancePrototype):jn=Gn.prototype;var Ws=ao(ar,function(...w2){if(Object.getPrototypeOf(this)!==jr)throw new ka("Use 'new' to construct "+ar);if(la.constructor_body===void 0)throw new ka(ar+" has no accessible constructor");var ws=la.constructor_body[w2.length];if(ws===void 0)throw new ka("Tried to invoke ctor of "+ar+" with invalid number of parameters ("+w2.length+") - expected ("+Object.keys(la.constructor_body).toString()+") parameters instead!");return ws.apply(this,w2)}),jr=Object.create(jn,{constructor:{value:Ws}});Ws.prototype=jr;var la=new Ul(ar,Ws,jr,an,Tr,$i,xs,pr);la.baseClass&&((Rs=la.baseClass).__derivedClasses!=null||(Rs.__derivedClasses=[]),la.baseClass.__derivedClasses.push(la));var Ma=new ji(ar,la,!0,!1,!1),qr=new ji(ar+"*",la,!1,!1,!1),v0=new ji(ar+" const*",la,!1,!0,!1);return va[pt]={pointerType:qr,constPointerType:v0},_a(Ln,Ws),[Ma,qr,v0]})},wh=(pt,ht)=>{for(var Wt=[],_i=0;_i<pt;_i++)Wt.push($e[ht+_i*4>>2]);return Wt},zx=pt=>{for(;pt.length;){var ht=pt.pop(),Wt=pt.pop();Wt(ht)}};function _c(pt){for(var ht=1;ht<pt.length;++ht)if(pt[ht]!==null&&pt[ht].destructorFunction===void 0)return!0;return!1}function sr(pt,ht,Wt,_i,Xi,$i){var ps=ht.length;ps<2&&cn("argTypes array size mismatch! Must at least get return value and 'this' types!");var xs=ht[1]!==null&&Wt!==null,nr=_c(ht),pr=ht[0].name!=="void",ar=ps-2,ln=new Array(ar),an=[],Ln=[],xa=function(...Rs){Rs.length!==ar&&cn("function "+pt+" called with "+Rs.length+" arguments, expected "+ar),Ln.length=0;var Tr;an.length=xs?2:1,an[0]=Xi,xs&&(Tr=ht[1].toWireType(Ln,this),an[1]=Tr);for(var jn=0;jn<ar;++jn)ln[jn]=ht[jn+2].toWireType(Ln,Rs[jn]),an.push(ln[jn]);var Ws=_i(...an);function jr(la){if(nr)zx(Ln);else for(var Ma=xs?1:2;Ma<ht.length;Ma++){var qr=Ma===1?Tr:ln[Ma-2];ht[Ma].destructorFunction!==null&&ht[Ma].destructorFunction(qr)}if(pr)return ht[0].fromWireType(la)}return jr(Ws)};return ao(pt,xa)}var Tc=(pt,ht,Wt,_i,Xi,$i)=>{var ps=wh(ht,Wt);Xi=hx(_i,Xi),xn([],[pt],xs=>{xs=xs[0];var nr="constructor "+xs.name;if(xs.registeredClass.constructor_body===void 0&&(xs.registeredClass.constructor_body=[]),xs.registeredClass.constructor_body[ht-1]!==void 0)throw new ka("Cannot register multiple constructors with identical number of parameters ("+(ht-1)+") for class '"+xs.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return xs.registeredClass.constructor_body[ht-1]=()=>{Ko("Cannot construct "+xs.name+" due to unbound types",ps)},xn([],ps,pr=>(pr.splice(1,0,null),xs.registeredClass.constructor_body[ht-1]=sr(nr,pr,null,Xi,$i),[])),[]})},rl=pt=>{pt=pt.trim();const ht=pt.indexOf("(");return ht!==-1?pt.substr(0,ht):pt},_0=(pt,ht,Wt,_i,Xi,$i,ps,xs,nr)=>{var pr=wh(Wt,_i);ht=cs(ht),ht=rl(ht),$i=hx(Xi,$i),xn([],[pt],ar=>{ar=ar[0];var ln=ar.name+"."+ht;ht.startsWith("@@")&&(ht=Symbol[ht.substring(2)]),xs&&ar.registeredClass.pureVirtualFunctions.push(ht);function an(){Ko("Cannot call "+ln+" due to unbound types",pr)}var Ln=ar.registeredClass.instancePrototype,xa=Ln[ht];return xa===void 0||xa.overloadTable===void 0&&xa.className!==ar.name&&xa.argCount===Wt-2?(an.argCount=Wt-2,an.className=ar.name,Ln[ht]=an):(kl(Ln,ht,ln),Ln[ht].overloadTable[Wt-2]=an),xn([],pr,Rs=>{var Tr=sr(ln,Rs,ar,$i,ps);return Ln[ht].overloadTable===void 0?(Tr.argCount=Wt-2,Ln[ht]=Tr):Ln[ht].overloadTable[Wt-2]=Tr,[]}),[]})},nl=(pt,ht,Wt)=>(pt instanceof Object||cn(Wt+' with invalid "this": '+pt),pt instanceof ht.registeredClass.constructor||cn(Wt+' incompatible with "this" of type '+pt.constructor.name),pt.$$.ptr||cn("cannot call emscripten binding method "+Wt+" on deleted object"),Ro(pt.$$.ptr,pt.$$.ptrType.registeredClass,ht.registeredClass)),ci=(pt,ht,Wt,_i,Xi,$i,ps,xs,nr,pr)=>{ht=cs(ht),Xi=hx(_i,Xi),xn([],[pt],ar=>{ar=ar[0];var ln=ar.name+"."+ht,an={get(){Ko("Cannot access "+ln+" due to unbound types",[Wt,ps])},enumerable:!0,configurable:!0};return nr?an.set=()=>Ko("Cannot access "+ln+" due to unbound types",[Wt,ps]):an.set=Ln=>cn(ln+" is a read-only property"),Object.defineProperty(ar.registeredClass.instancePrototype,ht,an),xn([],nr?[Wt,ps]:[Wt],Ln=>{var xa=Ln[0],Rs={get(){var jn=nl(this,ar,ln+" getter");return xa.fromWireType(Xi($i,jn))},enumerable:!0};if(nr){nr=hx(xs,nr);var Tr=Ln[1];Rs.set=function(jn){var Ws=nl(this,ar,ln+" setter"),jr=[];nr(pr,Ws,Tr.toWireType(jr,jn)),zx(jr)}}return Object.defineProperty(ar.registeredClass.instancePrototype,ht,Rs),[]}),[]})},al=[],wx=[],jo=pt=>{pt>9&&--wx[pt+1]===0&&(wx[pt]=void 0,al.push(pt))},xl=()=>wx.length/2-5-al.length,Ua=()=>{wx.push(0,1,void 0,1,null,1,!0,1,!1,1),V.count_emval_handles=xl},T0={toValue:pt=>(pt||cn("Cannot use deleted val. handle = "+pt),wx[pt]),toHandle:pt=>{switch(pt){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const ht=al.pop()||wx.length;return wx[ht]=pt,wx[ht+1]=1,ht}}}},Wl={name:"emscripten::val",fromWireType:pt=>{var ht=T0.toValue(pt);return jo(pt),ht},toWireType:(pt,ht)=>T0.toHandle(ht),argPackAdvance:h0,readValueFromPointer:Mo,destructorFunction:null},qo=pt=>l0(pt,Wl),Wx=pt=>{if(pt===null)return"null";var ht=typeof pt;return ht==="object"||ht==="array"||ht==="function"?pt.toString():""+pt},Hx=(pt,ht)=>{switch(ht){case 4:return function(Wt){return this.fromWireType(vt[Wt>>2])};case 8:return function(Wt){return this.fromWireType(nt[Wt>>3])};default:throw new TypeError("invalid float width ("+ht+"): "+pt)}},vc=(pt,ht,Wt)=>{ht=cs(ht),l0(pt,{name:ht,fromWireType:_i=>_i,toWireType:(_i,Xi)=>Xi,argPackAdvance:h0,readValueFromPointer:Hx(ht,Wt),destructorFunction:null})},Rc=(pt,ht,Wt)=>{switch(ht){case 1:return Wt?_i=>Xe[_i]:_i=>Ye[_i];case 2:return Wt?_i=>je[_i>>1]:_i=>Ke[_i>>1];case 4:return Wt?_i=>qe[_i>>2]:_i=>$e[_i>>2];default:throw new TypeError("invalid integer width ("+ht+"): "+pt)}},Lh=(pt,ht,Wt,_i,Xi)=>{ht=cs(ht);var $i=ar=>ar;if(_i===0){var ps=32-8*Wt;$i=ar=>ar<<ps>>>ps}var xs=ht.includes("unsigned"),nr=(ar,ln)=>{},pr;xs?pr=function(ar,ln){return nr(ln,this.name),ln>>>0}:pr=function(ar,ln){return nr(ln,this.name),ln},l0(pt,{name:ht,fromWireType:$i,toWireType:pr,argPackAdvance:h0,readValueFromPointer:Rc(ht,Wt,_i!==0),destructorFunction:null})},ll=(pt,ht,Wt)=>{var _i=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],Xi=_i[ht];function $i(ps){var xs=$e[ps>>2],nr=$e[ps+4>>2];return new Xi(Xe.buffer,nr,xs)}Wt=cs(Wt),l0(pt,{name:Wt,fromWireType:$i,argPackAdvance:h0,readValueFromPointer:$i},{ignoreDuplicateRegistrations:!0})},hl=(pt,ht,Wt,_i)=>{if(!(_i>0))return 0;for(var Xi=Wt,$i=Wt+_i-1,ps=0;ps<pt.length;++ps){var xs=pt.charCodeAt(ps);if(xs>=55296&&xs<=57343){var nr=pt.charCodeAt(++ps);xs=65536+((xs&1023)<<10)|nr&1023}if(xs<=127){if(Wt>=$i)break;ht[Wt++]=xs}else if(xs<=2047){if(Wt+1>=$i)break;ht[Wt++]=192|xs>>6,ht[Wt++]=128|xs&63}else if(xs<=65535){if(Wt+2>=$i)break;ht[Wt++]=224|xs>>12,ht[Wt++]=128|xs>>6&63,ht[Wt++]=128|xs&63}else{if(Wt+3>=$i)break;ht[Wt++]=240|xs>>18,ht[Wt++]=128|xs>>12&63,ht[Wt++]=128|xs>>6&63,ht[Wt++]=128|xs&63}}return ht[Wt]=0,Wt-Xi},_x=(pt,ht,Wt)=>hl(pt,Ye,ht,Wt),Mc=pt=>{for(var ht=0,Wt=0;Wt<pt.length;++Wt){var _i=pt.charCodeAt(Wt);_i<=127?ht++:_i<=2047?ht+=2:_i>=55296&&_i<=57343?(ht+=4,++Wt):ht+=3}return ht},kh=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,cl=(pt,ht,Wt)=>{for(var _i=ht+Wt,Xi=ht;pt[Xi]&&!(Xi>=_i);)++Xi;if(Xi-ht>16&&pt.buffer&&kh)return kh.decode(pt.subarray(ht,Xi));for(var $i="";ht<Xi;){var ps=pt[ht++];if(!(ps&128)){$i+=String.fromCharCode(ps);continue}var xs=pt[ht++]&63;if((ps&224)==192){$i+=String.fromCharCode((ps&31)<<6|xs);continue}var nr=pt[ht++]&63;if((ps&240)==224?ps=(ps&15)<<12|xs<<6|nr:ps=(ps&7)<<18|xs<<12|nr<<6|pt[ht++]&63,ps<65536)$i+=String.fromCharCode(ps);else{var pr=ps-65536;$i+=String.fromCharCode(55296|pr>>10,56320|pr&1023)}}return $i},L0=(pt,ht)=>pt?cl(Ye,pt,ht):"",_2=(pt,ht)=>{ht=cs(ht);var Wt=ht==="std::string";l0(pt,{name:ht,fromWireType(_i){var Xi=$e[_i>>2],$i=_i+4,ps;if(Wt)for(var xs=$i,nr=0;nr<=Xi;++nr){var pr=$i+nr;if(nr==Xi||Ye[pr]==0){var ar=pr-xs,ln=L0(xs,ar);ps===void 0?ps=ln:(ps+=String.fromCharCode(0),ps+=ln),xs=pr+1}}else{for(var an=new Array(Xi),nr=0;nr<Xi;++nr)an[nr]=String.fromCharCode(Ye[$i+nr]);ps=an.join("")}return Lo(_i),ps},toWireType(_i,Xi){Xi instanceof ArrayBuffer&&(Xi=new Uint8Array(Xi));var $i,ps=typeof Xi=="string";ps||Xi instanceof Uint8Array||Xi instanceof Uint8ClampedArray||Xi instanceof Int8Array||cn("Cannot pass non-string to std::string"),Wt&&ps?$i=Mc(Xi):$i=Xi.length;var xs=kc(4+$i+1),nr=xs+4;if($e[xs>>2]=$i,Wt&&ps)_x(Xi,nr,$i+1);else if(ps)for(var pr=0;pr<$i;++pr){var ar=Xi.charCodeAt(pr);ar>255&&(Lo(nr),cn("String has UTF-16 code units that do not fit in 8 bits")),Ye[nr+pr]=ar}else for(var pr=0;pr<$i;++pr)Ye[nr+pr]=Xi[pr];return _i!==null&&_i.push(Lo,xs),xs},argPackAdvance:h0,readValueFromPointer:Mo,destructorFunction(_i){Lo(_i)}})},T2=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Hl=(pt,ht)=>{for(var Wt=pt,_i=Wt>>1,Xi=_i+ht/2;!(_i>=Xi)&&Ke[_i];)++_i;if(Wt=_i<<1,Wt-pt>32&&T2)return T2.decode(Ye.subarray(pt,Wt));for(var $i="",ps=0;!(ps>=ht/2);++ps){var xs=je[pt+ps*2>>1];if(xs==0)break;$i+=String.fromCharCode(xs)}return $i},Ra=(pt,ht,Wt)=>{if(Wt!=null||(Wt=2147483647),Wt<2)return 0;Wt-=2;for(var _i=ht,Xi=Wt<pt.length*2?Wt/2:pt.length,$i=0;$i<Xi;++$i){var ps=pt.charCodeAt($i);je[ht>>1]=ps,ht+=2}return je[ht>>1]=0,ht-_i},Uh=pt=>pt.length*2,Xl=(pt,ht)=>{for(var Wt=0,_i="";!(Wt>=ht/4);){var Xi=qe[pt+Wt*4>>2];if(Xi==0)break;if(++Wt,Xi>=65536){var $i=Xi-65536;_i+=String.fromCharCode(55296|$i>>10,56320|$i&1023)}else _i+=String.fromCharCode(Xi)}return _i},ul=(pt,ht,Wt)=>{if(Wt!=null||(Wt=2147483647),Wt<4)return 0;for(var _i=ht,Xi=_i+Wt-4,$i=0;$i<pt.length;++$i){var ps=pt.charCodeAt($i);if(ps>=55296&&ps<=57343){var xs=pt.charCodeAt(++$i);ps=65536+((ps&1023)<<10)|xs&1023}if(qe[ht>>2]=ps,ht+=4,ht+4>Xi)break}return qe[ht>>2]=0,ht-_i},v2=pt=>{for(var ht=0,Wt=0;Wt<pt.length;++Wt){var _i=pt.charCodeAt(Wt);_i>=55296&&_i<=57343&&++Wt,ht+=4}return ht},lo=(pt,ht,Wt)=>{Wt=cs(Wt);var _i,Xi,$i,ps;ht===2?(_i=Hl,Xi=Ra,ps=Uh,$i=xs=>Ke[xs>>1]):ht===4&&(_i=Xl,Xi=ul,ps=v2,$i=xs=>$e[xs>>2]),l0(pt,{name:Wt,fromWireType:xs=>{for(var nr=$e[xs>>2],pr,ar=xs+4,ln=0;ln<=nr;++ln){var an=xs+4+ln*ht;if(ln==nr||$i(an)==0){var Ln=an-ar,xa=_i(ar,Ln);pr===void 0?pr=xa:(pr+=String.fromCharCode(0),pr+=xa),ar=an+ht}}return Lo(xs),pr},toWireType:(xs,nr)=>{typeof nr!="string"&&cn("Cannot pass non-string to C++ string type "+Wt);var pr=ps(nr),ar=kc(4+pr+ht);return $e[ar>>2]=pr/ht,Xi(nr,ar+4,pr+ht),xs!==null&&xs.push(Lo,ar),ar},argPackAdvance:h0,readValueFromPointer:Mo,destructorFunction(xs){Lo(xs)}})},Yl=(pt,ht)=>{ht=cs(ht),l0(pt,{isVoid:!0,name:ht,argPackAdvance:0,fromWireType:()=>{},toWireType:(Wt,_i)=>{}})};function Gh(pt){if(kt.xhrs.has(pt)){var ht=kt.xhrs.get(pt);kt.xhrs.free(pt),ht.readyState>0&&ht.readyState<4&&ht.abort()}}var R2=(pt,ht)=>{var Wt=ux[pt];return Wt===void 0&&cn(ht+" has unknown type "+aa(pt)),Wt},wc=(pt,ht,Wt)=>{var _i=[],Xi=pt.toWireType(_i,Wt);return _i.length&&($e[ht>>2]=T0.toHandle(_i)),Xi},M2=(pt,ht,Wt)=>(pt=T0.toValue(pt),ht=R2(ht,"emval::as"),wc(ht,Wt,pt)),zh={},Lc=pt=>{var ht=zh[pt];return ht===void 0?cs(pt):ht},j0=()=>{if(typeof globalThis=="object")return globalThis;function pt(ht){ht.$$$embind_global$$$=ht;var Wt=typeof $$$embind_global$$$=="object"&&ht.$$$embind_global$$$==ht;return Wt||delete ht.$$$embind_global$$$,Wt}if(typeof $$$embind_global$$$=="object"||(typeof __webpack_require__.g=="object"&&pt(__webpack_require__.g)?$$$embind_global$$$=__webpack_require__.g:typeof self=="object"&&pt(self)&&($$$embind_global$$$=self),typeof $$$embind_global$$$=="object"))return $$$embind_global$$$;throw Error("unable to get global object.")},ho=pt=>pt===0?T0.toHandle(j0()):(pt=Lc(pt),T0.toHandle(j0()[pt])),pl=(pt,ht)=>(pt=T0.toValue(pt),ht=T0.toValue(ht),T0.toHandle(pt[ht])),Gs=pt=>T0.toHandle(Lc(pt)),r0=pt=>{var ht=T0.toValue(pt);zx(ht),jo(pt)},k0=(pt,ht)=>{pt=R2(pt,"_emval_take_value");var Wt=pt.readValueFromPointer(ht);return T0.toHandle(Wt)},Y0=()=>{as("")},Mt=()=>!Te,lt=(pt,ht,Wt)=>Ye.copyWithin(pt,ht,ht+Wt),ni=()=>2147483648,wi=pt=>{var ht=Ue.buffer,Wt=(pt-ht.byteLength+65535)/65536;try{return Ue.grow(Wt),wt(),1}catch{}},ct=pt=>{var ht=Ye.length;pt>>>=0;var Wt=ni();if(pt>Wt)return!1;for(var _i=(nr,pr)=>nr+(pr-nr%pr)%pr,Xi=1;Xi<=4;Xi*=2){var $i=ht*(1+.2/Xi);$i=Math.min($i,pt+100663296);var ps=Math.min(Wt,_i(Math.max(pt,$i),65536)),xs=wi(ps);if(xs)return!0}return!1};class _t{constructor(){this.allocated=[void 0],this.freelist=[]}get(ht){return this.allocated[ht]}has(ht){return this.allocated[ht]!==void 0}allocate(ht){var Wt=this.freelist.pop()||this.allocated.length;return this.allocated[Wt]=ht,Wt}free(ht){this.allocated[ht]=void 0,this.freelist.push(ht)}}var kt={openDatabase(pt,ht,Wt,_i){try{var Xi=indexedDB.open(pt,ht)}catch($i){return _i($i)}Xi.onupgradeneeded=$i=>{var ps=$i.target.result;ps.objectStoreNames.contains("FILES")&&ps.deleteObjectStore("FILES"),ps.createObjectStore("FILES")},Xi.onsuccess=$i=>Wt($i.target.result),Xi.onerror=_i},init(){kt.xhrs=new _t;var pt=Wt=>{kt.dbInstance=Wt,qi()},ht=()=>{kt.dbInstance=!1,qi()};Hs(),kt.openDatabase("emscripten_filesystem",1,pt,ht)}};function Yt(pt,ht,Wt,_i,Xi){var $i=$e[pt+8>>2];if(!$i){Wt(pt,0,"no url specified!");return}var ps=L0($i),xs=pt+112,nr=L0(xs+0);nr||(nr="GET");var pr=$e[xs+56>>2],ar=$e[xs+68>>2],ln=$e[xs+72>>2],an=$e[xs+76>>2],Ln=$e[xs+80>>2],xa=$e[xs+84>>2],Rs=$e[xs+88>>2],Tr=$e[xs+52>>2],jn=!!(Tr&1),Ws=!!(Tr&2),jr=!!(Tr&64),la=ar?L0(ar):void 0,Ma=ln?L0(ln):void 0,qr=new XMLHttpRequest;if(qr.withCredentials=!!Ye[xs+60],qr.open(nr,ps,!jr,la,Ma),jr||(qr.timeout=pr),qr.url_=ps,qr.responseType="arraybuffer",Ln){var v0=L0(Ln);qr.overrideMimeType(v0)}if(an)for(;;){var w2=$e[an>>2];if(!w2)break;var ws=$e[an+4>>2];if(!ws)break;an+=8;var Ut=L0(w2),Hn=L0(ws);qr.setRequestHeader(Ut,Hn)}var Ya=kt.xhrs.allocate(qr);$e[pt>>2]=Ya;var km=xa&&Rs?Ye.slice(xa,xa+Rs):null;function au(){var Yn=0,ko=0;qr.response&&jn&&$e[pt+12>>2]===0&&(ko=qr.response.byteLength),ko>0&&(Yn=kc(ko),Ye.set(new Uint8Array(qr.response),Yn)),$e[pt+12>>2]=Yn,nn(pt+16,ko),nn(pt+24,0);var $o=qr.response?qr.response.byteLength:0;$o&&nn(pt+32,$o),je[pt+40>>1]=qr.readyState,je[pt+42>>1]=qr.status,qr.statusText&&_x(qr.statusText,pt+44,64)}qr.onload=Yn=>{kt.xhrs.has(Ya)&&(au(),qr.status>=200&&qr.status<300?ht?.(pt,qr,Yn):Wt?.(pt,qr,Yn))},qr.onerror=Yn=>{kt.xhrs.has(Ya)&&(au(),Wt?.(pt,qr,Yn))},qr.ontimeout=Yn=>{kt.xhrs.has(Ya)&&Wt?.(pt,qr,Yn)},qr.onprogress=Yn=>{if(kt.xhrs.has(Ya)){var ko=jn&&Ws&&qr.response?qr.response.byteLength:0,$o=0;ko>0&&jn&&Ws&&($o=kc(ko),Ye.set(new Uint8Array(qr.response),$o)),$e[pt+12>>2]=$o,nn(pt+16,ko),nn(pt+24,Yn.loaded-ko),nn(pt+32,Yn.total),je[pt+40>>1]=qr.readyState,qr.readyState>=3&&qr.status===0&&Yn.loaded>0&&(qr.status=200),je[pt+42>>1]=qr.status,qr.statusText&&_x(qr.statusText,pt+44,64),_i?.(pt,qr,Yn),$o&&Lo($o)}},qr.onreadystatechange=Yn=>{kt.xhrs.has(Ya)&&(je[pt+40>>1]=qr.readyState,qr.readyState>=2&&(je[pt+42>>1]=qr.status),Xi?.(pt,qr,Yn))};try{qr.send(km)}catch(Yn){Wt?.(pt,qr,Yn)}}var ri=pt=>{if(pt instanceof hr||pt=="unwind")return We;ce(1,pt)},$t=0,Mi=()=>Rr||$t>0,ki=pt=>{var ht;We=pt,Mi()||((ht=V.onExit)==null||ht.call(V,pt),Ge=!0),ce(pt,new hr(pt))},_s=(pt,ht)=>{We=pt,ki(pt)},ns=_s,Ts=()=>{if(!Mi())try{ns(We)}catch(pt){ri(pt)}},$r=pt=>{if(!Ge)try{pt(),Ts()}catch(ht){ri(ht)}},nn=(pt,ht)=>{$e[pt>>2]=ht;var Wt=$e[pt>>2];$e[pt+4>>2]=(ht-Wt)/4294967296};function vn(pt,ht,Wt,_i,Xi){if(!pt){Xi(ht,0,"IndexedDB not available!");return}var $i=ht+112,ps=$e[$i+64>>2];ps||(ps=$e[ht+8>>2]);var xs=L0(ps);try{var nr=pt.transaction(["FILES"],"readwrite"),pr=nr.objectStore("FILES"),ar=pr.put(Wt,xs);ar.onsuccess=ln=>{je[ht+40>>1]=4,je[ht+42>>1]=200,_x("OK",ht+44,64),_i(ht,0,xs)},ar.onerror=ln=>{je[ht+40>>1]=4,je[ht+42>>1]=413,_x("Payload Too Large",ht+44,64),Xi(ht,0,ln)}}catch(ln){Xi(ht,0,ln)}}function Rn(pt,ht,Wt,_i){if(!pt){_i(ht,0,"IndexedDB not available!");return}var Xi=ht+112,$i=$e[Xi+64>>2];$i||($i=$e[ht+8>>2]);var ps=L0($i);try{var xs=pt.transaction(["FILES"],"readonly"),nr=xs.objectStore("FILES"),pr=nr.get(ps);pr.onsuccess=ar=>{if(ar.target.result){var ln=ar.target.result,an=ln.byteLength||ln.length,Ln=kc(an);Ye.set(new Uint8Array(ln),Ln),$e[ht+12>>2]=Ln,nn(ht+16,an),nn(ht+24,0),nn(ht+32,an),je[ht+40>>1]=4,je[ht+42>>1]=200,_x("OK",ht+44,64),Wt(ht,0,ln)}else je[ht+40>>1]=4,je[ht+42>>1]=404,_x("Not Found",ht+44,64),_i(ht,0,"no data")},pr.onerror=ar=>{je[ht+40>>1]=4,je[ht+42>>1]=404,_x("Not Found",ht+44,64),_i(ht,0,ar)}}catch(ar){_i(ht,0,ar)}}function xr(pt,ht,Wt,_i){if(!pt){_i(ht,0,"IndexedDB not available!");return}var Xi=ht+112,$i=$e[Xi+64>>2];$i||($i=$e[ht+8>>2]);var ps=L0($i);try{var xs=pt.transaction(["FILES"],"readwrite"),nr=xs.objectStore("FILES"),pr=nr.delete(ps);pr.onsuccess=ar=>{var ln=ar.target.result;$e[ht+12>>2]=0,nn(ht+16,0),nn(ht+24,0),nn(ht+32,0),je[ht+40>>1]=4,je[ht+42>>1]=200,_x("OK",ht+44,64),Wt(ht,0,ln)},pr.onerror=ar=>{je[ht+40>>1]=4,je[ht+42>>1]=404,_x("Not Found",ht+44,64),_i(ht,0,ar)}}catch(ar){_i(ht,0,ar)}}function at(pt,ht,Wt,_i,Xi){var $i=pt+112,ps=$e[$i+36>>2],xs=$e[$i+40>>2],nr=$e[$i+44>>2],pr=$e[$i+48>>2],ar=$e[$i+52>>2],ln=!!(ar&64);function an(Ut){ln?Ut():$r(Ut)}var Ln=(Ut,Hn,Ya)=>{an(()=>{ps?$a(ps)(Ut):ht?.(Ut)})},xa=(Ut,Hn,Ya)=>{an(()=>{nr?$a(nr)(Ut):_i?.(Ut)})},Rs=(Ut,Hn,Ya)=>{an(()=>{xs?$a(xs)(Ut):Wt?.(Ut)})},Tr=(Ut,Hn,Ya)=>{an(()=>{pr?$a(pr)(Ut):Xi?.(Ut)})},jn=(Ut,Hn,Ya)=>{Yt(Ut,Ln,Rs,xa,Tr)},Ws=(Ut,Hn,Ya)=>{var km=(Yn,ko,$o)=>{an(()=>{ps?$a(ps)(Yn):ht?.(Yn)})},au=(Yn,ko,$o)=>{an(()=>{ps?$a(ps)(Yn):ht?.(Yn)})};vn(kt.dbInstance,Ut,Hn.response,km,au)},jr=(Ut,Hn,Ya)=>{Yt(Ut,Ws,Rs,xa,Tr)},la=L0($i+0),Ma=!!(ar&16),qr=!!(ar&4),v0=!!(ar&32);if(la==="EM_IDB_STORE"){var w2=$e[$i+84>>2],ws=$e[$i+88>>2];vn(kt.dbInstance,pt,Ye.slice(w2,w2+ws),Ln,Rs)}else if(la==="EM_IDB_DELETE")xr(kt.dbInstance,pt,Ln,Rs);else if(!Ma)Rn(kt.dbInstance,pt,Ln,v0?Rs:qr?jr:jn);else if(!v0)Yt(pt,qr?Ws:Ln,Rs,xa,Tr);else return 0;return pt}var Lr={},us=()=>le||"./this.program",jt=()=>{if(!jt.strings){var pt=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",ht={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:pt,_:us()};for(var Wt in Lr)Lr[Wt]===void 0?delete ht[Wt]:ht[Wt]=Lr[Wt];var _i=[];for(var Wt in ht)_i.push(Wt+"="+ht[Wt]);jt.strings=_i}return jt.strings},Ls=(pt,ht)=>{for(var Wt=0;Wt<pt.length;++Wt)Xe[ht++]=pt.charCodeAt(Wt);Xe[ht]=0},ui=(pt,ht)=>{var Wt=0;return jt().forEach((_i,Xi)=>{var $i=ht+Wt;$e[pt+Xi*4>>2]=$i,Ls(_i,$i),Wt+=_i.length+1}),0},co=(pt,ht)=>{var Wt=jt();$e[pt>>2]=Wt.length;var _i=0;return Wt.forEach(Xi=>_i+=Xi.length+1),$e[ht>>2]=_i,0},wo=pt=>pt%4===0&&(pt%100!==0||pt%400===0),Kl=(pt,ht)=>{for(var Wt=0,_i=0;_i<=ht;Wt+=pt[_i++]);return Wt},nu=[31,29,31,30,31,30,31,31,30,31,30,31],Gp=[31,28,31,30,31,30,31,31,30,31,30,31],vy=(pt,ht)=>{for(var Wt=new Date(pt.getTime());ht>0;){var _i=wo(Wt.getFullYear()),Xi=Wt.getMonth(),$i=(_i?nu:Gp)[Xi];if(ht>$i-Wt.getDate())ht-=$i-Wt.getDate()+1,Wt.setDate(1),Xi<11?Wt.setMonth(Xi+1):(Wt.setMonth(0),Wt.setFullYear(Wt.getFullYear()+1));else return Wt.setDate(Wt.getDate()+ht),Wt}return Wt};function Rt(pt,ht,Wt){var _i=Wt>0?Wt:Mc(pt)+1,Xi=new Array(_i),$i=hl(pt,Xi,0,Xi.length);return ht&&(Xi.length=$i),Xi}var Ry=(pt,ht)=>{Xe.set(pt,ht)},My=(pt,ht,Wt,_i)=>{var Xi=$e[_i+40>>2],$i={tm_sec:qe[_i>>2],tm_min:qe[_i+4>>2],tm_hour:qe[_i+8>>2],tm_mday:qe[_i+12>>2],tm_mon:qe[_i+16>>2],tm_year:qe[_i+20>>2],tm_wday:qe[_i+24>>2],tm_yday:qe[_i+28>>2],tm_isdst:qe[_i+32>>2],tm_gmtoff:qe[_i+36>>2],tm_zone:Xi?L0(Xi):""},ps=L0(Wt),xs={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var nr in xs)ps=ps.replace(new RegExp(nr,"g"),xs[nr]);var pr=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],ar=["January","February","March","April","May","June","July","August","September","October","November","December"];function ln(Ws,jr,la){for(var Ma=typeof Ws=="number"?Ws.toString():Ws||"";Ma.length<jr;)Ma=la[0]+Ma;return Ma}function an(Ws,jr){return ln(Ws,jr,"0")}function Ln(Ws,jr){function la(qr){return qr<0?-1:qr>0?1:0}var Ma;return(Ma=la(Ws.getFullYear()-jr.getFullYear()))===0&&(Ma=la(Ws.getMonth()-jr.getMonth()))===0&&(Ma=la(Ws.getDate()-jr.getDate())),Ma}function xa(Ws){switch(Ws.getDay()){case 0:return new Date(Ws.getFullYear()-1,11,29);case 1:return Ws;case 2:return new Date(Ws.getFullYear(),0,3);case 3:return new Date(Ws.getFullYear(),0,2);case 4:return new Date(Ws.getFullYear(),0,1);case 5:return new Date(Ws.getFullYear()-1,11,31);case 6:return new Date(Ws.getFullYear()-1,11,30)}}function Rs(Ws){var jr=vy(new Date(Ws.tm_year+1900,0,1),Ws.tm_yday),la=new Date(jr.getFullYear(),0,4),Ma=new Date(jr.getFullYear()+1,0,4),qr=xa(la),v0=xa(Ma);return Ln(qr,jr)<=0?Ln(v0,jr)<=0?jr.getFullYear()+1:jr.getFullYear():jr.getFullYear()-1}var Tr={"%a":Ws=>pr[Ws.tm_wday].substring(0,3),"%A":Ws=>pr[Ws.tm_wday],"%b":Ws=>ar[Ws.tm_mon].substring(0,3),"%B":Ws=>ar[Ws.tm_mon],"%C":Ws=>{var jr=Ws.tm_year+1900;return an(jr/100|0,2)},"%d":Ws=>an(Ws.tm_mday,2),"%e":Ws=>ln(Ws.tm_mday,2," "),"%g":Ws=>Rs(Ws).toString().substring(2),"%G":Rs,"%H":Ws=>an(Ws.tm_hour,2),"%I":Ws=>{var jr=Ws.tm_hour;return jr==0?jr=12:jr>12&&(jr-=12),an(jr,2)},"%j":Ws=>an(Ws.tm_mday+Kl(wo(Ws.tm_year+1900)?nu:Gp,Ws.tm_mon-1),3),"%m":Ws=>an(Ws.tm_mon+1,2),"%M":Ws=>an(Ws.tm_min,2),"%n":()=>`
`,"%p":Ws=>Ws.tm_hour>=0&&Ws.tm_hour<12?"AM":"PM","%S":Ws=>an(Ws.tm_sec,2),"%t":()=>"	","%u":Ws=>Ws.tm_wday||7,"%U":Ws=>{var jr=Ws.tm_yday+7-Ws.tm_wday;return an(Math.floor(jr/7),2)},"%V":Ws=>{var jr=Math.floor((Ws.tm_yday+7-(Ws.tm_wday+6)%7)/7);if((Ws.tm_wday+371-Ws.tm_yday-2)%7<=2&&jr++,jr){if(jr==53){var la=(Ws.tm_wday+371-Ws.tm_yday)%7;la!=4&&(la!=3||!wo(Ws.tm_year))&&(jr=1)}}else{jr=52;var Ma=(Ws.tm_wday+7-Ws.tm_yday-1)%7;(Ma==4||Ma==5&&wo(Ws.tm_year%400-1))&&jr++}return an(jr,2)},"%w":Ws=>Ws.tm_wday,"%W":Ws=>{var jr=Ws.tm_yday+7-(Ws.tm_wday+6)%7;return an(Math.floor(jr/7),2)},"%y":Ws=>(Ws.tm_year+1900).toString().substring(2),"%Y":Ws=>Ws.tm_year+1900,"%z":Ws=>{var jr=Ws.tm_gmtoff,la=jr>=0;return jr=Math.abs(jr)/60,jr=jr/60*100+jr%60,(la?"+":"-")+("0000"+jr).slice(-4)},"%Z":Ws=>Ws.tm_zone,"%%":()=>"%"};ps=ps.replace(/%%/g,"\0\0");for(var nr in Tr)ps.includes(nr)&&(ps=ps.replace(new RegExp(nr,"g"),Tr[nr]($i)));ps=ps.replace(/\0\0/g,"%");var jn=Rt(ps,!1);return jn.length>ht?0:(Ry(jn,pt),jn.length-1)},wy=(pt,ht,Wt,_i,Xi)=>My(pt,ht,Wt,_i);qn(),ka=V.BindingError=class extends Error{constructor(pt){super(pt),this.name="BindingError"}},Kr=V.InternalError=class extends Error{constructor(pt){super(pt),this.name="InternalError"}},Ll(),ur(),xx(),zl=V.UnboundTypeError=Gx(Error,"UnboundTypeError"),Ua(),kt.init();var Ly={a:Mn,s:Un,z:wl,l:xo,f:Tc,c:_0,o:ci,y:qo,r:vc,e:Lh,b:ll,q:_2,m:lo,A:Yl,B:Gh,g:M2,d:jo,n:ho,h:pl,k:Gs,j:r0,i:k0,p:Y0,D:Mt,x:lt,w:ct,C:at,u:ui,v:co,t:wy},Xx=$s(),kc=pt=>(kc=Xx.G)(pt),Lo=pt=>(Lo=Xx.I)(pt),Lm=pt=>(Lm=Xx.J)(pt),Ug=pt=>(Ug=Xx.K)(pt);V.dynCall_viijii=(pt,ht,Wt,_i,Xi,$i,ps)=>(V.dynCall_viijii=Xx.L)(pt,ht,Wt,_i,Xi,$i,ps),V.dynCall_iiiiij=(pt,ht,Wt,_i,Xi,$i,ps)=>(V.dynCall_iiiiij=Xx.M)(pt,ht,Wt,_i,Xi,$i,ps),V.dynCall_iiiiijj=(pt,ht,Wt,_i,Xi,$i,ps,xs,nr)=>(V.dynCall_iiiiijj=Xx.N)(pt,ht,Wt,_i,Xi,$i,ps,xs,nr),V.dynCall_iiiiiijj=(pt,ht,Wt,_i,Xi,$i,ps,xs,nr,pr)=>(V.dynCall_iiiiiijj=Xx.O)(pt,ht,Wt,_i,Xi,$i,ps,xs,nr,pr);var zp;Us=function pt(){zp||Gg(),zp||(Us=pt)};function Gg(){if(rs>0||(hi(),rs>0))return;function pt(){zp||(zp=!0,V.calledRun=!0,!Ge&&(ai(),$(V),V.onRuntimeInitialized&&V.onRuntimeInitialized(),Yi()))}V.setStatus?(V.setStatus("Running..."),setTimeout(function(){setTimeout(function(){V.setStatus("")},1),pt()},1)):pt()}if(V.preInit)for(typeof V.preInit=="function"&&(V.preInit=[V.preInit]);V.preInit.length>0;)V.preInit.pop()();return Gg(),A.ready}})();async function VM(W,A="./",V=!1){const $=await VY({locateFile:ne=>A+ne});return $.Loader.prototype.promisify=function(ne,...xe){return ne.call(this,...xe),new Promise(le=>{const ce=setInterval(()=>{if(this.ready)return clearInterval(ce),le(this.status)},5)})},$.Loader.prototype.load=function(ne){return this.promisify(this.loadAsync,ne,V)},$.Loader.prototype.remove=function(ne){return this.promisify(this.removeAsync,ne)},$.DictLoader.prototype.loadDict=function(ne){return this.promisify(this.loadDictAsync,W,ne)},$}var Vh=(()=>{var W=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(A={}){var V=A,$,ne;V.ready=new Promise((Mt,lt)=>{$=Mt,ne=lt});var xe=Object.assign({},V),le=!0,ce="";function ue(Mt){return V.locateFile?V.locateFile(Mt,ce):ce+Mt}typeof document<"u"&&document.currentScript&&(ce=document.currentScript.src),W&&(ce=W),ce.startsWith("blob:")?ce="":ce=ce.substr(0,ce.replace(/[?#].*/,"").lastIndexOf("/")+1),V.print||console.log.bind(console);var Te=V.printErr||console.error.bind(console);Object.assign(V,xe),xe=null,V.arguments&&V.arguments,V.thisProgram&&V.thisProgram,V.quit&&V.quit;var Me;V.wasmBinary&&(Me=V.wasmBinary);var Re,we=!1,ke,Ue,Ge,We,Xe,Ye,je,Ke;function qe(){var Mt=Re.buffer;V.HEAP8=ke=new Int8Array(Mt),V.HEAP16=Ge=new Int16Array(Mt),V.HEAPU8=Ue=new Uint8Array(Mt),V.HEAPU16=We=new Uint16Array(Mt),V.HEAP32=Xe=new Int32Array(Mt),V.HEAPU32=Ye=new Uint32Array(Mt),V.HEAPF32=je=new Float32Array(Mt),V.HEAPF64=Ke=new Float64Array(Mt)}var $e=[],vt=[],nt=[];function wt(){if(V.preRun)for(typeof V.preRun=="function"&&(V.preRun=[V.preRun]);V.preRun.length;)pi(V.preRun.shift());Xs($e)}function Kt(){Xs(vt)}function Ht(){if(V.postRun)for(typeof V.postRun=="function"&&(V.postRun=[V.postRun]);V.postRun.length;)ai(V.postRun.shift());Xs(nt)}function pi(Mt){$e.unshift(Mt)}function hi(Mt){vt.unshift(Mt)}function ai(Mt){nt.unshift(Mt)}var Yi=0,Wi=null;function ls(Mt){var lt;Yi++,(lt=V.monitorRunDependencies)==null||lt.call(V,Yi)}function Hi(Mt){var lt;if(Yi--,(lt=V.monitorRunDependencies)==null||lt.call(V,Yi),Yi==0&&Wi){var ni=Wi;Wi=null,ni()}}function rs(Mt){var lt;(lt=V.onAbort)==null||lt.call(V,Mt),Mt="Aborted("+Mt+")",Te(Mt),we=!0,Mt+=". Build with -sASSERTIONS for more info.";var ni=new WebAssembly.RuntimeError(Mt);throw ne(ni),ni}var Us="data:application/octet-stream;base64,",Hs=Mt=>Mt.startsWith(Us),qi;qi="poseutils.wasm",Hs(qi)||(qi=ue(qi));function as(Mt){if(Mt==qi&&Me)return new Uint8Array(Me);throw"both async and sync fetching of the wasm failed"}function li(Mt){return!Me&&le&&typeof fetch=="function"?fetch(Mt,{credentials:"same-origin"}).then(lt=>{if(!lt.ok)throw"failed to load wasm binary file at '"+Mt+"'";return lt.arrayBuffer()}).catch(()=>as(Mt)):Promise.resolve().then(()=>as(Mt))}function vi(Mt,lt,ni){return li(Mt).then(wi=>WebAssembly.instantiate(wi,lt)).then(ni,wi=>{Te("failed to asynchronously prepare wasm: "+wi),rs(wi)})}function Ui(Mt,lt,ni,wi){return!Mt&&typeof WebAssembly.instantiateStreaming=="function"&&!Hs(lt)&&typeof fetch=="function"?fetch(lt,{credentials:"same-origin"}).then(ct=>{var _t=WebAssembly.instantiateStreaming(ct,ni);return _t.then(wi,function(kt){return Te("wasm streaming compile failed: "+kt),Te("falling back to ArrayBuffer instantiation"),vi(lt,ni,wi)})}):vi(lt,ni,wi)}function hs(){var Mt={a:Lc};function lt(wi,ct){return j0=wi.exports,Re=j0.v,qe(),_a=j0.z,hi(j0.w),Hi(),j0}ls();function ni(wi){lt(wi.instance)}if(V.instantiateWasm)try{return V.instantiateWasm(Mt,lt)}catch(wi){Te("Module.instantiateWasm callback failed with error: "+wi),ne(wi)}return Ui(Me,qi,Mt,ni).catch(ne),{}}var Xs=Mt=>{for(;Mt.length>0;)Mt.shift()(V)};V.noExitRuntime;class cr{constructor(lt){this.excPtr=lt,this.ptr=lt-24}set_type(lt){Ye[this.ptr+4>>2]=lt}get_type(){return Ye[this.ptr+4>>2]}set_destructor(lt){Ye[this.ptr+8>>2]=lt}get_destructor(){return Ye[this.ptr+8>>2]}set_caught(lt){lt=lt?1:0,ke[this.ptr+12]=lt}get_caught(){return ke[this.ptr+12]!=0}set_rethrown(lt){lt=lt?1:0,ke[this.ptr+13]=lt}get_rethrown(){return ke[this.ptr+13]!=0}init(lt,ni){this.set_adjusted_ptr(0),this.set_type(lt),this.set_destructor(ni)}set_adjusted_ptr(lt){Ye[this.ptr+16>>2]=lt}get_adjusted_ptr(){return Ye[this.ptr+16>>2]}get_exception_ptr(){var lt=r0(this.get_type());if(lt)return Ye[this.excPtr>>2];var ni=this.get_adjusted_ptr();return ni!==0?ni:this.excPtr}}var Ks=0,$s=(Mt,lt,ni)=>{var wi=new cr(Mt);throw wi.init(lt,ni),Ks=Mt,Ks},hr={},rn=Mt=>{for(;Mt.length;){var lt=Mt.pop(),ni=Mt.pop();ni(lt)}};function Rr(Mt){return this.fromWireType(Ye[Mt>>2])}var Yr={},Tn={},Mn={},Un,qn=Mt=>{throw new Un(Mt)},$n=(Mt,lt,ni)=>{Mt.forEach(function(Yt){Mn[Yt]=lt});function wi(Yt){var ri=ni(Yt);ri.length!==Mt.length&&qn("Mismatched type converter count");for(var $t=0;$t<Mt.length;++$t)xn(Mt[$t],ri[$t])}var ct=new Array(lt.length),_t=[],kt=0;lt.forEach((Yt,ri)=>{Tn.hasOwnProperty(Yt)?ct[ri]=Tn[Yt]:(_t.push(Yt),Yr.hasOwnProperty(Yt)||(Yr[Yt]=[]),Yr[Yt].push(()=>{ct[ri]=Tn[Yt],++kt,kt===_t.length&&wi(ct)}))}),_t.length===0&&wi(ct)},cs=Mt=>{var lt=hr[Mt];delete hr[Mt];var ni=lt.rawConstructor,wi=lt.rawDestructor,ct=lt.fields,_t=ct.map(kt=>kt.getterReturnType).concat(ct.map(kt=>kt.setterArgumentType));$n([Mt],_t,kt=>{var Yt={};return ct.forEach((ri,$t)=>{var Mi=ri.fieldName,ki=kt[$t],_s=ri.getter,ns=ri.getterContext,Ts=kt[$t+ct.length],$r=ri.setter,nn=ri.setterContext;Yt[Mi]={read:vn=>ki.fromWireType(_s(ns,vn)),write:(vn,Rn)=>{var xr=[];$r(nn,vn,Ts.toWireType(xr,Rn)),rn(xr)}}}),[{name:lt.name,fromWireType:ri=>{var $t={};for(var Mi in Yt)$t[Mi]=Yt[Mi].read(ri);return wi(ri),$t},toWireType:(ri,$t)=>{for(var Mi in Yt)if(!(Mi in $t))throw new TypeError('Missing field: "'+Mi+'"');var ki=ni();for(Mi in Yt)Yt[Mi].write(ki,$t[Mi]);return ri!==null&&ri.push(wi,ki),ki},argPackAdvance:Kx,readValueFromPointer:Rr,destructorFunction:wi}]})},a0=(Mt,lt,ni,wi,ct)=>{},ux=()=>{for(var Mt=new Array(256),lt=0;lt<256;++lt)Mt[lt]=String.fromCharCode(lt);Yx=Mt},Yx,ka=Mt=>{for(var lt="",ni=Mt;Ue[ni];)lt+=Yx[Ue[ni++]];return lt},cn,Kr=Mt=>{throw new cn(Mt)};function px(Mt,lt,ni={}){var wi=lt.name;if(Mt||Kr('type "'+wi+'" must have a positive integer typeid pointer'),Tn.hasOwnProperty(Mt)){if(ni.ignoreDuplicateRegistrations)return;Kr("Cannot register type '"+wi+"' twice")}if(Tn[Mt]=lt,delete Mn[Mt],Yr.hasOwnProperty(Mt)){var ct=Yr[Mt];delete Yr[Mt],ct.forEach(_t=>_t())}}function xn(Mt,lt,ni={}){if(!("argPackAdvance"in lt))throw new TypeError("registerType registeredInstance requires argPackAdvance");return px(Mt,lt,ni)}var Kx=8,l0=(Mt,lt,ni,wi)=>{lt=ka(lt),xn(Mt,{name:lt,fromWireType:function(ct){return!!ct},toWireType:function(ct,_t){return _t?ni:wi},argPackAdvance:Kx,readValueFromPointer:function(ct){return this.fromWireType(Ue[ct])},destructorFunction:null})},h0=Mt=>({count:Mt.count,deleteScheduled:Mt.deleteScheduled,preservePointerOnDelete:Mt.preservePointerOnDelete,ptr:Mt.ptr,ptrType:Mt.ptrType,smartPtr:Mt.smartPtr,smartPtrType:Mt.smartPtrType}),wl=Mt=>{function lt(ni){return ni.$$.ptrType.registeredClass.name}Kr(lt(Mt)+" instance already deleted")},vh=!1,Xo=Mt=>{},h2=Mt=>{Mt.smartPtr?Mt.smartPtrType.rawDestructor(Mt.smartPtr):Mt.ptrType.registeredClass.rawDestructor(Mt.ptr)},Ri=Mt=>{Mt.count.value-=1;var lt=Mt.count.value===0;lt&&h2(Mt)},Rh=(Mt,lt,ni)=>{if(lt===ni)return Mt;if(ni.baseClass===void 0)return null;var wi=Rh(Mt,lt,ni.baseClass);return wi===null?null:ni.downcast(wi)},kn={},c0=()=>Object.keys(Yo).length,va=()=>{var Mt=[];for(var lt in Yo)Yo.hasOwnProperty(lt)&&Mt.push(Yo[lt]);return Mt},Ux=[],no=()=>{for(;Ux.length;){var Mt=Ux.pop();Mt.$$.deleteScheduled=!1,Mt.delete()}},H0,j2=Mt=>{H0=Mt,Ux.length&&H0&&H0(no)},Mr=()=>{V.getInheritedInstanceCount=c0,V.getLiveInheritedInstances=va,V.flushPendingDeletes=no,V.setDelayFunction=j2},Yo={},ur=(Mt,lt)=>{for(lt===void 0&&Kr("ptr should not be undefined");Mt.baseClass;)lt=Mt.upcast(lt),Mt=Mt.baseClass;return lt},Ti=(Mt,lt)=>(lt=ur(Mt,lt),Yo[lt]),q2=(Mt,lt)=>{(!lt.ptrType||!lt.ptr)&&qn("makeClassHandle requires ptr and ptrType");var ni=!!lt.smartPtrType,wi=!!lt.smartPtr;return ni!==wi&&qn("Both smartPtrType and smartPtr must be specified"),lt.count={value:1},X0(Object.create(Mt,{$$:{value:lt,writable:!0}}))};function xc(Mt){var lt=this.getPointee(Mt);if(!lt)return this.destructor(Mt),null;var ni=Ti(this.registeredClass,lt);if(ni!==void 0){if(ni.$$.count.value===0)return ni.$$.ptr=lt,ni.$$.smartPtr=Mt,ni.clone();var wi=ni.clone();return this.destructor(Mt),wi}function ct(){return this.isSmartPointer?q2(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:lt,smartPtrType:this,smartPtr:Mt}):q2(this.registeredClass.instancePrototype,{ptrType:this,ptr:Mt})}var _t=this.registeredClass.getActualType(lt),kt=kn[_t];if(!kt)return ct.call(this);var Yt;this.isConst?Yt=kt.constPointerType:Yt=kt.pointerType;var ri=Rh(lt,this.registeredClass,Yt.registeredClass);return ri===null?ct.call(this):this.isSmartPointer?q2(Yt.registeredClass.instancePrototype,{ptrType:Yt,ptr:ri,smartPtrType:this,smartPtr:Mt}):q2(Yt.registeredClass.instancePrototype,{ptrType:Yt,ptr:ri})}var X0=Mt=>typeof FinalizationRegistry>"u"?(X0=lt=>lt,Mt):(vh=new FinalizationRegistry(lt=>{Ri(lt.$$)}),X0=lt=>{var ni=lt.$$,wi=!!ni.smartPtr;if(wi){var ct={$$:ni};vh.register(lt,ct,lt)}return lt},Xo=lt=>vh.unregister(lt),X0(Mt)),lc=()=>{Object.assign(K0.prototype,{isAliasOf(Mt){if(!(this instanceof K0)||!(Mt instanceof K0))return!1;var lt=this.$$.ptrType.registeredClass,ni=this.$$.ptr;Mt.$$=Mt.$$;for(var wi=Mt.$$.ptrType.registeredClass,ct=Mt.$$.ptr;lt.baseClass;)ni=lt.upcast(ni),lt=lt.baseClass;for(;wi.baseClass;)ct=wi.upcast(ct),wi=wi.baseClass;return lt===wi&&ni===ct},clone(){if(this.$$.ptr||wl(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var Mt=X0(Object.create(Object.getPrototypeOf(this),{$$:{value:h0(this.$$)}}));return Mt.$$.count.value+=1,Mt.$$.deleteScheduled=!1,Mt},delete(){this.$$.ptr||wl(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Kr("Object already scheduled for deletion"),Xo(this),Ri(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||wl(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Kr("Object already scheduled for deletion"),Ux.push(this),Ux.length===1&&H0&&H0(no),this.$$.deleteScheduled=!0,this}})};function K0(){}var Ll=(Mt,lt)=>Object.defineProperty(lt,"name",{value:Mt}),Gn=(Mt,lt,ni)=>{if(Mt[lt].overloadTable===void 0){var wi=Mt[lt];Mt[lt]=function(...ct){return Mt[lt].overloadTable.hasOwnProperty(ct.length)||Kr("Function '"+ni+"' called with an invalid number of arguments ("+ct.length+") - expects one of ("+Mt[lt].overloadTable+")!"),Mt[lt].overloadTable[ct.length].apply(this,ct)},Mt[lt].overloadTable=[],Mt[lt].overloadTable[wi.argCount]=wi}},ao=(Mt,lt,ni)=>{V.hasOwnProperty(Mt)?((ni===void 0||V[Mt].overloadTable!==void 0&&V[Mt].overloadTable[ni]!==void 0)&&Kr("Cannot register public name '"+Mt+"' twice"),Gn(V,Mt,Mt),V.hasOwnProperty(ni)&&Kr("Cannot register multiple overloads of a function with the same number of arguments ("+ni+")!"),V[Mt].overloadTable[ni]=lt):(V[Mt]=lt,ni!==void 0&&(V[Mt].numArguments=ni))},kl=48,hc=57,cc=Mt=>{if(Mt===void 0)return"_unknown";Mt=Mt.replace(/[^a-zA-Z0-9_]/g,"$");var lt=Mt.charCodeAt(0);return lt>=kl&&lt<=hc?"_"+Mt:Mt};function Wa(Mt,lt,ni,wi,ct,_t,kt,Yt){this.name=Mt,this.constructor=lt,this.instancePrototype=ni,this.rawDestructor=wi,this.baseClass=ct,this.getActualType=_t,this.upcast=kt,this.downcast=Yt,this.pureVirtualFunctions=[]}var $2=(Mt,lt,ni)=>{for(;lt!==ni;)lt.upcast||Kr("Expected null or instance of "+ni.name+", got an instance of "+lt.name),Mt=lt.upcast(Mt),lt=lt.baseClass;return Mt};function Ul(Mt,lt){if(lt===null)return this.isReference&&Kr("null is not a valid "+this.name),0;lt.$$||Kr('Cannot pass "'+Ua(lt)+'" as a '+this.name),lt.$$.ptr||Kr("Cannot pass deleted object as a pointer of type "+this.name);var ni=lt.$$.ptrType.registeredClass,wi=$2(lt.$$.ptr,ni,this.registeredClass);return wi}function Ro(Mt,lt){var ni;if(lt===null)return this.isReference&&Kr("null is not a valid "+this.name),this.isSmartPointer?(ni=this.rawConstructor(),Mt!==null&&Mt.push(this.rawDestructor,ni),ni):0;(!lt||!lt.$$)&&Kr('Cannot pass "'+Ua(lt)+'" as a '+this.name),lt.$$.ptr||Kr("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&lt.$$.ptrType.isConst&&Kr("Cannot convert argument of type "+(lt.$$.smartPtrType?lt.$$.smartPtrType.name:lt.$$.ptrType.name)+" to parameter type "+this.name);var wi=lt.$$.ptrType.registeredClass;if(ni=$2(lt.$$.ptr,wi,this.registeredClass),this.isSmartPointer)switch(lt.$$.smartPtr===void 0&&Kr("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:lt.$$.smartPtrType===this?ni=lt.$$.smartPtr:Kr("Cannot convert argument of type "+(lt.$$.smartPtrType?lt.$$.smartPtrType.name:lt.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:ni=lt.$$.smartPtr;break;case 2:if(lt.$$.smartPtrType===this)ni=lt.$$.smartPtr;else{var ct=lt.clone();ni=this.rawShare(ni,wx.toHandle(()=>ct.delete())),Mt!==null&&Mt.push(this.rawDestructor,ni)}break;default:Kr("Unsupporting sharing policy")}return ni}function uc(Mt,lt){if(lt===null)return this.isReference&&Kr("null is not a valid "+this.name),0;lt.$$||Kr('Cannot pass "'+Ua(lt)+'" as a '+this.name),lt.$$.ptr||Kr("Cannot pass deleted object as a pointer of type "+this.name),lt.$$.ptrType.isConst&&Kr("Cannot convert argument of type "+lt.$$.ptrType.name+" to parameter type "+this.name);var ni=lt.$$.ptrType.registeredClass,wi=$2(lt.$$.ptr,ni,this.registeredClass);return wi}var Mh=()=>{Object.assign(c2.prototype,{getPointee(Mt){return this.rawGetPointee&&(Mt=this.rawGetPointee(Mt)),Mt},destructor(Mt){var lt;(lt=this.rawDestructor)==null||lt.call(this,Mt)},argPackAdvance:Kx,readValueFromPointer:Rr,fromWireType:xc})};function c2(Mt,lt,ni,wi,ct,_t,kt,Yt,ri,$t,Mi){this.name=Mt,this.registeredClass=lt,this.isReference=ni,this.isConst=wi,this.isSmartPointer=ct,this.pointeeType=_t,this.sharingPolicy=kt,this.rawGetPointee=Yt,this.rawConstructor=ri,this.rawShare=$t,this.rawDestructor=Mi,!ct&&lt.baseClass===void 0?wi?(this.toWireType=Ul,this.destructorFunction=null):(this.toWireType=uc,this.destructorFunction=null):this.toWireType=Ro}var Mo=(Mt,lt,ni)=>{V.hasOwnProperty(Mt)||qn("Replacing nonexistent public symbol"),V[Mt].overloadTable!==void 0&&ni!==void 0?V[Mt].overloadTable[ni]=lt:(V[Mt]=lt,V[Mt].argCount=ni)},xx=(Mt,lt,ni)=>{var wi=V["dynCall_"+Mt];return wi(lt,...ni)},ji=[],_a,u2=Mt=>{var lt=ji[Mt];return lt||(Mt>=ji.length&&(ji.length=Mt+1),ji[Mt]=lt=_a.get(Mt)),lt},lx=(Mt,lt,ni=[])=>{if(Mt.includes("j"))return xx(Mt,lt,ni);var wi=u2(lt)(...ni);return wi},Gl=(Mt,lt)=>(...ni)=>lx(Mt,lt,ni),$a=(Mt,lt)=>{Mt=ka(Mt);function ni(){return Mt.includes("j")?Gl(Mt,lt):u2(lt)}var wi=ni();return typeof wi!="function"&&Kr("unknown function pointer with signature "+Mt+": "+lt),wi},pc=(Mt,lt)=>{var ni=Ll(lt,function(wi){this.name=lt,this.message=wi;var ct=new Error(wi).stack;ct!==void 0&&(this.stack=this.toString()+`
`+ct.replace(/^Error(:[^\n]*)?\n/,""))});return ni.prototype=Object.create(Mt.prototype),ni.prototype.constructor=ni,ni.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},ni},u0,hx=Mt=>{var lt=Gs(Mt),ni=ka(lt);return ho(lt),ni},Gx=(Mt,lt)=>{var ni=[],wi={};function ct(_t){if(!wi[_t]&&!Tn[_t]){if(Mn[_t]){Mn[_t].forEach(ct);return}ni.push(_t),wi[_t]=!0}}throw lt.forEach(ct),new u0(Mt+": "+ni.map(hx).join([", "]))},zl=(Mt,lt,ni,wi,ct,_t,kt,Yt,ri,$t,Mi,ki,_s)=>{Mi=ka(Mi),_t=$a(ct,_t),Yt&&(Yt=$a(kt,Yt)),$t&&($t=$a(ri,$t)),_s=$a(ki,_s);var ns=cc(Mi);ao(ns,function(){Gx("Cannot construct "+Mi+" due to unbound types",[wi])}),$n([Mt,lt,ni],wi?[wi]:[],Ts=>{var $r;Ts=Ts[0];var nn,vn;wi?(nn=Ts.registeredClass,vn=nn.instancePrototype):vn=K0.prototype;var Rn=Ll(Mi,function(...Ls){if(Object.getPrototypeOf(this)!==xr)throw new cn("Use 'new' to construct "+Mi);if(at.constructor_body===void 0)throw new cn(Mi+" has no accessible constructor");var ui=at.constructor_body[Ls.length];if(ui===void 0)throw new cn("Tried to invoke ctor of "+Mi+" with invalid number of parameters ("+Ls.length+") - expected ("+Object.keys(at.constructor_body).toString()+") parameters instead!");return ui.apply(this,Ls)}),xr=Object.create(vn,{constructor:{value:Rn}});Rn.prototype=xr;var at=new Wa(Mi,Rn,xr,_s,nn,_t,Yt,$t);at.baseClass&&(($r=at.baseClass).__derivedClasses!=null||($r.__derivedClasses=[]),at.baseClass.__derivedClasses.push(at));var Lr=new c2(Mi,at,!0,!1,!1),us=new c2(Mi+"*",at,!1,!1,!1),jt=new c2(Mi+" const*",at,!1,!0,!1);return kn[Mt]={pointerType:us,constPointerType:jt},Mo(ns,Rn),[Lr,us,jt]})},aa=(Mt,lt)=>{for(var ni=[],wi=0;wi<Mt;wi++)ni.push(Ye[lt+wi*4>>2]);return ni};function Ko(Mt){for(var lt=1;lt<Mt.length;++lt)if(Mt[lt]!==null&&Mt[lt].destructorFunction===void 0)return!0;return!1}function xo(Mt,lt,ni,wi,ct,_t){var kt=lt.length;kt<2&&Kr("argTypes array size mismatch! Must at least get return value and 'this' types!");var Yt=lt[1]!==null&&ni!==null,ri=Ko(lt),$t=lt[0].name!=="void",Mi=kt-2,ki=new Array(Mi),_s=[],ns=[],Ts=function(...$r){$r.length!==Mi&&Kr("function "+Mt+" called with "+$r.length+" arguments, expected "+Mi),ns.length=0;var nn;_s.length=Yt?2:1,_s[0]=ct,Yt&&(nn=lt[1].toWireType(ns,this),_s[1]=nn);for(var vn=0;vn<Mi;++vn)ki[vn]=lt[vn+2].toWireType(ns,$r[vn]),_s.push(ki[vn]);var Rn=wi(..._s);function xr(at){if(ri)rn(ns);else for(var Lr=Yt?1:2;Lr<lt.length;Lr++){var us=Lr===1?nn:ki[Lr-2];lt[Lr].destructorFunction!==null&&lt[Lr].destructorFunction(us)}if($t)return lt[0].fromWireType(at)}return xr(Rn)};return Ll(Mt,Ts)}var wh=(Mt,lt,ni,wi,ct,_t)=>{var kt=aa(lt,ni);ct=$a(wi,ct),$n([],[Mt],Yt=>{Yt=Yt[0];var ri="constructor "+Yt.name;if(Yt.registeredClass.constructor_body===void 0&&(Yt.registeredClass.constructor_body=[]),Yt.registeredClass.constructor_body[lt-1]!==void 0)throw new cn("Cannot register multiple constructors with identical number of parameters ("+(lt-1)+") for class '"+Yt.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return Yt.registeredClass.constructor_body[lt-1]=()=>{Gx("Cannot construct "+Yt.name+" due to unbound types",kt)},$n([],kt,$t=>($t.splice(1,0,null),Yt.registeredClass.constructor_body[lt-1]=xo(ri,$t,null,ct,_t),[])),[]})},zx=Mt=>{Mt=Mt.trim();const lt=Mt.indexOf("(");return lt!==-1?Mt.substr(0,lt):Mt},_c=(Mt,lt,ni,wi,ct,_t,kt,Yt,ri)=>{var $t=aa(ni,wi);lt=ka(lt),lt=zx(lt),_t=$a(ct,_t),$n([],[Mt],Mi=>{Mi=Mi[0];var ki=Mi.name+"."+lt;lt.startsWith("@@")&&(lt=Symbol[lt.substring(2)]),Yt&&Mi.registeredClass.pureVirtualFunctions.push(lt);function _s(){Gx("Cannot call "+ki+" due to unbound types",$t)}var ns=Mi.registeredClass.instancePrototype,Ts=ns[lt];return Ts===void 0||Ts.overloadTable===void 0&&Ts.className!==Mi.name&&Ts.argCount===ni-2?(_s.argCount=ni-2,_s.className=Mi.name,ns[lt]=_s):(Gn(ns,lt,ki),ns[lt].overloadTable[ni-2]=_s),$n([],$t,$r=>{var nn=xo(ki,$r,Mi,_t,kt);return ns[lt].overloadTable===void 0?(nn.argCount=ni-2,ns[lt]=nn):ns[lt].overloadTable[ni-2]=nn,[]}),[]})},sr=(Mt,lt,ni)=>(Mt instanceof Object||Kr(ni+' with invalid "this": '+Mt),Mt instanceof lt.registeredClass.constructor||Kr(ni+' incompatible with "this" of type '+Mt.constructor.name),Mt.$$.ptr||Kr("cannot call emscripten binding method "+ni+" on deleted object"),$2(Mt.$$.ptr,Mt.$$.ptrType.registeredClass,lt.registeredClass)),Tc=(Mt,lt,ni,wi,ct,_t,kt,Yt,ri,$t)=>{lt=ka(lt),ct=$a(wi,ct),$n([],[Mt],Mi=>{Mi=Mi[0];var ki=Mi.name+"."+lt,_s={get(){Gx("Cannot access "+ki+" due to unbound types",[ni,kt])},enumerable:!0,configurable:!0};return ri?_s.set=()=>Gx("Cannot access "+ki+" due to unbound types",[ni,kt]):_s.set=ns=>Kr(ki+" is a read-only property"),Object.defineProperty(Mi.registeredClass.instancePrototype,lt,_s),$n([],ri?[ni,kt]:[ni],ns=>{var Ts=ns[0],$r={get(){var vn=sr(this,Mi,ki+" getter");return Ts.fromWireType(ct(_t,vn))},enumerable:!0};if(ri){ri=$a(Yt,ri);var nn=ns[1];$r.set=function(vn){var Rn=sr(this,Mi,ki+" setter"),xr=[];ri($t,Rn,nn.toWireType(xr,vn)),rn(xr)}}return Object.defineProperty(Mi.registeredClass.instancePrototype,lt,$r),[]}),[]})},rl=[],_0=[],nl=Mt=>{Mt>9&&--_0[Mt+1]===0&&(_0[Mt]=void 0,rl.push(Mt))},ci=()=>_0.length/2-5-rl.length,al=()=>{_0.push(0,1,void 0,1,null,1,!0,1,!1,1),V.count_emval_handles=ci},wx={toValue:Mt=>(Mt||Kr("Cannot use deleted val. handle = "+Mt),_0[Mt]),toHandle:Mt=>{switch(Mt){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const lt=rl.pop()||_0.length;return _0[lt]=Mt,_0[lt+1]=1,lt}}}},jo={name:"emscripten::val",fromWireType:Mt=>{var lt=wx.toValue(Mt);return nl(Mt),lt},toWireType:(Mt,lt)=>wx.toHandle(lt),argPackAdvance:Kx,readValueFromPointer:Rr,destructorFunction:null},xl=Mt=>xn(Mt,jo),Ua=Mt=>{if(Mt===null)return"null";var lt=typeof Mt;return lt==="object"||lt==="array"||lt==="function"?Mt.toString():""+Mt},T0=(Mt,lt)=>{switch(lt){case 4:return function(ni){return this.fromWireType(je[ni>>2])};case 8:return function(ni){return this.fromWireType(Ke[ni>>3])};default:throw new TypeError("invalid float width ("+lt+"): "+Mt)}},Wl=(Mt,lt,ni)=>{lt=ka(lt),xn(Mt,{name:lt,fromWireType:wi=>wi,toWireType:(wi,ct)=>ct,argPackAdvance:Kx,readValueFromPointer:T0(lt,ni),destructorFunction:null})},qo=(Mt,lt,ni)=>{switch(lt){case 1:return ni?wi=>ke[wi]:wi=>Ue[wi];case 2:return ni?wi=>Ge[wi>>1]:wi=>We[wi>>1];case 4:return ni?wi=>Xe[wi>>2]:wi=>Ye[wi>>2];default:throw new TypeError("invalid integer width ("+lt+"): "+Mt)}},Wx=(Mt,lt,ni,wi,ct)=>{lt=ka(lt);var _t=Mi=>Mi;if(wi===0){var kt=32-8*ni;_t=Mi=>Mi<<kt>>>kt}var Yt=lt.includes("unsigned"),ri=(Mi,ki)=>{},$t;Yt?$t=function(Mi,ki){return ri(ki,this.name),ki>>>0}:$t=function(Mi,ki){return ri(ki,this.name),ki},xn(Mt,{name:lt,fromWireType:_t,toWireType:$t,argPackAdvance:Kx,readValueFromPointer:qo(lt,ni,wi!==0),destructorFunction:null})},Hx=(Mt,lt,ni)=>{var wi=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],ct=wi[lt];function _t(kt){var Yt=Ye[kt>>2],ri=Ye[kt+4>>2];return new ct(ke.buffer,ri,Yt)}ni=ka(ni),xn(Mt,{name:ni,fromWireType:_t,argPackAdvance:Kx,readValueFromPointer:_t},{ignoreDuplicateRegistrations:!0})},vc=(Mt,lt,ni,wi)=>{if(!(wi>0))return 0;for(var ct=ni,_t=ni+wi-1,kt=0;kt<Mt.length;++kt){var Yt=Mt.charCodeAt(kt);if(Yt>=55296&&Yt<=57343){var ri=Mt.charCodeAt(++kt);Yt=65536+((Yt&1023)<<10)|ri&1023}if(Yt<=127){if(ni>=_t)break;lt[ni++]=Yt}else if(Yt<=2047){if(ni+1>=_t)break;lt[ni++]=192|Yt>>6,lt[ni++]=128|Yt&63}else if(Yt<=65535){if(ni+2>=_t)break;lt[ni++]=224|Yt>>12,lt[ni++]=128|Yt>>6&63,lt[ni++]=128|Yt&63}else{if(ni+3>=_t)break;lt[ni++]=240|Yt>>18,lt[ni++]=128|Yt>>12&63,lt[ni++]=128|Yt>>6&63,lt[ni++]=128|Yt&63}}return lt[ni]=0,ni-ct},Rc=(Mt,lt,ni)=>vc(Mt,Ue,lt,ni),Lh=Mt=>{for(var lt=0,ni=0;ni<Mt.length;++ni){var wi=Mt.charCodeAt(ni);wi<=127?lt++:wi<=2047?lt+=2:wi>=55296&&wi<=57343?(lt+=4,++ni):lt+=3}return lt},ll=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,hl=(Mt,lt,ni)=>{for(var wi=lt+ni,ct=lt;Mt[ct]&&!(ct>=wi);)++ct;if(ct-lt>16&&Mt.buffer&&ll)return ll.decode(Mt.subarray(lt,ct));for(var _t="";lt<ct;){var kt=Mt[lt++];if(!(kt&128)){_t+=String.fromCharCode(kt);continue}var Yt=Mt[lt++]&63;if((kt&224)==192){_t+=String.fromCharCode((kt&31)<<6|Yt);continue}var ri=Mt[lt++]&63;if((kt&240)==224?kt=(kt&15)<<12|Yt<<6|ri:kt=(kt&7)<<18|Yt<<12|ri<<6|Mt[lt++]&63,kt<65536)_t+=String.fromCharCode(kt);else{var $t=kt-65536;_t+=String.fromCharCode(55296|$t>>10,56320|$t&1023)}}return _t},_x=(Mt,lt)=>Mt?hl(Ue,Mt,lt):"",Mc=(Mt,lt)=>{lt=ka(lt);var ni=lt==="std::string";xn(Mt,{name:lt,fromWireType(wi){var ct=Ye[wi>>2],_t=wi+4,kt;if(ni)for(var Yt=_t,ri=0;ri<=ct;++ri){var $t=_t+ri;if(ri==ct||Ue[$t]==0){var Mi=$t-Yt,ki=_x(Yt,Mi);kt===void 0?kt=ki:(kt+=String.fromCharCode(0),kt+=ki),Yt=$t+1}}else{for(var _s=new Array(ct),ri=0;ri<ct;++ri)_s[ri]=String.fromCharCode(Ue[_t+ri]);kt=_s.join("")}return ho(wi),kt},toWireType(wi,ct){ct instanceof ArrayBuffer&&(ct=new Uint8Array(ct));var _t,kt=typeof ct=="string";kt||ct instanceof Uint8Array||ct instanceof Uint8ClampedArray||ct instanceof Int8Array||Kr("Cannot pass non-string to std::string"),ni&&kt?_t=Lh(ct):_t=ct.length;var Yt=pl(4+_t+1),ri=Yt+4;if(Ye[Yt>>2]=_t,ni&&kt)Rc(ct,ri,_t+1);else if(kt)for(var $t=0;$t<_t;++$t){var Mi=ct.charCodeAt($t);Mi>255&&(ho(ri),Kr("String has UTF-16 code units that do not fit in 8 bits")),Ue[ri+$t]=Mi}else for(var $t=0;$t<_t;++$t)Ue[ri+$t]=ct[$t];return wi!==null&&wi.push(ho,Yt),Yt},argPackAdvance:Kx,readValueFromPointer:Rr,destructorFunction(wi){ho(wi)}})},kh=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,cl=(Mt,lt)=>{for(var ni=Mt,wi=ni>>1,ct=wi+lt/2;!(wi>=ct)&&We[wi];)++wi;if(ni=wi<<1,ni-Mt>32&&kh)return kh.decode(Ue.subarray(Mt,ni));for(var _t="",kt=0;!(kt>=lt/2);++kt){var Yt=Ge[Mt+kt*2>>1];if(Yt==0)break;_t+=String.fromCharCode(Yt)}return _t},L0=(Mt,lt,ni)=>{if(ni!=null||(ni=2147483647),ni<2)return 0;ni-=2;for(var wi=lt,ct=ni<Mt.length*2?ni/2:Mt.length,_t=0;_t<ct;++_t){var kt=Mt.charCodeAt(_t);Ge[lt>>1]=kt,lt+=2}return Ge[lt>>1]=0,lt-wi},_2=Mt=>Mt.length*2,T2=(Mt,lt)=>{for(var ni=0,wi="";!(ni>=lt/4);){var ct=Xe[Mt+ni*4>>2];if(ct==0)break;if(++ni,ct>=65536){var _t=ct-65536;wi+=String.fromCharCode(55296|_t>>10,56320|_t&1023)}else wi+=String.fromCharCode(ct)}return wi},Hl=(Mt,lt,ni)=>{if(ni!=null||(ni=2147483647),ni<4)return 0;for(var wi=lt,ct=wi+ni-4,_t=0;_t<Mt.length;++_t){var kt=Mt.charCodeAt(_t);if(kt>=55296&&kt<=57343){var Yt=Mt.charCodeAt(++_t);kt=65536+((kt&1023)<<10)|Yt&1023}if(Xe[lt>>2]=kt,lt+=4,lt+4>ct)break}return Xe[lt>>2]=0,lt-wi},Ra=Mt=>{for(var lt=0,ni=0;ni<Mt.length;++ni){var wi=Mt.charCodeAt(ni);wi>=55296&&wi<=57343&&++ni,lt+=4}return lt},Uh=(Mt,lt,ni)=>{ni=ka(ni);var wi,ct,_t,kt;lt===2?(wi=cl,ct=L0,kt=_2,_t=Yt=>We[Yt>>1]):lt===4&&(wi=T2,ct=Hl,kt=Ra,_t=Yt=>Ye[Yt>>2]),xn(Mt,{name:ni,fromWireType:Yt=>{for(var ri=Ye[Yt>>2],$t,Mi=Yt+4,ki=0;ki<=ri;++ki){var _s=Yt+4+ki*lt;if(ki==ri||_t(_s)==0){var ns=_s-Mi,Ts=wi(Mi,ns);$t===void 0?$t=Ts:($t+=String.fromCharCode(0),$t+=Ts),Mi=_s+lt}}return ho(Yt),$t},toWireType:(Yt,ri)=>{typeof ri!="string"&&Kr("Cannot pass non-string to C++ string type "+ni);var $t=kt(ri),Mi=pl(4+$t+lt);return Ye[Mi>>2]=$t/lt,ct(ri,Mi+4,$t+lt),Yt!==null&&Yt.push(ho,Mi),Mi},argPackAdvance:Kx,readValueFromPointer:Rr,destructorFunction(Yt){ho(Yt)}})},Xl=(Mt,lt,ni,wi,ct,_t)=>{hr[Mt]={name:ka(lt),rawConstructor:$a(ni,wi),rawDestructor:$a(ct,_t),fields:[]}},ul=(Mt,lt,ni,wi,ct,_t,kt,Yt,ri,$t)=>{hr[Mt].fields.push({fieldName:ka(lt),getterReturnType:ni,getter:$a(wi,ct),getterContext:_t,setterArgumentType:kt,setter:$a(Yt,ri),setterContext:$t})},v2=(Mt,lt)=>{lt=ka(lt),xn(Mt,{isVoid:!0,name:lt,argPackAdvance:0,fromWireType:()=>{},toWireType:(ni,wi)=>{}})},lo=(Mt,lt)=>{var ni=Tn[Mt];return ni===void 0&&Kr(lt+" has unknown type "+hx(Mt)),ni},Yl=(Mt,lt)=>{Mt=lo(Mt,"_emval_take_value");var ni=Mt.readValueFromPointer(lt);return wx.toHandle(ni)},Gh=()=>{rs("")},R2=(Mt,lt,ni)=>Ue.copyWithin(Mt,lt,lt+ni),wc=()=>2147483648,M2=Mt=>{var lt=Re.buffer,ni=(Mt-lt.byteLength+65535)/65536;try{return Re.grow(ni),qe(),1}catch{}},zh=Mt=>{var lt=Ue.length;Mt>>>=0;var ni=wc();if(Mt>ni)return!1;for(var wi=(ri,$t)=>ri+($t-ri%$t)%$t,ct=1;ct<=4;ct*=2){var _t=lt*(1+.2/ct);_t=Math.min(_t,Mt+100663296);var kt=Math.min(ni,wi(Math.max(Mt,_t),65536)),Yt=M2(kt);if(Yt)return!0}return!1};Un=V.InternalError=class extends Error{constructor(Mt){super(Mt),this.name="InternalError"}},ux(),cn=V.BindingError=class extends Error{constructor(Mt){super(Mt),this.name="BindingError"}},lc(),Mr(),Mh(),u0=V.UnboundTypeError=pc(Error,"UnboundTypeError"),al();var Lc={c:$s,m:cs,p:a0,u:l0,i:zl,h:wh,b:_c,e:Tc,t:xl,k:Wl,d:Wx,a:Hx,j:Mc,g:Uh,n:Xl,f:ul,l:v2,o:Yl,q:Gh,s:R2,r:zh},j0=hs(),ho=Mt=>(ho=j0.x)(Mt),pl=Mt=>(pl=j0.y)(Mt),Gs=Mt=>(Gs=j0.A)(Mt),r0=Mt=>(r0=j0.B)(Mt),k0;Wi=function Mt(){k0||Y0(),k0||(Wi=Mt)};function Y0(){if(Yi>0||(wt(),Yi>0))return;function Mt(){k0||(k0=!0,V.calledRun=!0,!we&&(Kt(),$(V),V.onRuntimeInitialized&&V.onRuntimeInitialized(),Ht()))}V.setStatus?(V.setStatus("Running..."),setTimeout(function(){setTimeout(function(){V.setStatus("")},1),Mt()},1)):Mt()}if(V.preInit)for(typeof V.preInit=="function"&&(V.preInit=[V.preInit]);V.preInit.length>0;)V.preInit.pop()();return Y0(),A.ready}})();const Vj=Cd();Vj.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,W=>{W&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Vr;(function(W){W[W.DT_INVALID=0]="DT_INVALID",W[W.DT_FLOAT=1]="DT_FLOAT",W[W.DT_DOUBLE=2]="DT_DOUBLE",W[W.DT_INT32=3]="DT_INT32",W[W.DT_UINT8=4]="DT_UINT8",W[W.DT_INT16=5]="DT_INT16",W[W.DT_INT8=6]="DT_INT8",W[W.DT_STRING=7]="DT_STRING",W[W.DT_COMPLEX64=8]="DT_COMPLEX64",W[W.DT_INT64=9]="DT_INT64",W[W.DT_BOOL=10]="DT_BOOL",W[W.DT_QINT8=11]="DT_QINT8",W[W.DT_QUINT8=12]="DT_QUINT8",W[W.DT_QINT32=13]="DT_QINT32",W[W.DT_BFLOAT16=14]="DT_BFLOAT16",W[W.DT_QINT16=15]="DT_QINT16",W[W.DT_QUINT16=16]="DT_QUINT16",W[W.DT_UINT16=17]="DT_UINT16",W[W.DT_COMPLEX128=18]="DT_COMPLEX128",W[W.DT_HALF=19]="DT_HALF",W[W.DT_RESOURCE=20]="DT_RESOURCE",W[W.DT_VARIANT=21]="DT_VARIANT",W[W.DT_UINT32=22]="DT_UINT32",W[W.DT_UINT64=23]="DT_UINT64",W[W.DT_FLOAT_REF=101]="DT_FLOAT_REF",W[W.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",W[W.DT_INT32_REF=103]="DT_INT32_REF",W[W.DT_UINT8_REF=104]="DT_UINT8_REF",W[W.DT_INT16_REF=105]="DT_INT16_REF",W[W.DT_INT8_REF=106]="DT_INT8_REF",W[W.DT_STRING_REF=107]="DT_STRING_REF",W[W.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",W[W.DT_INT64_REF=109]="DT_INT64_REF",W[W.DT_BOOL_REF=110]="DT_BOOL_REF",W[W.DT_QINT8_REF=111]="DT_QINT8_REF",W[W.DT_QUINT8_REF=112]="DT_QUINT8_REF",W[W.DT_QINT32_REF=113]="DT_QINT32_REF",W[W.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",W[W.DT_QINT16_REF=115]="DT_QINT16_REF",W[W.DT_QUINT16_REF=116]="DT_QUINT16_REF",W[W.DT_UINT16_REF=117]="DT_UINT16_REF",W[W.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",W[W.DT_HALF_REF=119]="DT_HALF_REF",W[W.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",W[W.DT_VARIANT_REF=121]="DT_VARIANT_REF",W[W.DT_UINT32_REF=122]="DT_UINT32_REF",W[W.DT_UINT64_REF=123]="DT_UINT64_REF"})(Vr||(Vr={}));var b0;(function(W){(function(A){A[A.LEGACY=0]="LEGACY",A[A.V1=1]="V1",A[A.V2=2]="V2"})(W.CheckpointFormatVersion||(W.CheckpointFormatVersion={}))})(b0||(b0={}));const b1={};function b2(W){return b1[W]}function b3(W,A,V,$,ne){const xe=A.inputParams[W];if(xe&&xe.inputIndexStart!==void 0){const ce=xe.inputIndexStart,ue=xe.inputIndexEnd===0?void 0:xe.inputIndexEnd===void 0?ce+1:xe.inputIndexEnd,Te=ce<0?A.inputNames.length+ce:ce;if(xe.type==="tensor")return b4(A.inputNames[Te],V,$,ne);if(xe.type==="tensors"){const we=A.inputs.slice(ce,ue);return A.inputNames.slice(ce,ue).filter((ke,Ue)=>{var Ge;return((Ge=we[Ue])===null||Ge===void 0?void 0:Ge.op)!=="NoOp"}).map(ke=>b4(ke,V,$,ne))}const Me=b4(A.inputNames[Te],V,$,ne),Re=Me.dataSync();return xe.type==="number"?Re[0]:C7(Me.shape,Re)}const le=A.attrParams[W];return le&&le.value}function b4(W,A,V,$){const[ne,xe]=b8(W,V);if($!=null){const ce=$.getHashTableHandleByName(ne);if(ce!=null)return ce}const le=V.currentContextIds.find(ce=>!!A[b7(ne,ce)]);return le!==void 0?A[b7(ne,le)][xe]:void 0}function b5(W,A,V){return A[b7(W,V.currentContextId)]}function b6(W,A){const[V,$,ne]=b8(W,A);return[b7(V,A&&A.currentContextId),$,ne]}function b7(W,A){return A?W+"-"+A:W}function b8(W,A){if(W==="")return["",0,void 0];const V=A!=null&&A.parseNodeNameCache!=null;if(V){const xe=A.parseNodeNameCache.get(W);if(xe!=null)return xe}const $=W.split(":");let ne;if($.length===1)ne=[W,0,void 0];else{const xe=$[0],le=$.length===3?$[1]:void 0,ce=Number($[$.length-1]);ne=[xe,ce,le]}return V&&A.parseNodeNameCache.set(W,ne),ne}function b9(W,A,V){let $=b3("pad",W,A,V);if($==="explicit"){$=b3("explicitPaddings",W,A,V);const ne=[[0,0],[0,0],[0,0],[0,0]];for(let xe=0;xe<4;xe++)ne[xe][0]=$[xe*2],ne[xe][1]=$[xe*2+1];return ne}return $}function bC(W){return W.kept?W:Ou(W)}const bm=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var bN=Object.freeze({__proto__:null,json:bm});const bJ=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var bf=Object.freeze({__proto__:null,json:bJ});const bi=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var bO=Object.freeze({__proto__:null,json:bi});const bt=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var bB=Object.freeze({__proto__:null,json:bt});const bS=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var bd=Object.freeze({__proto__:null,json:bS});const bV=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var bb=Object.freeze({__proto__:null,json:bV});const bP=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var bE=Object.freeze({__proto__:null,json:bP});const bD=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var bg=Object.freeze({__proto__:null,json:bD});const bZ=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var bo=Object.freeze({__proto__:null,json:bZ});const be=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var bQ=Object.freeze({__proto__:null,json:be});const bs=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];var bF=Object.freeze({__proto__:null,json:bs});const bI=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];var by=Object.freeze({__proto__:null,json:bI});const bA=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];var bp=Object.freeze({__proto__:null,json:bA});const bw=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var bX=Object.freeze({__proto__:null,json:bw});const bc=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var bW=Object.freeze({__proto__:null,json:bc});const bR=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var bK=Object.freeze({__proto__:null,json:bR});const bT=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var bv=Object.freeze({__proto__:null,json:bT});const bq=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var bl=Object.freeze({__proto__:null,json:bq});const ba=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var bn=Object.freeze({__proto__:null,json:ba});class bL{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const A=[bN,bf,bO,bB,bd,bb,bE,bg,bo,bQ,bF,by,bp,bX,bW,bK,bv,bl,bn],V=[].concat(...A.map($=>$.json));this.opMappers=V.reduce(($,ne)=>($[ne.tfOpName]=ne,$),{})}transformGraph(A,V={}){const $=A.node,ne=[],xe=[],le=[],ce=$.reduce((Ge,We)=>(Ge[We.name]=this.mapNode(We),We.op.startsWith("Placeholder")?ne.push(Ge[We.name]):We.op==="Const"?xe.push(Ge[We.name]):(We.input==null||We.input.length===0)&&le.push(Ge[We.name]),Ge),{});let ue=[];const Te=[];let Me={},Re={};V!=null&&(Me=this.mapSignatureEntries(V.inputs),Re=this.mapSignatureEntries(V.outputs));const we=Object.keys(ce);we.forEach(Ge=>{const We=ce[Ge];We.inputNames.forEach((Xe,Ye)=>{const[je,,Ke]=b6(Xe),qe=ce[je];if(qe.outputs!=null){const $e=qe.outputs.indexOf(Ke);if($e!==-1){const vt=je+":"+$e;We.inputNames[Ye]=vt}}We.inputs.push(qe),qe.children.push(We)})}),Object.keys(Re).length===0?we.forEach(Ge=>{const We=ce[Ge];We.children.length===0&&Te.push(We)}):Object.keys(Re).forEach(Ge=>{const[We]=b6(Ge),Xe=ce[We];Xe!=null&&(Xe.signatureKey=Re[Ge],Te.push(Xe))}),Object.keys(Me).length>0?Object.keys(Me).forEach(Ge=>{const[We]=b6(Ge),Xe=ce[We];Xe&&(Xe.signatureKey=Me[Ge],ue.push(Xe))}):ue=ne;let ke={};A.library!=null&&A.library.function!=null&&(ke=A.library.function.reduce((Ge,We)=>(Ge[We.signature.name]=this.mapFunction(We),Ge),{}));const Ue={nodes:ce,inputs:ue,outputs:Te,weights:xe,placeholders:ne,signature:V,functions:ke};return le.length>0&&(Ue.initNodes=le),Ue}mapSignatureEntries(A){return Object.keys(A||{}).reduce((V,$)=>(V[A[$].name]=$,V),{})}mapNode(A){const V=b2(A.op)||this.opMappers[A.op]||{};A.attr==null&&(A.attr={});const $={name:A.name,op:A.op,category:V.category,inputNames:(A.input||[]).map(ne=>ne.startsWith("^")?ne.slice(1):ne),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:A.attr,outputs:V.outputs};return V.inputs!=null&&($.inputParams=V.inputs.reduce((ne,xe)=>(ne[xe.name]={type:xe.type,inputIndexStart:xe.start,inputIndexEnd:xe.end},ne),{})),V.attrs!=null&&($.attrParams=V.attrs.reduce((ne,xe)=>{const le=xe.type;let ce;switch(xe.type){case"string":ce=bz(A.attr,xe.tfName,xe.defaultValue),ce===void 0&&xe.tfDeprecatedName&&(ce=bz(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"string[]":ce=P0(A.attr,xe.tfName,xe.defaultValue),ce===void 0&&xe.tfDeprecatedName&&(ce=P0(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"number":ce=bU(A.attr,xe.tfName,xe.defaultValue||0),ce===void 0&&xe.tfDeprecatedName&&(ce=bU(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"number[]":ce=br(A.attr,xe.tfName,xe.defaultValue),ce===void 0&&xe.tfDeprecatedName&&(ce=br(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"bool":ce=bx(A.attr,xe.tfName,xe.defaultValue),ce===void 0&&xe.tfDeprecatedName&&(ce=bx(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"bool[]":ce=P2(A.attr,xe.tfName,xe.defaultValue),ce===void 0&&xe.tfDeprecatedName&&(ce=P2(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"shape":ce=bj(A.attr,xe.tfName,xe.defaultValue),ce===void 0&&xe.tfDeprecatedName&&(ce=bj(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"shape[]":ce=P1(A.attr,xe.tfName,xe.defaultValue),ce===void 0&&xe.tfDeprecatedName&&(ce=P1(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"dtype":ce=bY(A.attr,xe.tfName,xe.defaultValue),ce===void 0&&xe.tfDeprecatedName&&(ce=bY(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"dtype[]":ce=bM(A.attr,xe.tfName,xe.defaultValue),ce===void 0&&xe.tfDeprecatedName&&(ce=bM(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"func":ce=bu(A.attr,xe.tfName,xe.defaultValue),ce===void 0&&xe.tfDeprecatedName&&(ce=bu(A.attr,xe.tfDeprecatedName,xe.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+xe.type+" for op: "+A.op)}return ne[xe.name]={value:ce,type:le},ne},{})),$}mapFunction(A){const V=A.nodeDef,$=[],ne=[];let xe={};V!=null&&(xe=V.reduce((Me,Re)=>(Me[Re.name]=this.mapNode(Re),Re.op==="Const"&&ne.push(Me[Re.name]),Me),{}));const le=[],ce=[];A.signature.inputArg.forEach(Me=>{const[Re]=b6(Me.name),we={name:Re,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:bG(Me.type),type:"dtype"}},children:[]};we.signatureKey=Me.name,le.push(we),xe[Re]=we}),Object.keys(xe).forEach(Me=>{const Re=xe[Me];Re.inputNames.forEach((we,ke)=>{const[Ue,,Ge]=b6(we),We=xe[Ue];if(We.outputs!=null){const Xe=We.outputs.indexOf(Ge);if(Xe!==-1){const Ye=Ue+":"+Xe;Re.inputNames[ke]=Ye}}Re.inputs.push(We),We.children.push(Re)})});const ue=A.ret;A.signature.outputArg.forEach(Me=>{const[Re,we]=b6(ue[Me.name]),ke=xe[Re];ke!=null&&(ke.defaultOutput=we,ce.push(ke))});const Te=this.mapArgsToSignature(A);return{nodes:xe,inputs:le,outputs:ce,weights:ne,placeholders:$,signature:Te}}mapArgsToSignature(A){return{methodName:A.signature.name,inputs:A.signature.inputArg.reduce((V,$)=>(V[$.name]=this.mapArgToTensorInfo($),V),{}),outputs:A.signature.outputArg.reduce((V,$)=>(V[$.name]=this.mapArgToTensorInfo($,A.ret),V),{})}}mapArgToTensorInfo(A,V){let $=A.name;return V!=null&&($=V[$]),{name:$,dtype:A.type}}}function bH(W){const A=Cd().global;if(typeof A.atob<"u")return A.atob(W);if(typeof Buffer<"u")return new Buffer(W,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function bk(W,A){const V=Array.isArray(W)?String.fromCharCode.apply(null,W):bH(W);return A?V:V.toLowerCase()}function bz(W,A,V,$=!1){const ne=W[A];return ne!=null?bk(ne.s,$):V}function bx(W,A,V){const $=W[A];return $?$.b:V}function bU(W,A,V){const $=W[A]||{},ne=$.i!=null?$.i:$.f!=null?$.f:V;return typeof ne=="number"?ne:parseInt(ne,10)}function bG(W){switch(typeof W=="string"&&(W=Vr[W]),W){case Vr.DT_FLOAT:case Vr.DT_HALF:return"float32";case Vr.DT_INT32:case Vr.DT_INT64:case Vr.DT_INT8:case Vr.DT_UINT8:return"int32";case Vr.DT_BOOL:return"bool";case Vr.DT_DOUBLE:return"float32";case Vr.DT_STRING:return"string";case Vr.DT_COMPLEX64:case Vr.DT_COMPLEX128:return"complex64";default:return null}}function bu(W,A,V){const $=W[A];return $&&$.func?$.func.name:V}function bY(W,A,V){const $=W[A];return $&&$.type?bG($.type):V}function bM(W,A,V){const $=W[A];return $&&$.list&&$.list.type?$.list.type.map(ne=>bG(ne)):V}function bh(W){if(!W.unknownRank)return W.dim!=null?W.dim.map(A=>typeof A.size=="number"?A.size:parseInt(A.size,10)):[]}function bj(W,A,V){const $=W[A];return $&&$.shape?bh($.shape):V}function br(W,A,V){const $=W[A];return $?(($.list.f&&$.list.f.length?$.list.f:$.list.i)||[]).map(ne=>typeof ne=="number"?ne:parseInt(ne,10)):V}function P0(W,A,V,$=!1){const ne=W[A];return ne&&ne.list&&ne.list.s?ne.list.s.map(xe=>bk(xe,$)):V}function P1(W,A,V){const $=W[A];return $&&$.list&&$.list.shape?$.list.shape.map(ne=>bh(ne)):V}function P2(W,A,V){const $=W[A];return $&&$.list&&$.list.b?$.list.b:V}class P3{constructor(A,V,$){this.node=A,this.tensorMap=V,this.context=$,this.inputs=[],this.attrs={},this.inputs=A.inputNames.map(ne=>this.getInput(ne)),A.rawAttrs!=null&&(this.attrs=Object.keys(A.rawAttrs).reduce((ne,xe)=>(ne[xe]=this.getAttr(xe),ne),{}))}getInput(A){return b4(A,this.tensorMap,this.context)}getAttr(A,V){const $=this.node.rawAttrs[A];if($.tensor!=null)return b4(A,this.tensorMap,this.context);if($.i!=null||$.f!=null)return bU(this.node.rawAttrs,A,V);if($.s!=null)return bz(this.node.rawAttrs,A,V);if($.b!=null)return bx(this.node.rawAttrs,A,V);if($.shape!=null)return bj(this.node.rawAttrs,A,V);if($.type!=null)return bY(this.node.rawAttrs,A,V);if($.list!=null){if($.list.i!=null||$.list.f!=null)return br(this.node.rawAttrs,A,V);if($.list.s!=null)return P0(this.node.rawAttrs,A,V);if($.list.shape!=null)return P1(this.node.rawAttrs,A,V);if($.list.b!=null)return P2(this.node.rawAttrs,A,V);if($.list.type!=null)return bM(this.node.rawAttrs,A,V)}return V}}const P4={conv2d:SX,depthwiseConv2d:Sv,matMul:Sl},P5={resizeBilinear:dd};var P6=Object.freeze({__proto__:null,add:OS,addN:Oe,atan2:Os,avgPool:OU,cast:ip,concat:OM,conv2d:tO,conv2dTranspose:td,cos:tb,depthToSpace:tE,depthwiseConv2d:tg,expandDims:B0,fill:t8,floor:B4,fused:P4,gather:B6,greaterEqual:BC,image:P5,lessEqual:BO,logicalAnd:BV,matMul:iX,max:tv,maxPool:BD,maximum:BZ,mean:Be,min:tl,minimum:BI,mul:OD,neg:iK,pad:BA,prelu:BT,range:S4,relu:S6,relu6:S8,reshape:Oz,scalar:tL,sigmoid:Oj,sin:SN,squeeze:SB,stack:Sd,stridedSlice:SE,sub:BS,tensor1d:SD,tile:B2,transpose:il,zerosLike:tQ});const P7=(W,A,V,$=P6)=>{switch(W.op){case"BiasAdd":case"AddV2":case"Add":return[$.add(b3("a",W,A,V),b3("b",W,A,V))];case"AddN":return[$.addN(b3("tensors",W,A,V))];case"FloorMod":case"Mod":return[$.mod(b3("a",W,A,V),b3("b",W,A,V))];case"Mul":return[$.mul(b3("a",W,A,V),b3("b",W,A,V))];case"RealDiv":case"Div":return[$.div(b3("a",W,A,V),b3("b",W,A,V))];case"DivNoNan":return[$.divNoNan(b3("a",W,A,V),b3("b",W,A,V))];case"FloorDiv":return[$.floorDiv(b3("a",W,A,V),b3("b",W,A,V))];case"Sub":return[$.sub(b3("a",W,A,V),b3("b",W,A,V))];case"Minimum":return[$.minimum(b3("a",W,A,V),b3("b",W,A,V))];case"Maximum":return[$.maximum(b3("a",W,A,V),b3("b",W,A,V))];case"Pow":return[$.pow(b3("a",W,A,V),b3("b",W,A,V))];case"SquaredDifference":return[$.squaredDifference(b3("a",W,A,V),b3("b",W,A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}},P8=(W,A,V,$=P6)=>{switch(W.op){case"Abs":case"ComplexAbs":return[$.abs(b3("x",W,A,V))];case"Acos":return[$.acos(b3("x",W,A,V))];case"Acosh":return[$.acosh(b3("x",W,A,V))];case"Asin":return[$.asin(b3("x",W,A,V))];case"Asinh":return[$.asinh(b3("x",W,A,V))];case"Atan":return[$.atan(b3("x",W,A,V))];case"Atan2":return[$.atan2(b3("x",W,A,V),b3("y",W,A,V))];case"Atanh":return[$.atanh(b3("x",W,A,V))];case"Ceil":return[$.ceil(b3("x",W,A,V))];case"Complex":return[$.complex(b3("real",W,A,V),b3("imag",W,A,V))];case"Cos":return[$.cos(b3("x",W,A,V))];case"Cosh":return[$.cosh(b3("x",W,A,V))];case"Elu":return[$.elu(b3("x",W,A,V))];case"Erf":return[$.erf(b3("x",W,A,V))];case"Exp":return[$.exp(b3("x",W,A,V))];case"Expm1":return[$.expm1(b3("x",W,A,V))];case"Floor":return[$.floor(b3("x",W,A,V))];case"Log":return[$.log(b3("x",W,A,V))];case"Log1p":return[$.log1p(b3("x",W,A,V))];case"Imag":return[$.imag(b3("x",W,A,V))];case"Neg":return[$.neg(b3("x",W,A,V))];case"Reciprocal":return[$.reciprocal(b3("x",W,A,V))];case"Real":return[$.real(b3("x",W,A,V))];case"Relu":return[$.relu(b3("x",W,A,V))];case"Round":return[$.round(b3("x",W,A,V))];case"Selu":return[$.selu(b3("x",W,A,V))];case"Sigmoid":return[$.sigmoid(b3("x",W,A,V))];case"Sin":return[$.sin(b3("x",W,A,V))];case"Sign":return[$.sign(b3("x",W,A,V))];case"Sinh":return[$.sinh(b3("x",W,A,V))];case"Softplus":return[$.softplus(b3("x",W,A,V))];case"Sqrt":return[$.sqrt(b3("x",W,A,V))];case"Square":return[$.square(b3("x",W,A,V))];case"Tanh":return[$.tanh(b3("x",W,A,V))];case"Tan":return[$.tan(b3("x",W,A,V))];case"ClipByValue":return[$.clipByValue(b3("x",W,A,V),b3("clipValueMin",W,A,V),b3("clipValueMax",W,A,V))];case"Relu6":return[$.relu6(b3("x",W,A,V))];case"Rsqrt":return[$.rsqrt(b4(W.inputNames[0],A,V))];case"LeakyRelu":return[$.leakyRelu(b3("x",W,A,V),b3("alpha",W,A,V))];case"Prelu":return[$.prelu(b3("x",W,A,V),b3("alpha",W,A,V))];case"IsNan":return[$.isNaN(b4(W.inputNames[0],A,V))];case"IsInf":return[$.isInf(b4(W.inputNames[0],A,V))];case"IsFinite":return[$.isFinite(b4(W.inputNames[0],A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}};function P9(W,A,V=""){if(!(typeof W=="number"||typeof A=="number")){e(W.length===A.length,()=>V+(" Shapes "+W+" and "+A+" must match"));for(let $=0;$<W.length;$++){const ne=W[$],xe=A[$];e(ne<0||xe<0||ne===xe,()=>V+(" Shapes "+W+" and "+A+" must match"))}}}function PC(W){return!(typeof W=="number"||W.some(A=>A<0))}function Pm(W,A,V){let $=PN(W,V);const ne=!PC($);if(ne&&A.length===0)throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: "+$);if(ne&&A.forEach(xe=>{$=PN(xe.shape,$)}),!PC($))throw new Error("Non-fully-defined elementShape: "+$);return $}function PN(W,A){if(typeof W=="number")return A;if(typeof A=="number")return W;if(W.length!==A.length)throw new Error("Incompatible ranks during merge: "+W+" vs. "+A);const V=[];for(let $=0;$<W.length;++$){const ne=W[$],xe=A[$];if(ne>=0&&xe>=0&&ne!==xe)throw new Error("Incompatible shape during merge: "+W+" vs. "+A);V[$]=ne>=0?ne:xe}return V}class PJ{constructor(A,V,$,ne,xe,le,ce){this.name=A,this.dtype=V,this.maxSize=$,this.elementShape=ne,this.identicalElementShapes=xe,this.dynamicSize=le,this.clearAfterRead=ce,this.tensors=[],this.closed_=!1,this.idTensor=tL(0),Jh(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(A){this.tensors.forEach(V=>{(A==null||!A.has(V.tensor.id))&&V.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(A){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(A<0||A>=this.size())throw new Error("Tried to read from index "+A+", but array size is: "+this.size());const V=this.tensors[A];if(V.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+A+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(V.cleared=!0),V.read=!0,V.tensor}readMany(A){return A.map(V=>this.read(V))}write(A,V){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(A<0||!this.dynamicSize&&A>=this.maxSize)throw new Error("Tried to write to index "+A+", but array is not resizeable and size is: "+this.maxSize);const $=this.tensors[A]||{};if(V.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+A+`,
          because the value dtype is `+V.dtype+", but TensorArray dtype is "+this.dtype+".");if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=V.shape),P9(this.elementShape,V.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+A+"."),$.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+A+", because it has already been read.");if($.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+A+", because it has already been written.");$.tensor=V,Jh(V),$.written=!0,this.tensors[A]=$}writeMany(A,V){if(A.length!==V.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+A.length+" is not the same as tensors size: "+V.length+".");A.forEach(($,ne)=>this.write($,V[ne]))}gather(A,V){if(V&&V!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+V);if(A)A=A.slice(0,this.size());else{A=[];for(let ne=0;ne<this.size();ne++)A.push(ne)}if(A.length===0)return Jk([],[0].concat(this.elementShape));const $=this.readMany(A);return P9(this.elementShape,$[0].shape,"TensorArray shape mismatch: "),Sd($,0)}concat(A){if(A&&A!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+A);if(this.size()===0)return Jk([],[0].concat(this.elementShape));const V=[];for(let ne=0;ne<this.size();ne++)V.push(ne);const $=this.readMany(V);return P9(this.elementShape,$[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+$[0].shape+")"),OM($,0)}scatter(A,V){if(V.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+V.dtype);if(A.length!==V.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+A.length+" vs. "+V.shape[0]);const $=Math.max(...A);if(!this.dynamicSize&&$>=this.maxSize)throw new Error("Max index must be < array size ("+$+"  vs. "+this.maxSize+")");this.writeMany(A,Se(V,0))}split(A,V){if(V.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+V.dtype);let $=0;const ne=A.map(ue=>($+=ue,$));if($!==V.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+$+", and tensor's shape is: "+V.shape);if(!this.dynamicSize&&A.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+A.length+"), and the TensorArray is not marked as dynamically resizeable");const xe=$===0?0:V.size/$,le=[];JY(()=>{V=Oz(V,[1,$,xe]);for(let ue=0;ue<A.length;++ue){const Te=[0,ue===0?0:ne[ue-1],0],Me=[1,A[ue],xe];le[ue]=Oz(t0(V,Te,Me),this.elementShape)}return le});const ce=[];for(let ue=0;ue<A.length;ue++)ce[ue]=ue;this.writeMany(ce,le)}}class Pf{get id(){return this.idTensor.id}constructor(A,V,$,ne=-1){this.tensors=A,this.elementShape=V,this.elementDtype=$,A?.forEach(xe=>{if($!==xe.dtype)throw new Error("Invalid data types; op elements "+$+", but list elements "+xe.dtype);P9(V,xe.shape,"TensorList shape mismatch: "),Jh(xe)}),this.idTensor=tL(0),this.maxNumElements=ne,Jh(this.idTensor)}copy(){return new Pf([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(A){this.tensors.forEach(V=>{(A==null||!A.has(V.id))&&V.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(A,V,$=-1){if(V!==this.elementDtype)throw new Error("Invalid data types; op elements "+V+", but list elements "+this.elementDtype);if($!==-1&&this.tensors.length!==$)throw new Error("Operation expected a list with "+$+" elements but got a list with "+this.tensors.length+" elements.");P9(A,this.elementShape,"TensorList shape mismatch: ");const ne=Pm(this.elementShape,this.tensors,A);return JY(()=>{const xe=this.tensors.map(le=>Oz(le,ne));return Sd(xe,0)})}popBack(A,V){if(V!==this.elementDtype)throw new Error("Invalid data types; op elements "+V+", but list elements "+this.elementDtype);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const $=Pm(this.elementShape,this.tensors,A),ne=this.tensors.pop();return ne.kept=!1,P9(ne.shape,A,"TensorList shape mismatch: "),Oz(ne,$)}pushBack(A){if(A.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+A.dtype+", but list elements "+this.elementDtype);if(P9(A.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Jh(A),this.tensors.push(A)}resize(A){if(A<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+A);if(this.maxNumElements!==-1&&A>this.maxNumElements)throw new Error("TensorListResize input size "+A+" is greater maxNumElement "+this.maxNumElements+".");const V=new Pf([],this.elementShape,this.elementDtype,this.maxNumElements);V.tensors.length=A;for(let $=0;$<Math.min(this.tensors.length,A);++$)V.tensors[$]=this.tensors[$];return V}getItem(A,V,$){if($!==this.elementDtype)throw new Error("Invalid data types; op elements "+$+", but list elements "+this.elementDtype);if(A<0||A>this.tensors.length)throw new Error("Trying to access element "+A+" in a list with "+this.tensors.length+" elements.");if(this.tensors[A]==null)throw new Error("element at index "+A+" is null.");P9(this.tensors[A].shape,V,"TensorList shape mismatch: ");const ne=Pm(this.elementShape,this.tensors,V);return Oz(this.tensors[A],ne)}setItem(A,V){if(V.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+V.dtype+", but list elements "+this.elementDtype);if(A<0||this.maxNumElements!==-1&&A>=this.maxNumElements)throw new Error("Trying to set element "+A+" in a list with max "+this.maxNumElements+" elements.");P9(this.elementShape,V.shape,"TensorList shape mismatch: "),Jh(V),this.tensors[A]!=null&&(this.tensors[A].kept=!1),this.tensors[A]=V}gather(A,V,$){if(V!==this.elementDtype)throw new Error("Invalid data types; op elements "+V+", but list elements "+this.elementDtype);P9(this.elementShape,$,"TensorList shape mismatch: "),A=A.slice(0,this.size());const ne=Pm(this.elementShape,this.tensors,$);return A.length===0?Jk([],[0].concat(ne)):JY(()=>{const xe=A.map(le=>Oz(this.tensors[le],ne));return Sd(xe,0)})}concat(A,V){if(A&&A!==this.elementDtype)throw new Error("TensorList dtype is "+this.elementDtype+" but concat requested dtype "+A);P9(this.elementShape,V,"TensorList shape mismatch: ");const $=Pm(this.elementShape,this.tensors,V);return this.size()===0?Jk([],[0].concat($)):JY(()=>{const ne=this.tensors.map(xe=>Oz(xe,$));return OM(ne,0)})}}function Pi(W,A,V){const $=W.dtype;if(W.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+W.shape);if(W.dtype!==V)throw new Error("Invalid data types; op elements "+W.dtype+", but list elements "+V);const ne=W.shape.slice(1);P9(ne,A,"TensorList shape mismatch: ");const xe=Se(W);return new Pf(xe,A,$)}function PO(W,A,V,$){return new Pf([],W,A,$)}function Pt(W,A,V,$){if(A.length!==W.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+A.length+" vs. "+W.shape[0]);const ne=Math.max(...A);if($!=null&&$!==-1&&ne>=$)throw new Error("Max index must be < array size ("+ne+"  vs. "+$+")");const xe=new Pf([],V,W.dtype,$),le=Se(W,0);return A.forEach((ce,ue)=>{xe.setItem(ce,le[ue])}),xe}function PB(W,A,V){let $=0;const ne=A.map(Me=>($+=Me,$));if($!==W.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+$+", and tensor's shape is: "+W.shape);const xe=W.shape.slice(1),le=PN(xe,V),ce=$===0?0:W.size/$,ue=JY(()=>{const Me=[];W=Oz(W,[1,$,ce]);for(let Re=0;Re<A.length;++Re){const we=[0,Re===0?0:ne[Re-1],0],ke=[1,A[Re],ce];Me[Re]=Oz(t0(W,we,ke),le)}return W.dispose(),Me}),Te=new Pf([],V,W.dtype,A.length);for(let Me=0;Me<ue.length;Me++)Te.setItem(Me,ue[Me]);return Te}const PS=async(W,A,V)=>{switch(W.op){case"If":case"StatelessIf":{const $=b3("thenBranch",W,A,V),ne=b3("elseBranch",W,A,V),xe=b3("cond",W,A,V),le=b3("args",W,A,V);return(await xe.data())[0]?V.functionMap[$].executeFunctionAsync(le,V.tensorArrayMap,V.tensorListMap):V.functionMap[ne].executeFunctionAsync(le,V.tensorArrayMap,V.tensorListMap)}case"While":case"StatelessWhile":{const $=b3("body",W,A,V),ne=b3("cond",W,A,V),xe=b3("args",W,A,V),le=await V.functionMap[ne].executeFunctionAsync(xe,V.tensorArrayMap,V.tensorListMap),ce=xe.map(Me=>Me.id);let ue=await le[0].data();le.forEach(Me=>{!Me.kept&&ce.indexOf(Me.id)===-1&&Me.dispose()});let Te=xe;for(;ue[0];){const Me=Te;Te=await V.functionMap[$].executeFunctionAsync(Te,V.tensorArrayMap,V.tensorListMap);const Re=Te.map(ke=>ke.id);Me.forEach(ke=>{!ke.kept&&ce.indexOf(ke.id)===-1&&Re.indexOf(ke.id)===-1&&ke.dispose()});const we=await V.functionMap[ne].executeFunctionAsync(Te,V.tensorArrayMap,V.tensorListMap);ue=await we[0].data(),we.forEach(ke=>{!ke.kept&&ce.indexOf(ke.id)===-1&&Re.indexOf(ke.id)===-1&&ke.dispose()})}return Te}case"LoopCond":{const $=b3("pred",W,A,V);return[bC($)]}case"Switch":{const $=b3("pred",W,A,V);let ne=b3("data",W,A,V);return ne.kept||(ne=bC(ne)),(await $.data())[0]?[void 0,ne]:[ne,void 0]}case"Merge":{const $=W.inputNames.find(ne=>b4(ne,A,V)!==void 0);if($){const ne=b4($,A,V);return[bC(ne)]}return}case"Enter":{const $=b3("frameName",W,A,V),ne=b3("tensor",W,A,V);return V.enterFrame($),[bC(ne)]}case"Exit":{const $=b3("tensor",W,A,V);return V.exitFrame(),[bC($)]}case"NextIteration":{const $=b3("tensor",W,A,V);return V.nextIteration(),[bC($)]}case"TensorArrayV3":{const $=b3("size",W,A,V),ne=b3("dtype",W,A,V),xe=b3("elementShape",W,A,V),le=b3("dynamicSize",W,A,V),ce=b3("clearAfterRead",W,A,V),ue=b3("identicalElementShapes",W,A,V),Te=b3("name",W,A,V),Me=new PJ(Te,ne,$,xe,ue,le,ce);return V.addTensorArray(Me),[Me.idTensor,tL(1)]}case"TensorArrayWriteV3":{const $=b3("tensorArrayId",W,A,V),ne=b3("index",W,A,V),xe=b3("tensor",W,A,V),le=V.getTensorArray($.id);return le.write(ne,xe),[le.idTensor]}case"TensorArrayReadV3":{const $=b3("tensorArrayId",W,A,V),ne=b3("index",W,A,V);return[V.getTensorArray($.id).read(ne)]}case"TensorArrayGatherV3":{const $=b3("tensorArrayId",W,A,V),ne=b3("indices",W,A,V),xe=b3("dtype",W,A,V);return[V.getTensorArray($.id).gather(ne,xe)]}case"TensorArrayScatterV3":{const $=b3("tensorArrayId",W,A,V),ne=b3("indices",W,A,V),xe=b3("tensor",W,A,V),le=V.getTensorArray($.id);return le.scatter(ne,xe),[le.idTensor]}case"TensorArrayConcatV3":{const $=b3("tensorArrayId",W,A,V),ne=V.getTensorArray($.id),xe=b3("dtype",W,A,V);return[ne.concat(xe)]}case"TensorArraySplitV3":{const $=b3("tensorArrayId",W,A,V),ne=b3("tensor",W,A,V),xe=b3("lengths",W,A,V),le=V.getTensorArray($.id);return le.split(xe,ne),[le.idTensor]}case"TensorArraySizeV3":{const $=b3("tensorArrayId",W,A,V),ne=V.getTensorArray($.id);return[tL(ne.size(),"int32")]}case"TensorArrayCloseV3":{const $=b3("tensorArrayId",W,A,V),ne=V.getTensorArray($.id);return ne.clearAndClose(),[ne.idTensor]}case"TensorListSetItem":{const $=b3("tensorListId",W,A,V),ne=b3("index",W,A,V),xe=b3("tensor",W,A,V),le=V.getTensorList($.id);return le.setItem(ne,xe),[le.idTensor]}case"TensorListGetItem":{const $=b3("tensorListId",W,A,V),ne=b3("index",W,A,V),xe=b3("elementShape",W,A,V),le=b3("elementDType",W,A,V);return[V.getTensorList($.id).getItem(ne,xe,le)]}case"TensorListScatterV2":case"TensorListScatter":{const $=b3("indices",W,A,V),ne=b3("tensor",W,A,V),xe=b3("elementShape",W,A,V),le=b3("numElements",W,A,V),ce=Pt(ne,$,xe,le);return V.addTensorList(ce),[ce.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const $=b3("elementShape",W,A,V),ne=b3("elementDType",W,A,V);let xe;W.op==="TensorListReserve"?xe="numElements":xe="maxNumElements";const le=b3(xe,W,A,V),ce=W.op==="TensorListReserve"?-1:le,ue=PO($,ne,le,ce);return V.addTensorList(ue),[ue.idTensor]}case"TensorListGather":{const $=b3("tensorListId",W,A,V),ne=b3("indices",W,A,V),xe=b3("elementShape",W,A,V),le=b3("elementDType",W,A,V);return[V.getTensorList($.id).gather(ne,le,xe)]}case"TensorListStack":{const $=b3("tensorListId",W,A,V),ne=b3("elementShape",W,A,V),xe=b3("elementDType",W,A,V),le=b3("numElements",W,A,V);return[V.getTensorList($.id).stack(ne,xe,le)]}case"TensorListFromTensor":{const $=b3("tensor",W,A,V),ne=b3("elementShape",W,A,V),xe=b3("elementDType",W,A,V),le=Pi($,ne,xe);return V.addTensorList(le),[le.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const $=b3("tensorListId",W,A,V),ne=V.getTensorList($.id),xe=b3("dtype",W,A,V),le=b3("elementShape",W,A,V);return[ne.concat(xe,le)]}case"TensorListPushBack":{const $=b3("tensorListId",W,A,V),ne=b3("tensor",W,A,V),xe=V.getTensorList($.id);return xe.pushBack(ne),[xe.idTensor]}case"TensorListPopBack":{const $=b3("tensorListId",W,A,V),ne=b3("elementShape",W,A,V),xe=b3("elementDType",W,A,V);return[V.getTensorList($.id).popBack(ne,xe)]}case"TensorListSplit":{const $=b3("tensor",W,A,V),ne=b3("elementShape",W,A,V),xe=b3("lengths",W,A,V),le=PB($,xe,ne);return V.addTensorList(le),[le.idTensor]}case"TensorListLength":{const $=b3("tensorListId",W,A,V),ne=V.getTensorList($.id);return[tL(ne.size(),"int32")]}case"TensorListResize":{const $=b3("tensorListId",W,A,V),ne=b3("size",W,A,V),xe=V.getTensorList($.id).resize(ne);return V.addTensorList(xe),[xe.idTensor]}default:throw TypeError("Node type "+W.op+" is not implemented")}};function Pd(W,A,V){const[$,ne]=b3("fusedOps",W,A,V),xe=$==="biasadd",le=!xe,ce=ne==="prelu",ue=$==="fusedbatchnorm",Te=b3("numArgs",W,A,V);if(xe){if(ce&&Te!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!ce&&xe&&Te!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(ue)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const Me=b3("strides",W,A,V),Re=b9(W,A,V),we=b3("dataFormat",W,A,V).toUpperCase(),ke=b3("dilations",W,A,V);let[Ue,Ge]=b3("args",W,A,V);le&&(Ge=Ue,Ue=void 0);const We=b3("leakyreluAlpha",W,A,V);return{stride:Me,pad:Re,dataFormat:we,dilations:ke,biasArg:Ue,preluArg:Ge,activationFunc:ne,leakyreluAlpha:We}}const PV=(W,A,V,$=P6)=>{switch(W.op){case"Conv1D":{const ne=b3("stride",W,A,V),xe=b3("pad",W,A,V),le=b3("dataFormat",W,A,V).toUpperCase(),ce=b3("dilation",W,A,V);return[$.conv1d(b3("x",W,A,V),b3("filter",W,A,V),ne,xe,le,ce)]}case"Conv2D":{const ne=b3("strides",W,A,V),xe=b9(W,A,V),le=b3("dataFormat",W,A,V).toUpperCase(),ce=b3("dilations",W,A,V);return[$.conv2d(b3("x",W,A,V),b3("filter",W,A,V),[ne[1],ne[2]],xe,le,[ce[1],ce[2]])]}case"_FusedConv2D":{const{stride:ne,pad:xe,dataFormat:le,dilations:ce,biasArg:ue,preluArg:Te,activationFunc:Me,leakyreluAlpha:Re}=Pd(W,A,V),we=W.name.endsWith("batch_normalization_88/FusedBatchNormV3")||W.name.endsWith("batch_normalization_90/FusedBatchNormV3")?Cd().get("WEBGL_USE_SHAPES_UNIFORMS"):void 0;we&&Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!1);const ke=[$.fused.conv2d({x:b3("x",W,A,V),filter:b3("filter",W,A,V),strides:[ne[1],ne[2]],pad:xe,dataFormat:le,dilations:[ce[1],ce[2]],bias:ue,activation:Me,preluActivationWeights:Te,leakyreluAlpha:Re})];return we&&Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!0),ke}case"FusedDepthwiseConv2dNative":{const{stride:ne,pad:xe,dataFormat:le,dilations:ce,biasArg:ue,preluArg:Te,activationFunc:Me,leakyreluAlpha:Re}=Pd(W,A,V);return[$.fused.depthwiseConv2d({x:b3("x",W,A,V),filter:b3("filter",W,A,V),strides:[ne[1],ne[2]],pad:xe,dataFormat:le,dilations:[ce[1],ce[2]],bias:ue,activation:Me,preluActivationWeights:Te,leakyreluAlpha:Re})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const ne=b3("outputShape",W,A,V),xe=b3("strides",W,A,V),le=b9(W,A,V);return[$.conv2dTranspose(b3("x",W,A,V),b3("filter",W,A,V),ne,[xe[1],xe[2]],le)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const ne=b3("strides",W,A,V),xe=b9(W,A,V),le=b3("dilations",W,A,V),ce=b3("dataFormat",W,A,V).toUpperCase();return[$.depthwiseConv2d(b3("input",W,A,V),b3("filter",W,A,V),[ne[1],ne[2]],xe,ce,[le[1],le[2]])]}case"Conv3D":{const ne=b3("strides",W,A,V),xe=b3("pad",W,A,V),le=b3("dataFormat",W,A,V).toUpperCase(),ce=b3("dilations",W,A,V);return[$.conv3d(b3("x",W,A,V),b3("filter",W,A,V),[ne[1],ne[2],ne[3]],xe,le,[ce[1],ce[2],ce[3]])]}case"AvgPool":{const ne=b3("strides",W,A,V),xe=b3("pad",W,A,V),le=b3("kernelSize",W,A,V);return[$.avgPool(b3("x",W,A,V),[le[1],le[2]],[ne[1],ne[2]],xe)]}case"MaxPool":{const ne=b3("strides",W,A,V),xe=b3("pad",W,A,V),le=b3("kernelSize",W,A,V);return[$.maxPool(b3("x",W,A,V),[le[1],le[2]],[ne[1],ne[2]],xe)]}case"MaxPoolWithArgmax":{const ne=b3("strides",W,A,V),xe=b3("pad",W,A,V),le=b3("kernelSize",W,A,V),ce=b3("includeBatchInIndex",W,A,V),{result:ue,indexes:Te}=$.maxPoolWithArgmax(b3("x",W,A,V),[le[1],le[2]],[ne[1],ne[2]],xe,ce);return[ue,Te]}case"AvgPool3D":{const ne=b3("strides",W,A,V),xe=b3("pad",W,A,V),le=b3("kernelSize",W,A,V);return[$.avgPool3d(b3("x",W,A,V),[le[1],le[2],le[3]],[ne[1],ne[2],ne[3]],xe)]}case"MaxPool3D":{const ne=b3("strides",W,A,V),xe=b3("pad",W,A,V),le=b3("kernelSize",W,A,V);return[$.maxPool3d(b3("x",W,A,V),[le[1],le[2],le[3]],[ne[1],ne[2],ne[3]],xe)]}case"Dilation2D":{const ne=b3("strides",W,A,V),xe=b3("pad",W,A,V),le=b3("dilations",W,A,V),ce=ne[1],ue=ne[2],Te=le[1],Me=le[2];return[$.dilation2d(b3("x",W,A,V),b3("filter",W,A,V),[ce,ue],xe,[Te,Me],"NHWC")]}default:throw TypeError("Node type "+W.op+" is not implemented")}},Pb=(W,A,V,$=P6)=>{switch(W.op){case"Fill":{const ne=b3("shape",W,A,V),xe=b3("dtype",W,A,V),le=b3("value",W,A,V);return[$.fill(ne,le,xe)]}case"LinSpace":{const ne=b3("start",W,A,V),xe=b3("stop",W,A,V),le=b3("num",W,A,V);return[$.linspace(ne,xe,le)]}case"Multinomial":{const ne=b3("logits",W,A,V),xe=b3("numSamples",W,A,V),le=b3("seed",W,A,V);return[$.multinomial(ne,xe,le)]}case"OneHot":{const ne=b3("indices",W,A,V),xe=b3("depth",W,A,V),le=b3("onValue",W,A,V),ce=b3("offValue",W,A,V),ue=b3("dtype",W,A,V);return[$.oneHot(ne,xe,le,ce,ue)]}case"Ones":return[$.ones(b3("shape",W,A,V),b3("dtype",W,A,V))];case"OnesLike":return[$.onesLike(b3("x",W,A,V))];case"RandomStandardNormal":return[$.randomStandardNormal(b3("shape",W,A,V),b3("dtype",W,A,V),b3("seed",W,A,V))];case"RandomUniform":return[$.randomUniform(b3("shape",W,A,V),b3("minval",W,A,V),b3("maxval",W,A,V),b3("dtype",W,A,V))];case"RandomUniformInt":return[$.randomUniformInt(b3("shape",W,A,V),b3("minval",W,A,V),b3("maxval",W,A,V),b3("seed",W,A,V))];case"Range":{const ne=b3("start",W,A,V),xe=b3("stop",W,A,V),le=b3("step",W,A,V);return[$.range(ne,xe,le,b3("dtype",W,A,V))]}case"TruncatedNormal":{const ne=b3("shape",W,A,V),xe=b3("mean",W,A,V),le=b3("stdDev",W,A,V),ce=b3("seed",W,A,V);return[$.truncatedNormal(ne,xe,le,b3("dtype",W,A,V),ce)]}case"Zeros":return[$.zeros(b3("shape",W,A,V),b3("dtype",W,A,V))];case"ZerosLike":return[$.zerosLike(b3("x",W,A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}};function PP(W,A,V){const $=b3("boxes",W,A,V),ne=b3("scores",W,A,V),xe=b3("maxOutputSize",W,A,V),le=b3("iouThreshold",W,A,V),ce=b3("scoreThreshold",W,A,V),ue=b3("softNmsSigma",W,A,V);return{boxes:$,scores:ne,maxOutputSize:xe,iouThreshold:le,scoreThreshold:ce,softNmsSigma:ue}}const PE=async(W,A,V,$,ne=P6)=>{switch(W.op){case"NonMaxSuppressionV5":{const{boxes:xe,scores:le,maxOutputSize:ce,iouThreshold:ue,scoreThreshold:Te,softNmsSigma:Me}=PP(W,A,V),Re=await ne.image.nonMaxSuppressionWithScoreAsync(xe,le,ce,ue,Te,Me);return[Re.selectedIndices,Re.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:xe,scores:le,maxOutputSize:ce,iouThreshold:ue,scoreThreshold:Te}=PP(W,A,V),Me=b3("padToMaxOutputSize",W,A,V),Re=await ne.image.nonMaxSuppressionPaddedAsync(xe,le,ce,ue,Te,Me);return[Re.selectedIndices,Re.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:xe,scores:le,maxOutputSize:ce,iouThreshold:ue,scoreThreshold:Te}=PP(W,A,V);return[await ne.image.nonMaxSuppressionAsync(xe,le,ce,ue,Te)]}case"Where":{const xe=ne.cast(b3("condition",W,A,V),"bool"),le=[await ne.whereAsync(xe)];return xe.dispose(),le}case"ListDiff":return ne.setdiff1dAsync(b3("x",W,A,V),b3("y",W,A,V));default:throw TypeError("Node type "+W.op+" is not implemented")}},PD=(W,A,V,$=P6)=>{switch(W.op){case"LowerBound":{const ne=b3("sortedSequence",W,A,V),xe=b3("values",W,A,V);return[$.lowerBound(ne,xe)]}case"TopKV2":{const ne=b3("x",W,A,V),xe=b3("k",W,A,V),le=b3("sorted",W,A,V),ce=$.topk(ne,xe,le);return[ce.values,ce.indices]}case"UpperBound":{const ne=b3("sortedSequence",W,A,V),xe=b3("values",W,A,V);return[$.upperBound(ne,xe)]}case"Unique":{const ne=b3("x",W,A,V),xe=$.unique(ne);return[xe.values,xe.indices]}case"UniqueV2":{const ne=b3("x",W,A,V),xe=b3("axis",W,A,V),le=$.unique(ne,xe);return[le.values,le.indices]}default:throw TypeError("Node type "+W.op+" is not implemented")}},Pg=(W,A,V,$=P6)=>{switch(W.op){case"Const":return A[W.name];case"PlaceholderWithDefault":const ne=b3("default",W,A,V);return[b4(W.name,A,V)||ne];case"Placeholder":return[b4(W.name,A,V)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const Me=b3("x",W,A,V);return[bC(Me)]}case"IdentityN":return b3("x",W,A,V).map(Me=>bC(Me));case"Snapshot":const xe=b3("x",W,A,V);return[bC(xe)];case"Shape":return[$.tensor1d(b3("x",W,A,V).shape,"int32")];case"ShapeN":return b3("x",W,A,V).map(Me=>$.tensor1d(Me.shape));case"Size":return[$.scalar(b3("x",W,A,V).size,"int32")];case"Rank":return[$.scalar(b3("x",W,A,V).rank,"int32")];case"NoOp":return[$.scalar(1)];case"Print":const le=b3("x",W,A,V),ce=b3("data",W,A,V),ue=b3("message",W,A,V),Te=b3("summarize",W,A,V);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(ue);for(let Me=0;Me<ce.length;Me++)console.log(Array.prototype.slice.call(ce[Me].dataSync()).slice(0,Te));return[le];default:throw TypeError("Node type "+W.op+" is not implemented")}};class PZ{get id(){return this.handle.id}constructor(A,V){this.keyDType=A,this.valueDType=V,this.handle=tL(0),this.tensorMap=new Map,Jh(this.handle)}clearAndClose(){this.tensorMap.forEach(A=>A.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return tL(this.size(),"int32")}async import(A,V){this.checkKeyAndValueTensor(A,V);const $=await A.data();return this.tensorMap.forEach(ne=>ne.dispose()),this.tensorMap.clear(),JY(()=>{const ne=Se(V),xe=$.length,le=ne.length;e(xe===le,()=>"The number of elements doesn't match, keys has "+xe+" elements, the values has "+le+" elements.");for(let ce=0;ce<xe;ce++){const ue=$[ce],Te=ne[ce];Jh(Te),this.tensorMap.set(ue,Te)}return this.handle})}async find(A,V){this.checkKeyAndValueTensor(A,V);const $=await A.data();return JY(()=>{const ne=[];for(let xe=0;xe<$.length;xe++){const le=$[xe],ce=this.findWithDefault(le,V);ne.push(ce)}return Sd(ne)})}findWithDefault(A,V){const $=this.tensorMap.get(A);return $??V}checkKeyAndValueTensor(A,V){if(A.dtype!==this.keyDType)throw new Error("Expect key dtype "+this.keyDType+", but got "+A.dtype);if(V.dtype!==this.valueDType)throw new Error("Expect value dtype "+this.valueDType+", but got "+V.dtype)}}const Po=async(W,A,V,$)=>{switch(W.op){case"HashTable":case"HashTableV2":{const ne=$.getHashTableHandleByName(W.name);if(ne!=null)return[ne];{const xe=b3("keyDType",W,A,V),le=b3("valueDType",W,A,V),ce=new PZ(xe,le);return $.addHashTable(W.name,ce),[ce.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const ne=b3("tableHandle",W,A,V,$),xe=b3("keys",W,A,V),le=b3("values",W,A,V);return[await $.getHashTableById(ne.id).import(xe,le)]}case"LookupTableFind":case"LookupTableFindV2":{const ne=b3("tableHandle",W,A,V,$),xe=b3("keys",W,A,V),le=b3("defaultValue",W,A,V);return[await $.getHashTableById(ne.id).find(xe,le)]}case"LookupTableSize":case"LookupTableSizeV2":{const ne=b3("tableHandle",W,A,V,$);return[$.getHashTableById(ne.id).tensorSize()]}default:throw TypeError("Node type "+W.op+" is not implemented")}},Pe=(W,A,V,$=P6)=>{switch(W.op){case"ResizeBilinear":{const ne=b3("images",W,A,V),xe=b3("size",W,A,V),le=b3("alignCorners",W,A,V),ce=b3("halfPixelCenters",W,A,V);return[$.image.resizeBilinear(ne,[xe[0],xe[1]],le,ce)]}case"ResizeNearestNeighbor":{const ne=b3("images",W,A,V),xe=b3("size",W,A,V),le=b3("alignCorners",W,A,V),ce=b3("halfPixelCenters",W,A,V);return[$.image.resizeNearestNeighbor(ne,[xe[0],xe[1]],le,ce)]}case"CropAndResize":{const ne=b3("image",W,A,V),xe=b3("boxes",W,A,V),le=b3("boxInd",W,A,V),ce=b3("cropSize",W,A,V),ue=b3("method",W,A,V),Te=b3("extrapolationValue",W,A,V);return[$.image.cropAndResize(ne,xe,le,ce,ue,Te)]}case"ImageProjectiveTransformV3":{const ne=b3("images",W,A,V),xe=b3("transforms",W,A,V),le=b3("outputShape",W,A,V),ce=b3("fillValue",W,A,V),ue=b3("interpolation",W,A,V),Te=b3("fillMode",W,A,V);return[$.image.transform(ne,xe,ue.toLowerCase(),Te.toLowerCase(),ce,le)]}default:throw TypeError("Node type "+W.op+" is not implemented")}},PQ=(W,A,V,$=P6)=>{switch(W.op){case"Equal":return[$.equal(b3("a",W,A,V),b3("b",W,A,V))];case"NotEqual":return[$.notEqual(b3("a",W,A,V),b3("b",W,A,V))];case"Greater":return[$.greater(b3("a",W,A,V),b3("b",W,A,V))];case"GreaterEqual":return[$.greaterEqual(b3("a",W,A,V),b3("b",W,A,V))];case"Less":return[$.less(b3("a",W,A,V),b3("b",W,A,V))];case"LessEqual":return[$.lessEqual(b3("a",W,A,V),b3("b",W,A,V))];case"LogicalAnd":return[$.logicalAnd(b3("a",W,A,V),b3("b",W,A,V))];case"LogicalNot":return[$.logicalNot(b3("a",W,A,V))];case"LogicalOr":return[$.logicalOr(b3("a",W,A,V),b3("b",W,A,V))];case"Select":case"SelectV2":return[$.where(b3("condition",W,A,V),b3("a",W,A,V),b3("b",W,A,V))];case"BitwiseAnd":return[$.bitwiseAnd(b3("a",W,A,V),b3("b",W,A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}},Ps=(W,A,V,$=P6)=>{switch(W.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[$.matMul(b3("a",W,A,V),b3("b",W,A,V),b3("transposeA",W,A,V),b3("transposeB",W,A,V))];case"Einsum":return[$.einsum(b3("equation",W,A,V),...b3("tensors",W,A,V))];case"Transpose":return[$.transpose(b3("x",W,A,V),b3("perm",W,A,V))];case"_FusedMatMul":const[ne,xe]=b3("fusedOps",W,A,V),le=ne==="biasadd",ce=xe==="prelu",ue=b3("numArgs",W,A,V),Te=b3("leakyreluAlpha",W,A,V);if(le){if(ce&&ue!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!ce&&ue!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[Me,Re]=b3("args",W,A,V);return[$.fused.matMul({a:b3("a",W,A,V),b:b3("b",W,A,V),transposeA:b3("transposeA",W,A,V),transposeB:b3("transposeB",W,A,V),bias:Me,activation:xe,preluActivationWeights:Re,leakyreluAlpha:Te})];case"MatrixBandPart":return[$.linalg.bandPart(b3("a",W,A,V),b3("numLower",W,A,V),b3("numUpper",W,A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}},PF=(W,A,V,$=P6)=>{switch(W.op){case"EuclideanNorm":return[$.euclideanNorm(b3("x",W,A,V),b3("axis",W,A,V),b3("keepDims",W,A,V))];case"FusedBatchNorm":case"FusedBatchNormV2":return[$.batchNorm(b3("x",W,A,V),b3("mean",W,A,V),b3("variance",W,A,V),b3("offset",W,A,V),b3("scale",W,A,V),b3("epsilon",W,A,V))];case"FusedBatchNormV3":return[$.batchNorm(b3("x",W,A,V),b3("mean",W,A,V),b3("variance",W,A,V),b3("offset",W,A,V),b3("scale",W,A,V),b3("epsilon",W,A,V))];case"LRN":return[$.localResponseNormalization(b3("x",W,A,V),b3("radius",W,A,V),b3("bias",W,A,V),b3("alpha",W,A,V),b3("beta",W,A,V))];case"Softmax":return[$.softmax(b3("x",W,A,V))];case"LogSoftmax":return[$.logSoftmax(b3("x",W,A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}},PI=(W,A,V,$=P6)=>{switch(W.op){case"RaggedGather":{const{outputNestedSplits:ne,outputDenseValues:xe}=$.raggedGather(b3("paramsNestedSplits",W,A,V),b3("paramsDenseValues",W,A,V),b3("indices",W,A,V),b3("outputRaggedRank",W,A,V));return ne.concat(xe)}case"RaggedRange":{const{rtNestedSplits:ne,rtDenseValues:xe}=$.raggedRange(b3("starts",W,A,V),b3("limits",W,A,V),b3("splits",W,A,V));return[ne,xe]}case"RaggedTensorToTensor":return[$.raggedTensorToTensor(b3("shape",W,A,V),b3("values",W,A,V),b3("defaultValue",W,A,V),b3("rowPartitionTensors",W,A,V),b3("rowPartitionTypes",W,A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}},Py=(W,A,V,$=P6)=>{switch(W.op){case"Max":{const ce=b3("axis",W,A,V),ue=b3("keepDims",W,A,V);return[$.max(b3("x",W,A,V),ce,ue)]}case"Mean":{const ce=b3("axis",W,A,V),ue=b3("keepDims",W,A,V);return[$.mean(b3("x",W,A,V),ce,ue)]}case"Min":{const ce=b3("axis",W,A,V),ue=b3("keepDims",W,A,V);return[$.min(b3("x",W,A,V),ce,ue)]}case"Sum":{const ce=b3("axis",W,A,V),ue=b3("keepDims",W,A,V);return[$.sum(b3("x",W,A,V),ce,ue)]}case"All":{const ce=b3("axis",W,A,V),ue=b3("keepDims",W,A,V);return[$.all(b3("x",W,A,V),ce,ue)]}case"Any":{const ce=b3("axis",W,A,V),ue=b3("keepDims",W,A,V);return[$.any(b3("x",W,A,V),ce,ue)]}case"ArgMax":{const ce=b3("axis",W,A,V);return[$.argMax(b3("x",W,A,V),ce)]}case"ArgMin":{const ce=b3("axis",W,A,V);return[$.argMin(b3("x",W,A,V),ce)]}case"Prod":{const ce=b3("axis",W,A,V),ue=b3("keepDims",W,A,V);return[$.prod(b3("x",W,A,V),ce,ue)]}case"Cumprod":{const ce=b3("axis",W,A,V),ue=b3("exclusive",W,A,V),Te=b3("reverse",W,A,V);return[$.cumprod(b3("x",W,A,V),ce,ue,Te)]}case"Cumsum":{const ce=b3("axis",W,A,V),ue=b3("exclusive",W,A,V),Te=b3("reverse",W,A,V);return[$.cumsum(b3("x",W,A,V),ce,ue,Te)]}case"Bincount":const ne=b3("x",W,A,V),xe=b3("weights",W,A,V),le=b3("size",W,A,V);return[$.bincount(ne,xe,le)];case"DenseBincount":{const ce=b3("x",W,A,V),ue=b3("weights",W,A,V),Te=b3("size",W,A,V),Me=b3("binaryOutput",W,A,V);return[$.denseBincount(ce,ue,Te,Me)]}default:throw TypeError("Node type "+W.op+" is not implemented")}},PA=(W,A,V,$=P6)=>{switch(W.op){case"ConcatV2":case"Concat":{const ne=b3("n",W,A,V),xe=b3("axis",W,A,V);let le=b3("tensors",W,A,V);return le=le.slice(0,ne),[$.concat(le,xe)]}case"Gather":{const ne=b3("x",W,A,V),xe=b3("indices",W,A,V);return[$.gather(ne,$.cast(xe,"int32"),0)]}case"GatherV2":{const ne=b3("axis",W,A,V),xe=b3("batchDims",W,A,V),le=b3("x",W,A,V),ce=b3("indices",W,A,V);return[$.gather(le,$.cast(ce,"int32"),ne,xe)]}case"Reverse":{const ne=b3("dims",W,A,V),xe=[];for(let ce=0;ce<ne.length;ce++)ne[ce]&&xe.push(ce);const le=b3("x",W,A,V);return[$.reverse(le,xe)]}case"ReverseV2":{const ne=b3("axis",W,A,V),xe=b3("x",W,A,V);return[$.reverse(xe,ne)]}case"Slice":{const ne=b3("begin",W,A,V),xe=b3("size",W,A,V);return[$.slice(b3("x",W,A,V),ne,xe)]}case"StridedSlice":{const ne=b3("begin",W,A,V),xe=b3("end",W,A,V),le=b3("strides",W,A,V),ce=b3("beginMask",W,A,V),ue=b3("endMask",W,A,V),Te=b3("ellipsisMask",W,A,V),Me=b3("newAxisMask",W,A,V),Re=b3("shrinkAxisMask",W,A,V),we=b3("x",W,A,V);return[$.stridedSlice(we,ne,xe,le,ce,ue,Te,Me,Re)]}case"Pack":return JY(()=>{const ne=b3("axis",W,A,V),xe=b3("tensors",W,A,V),le=xe[0].shape,ce=$.squeeze(xe[0]).shape,ue=xe.map(Te=>{const Me=X(Te.shape,le);if(!Me&&!X($.squeeze(Te).shape,ce))throw new Error("the input tensors shape does not match");return Me?Te:$.reshape(Te,le)});return[$.stack(ue,ne)]});case"Unpack":{const ne=b3("axis",W,A,V),xe=b3("tensor",W,A,V);return $.unstack(xe,ne)}case"Tile":{const ne=b3("reps",W,A,V);return[$.tile(b3("x",W,A,V),ne)]}case"Split":case"SplitV":{const ne=b3("axis",W,A,V),xe=b3("numOrSizeSplits",W,A,V),le=b3("x",W,A,V);return $.split(le,xe,ne)}case"ScatterNd":{const ne=b3("indices",W,A,V),xe=b3("values",W,A,V),le=b3("shape",W,A,V);return[$.scatterND(ne,xe,le)]}case"GatherNd":{const ne=b3("x",W,A,V),xe=b3("indices",W,A,V);return[$.gatherND(ne,xe)]}case"SparseToDense":{const ne=b3("sparseIndices",W,A,V),xe=b3("outputShape",W,A,V),le=b3("sparseValues",W,A,V),ce=b3("defaultValue",W,A,V);return[$.sparseToDense(ne,le,xe,le.dtype===ce.dtype?ce:$.cast(ce,le.dtype))]}case"TensorScatterUpdate":{const ne=b3("indices",W,A,V),xe=b3("values",W,A,V),le=b3("tensor",W,A,V);return[$.tensorScatterUpdate(le,ne,xe)]}default:throw TypeError("Node type "+W.op+" is not implemented")}},Pp=(W,A,V,$=P6)=>{switch(W.op){case"SparseFillEmptyRows":{const{outputIndices:ne,outputValues:xe,emptyRowIndicator:le,reverseIndexMap:ce}=$.sparse.sparseFillEmptyRows(b3("indices",W,A,V),b3("values",W,A,V),b3("denseShape",W,A,V),b3("defaultValue",W,A,V));return[ne,xe,le,ce]}case"SparseReshape":{const{outputIndices:ne,outputShape:xe}=$.sparse.sparseReshape(b3("inputIndices",W,A,V),b3("inputShape",W,A,V),b3("newShape",W,A,V));return[ne,xe]}case"SparseSegmentMean":return[$.sparse.sparseSegmentMean(b3("data",W,A,V),b3("indices",W,A,V),b3("segmentIds",W,A,V))];case"SparseSegmentSum":return[$.sparse.sparseSegmentSum(b3("data",W,A,V),b3("indices",W,A,V),b3("segmentIds",W,A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}},Pw=(W,A,V,$=P6)=>{switch(W.op){case"FFT":return[$.fft(b3("x",W,A,V))];case"IFFT":return[$.ifft(b3("x",W,A,V))];case"RFFT":return[$.rfft(b3("x",W,A,V))];case"IRFFT":return[$.irfft(b3("x",W,A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}},PX=(W,A,V,$=P6)=>{switch(W.op){case"StaticRegexReplace":return[$.string.staticRegexReplace(b3("input",W,A,V),b3("pattern",W,A,V),b3("rewrite",W,A,V),b3("replaceGlobal",W,A,V))];case"StringNGrams":{const{nGrams:ne,nGramsSplits:xe}=$.string.stringNGrams(b3("data",W,A,V),b3("dataSplits",W,A,V),b3("separator",W,A,V),b3("nGramWidths",W,A,V),b3("leftPad",W,A,V),b3("rightPad",W,A,V),b3("padWidth",W,A,V),b3("preserveShortSequences",W,A,V));return[ne,xe]}case"StringSplit":{const{indices:ne,values:xe,shape:le}=$.string.stringSplit(b3("input",W,A,V),b3("delimiter",W,A,V),b3("skipEmpty",W,A,V));return[ne,xe,le]}case"StringToHashBucketFast":return[$.string.stringToHashBucketFast(b3("input",W,A,V),b3("numBuckets",W,A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}},Pc=(W,A,V,$=P6)=>{switch(W.op){case"Cast":return[$.cast(b3("x",W,A,V),b3("dtype",W,A,V))];case"ExpandDims":{const ne=b3("axis",W,A,V);return[$.expandDims(b3("x",W,A,V),ne)]}case"Squeeze":{const ne=b3("axis",W,A,V);return[$.squeeze(b3("x",W,A,V),ne)]}case"Reshape":return[$.reshape(b3("x",W,A,V),b3("shape",W,A,V))];case"EnsureShape":return[$.ensureShape(b3("x",W,A,V),b3("shape",W,A,V))];case"MirrorPad":return[$.mirrorPad(b3("x",W,A,V),b3("padding",W,A,V),b3("mode",W,A,V))];case"PadV2":case"Pad":return[$.pad(b3("x",W,A,V),b3("padding",W,A,V),b3("constantValue",W,A,V))];case"SpaceToBatchND":{const ne=b3("blockShape",W,A,V),xe=b3("paddings",W,A,V);return[$.spaceToBatchND(b3("x",W,A,V),ne,xe)]}case"BatchToSpaceND":{const ne=b3("blockShape",W,A,V),xe=b3("crops",W,A,V);return[$.batchToSpaceND(b3("x",W,A,V),ne,xe)]}case"DepthToSpace":{const ne=b3("blockSize",W,A,V),xe=b3("dataFormat",W,A,V).toUpperCase();return[$.depthToSpace(b3("x",W,A,V),ne,xe)]}case"BroadcastTo":return[$.broadcastTo(b3("x",W,A,V),b3("shape",W,A,V))];case"BroadcastArgs":return[$.broadcastArgs(b3("s0",W,A,V),b3("s1",W,A,V))];default:throw TypeError("Node type "+W.op+" is not implemented")}};function PW(W,A,V,$,ne=JY){const xe=((le,ce,ue)=>{switch(le.category){case"arithmetic":return ne(()=>P7(le,ce,ue));case"basic_math":return ne(()=>P8(le,ce,ue));case"control":return PS(le,ce,ue);case"convolution":return ne(()=>PV(le,ce,ue));case"creation":return ne(()=>Pb(le,ce,ue));case"dynamic":return PE(le,ce,ue);case"evaluation":return ne(()=>PD(le,ce,ue));case"image":return ne(()=>Pe(le,ce,ue));case"graph":return ne(()=>Pg(le,ce,ue));case"logical":return ne(()=>PQ(le,ce,ue));case"matrices":return ne(()=>Ps(le,ce,ue));case"normalization":return ne(()=>PF(le,ce,ue));case"ragged":return ne(()=>PI(le,ce,ue));case"reduction":return ne(()=>Py(le,ce,ue));case"slice_join":return ne(()=>PA(le,ce,ue));case"sparse":return ne(()=>Pp(le,ce,ue));case"spectral":return ne(()=>Pw(le,ce,ue));case"string":return ne(()=>PX(le,ce,ue));case"transformation":return ne(()=>Pc(le,ce,ue));case"hash_table":return Po(le,ce,ue,$);case"custom":const Te=b2(le.op);if(Te&&Te.customExecutor)return Te.customExecutor(new P3(le,ce,ue));throw TypeError("Custom op "+le.op+" is not registered.");default:throw TypeError("Unknown op '"+le.op+"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(W,A,V);return Cf(xe)?xe.then(le=>[].concat(le)):[].concat(xe)}class PR{constructor(A={},V={},$={},ne={},xe){this.weightMap=A,this.tensorArrayMap=V,this.tensorListMap=$,this.functionMap=ne,this.parseNodeNameCache=xe,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(A,V){return{id:A,frameName:V,iterationId:0}}set currentContext(A){this.contexts!==A&&(this.contexts=A,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const A=[];for(let V=0;V<this.contexts.length-1;V++){const $=this.contexts.slice(0,this.contexts.length-V);A.push(this.contextIdforContexts($))}A.push(""),this._currentContextIds=A}contextIdforContexts(A){return A?A.map(V=>V.id===0&&V.iterationId===0?"":V.frameName+"-"+V.iterationId).join("/"):""}enterFrame(A){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,A)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const A=Object.assign({},this.contexts[this.contexts.length-1]);A.iterationId+=1,A.id=this.lastId,this.contexts.splice(-1,1,A),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(A){return this.weightMap[A]}addTensorArray(A){this.tensorArrayMap[A.id]=A}getTensorArray(A){return this.tensorArrayMap[A]}addTensorList(A){this.tensorListMap[A.id]=A}getTensorList(A){return this.tensorListMap[A]}dispose(A){for(const V in this.tensorArrayMap)this.tensorArrayMap[V].clearAndClose(A);for(const V in this.tensorListMap)this.tensorListMap[V].clearAndClose(A)}}function PK(W,A,V,$){const ne=new Set,xe=[];let le=null,ce=null;const ue=new Set,Te=new Set(Object.keys(W).map(we=>b8(we)[0]));$=$||[];const Me=new Set($.map(we=>b8(we.name)[0])),Re=[...A];for(;Re.length>0;){const we=Re.pop();if((Pk(we)||Pz(we)||Px(we))&&le==null&&(le=we,ce=le.children.map(ke=>ke.name).filter(ke=>ne.has(ke))),ne.add(we.name),V[we.name]==null&&!Te.has(we.name)&&!Me.has(we.name)){if(we.inputs.length===0){xe.push(we.name);continue}we.inputs.forEach(ke=>{ue.has(ke.name)||(ue.add(ke.name),Re.push(ke))})}}return{inputs:W,outputs:A,usedNodes:ne,missingInputs:xe,dynamicNode:le,syncInputs:ce}}function PT(W,A){const{usedNodes:V,inputs:$}=A,ne=Object.keys($).map(We=>b8(We)[0]).map(We=>W.nodes[We]),xe=W.initNodes||[],le=We=>V.has(typeof We=="string"?We:We.name);function ce(We){return[...new Map(We.map(Xe=>[Xe.name,Xe])).values()]}const ue=ce([...ne,...W.weights,...xe]).filter(le),Te=ce([...ue,...Object.values(W.nodes)]).filter(le),Me=new Map(Te.map(We=>[We.name,We])),Re={};for(const We of Te){Re[We.name]=Re[We.name]||0;for(const Xe of We.children)le(Xe)||(Re[Xe.name]=Number.POSITIVE_INFINITY),Re[Xe.name]=(Re[Xe.name]||0)+1}const we=Object.entries(Re).filter(([,We])=>We===0).map(([We])=>We),ke=[...we];for(;we.length>0;){const We=we.pop(),Xe=Me.get(We);for(const Ye of Xe.children.filter(le))--Re[Ye.name]===0&&(ke.push(Ye.name),we.push(Ye.name))}const Ue=ke.map(We=>Me.get(We)),Ge=Pv(Ue,ue);return Pl(Ge,ue),Ge}function Pv(W,A){const V=new Map(W.map(xe=>[xe.name,xe])),$=A.map(xe=>xe.name),ne=new Set($);for(;$.length>0;){const xe=$.pop(),le=V.get(xe);for(const ce of le.children)!V.has(ce.name)||ne.has(ce.name)||(ne.add(ce.name),$.push(ce.name))}return W.filter(xe=>ne.has(xe.name))}class Pq extends Error{constructor(A){super("NodesExecutionOrderError: "+A)}}function Pl(W,A){const V=new Map(W.map((ce,ue)=>[ce.name,ue])),$=new Set(A.map(ce=>ce.name)),ne=ce=>$.has(typeof ce=="string"?ce:ce.name),xe=new Set(W.map(ce=>ce.name)),le=ce=>xe.has(typeof ce=="string"?ce:ce.name);for(const ce of W){for(const ue of ce.children.filter(le)){if(!V.has(ue.name))throw new Pq("Child "+ue.name+" of node "+ce.name+" is unreachable.");if(V.get(ce.name)>V.get(ue.name))throw new Pq("Node "+ce.name+" is scheduled to run after its child "+ue.name+".")}if(!ne(ce))for(const ue of ce.inputs){if(!V.has(ue.name))throw new Pq("Input "+ue.name+" of node "+ce.name+" is unreachable.");if(V.get(ue.name)>V.get(ce.name))throw new Pq("Node "+ce.name+" is scheduled to run before its input "+ue.name+".")}}}function Pa(W){const A=new Map(W.map((ce,ue)=>[ce.name,ue])),V=Number.MAX_SAFE_INTEGER,$=W.map((ce,ue)=>Pk(ce)?V:ue),ne=ce=>{const ue=$[A.get(ce.name)];return ue??-1},xe=W.map((ce,ue)=>ce.children.map(ne).reduce((Te,Me)=>Math.max(Te,Me),$[ue])),le=new Map;for(let ce=0;ce<W.length;++ce){const ue=xe[ce];if(ue===V)continue;const Te=W[ce],Me=W[ue];le.has(Me.name)||le.set(Me.name,[]),le.get(Me.name).push(Te)}return le}const Pn=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),PL=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),PH=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Pk(W){return Pn.has(W.op)}function Pz(W){return PL.has(W.op)}function Px(W){return PH.has(W.op)}class PU{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(A){const V=Object.keys(A).map($=>A[$].map(ne=>ne.id));this._weightIds=[].concat(...V),this._weightMap=A}set resourceManager(A){this._resourceManager=A}get inputs(){return this._inputs.map(A=>({name:A.name,shape:A.attrParams.shape?A.attrParams.shape.value:void 0,dtype:A.attrParams.dtype?A.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(A=>({name:A.name,shape:A.attrParams.shape?A.attrParams.shape.value:void 0,dtype:A.attrParams.dtype?A.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(A=>A.signatureKey||A.name)}get outputNodes(){return this._outputs.map(A=>{const V=A.signatureKey||A.name;return A.defaultOutput?V+":"+A.defaultOutput:V})}get functions(){return Object.keys(this._functions).reduce((A,V)=>(A[V]=this._functions[V].signature,A),{})}constructor(A,V){this.graph=A,this.parent=V,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=A.outputs,this._inputs=A.inputs,this._initNodes=A.initNodes,this._signature=A.signature,this._functions=A.functions,A.functions!=null&&Object.keys(A.functions).forEach($=>{this._functionExecutorMap[$]=new PU(A.functions[$],this)})}getCompilationKey(A,V){const $=A.map(xe=>xe.name).sort(),ne=V.map(xe=>xe.name).sort();return $.join(this.SEPARATOR)+"--"+ne.join(this.SEPARATOR)}compile(A,V){const $=PK(A,V,this.weightMap,this._initNodes),{missingInputs:ne,dynamicNode:xe,syncInputs:le}=$;if(xe!=null)throw new Error("This execution contains the node '"+xe.name+"', which has the dynamic op '"+xe.op+"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs ["+le+"]");if(ne.length>0){const Te=V.map(Re=>Re.name),Me=Object.keys(A);throw new Error("Cannot compute the outputs ["+Te+"] from the provided inputs ["+Me+"]. Missing the following inputs: ["+ne+"]")}const ce=PT(this.graph,$),ue=Pa(ce);return{orderedNodes:ce,nodeLiveUntilMap:ue}}cloneAndKeepTensor(A){if(A==null)return null;const V=A.clone();return Jh(V),V}cloneTensorList(A){return A?A.map(V=>this.cloneAndKeepTensor(V)):null}cloneTensorMap(A){return Object.fromEntries(Object.entries(A).map(([V,$])=>[V,this.cloneTensorList($)]))}execute(A,V){this.disposeIntermediateTensors(),A=this.mapInputs(A);const $=Object.keys(A).sort();this.checkInputs(A),this.checkInputShapeAndType(A),V=this.mapOutputs(V),this.checkOutputs(V);const ne=$.map(we=>this.graph.nodes[b8(we)[0]]),xe=V.map(we=>b8(we)[0]),le=new Set(xe);let ce=xe.map(we=>this.graph.nodes[we]);ce.length===0&&(ce=this._outputs);const ue=this.getCompilationKey(ne,ce);let Te=this.compiledMap.get(ue);Te==null&&(Te=this.compile(A,ce),this.compiledMap.set(ue,Te));try{this.keepIntermediateTensors=Cd().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(we){this.keepIntermediateTensors=!1,console.warn(we.message)}const Me={},Re={};return JY(()=>{const we=new PR(this.weightMap,Me,Re,this.functionExecutorMap,this.parseNodeNameCache),ke=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(A).forEach(Xe=>{const[Ye,je]=b8(Xe,we),Ke=[];Ke[je]=A[Xe],ke[Ye]=Ke,this.keepIntermediateTensors&&(this.clonedTensorsMap[Ye]=this.cloneTensorList(Ke))});const Ue=this.getFrozenTensorIds(ke),{orderedNodes:Ge,nodeLiveUntilMap:We}=Te;for(const Xe of Ge){if(ke[Xe.name])continue;const Ye=PW(Xe,ke,we,this._resourceManager);if(Cf(Ye))throw new Error("The execution of the op '"+Xe.op+"' returned a promise. Please use model.executeAsync() instead.");ke[Xe.name]=Ye,this.keepIntermediateTensors&&(this.clonedTensorsMap[Xe.name]=this.cloneTensorList(Ye)),this.checkTensorForDisposalWithNodeLiveUntilInfo(Xe,ke,we,Ue,le,We.get(Xe.name))}return this.parent==null&&we.dispose(Ue),V.map(Xe=>b4(Xe,ke,we))})}getFrozenTensorIds(A){const V=[].concat.apply([],Object.keys(A).map($=>A[$]).map($=>$.map(ne=>ne.id)));return new Set(V)}checkTensorForDisposal(A,V,$,ne,xe,le,ce){if(!(Pk(V)||le.has(A))){for(const ue of $[A])ue!=null&&(ce[ue.id]=(ce[ue.id]||0)+V.children.length);for(const ue of V.inputs){if(Pk(ue))continue;const Te=b5(ue.name,$,ne);if(Te!=null)for(const Me of Te){if(!Me||Me.kept||xe.has(Me.id))continue;const Re=ce[Me.id];Re===1?(Me.dispose(),delete ce[Me.id]):Re!=null&&ce[Me.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(A,V,$,ne,xe,le){function ce(ue){return Pk(ue)||xe.has(ue.name)}if(!(Pk(A)||le==null))for(const ue of le){if(ce(ue))continue;const Te=b5(ue.name,V,$);for(const Me of Te)!Me||Me.kept||ne.has(Me.id)||Me.dispose()}}async executeAsync(A,V){return this._executeAsync(A,V)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(A=>{for(const V of A)V&&!V.isDisposed&&V.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(A,V,$=!1,ne={},xe={}){this.disposeIntermediateTensors(),$||(A=this.mapInputs(A),this.checkInputs(A),this.checkInputShapeAndType(A),V=this.mapOutputs(V),this.checkOutputs(V));try{this.keepIntermediateTensors=Cd().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(we){this.keepIntermediateTensors=!1,console.warn(we.message)}const le=new PR(this.weightMap,ne,xe,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const ce=await this.executeWithControlFlow(A,le,V,$),ue=V.map(we=>b4(we,ce,le)),Te=ue.map(we=>we.id),Me=Object.keys(A).map(we=>A[we].id),Re=new Set([...Te,...Me,...this.weightIds]);return Object.values(ce).forEach(we=>{we.forEach(ke=>{ke&&!ke.isDisposed&&!Re.has(ke.id)&&ke.dispose()})}),this.parent==null&&le.dispose(Re),ue}async executeFunctionAsync(A,V,$){const ne=A.reduce((xe,le,ce)=>(xe[this.inputs[ce].name]=le,xe),{});return this._executeAsync(ne,this.outputNodes,!0,V,$)}async executeWithControlFlow(A,V,$,ne){const xe=Object.keys(A),le=xe.map(Ke=>this.graph.nodes[b8(Ke)[0]]),ce=$.map(Ke=>b8(Ke)[0]),ue=new Set(ce);let Te=ce.map(Ke=>this.graph.nodes[Ke]);Te.length===0&&(Te=this._outputs);const{usedNodes:Me,missingInputs:Re,dynamicNode:we,syncInputs:ke}=PK(A,Te,this.weightMap,this._initNodes),Ue=[...le,...this.graph.weights,...this._initNodes||[]].map(Ke=>({node:Ke,contexts:V.currentContext})),Ge=Object.assign({},this.weightMap);Object.keys(A).forEach(Ke=>{const[qe,$e]=b8(Ke),vt=[];vt[$e]=A[Ke],Ge[qe]=vt});const We={},Xe=this.getFrozenTensorIds(Ge),Ye={};for(;Ue.length>0;){const Ke=this.processStack(le,Ue,V,Ge,Ye,Xe,ue,We,Me);await Promise.all(Ke)}we==null&&!ne&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const je=Te.filter(Ke=>!Pk(Ke)&&!b4(Ke.name,Ge,V)).map(Ke=>Ke.name);if(je.length>0){let Ke="";throw we!=null&&(Ke="Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs ["+ke+"]"),new Error("Cannot compute the outputs ["+je+"] from the provided inputs ["+xe+"]. Consider providing the following inputs: ["+Re+"]. "+Ke)}return Ge}processStack(A,V,$,ne,xe,le,ce,ue,Te){const Me=[];for(;V.length>0;){const Re=V.pop();$.currentContext=Re.contexts;let we="";if(Re.node.op==="Enter"&&b3("isConstant",Re.node,ne,$)&&([we]=b6(Re.node.name,$)),ne[Re.node.name]==null){const ke=PW(Re.node,ne,$,this._resourceManager);we||([we]=b6(Re.node.name,$));const Ue=$.currentContext;Cf(ke)?Me.push(ke.then(Ge=>(ne[we]=Ge,this.keepIntermediateTensors&&(this.clonedTensorsMap[we]=this.cloneTensorList(Ge)),$.currentContext=Ue,this.checkTensorForDisposal(we,Re.node,ne,$,le,ce,ue),this.processChildNodes(Re.node,V,$,ne,xe,Te),Ge))):(ne[we]=ke,this.keepIntermediateTensors&&(this.clonedTensorsMap[we]=this.cloneTensorList(ke)),this.checkTensorForDisposal(we,Re.node,ne,$,le,ce,ue),this.processChildNodes(Re.node,V,$,ne,xe,Te))}else this.processChildNodes(Re.node,V,$,ne,xe,Te)}return Me}processChildNodes(A,V,$,ne,xe,le){A.children.forEach(ce=>{const[ue]=b6(ce.name,$);xe[ue]||!le.has(ce.name)||(ce.op==="Merge"?ce.inputNames.some(Te=>!!b4(Te,ne,$))&&(xe[ue]=!0,V.push({contexts:$.currentContext,node:ce})):ce.inputNames.every(Te=>!!b4(Te,ne,$))&&(xe[ue]=!0,V.push({contexts:$.currentContext,node:ce})))})}dispose(){Object.keys(this.weightMap).forEach(A=>this.weightMap[A].forEach(V=>V.dispose()))}checkInputShapeAndType(A){Object.keys(A).forEach(V=>{const $=A[V],[ne]=b8(V),xe=this.graph.nodes[ne];if(xe.attrParams.shape&&xe.attrParams.shape.value){const le=xe.attrParams.shape.value,ce=le.length===$.shape.length&&$.shape.every((ue,Te)=>le[Te]===-1||le[Te]===ue);e(ce,()=>"The shape of dict['"+xe.name+"'] provided in model.execute(dict) must be ["+le+"], but was ["+$.shape+"]")}xe.attrParams.dtype&&xe.attrParams.dtype.value&&e($.dtype===xe.attrParams.dtype.value,()=>"The dtype of dict['"+xe.name+"'] provided in model.execute(dict) must be "+xe.attrParams.dtype.value+", but was "+$.dtype)})}mapInputs(A){var V,$;const ne={};for(const xe in A){const le=($=(V=this._signature)===null||V===void 0?void 0:V.inputs)===null||$===void 0?void 0:$[xe];le!=null?ne[le.name]=A[xe]:ne[xe]=A[xe]}return ne}checkInputs(A){const V=Object.keys(A).filter($=>{const[ne]=b8($);return this.graph.nodes[ne]==null});if(V.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+V+"] that are not part of graph")}mapOutputs(A){return A.map(V=>{var $,ne;const xe=(ne=($=this._signature)===null||$===void 0?void 0:$.outputs)===null||ne===void 0?void 0:ne[V];return xe!=null?xe.name:V},{})}checkOutputs(A){A.forEach(V=>{const[$]=b8(V);if(!this.graph.nodes[$])throw new Error("The output '"+V+"' is not found in the graph")})}}class PG{constructor(A={},V={}){this.hashTableNameToHandle=A,this.hashTableMap=V}addHashTable(A,V){this.hashTableNameToHandle[A]=V.handle,this.hashTableMap[V.id]=V}getHashTableHandleByName(A){return this.hashTableNameToHandle[A]}getHashTableById(A){return this.hashTableMap[A]}dispose(){for(const A in this.hashTableMap)this.hashTableMap[A].clearAndClose(),delete this.hashTableMap[A];for(const A in this.hashTableNameToHandle)this.hashTableNameToHandle[A].dispose(),delete this.hashTableNameToHandle[A]}}const Pu="?tfjs-format=file",PY="model.json";class PM{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(A,V={},$=iy){this.modelUrl=A,this.loadOptions=V,this.version="n/a",this.io=$,V==null&&(this.loadOptions={}),this.resourceManager=new PG}findIOHandler(){const A=this.modelUrl;if(A.load!=null)this.handler=A;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(A,this.loadOptions);else{const V=this.io.getLoadHandlers(A,this.loadOptions);if(V.length===0)V.push(this.io.browserHTTPRequest(A,this.loadOptions));else if(V.length>1)throw new Error("Found more than one ("+V.length+") load handlers for URL '"+[A]+"'");this.handler=V[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const A=this.handler.load();return Cf(A)?A.then(V=>V.getWeightStream==null?this.loadSync(V):this.loadStreaming(V)):this.loadSync(A)}loadSync(A){const V=this.io.decodeWeights(A.weightData,A.weightSpecs);return this.loadWithWeightMap(A,V)}async loadStreaming(A){if(A.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const V=await f9(A.getWeightStream(),A.weightSpecs);return this.loadWithWeightMap(A,V)}loadWithWeightMap(A,V){this.artifacts=A;const $=this.artifacts.modelTopology;let ne=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const xe=this.artifacts.userDefinedMetadata;xe.signature!=null&&(ne=xe.signature),xe.structuredOutputKeys!=null&&(this.structuredOutputKeys=xe.structuredOutputKeys)}if(this.signature=ne,this.version=$.versions.producer+"."+$.versions.minConsumer,this.executor=new PU(bL.Instance.transformGraph($,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(V),this.executor.resourceManager=this.resourceManager,A.modelInitializer!=null&&A.modelInitializer.node!=null){const xe=bL.Instance.transformGraph(A.modelInitializer);this.initializer=new PU(xe),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=A.initializerSignature}return!0}async save(A,V){if(typeof A=="string"){const $=this.io.getSaveHandlers(A);if($.length===0)throw new Error("Cannot find any save handlers for URL '"+A+"'");if($.length>1)throw new Error("Found more than one ("+$.length+") save handlers for URL '"+A+"'");A=$[0]}if(A.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return A.save(this.artifacts)}addStructuredOutputNames(A){if(this.structuredOutputKeys){const V=A instanceof JJ?[A]:A,$={};return V.forEach((ne,xe)=>$[this.structuredOutputKeys[xe]]=ne),$}return A}predict(A,V){const $=this.execute(A,this.outputNodes);return this.addStructuredOutputNames($)}async predictAsync(A,V){const $=await this.executeAsync(A,this.outputNodes);return this.addStructuredOutputNames($)}normalizeInputs(A){var V;if(!(A instanceof JJ)&&!Array.isArray(A)){const xe=(V=this.signature)===null||V===void 0?void 0:V.inputs;if(xe!=null)for(const le in xe){const ce=xe[le];ce.resourceId!=null&&(A[le]=this.resourceIdToCapturedInput[ce.resourceId])}return A}A=Array.isArray(A)?A:[A];const $=Object.keys(this.resourceIdToCapturedInput).length;if(A.length+$!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has "+(this.inputNodes.length-$)+" non-resource placeholders, while there are "+A.length+" input tensors provided.");let ne=0;return this.inputNodes.reduce((xe,le)=>{var ce,ue,Te;const Me=(Te=(ue=(ce=this.signature)===null||ce===void 0?void 0:ce.inputs)===null||ue===void 0?void 0:ue[le])===null||Te===void 0?void 0:Te.resourceId;return Me!=null?xe[le]=this.resourceIdToCapturedInput[Me]:xe[le]=A[ne++],xe},{})}normalizeOutputs(A){return A=A||this.outputNodes,Array.isArray(A)?A:[A]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(A){if(this.resourceIdToCapturedInput={},this.initializerSignature){const V=this.initializerSignature.outputs,$=Object.keys(V);for(let ne=0;ne<$.length;ne++){const xe=$[ne],le=V[xe];this.resourceIdToCapturedInput[le.resourceId]=A[ne]}}}execute(A,V){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),A=this.normalizeInputs(A),V=this.normalizeOutputs(V);const $=this.executor.execute(A,V);return $.length>1?$:$[0]}async executeAsync(A,V){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),A=this.normalizeInputs(A),V=this.normalizeOutputs(V);const $=await this.executor.executeAsync(A,V);return $.length>1?$:$[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(A){return Object.keys(A).reduce((V,$)=>(V[$]=[A[$]],V),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&JM(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Ph(W,A={},V=iy){if(W==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");A==null&&(A={}),A.fromTFHub&&typeof W=="string"&&(W=Pj(W));const $=new PM(W,A,V);return await $.load(),$}function Pj(W){return W.endsWith("/")||(W=W+"/"),""+W+PY+Pu}const Pr={},E0={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function E1(W,A){Pr[W]=A}function E2(W,A){if(!(W in Pr)||A!=null){const $=E4(W,A);if($!==null)Pr[W]=$;else return console.log("Could not get context for WebGL version",W),null}const V=Pr[W];return V==null||V.isContextLost()?(delete Pr[W],E2(W)):(V.disable(V.DEPTH_TEST),V.disable(V.STENCIL_TEST),V.disable(V.BLEND),V.disable(V.DITHER),V.disable(V.POLYGON_OFFSET_FILL),V.disable(V.SAMPLE_COVERAGE),V.enable(V.SCISSOR_TEST),V.enable(V.CULL_FACE),V.cullFace(V.BACK),Pr[W])}function E3(W){if(!Cd().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&W===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function E4(W,A){if(W!==1&&W!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const V=A??E3(W);return V.addEventListener("webglcontextlost",$=>{$.preventDefault(),delete Pr[W]},!1),Cd().getBool("SOFTWARE_WEBGL_ENABLED")&&(E0.failIfMajorPerformanceCaveat=!1),W===1?V.getContext("webgl",E0)||V.getContext("experimental-webgl",E0):V.getContext("webgl2",E0)}var E5;(function(W){W[W.DENSE=0]="DENSE",W[W.SHARED_BATCH=1]="SHARED_BATCH"})(E5||(E5={}));var E6;(function(W){W[W.RENDER=0]="RENDER",W[W.UPLOAD=1]="UPLOAD",W[W.PIXELS=2]="PIXELS",W[W.DOWNLOAD=3]="DOWNLOAD"})(E6||(E6={}));var E7;(function(W){W[W.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",W[W.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",W[W.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",W[W.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",W[W.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(E7||(E7={}));function E8(W,A){return[A,W]}function E9(W,A){return W*A}function EC(W){const A=F(W),V=Math.ceil(A/4);return K(V)}function Em(W,A){return[Math.max(1,Math.ceil(A/2)),Math.max(1,Math.ceil(W/2))]}function EN(W,A){const[V,$]=Em(W,A);return V*$*4}function EJ(W,A){const V=W;let $,ne,xe,le,ce,ue,Te,Me,Re,we;return Cd().getNumber("WEBGL_VERSION")===2?($=V.R32F,ne=V.R16F,xe=V.RGBA16F,le=V.RGBA32F,ce=V.RED,Te=4,Me=1,Re=V.HALF_FLOAT,we=V.FLOAT,ue=V.RGBA8):($=W.RGBA,ne=W.RGBA,xe=W.RGBA,le=V.RGBA,ce=W.RGBA,Te=4,Me=4,Re=A!=null?A.HALF_FLOAT_OES:null,we=W.FLOAT,ue=W.RGBA),{internalFormatFloat:$,internalFormatHalfFloat:ne,internalFormatPackedHalfFloat:xe,internalFormatPackedFloat:le,textureFormatFloat:ce,downloadTextureFormat:ue,downloadUnpackNumChannels:Te,defaultNumChannels:Me,textureTypeHalfFloat:Re,textureTypeFloat:we}}function Ef(W,A){const V=A();return Cd().getBool("DEBUG")&&Ei(W),V}function Ei(W){const A=W.getError();if(A!==W.NO_ERROR)throw new Error("WebGL Error: "+ES(W,A))}const EO=596e-10,Et=65504;function EB(W){return!!(Cd().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||W===0||EO<Math.abs(W)&&Math.abs(W)<Et)}function ES(W,A){switch(A){case W.NO_ERROR:return"NO_ERROR";case W.INVALID_ENUM:return"INVALID_ENUM";case W.INVALID_VALUE:return"INVALID_VALUE";case W.INVALID_OPERATION:return"INVALID_OPERATION";case W.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case W.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case W.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+A}}function Ed(W,A){return EK(W,()=>W.getExtension(A),'Extension "'+A+'" not supported on this browser.')}function EV(W,A){const V=EK(W,()=>W.createShader(W.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ef(W,()=>W.shaderSource(V,A)),Ef(W,()=>W.compileShader(V)),W.getShaderParameter(V,W.COMPILE_STATUS)===!1)throw console.log(W.getShaderInfoLog(V)),new Error("Failed to compile vertex shader.");return V}function Eb(W,A){const V=EK(W,()=>W.createShader(W.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ef(W,()=>W.shaderSource(V,A)),Ef(W,()=>W.compileShader(V)),Cd().get("ENGINE_COMPILE_ONLY"))return V;if(W.getShaderParameter(V,W.COMPILE_STATUS)===!1)throw EE(A,W.getShaderInfoLog(V)),new Error("Failed to compile fragment shader.");return V}const EP=/ERROR: [0-9]+:([0-9]+):/g;function EE(W,A){const V=EP.exec(A);if(V==null){console.log("Couldn't parse line number in error: "+A),console.log(W);return}const $=+V[1],ne=W.split(`
`),xe=ne.length.toString().length+2,le=ne.map((Re,we)=>T((we+1).toString(),xe)+Re);let ce=0;for(let Re=0;Re<le.length;Re++)ce=Math.max(le[Re].length,ce);const ue=le.slice(0,$-1),Te=le.slice($-1,$),Me=le.slice($);console.log(ue.join(`
`)),console.log(A.split(`
`)[0]),console.log("%c "+T(Te[0],ce),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(Me.join(`
`))}function ED(W){return EK(W,()=>W.createProgram(),"Unable to create WebGLProgram.")}function Eg(W,A){if(Ef(W,()=>W.linkProgram(A)),!Cd().get("ENGINE_COMPILE_ONLY")&&W.getProgramParameter(A,W.LINK_STATUS)===!1)throw console.log(W.getProgramInfoLog(A)),new Error("Failed to link vertex and fragment shaders.")}function EZ(W,A){if(Ef(W,()=>W.validateProgram(A)),W.getProgramParameter(A,W.VALIDATE_STATUS)===!1)throw console.log(W.getProgramInfoLog(A)),new Error("Shader program validation failed.")}function Eo(W,A){const V=EK(W,()=>W.createBuffer(),"Unable to create WebGLBuffer");return Ef(W,()=>W.bindBuffer(W.ARRAY_BUFFER,V)),Ef(W,()=>W.bufferData(W.ARRAY_BUFFER,A,W.STATIC_DRAW)),V}function Ee(W,A){const V=EK(W,()=>W.createBuffer(),"Unable to create WebGLBuffer");return Ef(W,()=>W.bindBuffer(W.ELEMENT_ARRAY_BUFFER,V)),Ef(W,()=>W.bufferData(W.ELEMENT_ARRAY_BUFFER,A,W.STATIC_DRAW)),V}function EQ(W){return EK(W,()=>W.createTexture(),"Unable to create WebGLTexture.")}function Es(W,A){const V=Cd().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(W<=0||A<=0){const $="["+W+"x"+A+"]";throw new Error("Requested texture size "+$+" is invalid.")}if(W>V||A>V){const $="["+W+"x"+A+"]",ne="["+V+"x"+V+"]";throw new Error("Requested texture size "+$+" greater than WebGL maximum on this browser / GPU "+ne+".")}}function EF(W){return EK(W,()=>W.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function EI(W,A,V,$,ne,xe,le){const ce=W.getAttribLocation(A,V);return ce===-1?!1:(Ef(W,()=>W.bindBuffer(W.ARRAY_BUFFER,$)),Ef(W,()=>W.vertexAttribPointer(ce,ne,W.FLOAT,!1,xe,le)),Ef(W,()=>W.enableVertexAttribArray(ce)),!0)}function Ey(W,A,V){ET(W,V),Ef(W,()=>W.activeTexture(W.TEXTURE0+V)),Ef(W,()=>W.bindTexture(W.TEXTURE_2D,A))}function EA(W,A,V){return EK(W,()=>W.getUniformLocation(A,V),'uniform "'+V+'" not present in program.')}function Ep(W,A,V){return W.getUniformLocation(A,V)}function Ew(W,A,V,$){Ef(W,()=>Ey(W,A,$)),Ef(W,()=>W.uniform1i(V,$))}function EX(W,A,V){Ef(W,()=>W.bindFramebuffer(W.FRAMEBUFFER,V)),Ef(W,()=>W.framebufferTexture2D(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_2D,A,0))}function Ec(W,A){Ef(W,()=>W.bindFramebuffer(W.FRAMEBUFFER,A)),Ef(W,()=>W.framebufferTexture2D(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_2D,null,0))}function EW(W){const A=W.checkFramebufferStatus(W.FRAMEBUFFER);if(A!==W.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+ER(W,A))}function ER(W,A){switch(A){case W.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case W.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case W.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case W.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+A}}function EK(W,A,V){const $=Ef(W,()=>A());if($==null)throw new Error(V);return $}function ET(W,A){const V=W.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,$=A+W.TEXTURE0;if($<W.TEXTURE0||$>V){const ne="[gl.TEXTURE0, gl.TEXTURE"+V+"]";throw new Error("textureUnit must be in "+ne+".")}}function Ev(W,A=2){return F(W.slice(0,W.length-A))}function Eq(W){if(W.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[W.length>1?W[W.length-2]:1,W[W.length-1]]}function El(W){let A=[1,1,1];return W.length===0||W.length===1&&W[0]===1||(A=[Ev(W),...Eq(W)]),A}function Ea(W,A=!1){let V=Cd().getNumber("WEBGL_MAX_TEXTURE_SIZE"),$=Cd().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");$===1/0&&Cd().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&($=V/2),A&&(V=V*2,$=$*2,W=W.map((ce,ue)=>ue>=W.length-2?B(W[ue]):W[ue]),W.length===1&&(W=[2,W[0]])),W.length!==2&&(W=L(W).newShape);let ne=F(W),xe=null;W.length<=1&&ne<=V?xe=[1,ne]:W.length===2&&W[0]<=V&&W[1]<=V?xe=W:W.length===3&&W[0]*W[1]<=V&&W[2]<=V?xe=[W[0]*W[1],W[2]]:W.length===3&&W[0]<=V&&W[1]*W[2]<=V?xe=[W[0],W[1]*W[2]]:W.length===4&&W[0]*W[1]*W[2]<=V&&W[3]<=V?xe=[W[0]*W[1]*W[2],W[3]]:W.length===4&&W[0]<=V&&W[1]*W[2]*W[3]<=V&&(xe=[W[0],W[1]*W[2]*W[3]]);const le=xe!=null&&Math.max(...xe)>$&&Math.min(...xe)<=(A?2:1)&&Math.min(...xe)>0;if(xe==null||le)if(A){const ce=Ev(W);let ue=2,Te=2;W.length&&([ue,Te]=Eq(W)),ne=ce*(ue/2)*(Te/2),xe=K(ne).map(Me=>Me*2)}else xe=K(ne);return xe}function En(W){return W%2===0}function EL(W,A){if(W=W.slice(-2),A=A.slice(-2),X(W,A)||!W.length||!A.length||W[0]===0||W[1]===0||A[0]===0||A[1]===0)return!0;if(W.length!==A.length){const V=W[W.length-1],$=A[A.length-1];if(V===$||En(V)&&En($)&&(W[0]===1||A[0]===1))return!0}return W[1]===A[1]&&En(W[0])&&En(A[0])}let EH,Ek;function Ez(W){if(EH==null){const A=E2(W);EH=A.getParameter(A.MAX_TEXTURE_SIZE)}return EH}function Ex(W){if(Ek==null){const A=E2(W);Ek=A.getParameter(A.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ek)}function EU(W){if(W===0)return 0;let A;const V=E2(W);return EG(V,"EXT_disjoint_timer_query_webgl2")&&W===2?A=2:EG(V,"EXT_disjoint_timer_query")?A=1:A=0,A}function EG(W,A){return W.getExtension(A)!=null}function Eu(W){try{if(E2(W)!=null)return!0}catch(A){return console.log("Error when getting WebGL context: ",A),!1}return!1}function EY(W){if(W===0)return!1;const A=E2(W);if(W===1){if(!EG(A,"OES_texture_float"))return!1}else if(!EG(A,"EXT_color_buffer_float"))return!1;return Eh(A)}function EM(W){if(W===0)return!1;const A=E2(W);if(W===1){if(!EG(A,"OES_texture_float")||!EG(A,"WEBGL_color_buffer_float"))return!1}else{if(EG(A,"EXT_color_buffer_float"))return Eh(A);const V="EXT_color_buffer_half_float";if(EG(A,V)){const $=A.getExtension(V);return Ej(A,$)}return!1}return Eh(A)}function Eh(W){const A=EJ(W),V=W.createTexture();W.bindTexture(W.TEXTURE_2D,V);const $=1,ne=1;W.texImage2D(W.TEXTURE_2D,0,A.internalFormatFloat,$,ne,0,A.textureFormatFloat,A.textureTypeFloat,null);const xe=W.createFramebuffer();W.bindFramebuffer(W.FRAMEBUFFER,xe),W.framebufferTexture2D(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_2D,V,0);const le=W.checkFramebufferStatus(W.FRAMEBUFFER)===W.FRAMEBUFFER_COMPLETE;return W.bindTexture(W.TEXTURE_2D,null),W.bindFramebuffer(W.FRAMEBUFFER,null),W.deleteTexture(V),W.deleteFramebuffer(xe),le}function Ej(W,A){const V=EJ(W,A),$=W.createTexture();W.bindTexture(W.TEXTURE_2D,$);const ne=1,xe=1;W.texImage2D(W.TEXTURE_2D,0,V.internalFormatHalfFloat,ne,xe,0,V.textureFormatFloat,V.textureTypeHalfFloat,null);const le=W.createFramebuffer();W.bindFramebuffer(W.FRAMEBUFFER,le),W.framebufferTexture2D(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_2D,$,0);const ce=W.checkFramebufferStatus(W.FRAMEBUFFER)===W.FRAMEBUFFER_COMPLETE;return W.bindTexture(W.TEXTURE_2D,null),W.bindFramebuffer(W.FRAMEBUFFER,null),W.deleteTexture($),W.deleteFramebuffer(le),ce}function Er(W){return W!==2?!1:E2(W).fenceSync!=null}function D0(W,A){Array.isArray(W)||(W=[W]),W.forEach(V=>{V!=null&&e(V.dtype!=="complex64",()=>A+" does not support complex64 tensors in the WebGL backend.")})}const D1=Cd();D1.registerFlag("HAS_WEBGL",()=>D1.getNumber("WEBGL_VERSION")>0),D1.registerFlag("WEBGL_VERSION",()=>Eu(2)?2:Eu(1)?1:0),D1.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),D1.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>D1.get("WEBGL_VERSION")===2),D1.registerFlag("WEBGL_CPU_FORWARD",()=>!0),D1.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),D1.registerFlag("WEBGL_PACK",()=>D1.getBool("HAS_WEBGL")),D1.registerFlag("WEBGL_PACK_NORMALIZATION",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_CLIP",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_REDUCE",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_LAZILY_UNPACK",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_CONV_IM2COL",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>D1.getBool("WEBGL_PACK")),D1.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Ez(D1.getNumber("WEBGL_VERSION"))),D1.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Ex(D1.getNumber("WEBGL_VERSION"))),D1.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const W=D1.getNumber("WEBGL_VERSION");return W===0?0:EU(W)}),D1.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>D1.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!JX()),D1.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>EY(D1.getNumber("WEBGL_VERSION"))),D1.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>D1.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:D1.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),D1.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>EM(D1.getNumber("WEBGL_VERSION"))),D1.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Er(D1.getNumber("WEBGL_VERSION"))),D1.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>D1.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),D1.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,W=>{if(typeof W!="number")throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got "+W+".");if(W<0&&W!==-1)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got "+W+".")}),D1.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>JX()?1:-1,W=>{if(typeof W!="number")throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+W+".");if(W<0&&W!==-1)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got "+W+".")}),D1.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),D1.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),D1.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),D1.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),D1.registerFlag("WEBGL_EXP_CONV",()=>!1),D1.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>D1.getBool("IS_TEST")),D1.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),D1.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),D1.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),D1.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function D2(){let W,A,V,$,ne,xe,le,ce,ue,Te;return Cd().getNumber("WEBGL_VERSION")===2?(W="#version 300 es",A="in",V="out",$="in",ne="texture",xe="outputColor",le="out vec4 outputColor;",ce=Cd().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",ue="",Te=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(W="",A="attribute",V="varying",$="varying",ne="texture2D",xe="gl_FragColor",le="",ce=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,ue=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,Te=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:W,attribute:A,varyingVs:V,varyingFs:$,texture2D:ne,output:xe,defineOutput:le,defineSpecialNaN:ce,defineSpecialInf:ue,defineRound:Te}}function D3(W,A,V="index"){const $=C5(A);return $.map((ne,xe)=>{const le="int "+W[xe]+" = "+V+" / "+ne,ce=xe===$.length-1?"int "+W[xe+1]+" = "+V+" - "+W[xe]+" * "+ne:"index -= "+W[xe]+" * "+ne;return le+"; "+ce+";"}).join("")}function D4(W,A,V="index"){const $=C5(A);return $.map((ne,xe)=>{const le="int "+W[xe]+" = "+V+" / outShapeStrides["+xe+"]",ce=xe===$.length-1?"int "+W[xe+1]+" = "+V+" - "+W[xe]+" * outShapeStrides["+xe+"]":"index -= "+W[xe]+" * outShapeStrides["+xe+"]";return le+"; "+ce+";"}).join("")}function D5(W,A){const V=W.length,$=W.map(xe=>A+"["+xe+"]"),ne=new Array(V-1);ne[V-2]=$[V-1];for(let xe=V-3;xe>=0;--xe)ne[xe]="("+ne[xe+1]+" * "+$[xe+1]+")";return ne}function D6(W,A,V="index"){const $=W.map((xe,le)=>le),ne=D5($,A);return ne.map((xe,le)=>{const ce="int "+W[le]+" = "+V+" / "+ne[le],ue=le===ne.length-1?"int "+W[le+1]+" = "+V+" - "+W[le]+" * "+ne[le]:"index -= "+W[le]+" * "+ne[le];return ce+"; "+ue+";"}).join("")}function D7(W){const A=C5(W).map(V=>V.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * `+A[0]+" + coords.y * "+A[1]+` + coords.z;
  }
`}function D8(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const D9=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:DC}=Vs;function Dm(W,A,V){const $=[];if(W.forEach(we=>{const ke=F(we.shapeInfo.logicalShape);if(we.shapeInfo.isUniform?$.push("uniform float "+we.name+(ke>1?"["+ke+"]":"")+";"):($.push("uniform sampler2D "+we.name+";"),$.push("uniform int offset"+we.name+";")),V.enableShapeUniforms){const{uniformShape:Ue}=Dx(V.packedInputs,we.shapeInfo.logicalShape,we.shapeInfo.texShape);switch(Ue.length){case 1:$.push("uniform int "+we.name+"Shape;");break;case 2:$.push("uniform ivec2 "+we.name+"Shape;");break;case 3:$.push("uniform ivec3 "+we.name+"Shape;");break;case 4:$.push("uniform ivec4 "+we.name+"Shape;");break}$.push("uniform ivec2 "+we.name+"TexShape;")}}),V.enableShapeUniforms){switch(A.logicalShape.length){case 1:$.push("uniform int outShape;");break;case 2:$.push("uniform ivec2 outShape;"),$.push("uniform int outShapeStrides;");break;case 3:$.push("uniform ivec3 outShape;"),$.push("uniform ivec2 outShapeStrides;");break;case 4:$.push("uniform ivec4 outShape;"),$.push("uniform ivec3 outShapeStrides;");break}$.push("uniform ivec2 outTexShape;")}V.customUniforms&&V.customUniforms.forEach(we=>{$.push("uniform "+we.type+" "+we.name+(we.arrayIndex?"["+we.arrayIndex+"]":"")+";")});const ne=$.join(`
`),xe=W.map(we=>Df(we,A,V.packedInputs,V.enableShapeUniforms)).join(`
`),le=A.texShape,ce=D2(),ue=Dt(ce);let Te,Me,Re=Dd(ce);return A.isPacked?(Te=Di(A.logicalShape,le,V.enableShapeUniforms),Me=DS(ce)):(Te=DO(A.logicalShape,le,V.enableShapeUniforms),Me=DB(ce)),V.packedInputs&&(Re+=DE),[Re,ue,Me,ne,Te,xe,V.userCode].join(`
`)}function DN(W,A=!1){const V=W.shapeInfo.logicalShape;switch(V.length){case 0:return DX(W,A);case 1:return DW(W,A);case 2:return DK(W,A);case 3:return Dv(W,A);case 4:return Dl(W,A);case 5:return Da(W);case 6:return Dn(W);default:throw new Error(V.length+"-D input sampling is not yet supported")}}function DJ(W,A){switch(W.shapeInfo.logicalShape.length){case 0:return Dw(W);case 1:return Dc(W,A);case 2:return DR(W,A);case 3:return DT(W,A);default:return Dq(W,A)}}function Df(W,A,V=!1,$){let ne="";V?ne+=DJ(W,$):ne+=DN(W,$);const xe=W.shapeInfo.logicalShape,le=A.logicalShape;return xe.length<=le.length&&(V?ne+=DH(W,A):ne+=Dk(W,A)),ne}function Di(W,A,V){switch(W.length){case 0:return DD();case 1:return Dg(W,A,V);case 2:return Dy(W,A,V);case 3:return Do(W,A,V);default:return DQ(W,A,V)}}function DO(W,A,V){switch(W.length){case 0:return DD();case 1:return DZ(W,A,V);case 2:return DA(W,A,V);case 3:return De(W,A,V);case 4:return Ds(W,A,V);case 5:return DF(W,A);case 6:return DI(W,A);default:throw new Error(W.length+"-D output sampling is not yet supported")}}function Dt(W){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return `+W.texture2D+`(textureSampler, uv).r;
    }
  `}function DB(W){return`
    void setOutput(float val) {
      `+W.output+` = vec4(val, 0, 0, 0);
    }
  `}function DS(W){return`
    void setOutput(vec4 val) {
      `+W.output+` = val;
    }
  `}function Dd(W){return W.version+`
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    `+W.varyingFs+` vec2 resultUV;
    `+W.defineOutput+`
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    `+W.defineSpecialNaN+`
    `+W.defineSpecialInf+`
    `+W.defineRound+`

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    `+DV+`
    `+Db+`
    `+DP+`
  `}const DV=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Db=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,DP=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,DE=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function DD(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Dg(W,A,V){const $=[Math.ceil(A[0]/2),Math.ceil(A[1]/2)];return $[0]===1?V?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * `+$[1]+`.0);
      }
    `:$[1]===1?V?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * `+$[0]+`.0);
      }
    `:V?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+$[0]+", "+$[1]+`));
      return 2 * (resTexRC.x * `+$[1]+` + resTexRC.y);
    }
  `}function DZ(W,A,V){return A[0]===1?V?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * `+A[1]+`.0);
      }
    `:A[1]===1?V?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * `+A[0]+`.0);
      }
    `:V?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+A[0]+", "+A[1]+`));
      return resTexRC.x * `+A[1]+` + resTexRC.y;
    }
  `}function Do(W,A,V){if(V)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const $=[Math.ceil(A[0]/2),Math.ceil(A[1]/2)],ne=Math.ceil(W[2]/2),xe=ne*Math.ceil(W[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+$[0]+", "+$[1]+`));
      int index = resTexRC.x * `+$[1]+` + resTexRC.y;

      int b = index / `+xe+`;
      index -= b * `+xe+`;

      int r = 2 * (index / `+ne+`);
      int c = imod(index, `+ne+`) * 2;

      return ivec3(b, r, c);
    }
  `}function De(W,A,V){if(V)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    `+D4(["r","c","d"],W)+`
    return ivec3(r, c, d);
  }
`;const $=D3(["r","c","d"],W);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+A[0]+", "+A[1]+`));
      int index = resTexRC.x * `+A[1]+` + resTexRC.y;
      `+$+`
      return ivec3(r, c, d);
    }
  `}function DQ(W,A,V){if(V)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const $=[Math.ceil(A[0]/2),Math.ceil(A[1]/2)],ne=Math.ceil(W[W.length-1]/2),xe=ne*Math.ceil(W[W.length-2]/2);let le=xe,ce="",ue="b, r, c";for(let Te=2;Te<W.length-1;Te++)le*=W[W.length-Te-1],ce=`
      int b`+Te+" = index / "+le+`;
      index -= b`+Te+" * "+le+`;
    `+ce,ue="b"+Te+", "+ue;return`
    ivec`+W.length+` getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+$[0]+", "+$[1]+`));
      int index = resTexRC.x * `+$[1]+` + resTexRC.y;

      `+ce+`

      int b = index / `+xe+`;
      index -= b * `+xe+`;

      int r = 2 * (index / `+ne+`);
      int c = imod(index, `+ne+`) * 2;

      return ivec`+W.length+"("+ue+`);
    }
  `}function Ds(W,A,V){if(V)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      `+D4(["r","c","d","d2"],W)+`
      return ivec4(r, c, d, d2);
    }
  `;const $=D3(["r","c","d","d2"],W);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+A[0]+", "+A[1]+`));
      int index = resTexRC.x * `+A[1]+` + resTexRC.y;
      `+$+`
      return ivec4(r, c, d, d2);
    }
  `}function DF(W,A){const V=D3(["r","c","d","d2","d3"],W);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(`+A[0]+`,
                             `+A[1]+`));

      int index = resTexRC.x * `+A[1]+` + resTexRC.y;

      `+V+`

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function DI(W,A){const V=D3(["r","c","d","d2","d3","d4"],W);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+A[0]+", "+A[1]+`));
      int index = resTexRC.x * `+A[1]+` + resTexRC.y;

      `+V+`

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Dy(W,A,V){const $=[Math.ceil(A[0]/2),Math.ceil(A[1]/2)];if(X(W,A))return V?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(`+$[0]+", "+$[1]+`));
      }
    `;const ne=Math.ceil(W[1]/2);return V?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+$[0]+", "+$[1]+`));

      int index = resTexRC.x * `+$[1]+` + resTexRC.y;
      int r = 2 * (index / `+ne+`);
      int c = imod(index, `+ne+`) * 2;

      return ivec2(r, c);
    }
  `}function DA(W,A,V){return X(W,A)?V?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(`+A[0]+", "+A[1]+`));
      }
    `:W[1]===1?V?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+A[0]+", "+A[1]+`));
        int index = resTexRC.x * `+A[1]+` + resTexRC.y;
        return ivec2(index, 0);
      }
    `:W[0]===1?V?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+A[0]+", "+A[1]+`));
        int index = resTexRC.x * `+A[1]+` + resTexRC.y;
        return ivec2(0, index);
      }
    `:V?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+A[0]+", "+A[1]+`));
      int index = resTexRC.x * `+A[1]+` + resTexRC.y;
      int r = index / `+W[1]+`;
      int c = index - r * `+W[1]+`;
      return ivec2(r, c);
    }
  `}function Dp(W){return"offset"+W}function Dw(W){const A=W.name,V="get"+A.charAt(0).toUpperCase()+A.slice(1),$=D2();return`
    vec4 `+V+`() {
      return `+$.texture2D+"("+A+`, halfCR);
    }
  `}function DX(W,A){const V=W.name,$="get"+V.charAt(0).toUpperCase()+V.slice(1);if(W.shapeInfo.isUniform)return"float "+$+"() {return "+V+";}";const[ne,xe]=W.shapeInfo.texShape;if(ne===1&&xe===1)return`
      float `+$+`() {
        return sampleTexture(`+V+`, halfCR);
      }
    `;const le=Dp(V);if(A)return`
    float `+$+`() {
      vec2 uv = uvFromFlat(`+V+"TexShape[0], "+V+"TexShape[1], "+le+`);
      return sampleTexture(`+V+`, uv);
    }
  `;const[ce,ue]=W.shapeInfo.texShape;return`
    float `+$+`() {
      vec2 uv = uvFromFlat(`+ce+", "+ue+", "+le+`);
      return sampleTexture(`+V+`, uv);
    }
  `}function Dc(W,A){const V=W.name,$="get"+V.charAt(0).toUpperCase()+V.slice(1),ne=W.shapeInfo.texShape,xe=D2();if(A)return`
    vec4 `+$+`(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(`+V+"TexShape[0]) / 2.0), ceil(float("+V+`TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return `+xe.texture2D+"("+V+`, uv);
    }
  `;const le=[Math.ceil(ne[0]/2),Math.ceil(ne[1]/2)];return`
    vec4 `+$+`(int index) {
      vec2 uv = packedUVfrom1D(
        `+le[0]+", "+le[1]+`, index);
      return `+xe.texture2D+"("+V+`, uv);
    }
  `}function DW(W,A){const V=W.name,$="get"+V.charAt(0).toUpperCase()+V.slice(1);if(W.shapeInfo.isUniform)return`
      float `+$+`(int index) {
        `+DL(W)+`
      }
    `;const ne=W.shapeInfo.texShape,xe=ne[0],le=ne[1];if(le===1&&xe===1)return`
      float `+$+`(int index) {
        return sampleTexture(`+V+`, halfCR);
      }
    `;const ce=Dp(V);return le===1?A?`
      float `+$+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+ce+") + 0.5) / float("+V+`TexShape[0]));
        return sampleTexture(`+V+`, uv);
      }
    `:`
      float `+$+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+ce+") + 0.5) / "+xe+`.0);
        return sampleTexture(`+V+`, uv);
      }
    `:xe===1?A?`
      float `+$+`(int index) {
        vec2 uv = vec2((float(index + `+ce+") + 0.5) / float("+V+`TexShape[1]), 0.5);
        return sampleTexture(`+V+`, uv);
      }
    `:`
      float `+$+`(int index) {
        vec2 uv = vec2((float(index + `+ce+") + 0.5) / "+le+`.0, 0.5);
        return sampleTexture(`+V+`, uv);
      }
    `:A?`
    float `+$+`(int index) {
      vec2 uv = uvFromFlat(`+V+"TexShape[0], "+V+"TexShape[1], index + "+ce+`);
      return sampleTexture(`+V+`, uv);
    }
  `:`
    float `+$+`(int index) {
      vec2 uv = uvFromFlat(`+xe+", "+le+", index + "+ce+`);
      return sampleTexture(`+V+`, uv);
    }
  `}function DR(W,A){const V=W.shapeInfo.logicalShape,$=W.name,ne="get"+$.charAt(0).toUpperCase()+$.slice(1),xe=W.shapeInfo.texShape,le=xe[0],ce=xe[1],ue=D2();if(xe!=null&&X(V,xe))return A?`
      vec4 `+ne+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+$+"TexShape[1], "+$+`TexShape[0]);

        return `+ue.texture2D+"("+$+`, uv);
      }
    `:`
      vec4 `+ne+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+ce+".0, "+le+`.0);

        return `+ue.texture2D+"("+$+`, uv);
      }
    `;if(A)return`
    vec4 `+ne+`(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+$+"TexShape[0]) / 2.0), ceil(float("+$+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+$+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return `+ue.texture2D+"("+$+`, uv);
    }
  `;const Te=[Math.ceil(xe[0]/2),Math.ceil(xe[1]/2)],Me=Math.ceil(V[1]/2);return`
    vec4 `+ne+`(int row, int col) {
      vec2 uv = packedUVfrom2D(`+Me+", "+Te[0]+", "+Te[1]+`, row, col);
      return `+ue.texture2D+"("+$+`, uv);
    }
  `}function DK(W,A){const V=W.shapeInfo.logicalShape,$=W.name,ne="get"+$.charAt(0).toUpperCase()+$.slice(1),xe=W.shapeInfo.texShape;if(xe!=null&&X(V,xe)){if(A)return`
      float `+ne+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+$+"TexShape[1], "+$+`TexShape[0]);
        return sampleTexture(`+$+`, uv);
      }
    `;const we=xe[0],ke=xe[1];return`
    float `+ne+`(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(`+ke+".0, "+we+`.0);
      return sampleTexture(`+$+`, uv);
    }
  `}const{newShape:le,keptDims:ce}=L(V),ue=le;if(ue.length<V.length){const we=DU(W,ue),ke=["row","col"];return`
      `+DN(we,A)+`
      float `+ne+`(int row, int col) {
        return `+ne+"("+DG(ke,ce)+`);
      }
    `}if(W.shapeInfo.isUniform)return`
      float `+ne+`(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(`+V[1]+`, 1)));
        `+DL(W)+`
      }
    `;const Te=xe[0],Me=xe[1],Re=Dp($);return Me===1?A?`
      float `+ne+`(int row, int col) {
        float index = dot(vec3(row, col, `+Re+"), vec3("+$+`Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(`+$+`TexShape[0]));
        return sampleTexture(`+$+`, uv);
      }
    `:`
    float `+ne+`(int row, int col) {
      float index = dot(vec3(row, col, `+Re+"), vec3("+V[1]+`, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / `+Te+`.0);
      return sampleTexture(`+$+`, uv);
    }
  `:Te===1?A?`
      float `+ne+`(int row, int col) {
        float index = dot(vec3(row, col, `+Re+"), vec3("+$+`Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(`+$+`TexShape[1]), 0.5);
        return sampleTexture(`+$+`, uv);
      }
    `:`
    float `+ne+`(int row, int col) {
      float index = dot(vec3(row, col, `+Re+"), vec3("+V[1]+`, 1, 1));
      vec2 uv = vec2((index + 0.5) / `+Me+`.0, 0.5);
      return sampleTexture(`+$+`, uv);
    }
  `:A?`
      float `+ne+`(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+$+"Shape[1] + col + "+Re+`;
        vec2 uv = uvFromFlat(`+$+"TexShape[0], "+$+`TexShape[1], index);
        return sampleTexture(`+$+`, uv);
      }
    `:`
  float `+ne+`(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * `+V[1]+" + col + "+Re+`;
    vec2 uv = uvFromFlat(`+Te+", "+Me+`, index);
    return sampleTexture(`+$+`, uv);
  }
`}function DT(W,A){const V=W.shapeInfo.logicalShape,$=W.name,ne="get"+$.charAt(0).toUpperCase()+$.slice(1),xe=W.shapeInfo.texShape,le=[Math.ceil(xe[0]/2),Math.ceil(xe[1]/2)];if(V[0]===1){const we=V.slice(1),ke=[1,2],Ue=DU(W,we),Ge=["b","row","col"];return`
        `+DJ(Ue,A)+`
        vec4 `+ne+`(int b, int row, int col) {
          return `+ne+"("+DG(Ge,ke)+`);
        }
      `}const ce=D2();if(A)return`
    vec4 `+ne+`(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+$+"TexShape[0]) / 2.0), ceil(float("+$+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+$+`Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+$+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return `+ce.texture2D+"("+$+`, uv);
    }
  `;const ue=le[0],Te=le[1],Me=Math.ceil(V[2]/2),Re=Me*Math.ceil(V[1]/2);return`
    vec4 `+ne+`(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        `+ue+", "+Te+", "+Re+", "+Me+`, b, row, col);
      return `+ce.texture2D+"("+$+`, uv);
    }
  `}function Dv(W,A){const V=W.shapeInfo.logicalShape,$=W.name,ne="get"+$.charAt(0).toUpperCase()+$.slice(1),xe=V[1]*V[2],le=V[2],{newShape:ce,keptDims:ue}=L(V),Te=ce;if(Te.length<V.length){const Ge=DU(W,Te),We=["row","col","depth"];return`
        `+DN(Ge,A)+`
        float `+ne+`(int row, int col, int depth) {
          return `+ne+"("+DG(We,ue)+`);
        }
      `}if(W.shapeInfo.isUniform)return`
      float `+ne+`(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(`+xe+", "+le+`, 1)));
        `+DL(W)+`
      }
    `;const Me=W.shapeInfo.texShape,Re=Me[0],we=Me[1],ke=W.shapeInfo.flatOffset;if(we===xe&&ke==null)return A?`
      float `+ne+`(int row, int col, int depth) {
        int stride1 = `+$+`Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+$+"TexShape[1], "+$+`TexShape[0]);
        return sampleTexture(`+$+`, uv);
      }
    `:`
        float `+ne+`(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(`+le+`, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(`+we+".0, "+Re+`.0);
          return sampleTexture(`+$+`, uv);
        }
      `;if(we===le&&ke==null)return A?`
      float `+ne+`(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(`+$+`Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+$+"TexShape[1], "+$+`TexShape[0]);
        return sampleTexture(`+$+`, uv);
      }
    `:`
    float `+ne+`(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(`+V[1]+`, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+we+".0, "+Re+`.0);
      return sampleTexture(`+$+`, uv);
    }
  `;const Ue=Dp($);return A?`
    float `+ne+`(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = `+$+"Shape[1] * "+$+`Shape[2];
      int stride1 = `+$+`Shape[2];
      int index = row * stride0 + col * stride1 + depth + `+Ue+`;
      vec2 uv = uvFromFlat(`+$+"TexShape[0], "+$+`TexShape[1], index);
      return sampleTexture(`+$+`, uv);
    }
    `:`
      float `+ne+`(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+xe+" + col * "+le+" + depth + "+Ue+`;
        vec2 uv = uvFromFlat(`+Re+", "+we+`, index);
        return sampleTexture(`+$+`, uv);
      }
  `}function Dq(W,A){const V=W.name,$="get"+V.charAt(0).toUpperCase()+V.slice(1),ne=D2();if(A)return`
    vec4 `+$+`(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(`+V+`Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+V+`Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= `+V+`Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(`+V+"TexShape[0]) / 2.0), ceil(float("+V+`TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return `+ne.texture2D+"("+V+`, uv);
    }
  `;const xe=W.shapeInfo.logicalShape,le=xe.length,ce=W.shapeInfo.texShape,ue=[Math.ceil(ce[0]/2),Math.ceil(ce[1]/2)],Te=ue[0],Me=ue[1],Re=Math.ceil(xe[le-1]/2);let we=Re*Math.ceil(xe[le-2]/2),ke="int b, int row, int col",Ue="b * "+we+" + (row / 2) * "+Re+" + (col / 2)";for(let Ge=2;Ge<le-1;Ge++)ke="int b"+Ge+", "+ke,we*=xe[le-Ge-1],Ue="b"+Ge+" * "+we+" + "+Ue;return`
    vec4 `+$+"("+ke+`) {
      int index = `+Ue+`;
      int texR = index / `+Me+`;
      int texC = index - texR * `+Me+`;
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+Me+", "+Te+`);
      return `+ne.texture2D+"("+V+`, uv);
    }
  `}function Dl(W,A){const V=W.shapeInfo.logicalShape,$=W.name,ne="get"+$.charAt(0).toUpperCase()+$.slice(1),xe=V[3],le=V[2]*xe,ce=V[1]*le,{newShape:ue,keptDims:Te}=L(V);if(ue.length<V.length){const Ye=DU(W,ue),je=["row","col","depth","depth2"];return`
      `+DN(Ye,A)+`
      float `+ne+`(int row, int col, int depth, int depth2) {
        return `+ne+"("+DG(je,Te)+`);
      }
    `}if(W.shapeInfo.isUniform)return`
      float `+ne+`(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(`+ce+", "+le+", "+xe+`, 1)));
        `+DL(W)+`
      }
    `;const Me=W.shapeInfo.flatOffset,Re=W.shapeInfo.texShape,we=Re[0],ke=Re[1],Ue="int stride2 = "+$+"Shape[3];",Ge="int stride1 = "+$+"Shape[2] * stride2;",We="int stride0 = "+$+"Shape[1] * stride1;";if(ke===ce&&Me==null)return A?`
      float `+ne+`(int row, int col, int depth, int depth2) {
        `+Ue+`
        `+Ge+`
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+$+"TexShape[1], "+$+`TexShape[0]);
        return sampleTexture(`+$+`, uv);
      }
    `:`
      float `+ne+`(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(`+le+", "+xe+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+ke+".0, "+we+`.0);
        return sampleTexture(`+$+`, uv);
      }
    `;if(ke===xe&&Me==null)return A?`
      float `+ne+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+$+"Shape[1] * "+$+"Shape[2], "+$+`Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+$+"TexShape[1], "+$+`TexShape[0]);
        return sampleTexture(`+$+`, uv);
      }
    `:`
      float `+ne+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+V[1]*V[2]+", "+V[2]+`, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+ke+".0, "+we+`.0);
        return sampleTexture(`+$+`, uv);
      }
    `;const Xe=Dp($);return A?`
    float `+ne+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      `+Ue+`
      `+Ge+`
      `+We+`
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(`+$+"TexShape[0], "+$+"TexShape[1], index + "+Xe+`);
      return sampleTexture(`+$+`, uv);
    }
  `:`
    float `+ne+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+ce+" + col * "+le+` +
          depth * `+xe+` + depth2;
      vec2 uv = uvFromFlat(`+we+", "+ke+", index + "+Xe+`);
      return sampleTexture(`+$+`, uv);
    }
  `}function Da(W){const A=W.shapeInfo.logicalShape,V=W.name,$="get"+V.charAt(0).toUpperCase()+V.slice(1),ne=A[4],xe=A[3]*ne,le=A[2]*xe,ce=A[1]*le,{newShape:ue,keptDims:Te}=L(A);if(ue.length<A.length){const Ge=DU(W,ue),We=["row","col","depth","depth2","depth3"];return`
      `+DN(Ge)+`
      float `+$+`(int row, int col, int depth, int depth2, int depth3) {
        return `+$+"("+DG(We,Te)+`);
      }
    `}if(W.shapeInfo.isUniform)return`
      float `+$+`(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(`+ce+", "+le+", "+xe+", "+ne+`)) +
          depth3;
        `+DL(W)+`
      }
    `;const Me=W.shapeInfo.flatOffset,Re=W.shapeInfo.texShape,we=Re[0],ke=Re[1];if(ke===ce&&Me==null)return`
      float `+$+`(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(`+le+", "+xe+", "+ne+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+ke+".0, "+we+`.0);
        return sampleTexture(`+V+`, uv);
      }
    `;if(ke===ne&&Me==null)return`
      float `+$+`(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(`+A[1]*A[2]*A[3]+`,
               `+A[2]*A[3]+", "+A[3]+`, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+ke+".0, "+we+`.0);
        return sampleTexture(`+V+`, uv);
      }
    `;const Ue=Dp(V);return`
    float `+$+`(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+ce+" + col * "+le+" + depth * "+xe+` +
          depth2 * `+ne+" + depth3 + "+Ue+`;
      vec2 uv = uvFromFlat(`+we+", "+ke+`, index);
      return sampleTexture(`+V+`, uv);
    }
  `}function Dn(W){const A=W.shapeInfo.logicalShape,V=W.name,$="get"+V.charAt(0).toUpperCase()+V.slice(1),{newShape:ne,keptDims:xe}=L(A);if(ne.length<A.length){const We=DU(W,ne),Xe=["row","col","depth","depth2","depth3","depth4"];return`
      `+DN(We)+`
      float `+$+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return `+$+"("+DG(Xe,xe)+`);
      }
    `}const le=A[5],ce=A[4]*le,ue=A[3]*ce,Te=A[2]*ue,Me=A[1]*Te;if(W.shapeInfo.isUniform)return`
      float `+$+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(`+Me+", "+Te+", "+ue+", "+ce+`)) +
          dot(
            vec2(depth3, depth4),
            vec2(`+le+`, 1)));
        `+DL(W)+`
      }
    `;const Re=W.shapeInfo.flatOffset,we=W.shapeInfo.texShape,ke=we[0],Ue=we[1];if(Ue===Me&&Re==null)return`
      float `+$+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(`+Te+", "+ue+", "+ce+", "+le+`)) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+Ue+".0, "+ke+`.0);
        return sampleTexture(`+V+`, uv);
      }
    `;if(Ue===le&&Re==null)return`
      float `+$+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(`+A[1]*A[2]*A[3]*A[4]+`,
               `+A[2]*A[3]*A[4]+`,
               `+A[3]*A[4]+`,
               `+A[4]+`)) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+Ue+".0, "+ke+`.0);
        return sampleTexture(`+V+`, uv);
      }
    `;const Ge=Dp(V);return`
    float `+$+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+Me+" + col * "+Te+" + depth * "+ue+` +
          depth2 * `+ce+" + depth3 * "+le+" + depth4 + "+Ge+`;
      vec2 uv = uvFromFlat(`+ke+", "+Ue+`, index);
      return sampleTexture(`+V+`, uv);
    }
  `}function DL(W){const A=W.name,V=F(W.shapeInfo.logicalShape);return V<2?"return "+A+";":`
    for (int i = 0; i < `+V+`; i++) {
      if (i == index) {
        return `+A+`[i];
      }
    }
  `}function DH(W,A){const V=W.name,$=V.charAt(0).toUpperCase()+V.slice(1),ne="get"+$+"AtOutCoords",xe=W.shapeInfo.logicalShape.length,le=A.logicalShape.length,ce=DC(W.shapeInfo.logicalShape,A.logicalShape),ue=Dz(le),Te=le-xe;let Me;const Re=["x","y","z","w","u","v"];xe===0?Me="":le<2&&ce.length>=1?Me="coords = 0;":Me=ce.map(We=>"coords."+Re[We+Te]+" = 0;").join(`
`);let we="";le<2&&xe>0?we="coords":we=W.shapeInfo.logicalShape.map((We,Xe)=>"coords."+Re[Xe+Te]).join(", ");let ke="return outputValue;";const Ue=F(W.shapeInfo.logicalShape)===1,Ge=F(A.logicalShape)===1;if(xe===1&&!Ue&&!Ge)ke=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(Ue&&!Ge)le===1?ke=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:ke=`
        return vec4(outputValue.x);
      `;else if(ce.length){const We=xe-2,Xe=xe-1;ce.indexOf(We)>-1&&ce.indexOf(Xe)>-1?ke="return vec4(outputValue.x);":ce.indexOf(We)>-1?ke="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":ce.indexOf(Xe)>-1&&(ke="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 `+ne+`() {
      `+ue+` coords = getOutputCoords();
      `+Me+`
      vec4 outputValue = get`+$+"("+we+`);
      `+ke+`
    }
  `}function Dk(W,A){const V=W.name,$=V.charAt(0).toUpperCase()+V.slice(1),ne="get"+$+"AtOutCoords",xe=A.texShape,le=W.shapeInfo.texShape,ce=W.shapeInfo.logicalShape.length,ue=A.logicalShape.length;if(!W.shapeInfo.isUniform&&ce===ue&&W.shapeInfo.flatOffset==null&&X(le,xe))return`
      float `+ne+`() {
        return sampleTexture(`+V+`, resultUV);
      }
    `;const Te=Dz(ue),Me=DC(W.shapeInfo.logicalShape,A.logicalShape),Re=ue-ce;let we;const ke=["x","y","z","w","u","v"];ce===0?we="":ue<2&&Me.length>=1?we="coords = 0;":we=Me.map(Ge=>"coords."+ke[Ge+Re]+" = 0;").join(`
`);let Ue="";return ue<2&&ce>0?Ue="coords":Ue=W.shapeInfo.logicalShape.map((Ge,We)=>"coords."+ke[We+Re]).join(", "),`
    float `+ne+`() {
      `+Te+` coords = getOutputCoords();
      `+we+`
      return get`+$+"("+Ue+`);
    }
  `}function Dz(W){if(W<=1)return"int";if(W===2)return"ivec2";if(W===3)return"ivec3";if(W===4)return"ivec4";if(W===5)return"ivec5";if(W===6)return"ivec6";throw Error("GPU for rank "+W+" is not yet supported")}function Dx(W,A,V){const{newShape:$,keptDims:ne}=L(A),xe=A.length,le=W&&xe===3&&A[0]===1,ce=le?A.slice(1):$,ue=!W&&xe>1&&!X(A,V)&&$.length<xe||le;return{useSqueezeShape:ue,uniformShape:ue?ce:A,keptDims:ne}}function DU(W,A){const V=JSON.parse(JSON.stringify(W));return V.shapeInfo.logicalShape=A,V}function DG(W,A){return A.map(V=>W[V]).join(", ")}function Du(W,A,V,$){const ne=V.map((Me,Re)=>{const we={logicalShape:Me.shape,texShape:Me.isUniform?null:Me.texData.texShape,isUniform:Me.isUniform,isPacked:Me.isUniform?!1:Me.texData.isPacked,flatOffset:null};return Me.texData!=null&&Me.texData.slice!=null&&Me.texData.slice.flatOffset>0&&(we.flatOffset=Me.texData.slice.flatOffset),{name:A.variableNames[Re],shapeInfo:we}}),xe=ne.map(Me=>Me.shapeInfo),le={logicalShape:$.shape,texShape:$.texData.texShape,isUniform:!1,isPacked:$.texData.isPacked,flatOffset:null},ce=Dm(ne,le,A),ue=Eb(W.gl,ce),Te=W.createProgram(ue);return Cd().get("ENGINE_COMPILE_ONLY")?{program:A,fragmentShader:ue,source:ce,webGLProgram:Te,inShapeInfos:xe,outShapeInfo:le,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(W.buildVao(Te),Object.assign({program:A,fragmentShader:ue,source:ce,webGLProgram:Te,inShapeInfos:xe,outShapeInfo:le},DY(W,A,Te)))}function DY(W,A,V){const $=[],ne=[];let xe,le,ce,ue=null,Te=null;Te=W.getUniformLocation(V,"NAN",!1),Cd().getNumber("WEBGL_VERSION")===1&&(ue=W.getUniformLocation(V,"INFINITY",!1));const Me=!1;for(const Re of A.variableNames){const we={name:Re,uniform:W.getUniformLocation(V,Re,Me),offset:W.getUniformLocation(V,"offset"+Re,Me)};A.enableShapeUniforms&&(we.shape=W.getUniformLocation(V,Re+"Shape",Me),we.texShape=W.getUniformLocation(V,Re+"TexShape",Me)),$.push(we)}if(A.enableShapeUniforms&&(xe=W.getUniformLocation(V,"outShape",Me),ce=W.getUniformLocation(V,"outShapeStrides",Me),le=W.getUniformLocation(V,"outTexShape",Me)),A.customUniforms)for(const Re of A.customUniforms)ne.push(W.getUniformLocation(V,Re.name,Me));return{variablesLocations:$,customUniformLocations:ne,infLoc:ue,nanLoc:Te,outShapeLocation:xe,outShapeStridesLocation:ce,outTexShapeLocation:le}}function DM(W,A){if(W.length!==A.length)throw Error("Binary was compiled with "+W.length+" inputs, but was executed with "+A.length+" inputs");W.forEach((V,$)=>{const ne=V.logicalShape,xe=A[$],le=xe.shape;if(!X(ne,le))throw Error("Binary was compiled with different shapes than the current args. Shapes "+ne+" and "+le+" must match");if(V.isUniform&&xe.isUniform)return;const ce=V.texShape,ue=xe.isUniform?null:xe.texData.texShape;if(!X(ce,ue))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+ce+" and "+ue+" must match")})}function Dh(W,A,V,$,ne){A.program.enableShapeUniforms||(DM(A.inShapeInfos,V),DM([A.outShapeInfo],[$]));const xe=$.texData.texture,le=$.texData.texShape;$.texData.isPacked?W.setOutputPackedMatrixTexture(xe.texture,le[0],le[1]):W.setOutputMatrixTexture(xe.texture,le[0],le[1]),W.setProgram(A.webGLProgram),W.bindVertexArray(A.webGLProgram.vao),Cd().getNumber("WEBGL_VERSION")===1&&A.infLoc!==null&&W.gl.uniform1f(A.infLoc,1/0),A.nanLoc!==null&&W.gl.uniform1f(A.nanLoc,NaN);for(let ue=0;ue<V.length;++ue){const Te=V[ue],{uniform:Me,offset:Re,shape:we,texShape:ke}=A.variablesLocations[ue];if(we){const{uniformShape:Ue}=Dx(A.program.packedInputs,Te.shape,Te.texData.texShape);switch(Ue.length){case 1:W.gl.uniform1iv(we,new Int32Array(Ue));break;case 2:W.gl.uniform2iv(we,new Int32Array(Ue));break;case 3:W.gl.uniform3iv(we,new Int32Array(Ue));break;case 4:W.gl.uniform4iv(we,new Int32Array(Ue));break}}if(ke&&W.gl.uniform2i(ke,Te.texData.texShape[0],Te.texData.texShape[1]),Me!=null){if(Te.isUniform){if(F(Te.shape)<2)W.gl.uniform1f(Me,Te.uniformValues[0]);else{let Ue=Te.uniformValues;Ue instanceof Float32Array||(Ue=new Float32Array(Ue)),W.gl.uniform1fv(Me,Ue)}continue}Te.texData.slice!=null&&Re!=null&&W.gl.uniform1i(Re,Te.texData.slice.flatOffset),W.setInputMatrixTexture(Te.texData.texture.texture,Me,ue)}}const ce=A.outShapeLocation;if(ce)switch($.shape.length){case 1:W.gl.uniform1iv(ce,new Int32Array($.shape));break;case 2:W.gl.uniform2iv(ce,new Int32Array($.shape));break;case 3:W.gl.uniform3iv(ce,new Int32Array($.shape));break;case 4:W.gl.uniform4iv(ce,new Int32Array($.shape));break}if(A.outShapeStridesLocation){const ue=C5($.shape);switch($.shape.length){case 2:W.gl.uniform1iv(A.outShapeStridesLocation,new Int32Array(ue));break;case 3:W.gl.uniform2iv(A.outShapeStridesLocation,new Int32Array(ue));break;case 4:W.gl.uniform3iv(A.outShapeStridesLocation,new Int32Array(ue));break}}if(A.outTexShapeLocation&&W.gl.uniform2i(A.outTexShapeLocation,$.texData.texShape[0],$.texData.texShape[1]),A.program.customUniforms&&ne)for(let ue=0;ue<A.program.customUniforms.length;++ue){const Te=A.program.customUniforms[ue],Me=A.customUniformLocations[ue],Re=ne[ue];if(Te.type==="float")W.gl.uniform1fv(Me,Re);else if(Te.type==="vec2")W.gl.uniform2fv(Me,Re);else if(Te.type==="vec3")W.gl.uniform3fv(Me,Re);else if(Te.type==="vec4")W.gl.uniform4fv(Me,Re);else if(Te.type==="int")W.gl.uniform1iv(Me,Re);else if(Te.type==="ivec2")W.gl.uniform2iv(Me,Re);else if(Te.type==="ivec3")W.gl.uniform3iv(Me,Re);else if(Te.type==="ivec4")W.gl.uniform4iv(Me,Re);else throw Error("uniform type "+Te.type+" is not supported yet.")}W.executeProgram()}function Dj(W,A,V){let $="";A.concat(V).forEach(le=>{const ce=le.texData!=null&&le.texData.slice!=null&&le.texData.slice.flatOffset>0;if(W.enableShapeUniforms&&!le.isUniform){const ue=le.texData.texShape,{useSqueezeShape:Te,uniformShape:Me,keptDims:Re}=Dx(W.packedInputs,le.shape,ue);let we="",ke="",Ue="";if(Me.length===1&&W.packedInputs){const qe=[Math.ceil(ue[0]/2),Math.ceil(ue[1]/2)];we=(qe[0]>1)+"_"+(qe[1]>1)}else if(Me.length===2&&!W.packedInputs)ke=(Me[0]>1)+"_"+(Me[1]>1);else if(Me.length>2&&!W.packedInputs){const qe=C5(Me);Ue=(qe[0]===ue[1])+"_"+(qe[qe.length-1]===ue[1])}const Ge=le.shape.length,We=Me.length===2&&X(le.shape,ue),Xe=F(le.shape)===1,Ye=ia(le.shape,V.shape),je=!W.packedInputs&&Ge===V.shape.length&&X(ue,V.texData.texShape),Ke=W.packedInputs||Me.length>2?"":(ue[0]>1)+"_"+(ue[1]>1);$+=Ge+"_"+je+"_"+(Te?Re:"")+"_"+Me.length+"_"+Xe+"_"+Ye+"_"+We+"_"+we+"_"+ke+"_"+Ue+"_"+Ke+"_"+ce}else{const ue=le.isUniform?"uniform":le.texData.texShape;$+=le.shape+"_"+ue+"_"+ce}});const ne=W.userCode;let xe=W.constructor.name;return xe+="_"+$+"_"+ne+(""+Cd().getNumber("WEBGL_VERSION")),xe}function Dr(W){return Cd().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&W<=4}class g0{constructor(A){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=E5.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const V=D2();this.outputShape=A,this.enableShapeUniforms=Dr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?D4(["r","c","d"],A):D3(["r","c","d"],A))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        `+V.output+` = result;
      }
    `}}class g1{constructor(A){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=E5.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const V=D2();this.outputShape=A,this.enableShapeUniforms=Dr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?D4(["r","c","d"],A):D3(["r","c","d"],A))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        `+V.output+` = result;
      }
    `}}class g2{constructor(A){this.variableNames=["A"],this.outTexUsage=E6.DOWNLOAD;const V=D2();this.outputShape=A,this.userCode=`
      `+D9+`

      void main() {
        float x = getAAtOutCoords();
        `+V.output+` = encode_float(x);
      }
    `}}class g3{constructor(A){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=E6.DOWNLOAD;const V=D2();this.outputShape=A,this.userCode=`
      `+D9+`

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        `+V.output+` = encode_float(x);
      }
    `}}const g4={R:0,G:1,B:2,A:3};class g5{constructor(A,V=!1,$="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const ne=D2();this.outputShape=A,this.enableShapeUniforms=Dr(this.outputShape.length);let xe="result";V&&(xe="floor(result * 255. + 0.5)");let le="";for(let ce=0;ce<$.length;ce++){const ue=$[ce];le+=`
          if(offset == `+ce+`) {
            result = values[`+g4[ue]+`];
          }`}this.userCode=`
      `+(this.enableShapeUniforms?D8():D7(A))+`

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, `+$.length+`);

        flatIndex = idiv(flatIndex, `+$.length+`, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = `+ne.texture2D+`(A, uv);
          `+le+`
        }
        `+ne.output+" = vec4("+xe+`, 0., 0., 0.);
      }
    `}}class g6{constructor(A,V=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const $=D2();this.outputShape=A,this.enableShapeUniforms=Dr(this.outputShape.length);let ne="",xe="result";V&&(xe="floor(result * 255. + 0.5)");for(let le=0;le<=1;le++)for(let ce=0;ce<=1;ce++){const ue=le*2+ce;ne+=`
          localCoords = coords;
          if(localCoords[2] + `+ce+" < "+(this.enableShapeUniforms?"outShape[2]":""+A[2])+`) {
          localCoords[2] += `+ce+`;
          if (localCoords[1] + `+le+" < "+(this.enableShapeUniforms?"outShape[1]":""+A[1])+`) {
            localCoords[1] += `+le+`;

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = `+$.texture2D+`(A, uv);

            if (offset == 0) {
              result[`+ue+`] = values[0];
            } else if (offset == 1) {
              result[`+ue+`] = values[1];
            } else if (offset == 2) {
              result[`+ue+`] = values[2];
            } else {
              result[`+ue+`] = values[3];
            }
          }
        }
        `}this.userCode=`
        `+(this.enableShapeUniforms?D8():D7(A))+`

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          `+ne+`

          `+$.output+" = "+xe+`;
        }
    `}}function g7(W){const A=D2(),V=A.version+`
    precision highp float;
    `+A.attribute+` vec3 clipSpacePos;
    `+A.attribute+` vec2 uv;
    `+A.varyingVs+` vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return EV(W,V)}function g8(W){const A=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Eo(W,A)}function g9(W){const A=new Uint16Array([0,1,2,2,1,3]);return Ee(W,A)}function gC(W,A,V,$,ne,xe){Es(A,V);const le=EQ(W),ce=W.TEXTURE_2D;return Ef(W,()=>W.bindTexture(ce,le)),Ef(W,()=>W.texParameteri(ce,W.TEXTURE_WRAP_S,W.CLAMP_TO_EDGE)),Ef(W,()=>W.texParameteri(ce,W.TEXTURE_WRAP_T,W.CLAMP_TO_EDGE)),Ef(W,()=>W.texParameteri(ce,W.TEXTURE_MIN_FILTER,W.NEAREST)),Ef(W,()=>W.texParameteri(ce,W.TEXTURE_MAG_FILTER,W.NEAREST)),Cd().getNumber("WEBGL_VERSION")===1?Ef(W,()=>W.texImage2D(ce,0,$,A,V,0,ne,xe,null)):Ef(W,()=>W.texStorage2D(ce,1,$,A,V)),Ef(W,()=>W.bindTexture(W.TEXTURE_2D,null)),{texture:le,texShape:[V,A]}}function gm(W){return W.internalFormatFloat}function gN(W,A,V,$){const[ne,xe]=E8(A,V);return gC(W,ne,xe,gm($),$.textureFormatFloat,W.FLOAT)}function gJ(W){return W.internalFormatHalfFloat}function gf(W,A,V,$){const[ne,xe]=E8(A,V);return gC(W,ne,xe,gJ($),$.textureFormatFloat,$.textureTypeHalfFloat)}function gi(W){return W.downloadTextureFormat}function gO(W,A,V,$){const[ne,xe]=E8(A,V);return gC(W,ne,xe,gi($),W.RGBA,W.UNSIGNED_BYTE)}function gt(W){return W.internalFormatPackedFloat}function gB(W,A,V,$){const[ne,xe]=Em(A,V);return gC(W,ne,xe,gt($),W.RGBA,W.FLOAT)}function gS(W){return W.internalFormatPackedHalfFloat}function gd(W,A,V,$){const[ne,xe]=Em(A,V);return gC(W,ne,xe,gS($),W.RGBA,$.textureTypeHalfFloat)}function gV(W,A,V){return Ef(W,()=>W.bindBuffer(W.ARRAY_BUFFER,V)),EI(W,A,"clipSpacePos",V,3,20,0)&&EI(W,A,"uv",V,2,20,12)}function gb(W,A,V,$,ne,xe){Ef(W,()=>W.bindTexture(W.TEXTURE_2D,A));let le,ce,ue;ne instanceof Uint8Array?(le=new Uint8Array(V*$*4),ce=W.UNSIGNED_BYTE,ue=W.RGBA):(le=new Float32Array(V*$*4),ce=W.FLOAT,ue=xe.internalFormatPackedFloat),le.set(ne),Cd().getNumber("WEBGL_VERSION")===2?Ef(W,()=>W.texSubImage2D(W.TEXTURE_2D,0,0,0,V,$,W.RGBA,ce,le)):Ef(W,()=>W.texImage2D(W.TEXTURE_2D,0,ue,V,$,0,W.RGBA,ce,le)),Ef(W,()=>W.bindTexture(W.TEXTURE_2D,null))}function gP(W,A,V){Ef(W,()=>W.bindTexture(W.TEXTURE_2D,A)),V.data instanceof Uint8Array?Cd().getNumber("WEBGL_VERSION")===2?Ef(W,()=>W.texSubImage2D(W.TEXTURE_2D,0,0,0,V.width,V.height,W.RGBA,W.UNSIGNED_BYTE,V.data)):Ef(W,()=>W.texImage2D(W.TEXTURE_2D,0,W.RGBA,V.width,V.height,0,W.RGBA,W.UNSIGNED_BYTE,V.data)):Cd().getNumber("WEBGL_VERSION")===2?Ef(W,()=>W.texSubImage2D(W.TEXTURE_2D,0,0,0,W.RGBA,W.UNSIGNED_BYTE,V)):Ef(W,()=>W.texImage2D(W.TEXTURE_2D,0,W.RGBA,W.RGBA,W.UNSIGNED_BYTE,V)),Ef(W,()=>W.bindTexture(W.TEXTURE_2D,null))}function gE(W,A,V,$){const ne=W.createBuffer();Ef(W,()=>W.bindBuffer(W.PIXEL_PACK_BUFFER,ne));const xe=4*4*A*V;return Ef(W,()=>W.bufferData(W.PIXEL_PACK_BUFFER,xe,W.STREAM_READ)),Ef(W,()=>W.readPixels(0,0,V,A,W.RGBA,W.FLOAT,0)),Ef(W,()=>W.bindBuffer(W.PIXEL_PACK_BUFFER,null)),ne}function gD(W,A,V){const $=W,ne=new Float32Array(V);return $.bindBuffer($.PIXEL_PACK_BUFFER,A),$.getBufferSubData($.PIXEL_PACK_BUFFER,0,ne),$.bindBuffer($.PIXEL_PACK_BUFFER,null),ne}function gg(W,A,V,$){const[ne,xe]=E8(A,V),le=4,ce=new Uint8Array(E9(A*V,le));return Ef(W,()=>W.readPixels(0,0,ne,xe,$.downloadTextureFormat,W.UNSIGNED_BYTE,ce)),new Float32Array(ce.buffer)}function gZ(W,A,V,$,ne,xe,le,ce){const ue=W,Te=new Float32Array(EN(xe,le));return ue.bindBuffer(ue.PIXEL_PACK_BUFFER,A),ue.getBufferSubData(ue.PIXEL_PACK_BUFFER,0,Te),ue.bindBuffer(ue.PIXEL_PACK_BUFFER,null),Te}function go(W,A,V){const $=new Float32Array(A*V*4);return Ef(W,()=>W.readPixels(0,0,V,A,W.RGBA,W.FLOAT,$)),$}class ge{constructor(A){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const V=Cd().getNumber("WEBGL_VERSION");if(A!=null?(this.gl=A,E1(V,A)):this.gl=E2(V),A=this.gl,Cd().getNumber("WEBGL_VERSION")===2){const xe=A;this.createVertexArray=()=>Ef(xe,()=>xe.createVertexArray()),this.bindVertexArray=le=>Ef(xe,()=>xe.bindVertexArray(le)),this.deleteVertexArray=le=>Ef(xe,()=>xe.deleteVertexArray(le)),this.getVertexArray=()=>Ef(xe,()=>xe.getParameter(xe.VERTEX_ARRAY_BINDING))}else if(A!=null){const xe=A.getExtension("OES_vertex_array_object");if(xe==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ef(A,()=>xe.createVertexArrayOES()),this.bindVertexArray=le=>Ef(A,()=>xe.bindVertexArrayOES(le)),this.deleteVertexArray=le=>Ef(A,()=>xe.deleteVertexArrayOES(le)),this.getVertexArray=()=>Ef(A,()=>A.getParameter(xe.VERTEX_ARRAY_BINDING_OES))}let $="WEBGL_color_buffer_float";const ne="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Cd().getNumber("WEBGL_VERSION")===1){const xe="OES_texture_float",le="OES_texture_half_float";if(this.textureFloatExtension=Ed(this.gl,xe),EG(this.gl,le))this.textureHalfFloatExtension=Ed(this.gl,le);else if(Cd().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension($),EG(this.gl,ne))this.colorBufferHalfFloatExtension=Ed(this.gl,ne);else if(Cd().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if($="EXT_color_buffer_float",EG(this.gl,$))this.colorBufferFloatExtension=this.gl.getExtension($);else if(EG(this.gl,ne))this.colorBufferHalfFloatExtension=this.gl.getExtension(ne);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=g8(this.gl),this.indexBuffer=g9(this.gl),this.framebuffer=EF(this.gl),this.textureConfig=EJ(this.gl,this.textureHalfFloatExtension)}get debug(){return Cd().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const A=this.gl;Ef(A,()=>A.finish()),Ef(A,()=>A.bindFramebuffer(A.FRAMEBUFFER,null)),Ef(A,()=>A.deleteFramebuffer(this.framebuffer)),Ef(A,()=>A.bindBuffer(A.ARRAY_BUFFER,null)),Ef(A,()=>A.bindBuffer(A.ELEMENT_ARRAY_BUFFER,null)),Ef(A,()=>A.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(A,V){return this.throwIfDisposed(),gN(this.gl,A,V,this.textureConfig)}createFloat16MatrixTexture(A,V){return this.throwIfDisposed(),gf(this.gl,A,V,this.textureConfig)}createUnsignedBytesMatrixTexture(A,V){return this.throwIfDisposed(),gO(this.gl,A,V,this.textureConfig)}uploadPixelDataToTexture(A,V){this.throwIfDisposed(),gP(this.gl,A,V)}uploadDenseMatrixToTexture(A,V,$,ne){this.throwIfDisposed(),gb(this.gl,A,V,$,ne,this.textureConfig)}createFloat16PackedMatrixTexture(A,V){return this.throwIfDisposed(),gd(this.gl,A,V,this.textureConfig)}createPackedMatrixTexture(A,V){return this.throwIfDisposed(),gB(this.gl,A,V,this.textureConfig)}deleteMatrixTexture(A){this.throwIfDisposed(),this.outputTexture===A&&(Ec(this.gl,this.framebuffer),this.outputTexture=null),Ef(this.gl,()=>this.gl.deleteTexture(A))}downloadByteEncodedFloatMatrixFromOutputTexture(A,V,$){return this.downloadMatrixDriver(A,()=>gg(this.gl,V,$,this.textureConfig))}downloadPackedMatrixFromBuffer(A,V,$,ne,xe,le){return gZ(this.gl,A,V,$,ne,xe,le,this.textureConfig)}downloadFloat32MatrixFromBuffer(A,V){return gD(this.gl,A,V)}createBufferFromTexture(A,V,$){this.bindTextureToFrameBuffer(A);const ne=gE(this.gl,V,$,this.textureConfig);return this.unbindTextureToFrameBuffer(),ne}createAndWaitForFence(){const A=this.createFence(this.gl);return this.pollFence(A)}createFence(A){let V,$;if(Cd().getBool("WEBGL_FENCE_API_ENABLED")){const ne=A,xe=ne.fenceSync(ne.SYNC_GPU_COMMANDS_COMPLETE,0);A.flush(),$=()=>{const le=ne.clientWaitSync(xe,0,0);return le===ne.ALREADY_SIGNALED||le===ne.CONDITION_SATISFIED},V=xe}else Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(V=this.beginQuery(),this.endQuery(),$=()=>this.isQueryAvailable(V,Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):$=()=>!0;return{query:V,isFencePassed:$}}downloadMatrixFromPackedTexture(A,V,$){return this.downloadMatrixDriver(A,()=>go(this.gl,V,$))}createProgram(A){this.throwIfDisposed();const V=this.gl;this.vertexShader==null&&(this.vertexShader=g7(V));const $=ED(V);Ef(V,()=>V.attachShader($,this.vertexShader)),Ef(V,()=>V.attachShader($,A)),Eg(V,$);const ne=Object.assign($,{vao:this.createVertexArray()});return this.debug&&EZ(V,ne),ne}buildVao(A){this.setProgram(A),this.bindVertexArray(A.vao);const V=this.gl;Ef(V,()=>V.bindBuffer(V.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),gV(V,A,this.vertexBuffer)}deleteProgram(A){this.throwIfDisposed(),A===this.program&&(this.program=null),A!=null&&(Ef(this.gl,()=>this.gl.deleteProgram(A)),this.deleteVertexArray(A.vao))}setProgram(A){this.throwIfDisposed(),this.program=A,this.program!=null&&this.debug&&EZ(this.gl,this.program),Ef(this.gl,()=>this.gl.useProgram(A))}getUniformLocation(A,V,$=!0){return this.throwIfDisposed(),$?EA(this.gl,A,V):Ep(this.gl,A,V)}getAttributeLocation(A,V){return this.throwIfDisposed(),Ef(this.gl,()=>this.gl.getAttribLocation(A,V))}getUniformLocationNoThrow(A,V){return this.throwIfDisposed(),this.gl.getUniformLocation(A,V)}setInputMatrixTexture(A,V,$){this.throwIfDisposed(),this.throwIfNoProgram(),Ew(this.gl,A,V,$)}setOutputMatrixTexture(A,V,$){this.setOutputMatrixTextureDriver(A,$,V)}setOutputPackedMatrixTexture(A,V,$){this.throwIfDisposed();const[ne,xe]=Em(V,$);this.setOutputMatrixTextureDriver(A,ne,xe)}setOutputMatrixWriteRegion(A,V,$,ne){this.setOutputMatrixWriteRegionDriver($,A,ne,V)}setOutputPackedMatrixWriteRegion(A,V,$,ne){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&EZ(this.gl,this.program),EW(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const A=this.gl;if(this.debug){const V=this.getVertexArray();console.assert(V===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ef(A,()=>A.drawElements(A.TRIANGLES,6,A.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ef(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ed(this.gl,Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const $=this.gl,ne=this.getQueryTimerExtensionWebGL2(),xe=$.createQuery();return $.beginQuery(ne.TIME_ELAPSED_EXT,xe),xe}const A=this.getQueryTimerExtensionWebGL1(),V=A.createQueryEXT();return A.beginQueryEXT(A.TIME_ELAPSED_EXT,V),V}endQuery(){if(Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const V=this.gl,$=this.getQueryTimerExtensionWebGL2();V.endQuery($.TIME_ELAPSED_EXT);return}const A=this.getQueryTimerExtensionWebGL1();A.endQueryEXT(A.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(A){return await q(()=>this.disposed||this.isQueryAvailable(A,Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(A,Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(A,V){if(V===0)return null;if(V===2){const $=this.gl;return $.getQueryParameter(A,$.QUERY_RESULT)/1e6}else{const $=this.getQueryTimerExtensionWebGL1();return $.getQueryObjectEXT(A,$.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(A,V){if(V===0)return!0;if(V===2){const $=this.gl,ne=this.getQueryTimerExtensionWebGL2(),xe=$.getQueryParameter(A,$.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(ne.GPU_DISJOINT_EXT)),xe&&!this.disjoint}else{const $=this.getQueryTimerExtensionWebGL1(),ne=$.getQueryObjectEXT(A,$.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter($.GPU_DISJOINT_EXT)),ne&&!this.disjoint}}pollFence(A){return new Promise(V=>{this.addItemToPoll(()=>A.isFencePassed(),()=>V())})}pollItems(){const A=gQ(this.itemsToPoll.map(V=>V.isDoneFn));for(let V=0;V<=A;++V){const{resolveFn:$}=this.itemsToPoll[V];$()}this.itemsToPoll=this.itemsToPoll.slice(A+1)}addItemToPoll(A,V){if(this.itemsToPoll.push({isDoneFn:A,resolveFn:V}),this.itemsToPoll.length>1)return;let $;"setTimeoutCustom"in Cd().platform&&($=Cd().platform.setTimeoutCustom.bind(Cd().platform)),q(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,$)}bindTextureToFrameBuffer(A){this.throwIfDisposed(),EX(this.gl,A,this.framebuffer),this.debug&&EW(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(EX(this.gl,this.outputTexture,this.framebuffer),this.debug&&EW(this.gl)):Ec(this.gl,this.framebuffer)}downloadMatrixDriver(A,V){this.bindTextureToFrameBuffer(A);const $=V();return this.unbindTextureToFrameBuffer(),$}setOutputMatrixTextureDriver(A,V,$){this.throwIfDisposed();const ne=this.gl;EX(ne,A,this.framebuffer),this.debug&&EW(ne),this.outputTexture=A,Ef(ne,()=>ne.viewport(0,0,V,$)),Ef(ne,()=>ne.scissor(0,0,V,$))}setOutputMatrixWriteRegionDriver(A,V,$,ne){this.throwIfDisposed(),Ef(this.gl,()=>this.gl.scissor(A,V,$,ne))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function gQ(W){let A=0;for(;A<W.length&&W[A]();++A);return A-1}function gs(W,A){Array.isArray(W)||(W=[W]),W.forEach(V=>{V!=null&&e(V.dtype!=="complex64",()=>A+" does not support complex64 tensors in the CPU backend.")})}function gF(W){const A=new Float32Array(W.length);for(let V=0;V<W.length;++V)A[V]=Math.abs(W[V]);return A}const gI=W=>{const{x:A}=W.inputs,V=W.backend;gs(A,"abs");let $=new Float32Array(F(A.shape));const ne=V.data.get(A.dataId).values;return $=gF(ne),V.makeOutput($,A.shape,A.dtype)},gy={kernelName:CZ,backendName:"cpu",kernelFunc:gI};function gA(W){return(A,V,$,ne,xe)=>{const le=iH(A,V),ce=le.length,ue=C5(le),Te=F(le),Me=H(xe,Te),Re=A.length,we=V.length,ke=C5(A),Ue=C5(V),Ge=ia(A,le),We=ia(V,le);if(Ge.length+We.length===0)for(let Xe=0;Xe<Me.length;++Xe)Me[Xe]=W($[Xe%$.length],ne[Xe%ne.length]);else for(let Xe=0;Xe<Me.length;++Xe){const Ye=CJ(Xe,ce,ue),je=Ye.slice(-Re);Ge.forEach(vt=>je[vt]=0);const Ke=CN(je,Re,ke),qe=Ye.slice(-we);We.forEach(vt=>qe[vt]=0);const $e=CN(qe,we,Ue);Me[Xe]=W($[Ke],ne[$e])}return[Me,le]}}function gp(W){const{inputs:A,backend:V}=W,{real:$,imag:ne}=A,xe=V.data.get($.dataId).values,le=V.data.get(ne.dataId).values,ce=V.makeTensorInfo($.shape,"complex64"),ue=V.data.get(ce.dataId);return ue.complexTensorInfos={real:V.makeTensorInfo($.shape,"float32",xe),imag:V.makeTensorInfo(ne.shape,"float32",le)},ce}function gw(W,A,V="float32"){if(V==="complex64"){const ne=gw(W,A,"float32"),xe=gw(W,A,"float32");return gp({inputs:{real:ne,imag:xe},backend:W})}const $=CC(F(A),V);return W.makeTensorInfo(A,V,$)}function gX(W){const{inputs:A,backend:V}=W,{x:$}=A;return V.incRef($.dataId),{dataId:$.dataId,shape:$.shape,dtype:$.dtype}}const gc={kernelName:Cj,backendName:"cpu",kernelFunc:gX};function gW(W){const{inputs:A,backend:V}=W,{input:$}=A,ne=V.data.get($.dataId).complexTensorInfos.real,xe=V.data.get(ne.dataId).values;return V.makeTensorInfo(ne.shape,ne.dtype,xe)}function gR(W,A,V,$){if($==="int32"){const ne=Int32Array.from(W);return[A,"int32",ne]}if($==="bool"){const ne=NH([0],V),[xe,le]=gA((ce,ue)=>ce!==ue?1:0)(A,[],W,ne,"bool");return[le,"bool",xe]}throw new Error("Error in Cast: failed to cast "+V+" to "+$)}function gK(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{dtype:xe}=$;if(xe==="complex64"){if(ne.dtype==="complex64")return gX({inputs:{x:ne},backend:V});const Me=gw(V,ne.shape,ne.dtype),Re=gK({inputs:{x:ne},backend:V,attrs:{dtype:"float32"}}),we=gp({inputs:{real:Re,imag:Me},backend:V});return V.disposeIntermediateTensorInfo(Me),V.disposeIntermediateTensorInfo(Re),we}if(ne.dtype==="complex64"){const Me=gW({inputs:{input:ne},backend:V}),Re=gK({inputs:{x:Me},backend:V,attrs:{dtype:xe}});return V.disposeIntermediateTensorInfo(Me),Re}if(!Y(ne.dtype,xe)){const Me=gX({inputs:{x:ne},backend:V});return{dataId:Me.dataId,shape:Me.shape,dtype:xe}}const le=V.data.get(ne.dataId).values,[ce,ue,Te]=gR(le,ne.shape,ne.dtype,xe);return V.makeTensorInfo(ce,ue,Te)}const gT={kernelName:CA,backendName:"cpu",kernelFunc:gK};function gv(W,A,V,$){return V==null?({inputs:ne,backend:xe})=>{const{a:le,b:ce}=ne,ue=xe;gs([le,ce],W);const Te=ue.data.get(le.dataId).values,Me=ue.data.get(ce.dataId).values,Re=le.dtype==="string"?Ve(Te):Te,we=le.dtype==="string"?Ve(Me):Me,ke=$||le.dtype,[Ue,Ge]=A(le.shape,ce.shape,Re,we,ke);return ue.makeTensorInfo(Ge,ke,Ue)}:({inputs:ne,backend:xe})=>{const{a:le,b:ce}=ne,ue=xe;if(le.dtype==="complex64"||ce.dtype==="complex64"){const Te=gK({inputs:{x:le},backend:ue,attrs:{dtype:"complex64"}}),Me=ue.data.get(Te.dataId),Re=Me.complexTensorInfos.real,we=Me.complexTensorInfos.imag,ke=ue.data.get(Re.dataId).values,Ue=ue.data.get(we.dataId).values,Ge=gK({inputs:{x:ce},backend:ue,attrs:{dtype:"complex64"}}),We=ue.data.get(Ge.dataId),Xe=We.complexTensorInfos.real,Ye=We.complexTensorInfos.imag,je=ue.data.get(Xe.dataId).values,Ke=ue.data.get(Ye.dataId).values,[qe,$e,vt]=V(le.shape,ce.shape,ke,Ue,je,Ke),nt=ue.makeTensorInfo(vt,"float32",qe),wt=ue.makeTensorInfo(vt,"float32",$e),Kt=gp({inputs:{real:nt,imag:wt},backend:ue});return ue.disposeIntermediateTensorInfo(Te),ue.disposeIntermediateTensorInfo(Ge),ue.disposeIntermediateTensorInfo(nt),ue.disposeIntermediateTensorInfo(wt),Kt}else{const Te=ue.data.get(le.dataId).values,Me=ue.data.get(ce.dataId).values,Re=$||le.dtype,[we,ke]=A(le.shape,ce.shape,Te,Me,Re);return ue.makeTensorInfo(ke,Re,we)}}}function gq(W){return(A,V,$,ne,xe,le)=>{const ce=iH(A,V),ue=F(ce),Te=ce.length,Me=C5(ce),Re=H("float32",ue),we=H("float32",ue),ke=ia(A,ce),Ue=ia(V,ce),Ge=du($,ne),We=du(xe,le),Xe=A.length,Ye=C5(A),je=V.length,Ke=C5(V);if(ke.length+Ue.length===0)for(let qe=0;qe<Re.length;qe++){const $e=qe%Ge.length,vt=qe%We.length,nt=W(Ge[$e*2],Ge[$e*2+1],We[vt*2],We[vt*2+1]);Re[qe]=nt.real,we[qe]=nt.imag}else for(let qe=0;qe<Re.length;qe++){const $e=CJ(qe,Te,Me),vt=$e.slice(-Xe);ke.forEach(pi=>vt[pi]=0);const nt=CN(vt,Xe,Ye),wt=$e.slice(-je);Ue.forEach(pi=>wt[pi]=0);const Kt=CN(wt,je,Ke),Ht=W(Ge[nt*2],Ge[nt*2+1],We[Kt*2],We[Kt*2+1]);Re[qe]=Ht.real,we[qe]=Ht.imag}return[Re,we,ce]}}const gl=gA((W,A)=>W+A),ga=gq((W,A,V,$)=>({real:W+V,imag:A+$})),gn=gv(Co,gl,ga),gL={kernelName:Co,backendName:"cpu",kernelFunc:gn};function gH(W,A,V,$,ne){const xe=F($),le=CC(ne,V);for(let ce=0;ce<W.length;ce++){const ue=W[ce];if(ue<0)throw new Error("Input x must be non-negative!");ue>=ne||(xe>0?le[ue]+=A[ce]:le[ue]+=1)}return le}function gk(W,A,V,$=!1){const ne=W.shape[0],xe=W.shape[1],le=t7([ne,V],A.dtype);for(let ce=0;ce<ne;ce++)for(let ue=0;ue<xe;ue++){const Te=W.get(ce,ue);if(Te<0)throw new Error("Input x must be non-negative!");Te>=V||($?le.set(1,ce,Te):A.size>0?le.set(le.get(ce,Te)+A.get(ce,ue),ce,Te):le.set(le.get(ce,Te)+1,ce,Te))}return le}const gz=gA((W,A)=>W&A);function gx(W){return(A,V,$)=>{const ne=x(V,A.length);for(let xe=0;xe<A.length;++xe)ne[xe]=W(A[xe],$);return ne}}function gU(W,A,V){const $=gx(A);return gG(W,$,V)}function gG(W,A,V){return({inputs:$,attrs:ne,backend:xe})=>{const{x:le}=$;gs(le,W);const ce=xe,ue=ce.data.get(le.dataId).values;let Te;if(le.dtype==="string"){if(!Array.isArray(ue))throw new Error("String tensor's value was not an instance of Array");Te=Ve(ue)}else Te=ue;const Me=V||le.dtype,Re=A(Te,Me,ne);return ce.makeTensorInfo(le.shape,Me,Re)}}const gu=gx(W=>Math.ceil(W));function gY(W,A,V,$){const ne=x(V,F(A));if($&&V!=="string"){let xe=0;W.forEach(le=>{const ce=F(le.shape);ne.set(le.vals,xe),xe+=ce})}else{let xe=0;W.forEach(le=>{const ce=V==="string"?Ve(le.vals):le.vals;let ue=0;for(let Te=0;Te<le.shape[0];++Te){const Me=Te*A[1]+xe;for(let Re=0;Re<le.shape[1];++Re)ne[Me+Re]=ce[ue++]}xe+=le.shape[1]})}return ne}const gM=gA((W,A)=>W===A?1:0),gh=gx(W=>Math.exp(W)),gj=gx(W=>Math.expm1(W)),gr=gx(W=>Math.floor(W)),Z0=gG(CG,gr),Z1={kernelName:CG,backendName:"cpu",kernelFunc:Z0},Z2=gA((W,A)=>Math.floor(W/A));function Z3(W,A,V,$,ne,xe,le,ce,ue){const Te=t7([$,xe],V);for(let Me=0;Me<$;Me++){const Re=[];let we=0;for(let ke=0;ke<ne;ke++){const Ue=W[Me*ne+ke];we+=Ue*le[ke],Re.push(Ue)}if(we<0||we>=ue/xe)throw new Error("Invalid indices: "+Re+" does not index into "+ce);for(let ke=0;ke<xe;ke++)Te.values[Me*xe+ke]=A.get(...A.indexToLoc(we*xe+ke))}return Te}function Z4(W,A,V){const $=t7(V,W.dtype);for(let ne=0;ne<$.size;++ne){const xe=$.indexToLoc(ne).slice(),le=xe[0],ce=xe[2],ue=A.locToIndex([le,ce]);xe[2]=A.values[ue];const Te=W.locToIndex(xe);0<=Te&&Te<W.values.length&&($.values[ne]=W.values[Te])}return $}const Z5=gA((W,A)=>W>A?1:0),Z6=gA((W,A)=>W>=A?1:0),Z7=gv(Ch,Z6,null,"bool"),Z8={kernelName:Ch,backendName:"cpu",kernelFunc:Z7},Z9=gA((W,A)=>W<A?1:0),ZC=gv(m1,Z9,null,"bool"),Zm={kernelName:m1,backendName:"cpu",kernelFunc:ZC},ZN=gA((W,A)=>W<=A?1:0),ZJ=gv(m2,ZN,null,"bool"),Zf={kernelName:m2,backendName:"cpu",kernelFunc:ZJ};function Zi(W,A,V){const $=(A-W)/(V-1),ne=CC(V,"float32");ne[0]=W;for(let xe=1;xe<ne.length;xe++)ne[xe]=ne[xe-1]+$;return ne}const ZO=gx(W=>Math.log(W));function Zt(W,A,V,$){const ne=H($,F(V));for(let xe=0;xe<ne.length;++xe){const le=xe*A;let ce=W[le];for(let ue=0;ue<A;++ue){const Te=W[le+ue];(Number.isNaN(Te)||Te>ce)&&(ce=Te)}ne[xe]=ce}return ne}const ZB=gA((W,A)=>Math.max(W,A)),ZS=gv(m6,ZB),Zd={kernelName:m6,backendName:"cpu",kernelFunc:ZS},ZV=gA((W,A)=>Math.min(W,A)),Zb=gv(mC,ZV),ZP={kernelName:mC,backendName:"cpu",kernelFunc:Zb},ZE=gA((W,A)=>W*A),ZD=gq((W,A,V,$)=>({real:W*V-A*$,imag:W*$+A*V})),Zg=gv(mm,ZE,ZD),ZZ={kernelName:mm,backendName:"cpu",kernelFunc:Zg};function Zo(W,A,V){const $=Nn(-1,V);return ZE([],A,$,W,V)}function Ze(W){const{inputs:A,backend:V}=W,{x:$}=A;gs($,"neg");const ne=V.data.get($.dataId).values,[xe,le]=Zo(ne,$.shape,$.dtype);return V.makeTensorInfo(le,$.dtype,xe)}const ZQ={kernelName:mN,backendName:"cpu",kernelFunc:Ze},Zs=gA((W,A)=>W!==A?1:0);function ZF(W,A,V,$,ne){const xe=A.length,le=F(A),ce=C5(A),ue=C5(ne),Te=H(V,F(ne));for(let Me=0;Me<le;++Me){const Re=CJ(Me,xe,ce),we=new Array(Re.length);for(let Ue=0;Ue<we.length;Ue++)we[Ue]=Re[$[Ue]];const ke=CN(we,xe,ue);Te[ke]=W[Me]}return Te}function ZI(W){const{inputs:A,attrs:V,backend:$}=W,{x:ne}=A,{perm:xe}=V;gs(ne,"transpose");const le=ne.shape.length,ce=new Array(le);for(let Me=0;Me<ce.length;Me++)ce[Me]=ne.shape[xe[Me]];const ue=$.data.get(ne.dataId).values,Te=ZF(ue,ne.shape,ne.dtype,xe,ce);return{dataId:$.write(Te,ce,ne.dtype),shape:ce,dtype:ne.dtype}}const Zy={kernelName:mK,backendName:"cpu",kernelFunc:ZI};function ZA(W,A,V,$){const[ne,xe]=tw(W,$),le=Jb(A,"int32"),ce=CC(F(ne),le),ue=F(xe);for(let Te=0;Te<ce.length;++Te){const Me=Te*ue;let Re=1;for(let we=0;we<ue;++we)Re*=V[Me+we];ce[Te]=Re}return{outVals:ce,outShape:ne,outDtype:le}}function Zp(W,A,V){W.forEach(($,ne)=>{if($<0||$>=V){const xe=CJ(ne,A.length,C5(A)).join(",");throw new Error("indices["+xe+"] = "+$+" is not in [0, "+V+")")}})}function Zw(W,A){for(let V=0;V<W.length;++V){const $=W[V],ne=V===W.length-1?A:W[V+1].length;if($.length===0)throw new Error("Ragged splits may not be empty");if($[0]<0)throw new Error("Ragged splits must be non-negative");if($[$.length-1]>ne)throw new Error("Ragged splits must not point past values");for(let xe=1;xe<$.length;++xe)if($[xe-1]>$[xe])throw new Error("Ragged splits must be sorted in ascending order")}}function ZX(W,A,V,$){const ne=[];let xe=0;const le=A.length-1+V.length,ce=new Array(le).fill(null).map(()=>[0]);Zw(V,$);let ue=1;for(let Te=0;Te<A.length-1;++Te){ue*=A[Te];const Me=A[Te+1];for(let Re=1;Re<ue+1;++Re)ce[Te].push(Re*Me)}for(let Te=0;Te<W.length;++Te){let Me=W[Te],Re=W[Te]+1;for(let we=0;we<V.length;++we){const ke=V[we],Ue=we+A.length-1;if(Ue>=0){const Ge=ce[Ue],We=Ge[Ge.length-1]-ke[Me];for(let Xe=Me;Xe<Re;++Xe)ce[Ue].push(ke[Xe+1]+We)}Me=ke[Me],Re=ke[Re]}Re!==Me&&(ne.push([Me,Re]),xe+=Re-Me)}return{outSplits:ce,valueSlices:ne,numValues:xe}}function Zc(W){const A=[];for(let V=0;V<W.length;++V){const $=W[V].length,ne=x("int32",$);A.push(ne),W[V].forEach((xe,le)=>ne[le]=xe)}return A}function ZW(W,A){const V=W.slice(0,A);for(;V.length<A;)V.push(1);for(let $=A;$<W.length;$++)V[A-1]*=W[$];return V}function ZR(W,A,V,$,ne,xe){const le=ZW(A,2)[1],ce=ZW(xe,2)[1];let ue=0;for(const Te of V)for(let Me=Te[0];Me<Te[1];++Me){for(let Re=0;Re<$;++Re)ne[ue*ce+Re]=W[Me*le+Re];++ue}}function ZK(W,A,V,$,ne){const xe=A.slice();xe[0]=ne;const le=x(V,F(xe)),ce=W.length,ue=ce===0?0:ce/A[0];return ZR(W,A,$,ue,le,xe),[le,xe]}function ZT(W,A,V,$,ne,xe,le,ce){if(W.length===0)throw new Error("paramsNestedSplits must be non empty");if(A[0].length===0)throw new Error("Split tensors must not be scalars");const ue=A[0][0]-1;if(Zp(xe,le,ue),$.length===0)throw new Error("params.rank must be nonzero");const Te=$[0],{outSplits:Me,valueSlices:Re,numValues:we}=ZX(xe,le,W,Te),ke=Zc(Me),Ue=ZK(V,$,ne,Re,we);return[ke,Ue[0],Ue[1]]}const Zv=2147483647;function Zq(W,A,V,$,ne,xe,le){if(A.length>1)throw new Error("starts must be a scalar or vector");if(ne.length>1)throw new Error("limits must be a scalar or vector");if(le.length>1)throw new Error("deltas must be a scalar or vector");const ce=A.length===0,ue=ne.length===0,Te=le.length===0,Me=[];ce||Me.push(A[0]),ue||Me.push(ne[0]),Te||Me.push(le[0]);for(let We=1;We<Me.length;++We)if(Me[We]!==Me[We-1])throw new Error("starts, limits, and deltas must have the same shape");const Re=Me.length===0?1:Me[0],we=x("int32",Re+1);we[0]=0;for(let We=0;We<Re;++We){const Xe=ce?W[0]:W[We],Ye=ue?$[0]:$[We],je=Te?xe[0]:xe[We];if(je===0)throw new Error("Requires delta != 0");let Ke;if(je>0&&Ye<Xe||je<0&&Ye>Xe)Ke=0;else if(Ke=Math.ceil(Math.abs((Ye-Xe)/je)),Ke>Zv)throw new Error("Requires ((limit - start) / delta) <= "+Zv);we[We+1]=we[We]+Ke}const ke=we[Re],Ue=x(V,ke);let Ge=0;for(let We=0;We<Re;++We){const Xe=we[We+1]-we[We];let Ye=ce?W[0]:W[We];const je=Te?xe[0]:xe[We];for(let Ke=0;Ke<Xe;++Ke)Ue[Ge++]=Ye,Ye+=je}return[we,Ue]}var Zl=dA;class Za{constructor(A,V,$,ne,xe,le,ce,ue,Te,Me){this.shape=A,this.shapeShape=V,this.values=$,this.valuesShape=ne,this.valuesDType=xe,this.defaultValue=le,this.defaultValueShape=ce,this.rowPartitionValues=ue,this.rowPartitionValuesShapes=Te,this.rowPartitionTypes=dw(Me),this.raggedRank=dX(this.rowPartitionTypes)}getRowPartitionTypeByDimension(A){return this.rowPartitionTypes[0]===Zl.FIRST_DIM_SIZE?this.rowPartitionTypes[A+1]:this.rowPartitionTypes[A]}getRowPartitionTensor(A){return this.rowPartitionTypes[0]===Zl.FIRST_DIM_SIZE?this.rowPartitionValues[A+1]:this.rowPartitionValues[A]}getMaxWidth(A){const V=this.getRowPartitionTensor(A-1);switch(this.getRowPartitionTypeByDimension(A-1)){case Zl.VALUE_ROWIDS:return Za.getMaxWidthValueRowID(V);case Zl.ROW_SPLITS:return Za.getMaxWidthRowSplit(V);default:throw new Error("Cannot handle partition type "+Zl[this.getRowPartitionTypeByDimension(A-1)])}}static getMaxWidthRowSplit(A){const V=A.length;if(V===0||V===1)return 0;let $=0;for(let ne=0;ne<V-1;++ne){const xe=A[ne+1]-A[ne];xe>$&&($=xe)}return $}static getMaxWidthValueRowID(A){const V=A.length;if(V===0)return 0;let $=0,ne=A[0],xe=0;for(let le=1;le<V;++le){const ce=A[le];ce!==ne&&(ne=ce,xe=Math.max(le-$,xe),$=le)}return Math.max(V-$,xe)}tensorShapeFromTensor(A,V,$=!0){if(V.length===0){if(A[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return ZL(A,$)}calculateOutputSize(A){const V=this.valuesShape,$=this.defaultValueShape;dc($,V);const ne=this.tensorShapeFromTensor(this.shape,this.shapeShape),xe=dp(this.raggedRank,ne,V);xe[0]<0&&(xe[0]=A);for(let le=1;le<=this.raggedRank;++le)xe[le]<0&&(xe[le]=this.getMaxWidth(le));return xe}calculateFirstParentOutputIndex(A,V,$){const ne=Math.min(A,$),xe=[];let le=0;for(let ce=0;ce<ne;++ce,le+=V)xe.push(le);for(let ce=ne;ce<A;++ce)xe.push(-1);return e(xe.length===A,()=>"Final length of result must be equal to firstDimension."),xe}calculateOutputIndexRowSplit(A,V,$,ne){const xe=A.length,le=[];for(let ce=0;ce<xe-1;++ce){const ue=A[ce+1]-A[ce];let Te=Math.min(ne,ue),Me=V[ce];Me===-1&&(Te=0);for(let Re=0;Re<Te;++Re)le.push(Me),Me+=$;for(let Re=0;Re<ue-Te;++Re)le.push(-1)}if(xe>0&&le.length!==A[xe-1])throw new Error("Invalid row split size.");return le}calculateOutputIndexValueRowID(A,V,$,ne){const xe=A.length,le=[];if(xe===0)return[];let ce=0,ue=A[0];if(ue>=V.length)throw new Error("Got currentValueRowId="+ue+", which is not less than "+V.length);let Te=V[ue];le.push(Te);for(let Me=1;Me<xe;++Me){const Re=A[Me];if(Re===ue)Te>=0&&(++ce,ce<ne?Te+=$:Te=-1);else{if(ce=0,ue=Re,Re>=V.length)throw new Error("Got nextValueRowId="+Re+" which is not less than "+V.length);Te=V[Re]}le.push(Te)}if(le.length!==A.length)throw new Error("Invalid row ids.");return le}calculateOutputIndex(A,V,$,ne){const xe=this.getRowPartitionTensor(A),le=this.getRowPartitionTypeByDimension(A);switch(le){case Zl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(xe,V,$,ne);case Zl.ROW_SPLITS:if(xe.length-1>V.length)throw new Error("Row partition size is greater than output size: "+(xe.length-1)+" > "+V.length);return this.calculateOutputIndexRowSplit(xe,V,$,ne);default:throw new Error("Unsupported partition type: "+Zl[le])}}getFirstDimensionSize(){const A=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const V=this.rowPartitionTypes[0];switch(V){case Zl.FIRST_DIM_SIZE:return A[0];case Zl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Zl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type "+Zl[V])}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const A=this.getFirstDimensionSize(),V=this.calculateOutputSize(A),$=new Array(this.raggedRank+1);$[$.length-1]=1;for(let le=$.length-2;le>=0;--le)$[le]=$[le+1]*V[le+1];const ne=ZL(V,!1),xe=x(this.valuesDType,F(ne));if($[0]*V[0]>0){let le=this.calculateFirstParentOutputIndex(A,$[0],V[0]);for(let ce=1;ce<=this.raggedRank;++ce)le=this.calculateOutputIndex(ce-1,le,$[ce],V[ce]);this.setOutput(this.raggedRank,le,xe,ne)}return[ne,xe]}setOutput(A,V,$,ne){if($.length===0)return;const xe=this.values,le=$;let ce=ne.slice();ce=ce.slice(A+1);const ue=F(ce),Te=V.length;let Me=this.defaultValue;if(Me.length!==ue&&Me.length!==1){const Ue=this.defaultValueShape;JY(()=>{const Ge=Oz(Me,Ue);Me=t6(Ge,ce).dataSync()})}let Re=0,we=0,ke=0;for(let Ue=0;Ue<=Te;++Ue){let Ge=Ue<Te?V[Ue]:-1;if(Ge===ke){++ke;continue}if(we<ke){const We=xe.subarray(Re*ue),Xe=le.subarray(we*ue),Ye=(ke-we)*ue;Zn(Xe,We,Ye)}if(Ue>=Te){const We=$.length;Ge=Math.floor(We/ue)}if(Ge>ke)if(this.defaultValue.length===1)le.subarray(ke*ue,Ge*ue).fill(this.defaultValue[0]),ke=Ge;else for(;Ge>ke;){const We=le.slice(ke*ue);Zn(We,Me,ue),++ke}Ge<0?(Re=Ue+1,we=ke):(Re=Ue,we=ke,ke=we+1)}}}function Zn(W,A,V){for(let $=0;$<V;$++)W[$]=A[$]}function ZL(W,A){const V=[];for(let $ of W){if($<0){if(!A)throw new Error("Dimension "+$+" must be >= 0");if($<-1)throw new Error("Dimension "+$+" must be >= -1");$=-1}V.push($)}return V}function ZH(W,A,V,$,ne,xe,le,ce,ue,Te){return new Za(W,A,V,$,ne,xe,le,ce,ue,Te).compute()}function Zk(W,A,V,$){const ne=W===A,xe=W<A&&V<0,le=A<W&&V>1;if(ne||xe||le)return CC(0,$);const ce=Math.abs(Math.ceil((A-W)/V)),ue=CC(ce,$);A<W&&V===1&&(V=-1),ue[0]=W;for(let Te=1;Te<ue.length;Te++)ue[Te]=ue[Te-1]+V;return ue}const Zz=gx(W=>1/Math.sqrt(W));function Zx(W,A,V,$,ne,xe,le,ce,ue,Te){const Me=[$/ne,ne],Re=W.values,we=A.values;if($===0)return t7(V,A.dtype);const ke=ue instanceof J8?ue:t7(Me,A.dtype);typeof ue=="string"||typeof ue=="number"?ke.values.fill(ue):typeof ue=="boolean"&&ke.values.fill(+ue);for(let Ue=0;Ue<xe;Ue++){const Ge=[];let We=0;for(let Xe=0;Xe<le;Xe++){const Ye=Re[Ue*le+Xe];Ge.push(Ye),We+=Ye*ce[Xe]}if(We<0||We>=$/ne)throw new Error("Invalid indices: "+Ge+" does not index into "+V);for(let Xe=0;Xe<ne;Xe++)Te?ke.values[We*ne+Xe]+=we[Ue*ne+Xe]:ke.values[We*ne+Xe]=A.rank===0?we[0]:we[Ue*ne+Xe]}return ke}const ZU=gx(W=>1/(1+Math.exp(-W))),ZG=gU(mF,W=>1/(1+Math.exp(-W))),Zu={kernelName:mF,backendName:"cpu",kernelFunc:ZG};function ZY(W,A,V,$,ne){const xe=Om($,A,V),le=F(V),ce=C5($);if(xe){const Re=ON(A,ce);return ne==="string"?W.slice(Re,Re+le):W.subarray(Re,Re+le)}const ue=ne==="string"?Ve(W):W,Te=t7($,ne,ue),Me=t7(V,ne);for(let Re=0;Re<Me.size;++Re){const we=Me.indexToLoc(Re),ke=we.map((Ue,Ge)=>Ue+A[Ge]);Me.set(Te.get(...ke),...we)}return ne==="string"?VQ(Me.values):Me.values}function ZM(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{begin:xe,size:le}=$;gs(ne,"slice");const[ce,ue]=OJ(ne,xe,le);ir(ne,ce,ue);const Te=V.data.get(ne.dataId).values,Me=ZY(Te,ce,ue,ne.shape,ne.dtype);return V.makeTensorInfo(ue,ne.dtype,Me)}const Zh={kernelName:mQ,backendName:"cpu",kernelFunc:ZM};function Zj(W,A,V,$,ne,xe,le){const ce=A[0],ue=xe[0],Te=new Array(ue),Me=new Array(ce),Re=A[1];if(ue===0){if(ce!==0)throw new Error(VJ(ce));const We=x(V,0),Xe=x(ne,0);return[We,[0,Re],Xe,Te,Me]}let we=!0,ke=0;const Ue=new Array(ue).fill(0);for(let We=0;We<ce;++We){const Xe=W[We*Re];if(Xe<0)throw new Error(Vf(We,Xe));if(Xe>=ue)throw new Error(Vi(We,Xe,ue));++Ue[Xe],we=we&&Xe>=ke,ke=Xe}let Ge=!0;for(let We=0;We<ue;++We){const Xe=Ue[We]===0;Te[We]=Xe,Ge=Ge&&!Xe,Ue[We]=Math.max(Ue[We],1),We>0&&(Ue[We]+=Ue[We-1])}if(Ge&&we){const We=W,Xe=$;for(let Ye=0;Ye<ce;++Ye)Me[Ye]=Ye;return[We,[ce,Re],Xe,Te,Me]}else{const We=Ue[ue-1],Xe=x(V,We*Re),Ye=x(ne,We),je=new Array(ue).fill(0);for(let Ke=0;Ke<ce;++Ke){const qe=W[Ke*Re],$e=je[qe],vt=(qe===0?0:Ue[qe-1])+$e;je[qe]++;for(let nt=0;nt<Re;++nt)Xe[vt*Re+nt]=W[Ke*Re+nt];Ye[vt]=$[Ke],Me[Ke]=vt}for(let Ke=0;Ke<ue;++Ke)if(je[Ke]===0){const qe=Ke===0?0:Ue[Ke-1];Xe[qe*Re+0]=Ke;for(let $e=1;$e<Re;++$e)Xe[qe*Re+$e]=0;Ye[qe]=le}return[Xe,[We,Re],Ye,Te,Me]}}function Zr(W,A,V,$,ne){const xe=F($),le=A[0],ce=ne.length,ue=[];let Te=1,Me=-1;for(let Ge=0;Ge<ce;++Ge){const We=ne[Ge];if(We===-1){if(Me!==-1)throw new Error(VO(Me,Ge));Me=Ge,ue.push(1)}else{if(We<0)throw new Error(Vt(Ge,We));Te*=We,ue.push(We)}}if(Me!==-1){if(Te<=0)throw new Error(VB());const Ge=Math.trunc(xe/Te);if(Te*Ge!==xe)throw new Error(VS($,ue));ue[Me]=Ge}if(F(ue)!==xe)throw new Error(Vd($,ue));const Re=$.length,we=[];if(Re>0){we[Re-1]=1;for(let Ge=Re-2;Ge>=0;--Ge)we[Ge]=we[Ge+1]*$[Ge+1]}const ke=[];if(ce>0){ke[ce-1]=1;for(let Ge=ce-2;Ge>=0;--Ge)ke[Ge]=ke[Ge+1]*ue[Ge+1]}const Ue=x(V,le*ce);for(let Ge=0;Ge<le;++Ge){let We=0;for(let Xe=0;Xe<Re;++Xe)We+=W[Ge*Re+Xe]*we[Xe];for(let Xe=0;Xe<ce;++Xe)Ue[Ge*ce+Xe]=Math.trunc(We/ke[Xe]),We%=ke[Xe]}return[Ue,[le,ce],ue]}function o0(W,A,V,$,ne,xe=!1,le=0){const ce=$.length,ue=[A[0],W.length/A[0]],Te=ue[1],Me=ce>0?ne[ce-1]+1:0;if(Me<0)throw new Error(VV());const Re=A.slice();Re[0]=Me;const we=Re.reduce((Ye,je)=>Ye*je,1),ke=x(V,we);if(ce===0)return Me>0&&ke.fill(le),[ke,Re];if(Me<=0)throw new Error(VV());let Ue=0,Ge=1,We=0,Xe=ne[Ue];for(;;){let Ye=0;if(Ge<ce){if(Ye=ne[Ge],Xe===Ye){++Ge;continue}if(Xe>=Ye)throw new Error(Vb())}if(Xe<0||Xe>=Me)throw new Error(VP(Xe,Me));Xe>We&&ke.fill(le,We*Te,Xe*Te);for(let je=Ue;je<Ge;++je){const Ke=$[je];if(Ke<0||Ke>=ue[0])throw new Error(VE(je,$[je],ue[0]));for(let qe=0;qe<Te;qe++)ke[Xe*Te+qe]+=W[Ke*Te+qe]}if(xe)for(let je=0;je<Te;je++)ke[Xe*Te+je]/=Ge-Ue;if(Ue=Ge,++Ge,We=Xe+1,Xe=Ye,Ge>ce)break}return We<Me&&ke.fill(le,We*Te,Me*Te),[ke,Re]}const o1=gx(W=>Math.sqrt(W)),o2=gU(mI,W=>Math.sqrt(W)),o3={kernelName:mI,backendName:"cpu",kernelFunc:o2},o4=gA((W,A)=>{const V=W-A;return V*V}),o5=gx((W,A)=>{const{pattern:V,replaceGlobal:$,rewrite:ne}=A;return W.replace(new RegExp(V,$?"g":""),ne)});function o6(W,A,V,$){const ne=t7(W,A.dtype);for(let xe=0;xe<ne.size;xe++){const le=ne.indexToLoc(xe),ce=new Array(le.length);for(let ue=0;ue<ce.length;ue++)ce[ue]=le[ue]*V[ue]+$[ue];ne.set(A.get(...ce),...le)}return ne}class o7{constructor(A,V,$,ne,xe,le){this.separator=Nz(A),this.nGramWidths=V,this.leftPad=Nz($),this.rightPad=Nz(ne),this.padWidth=xe,this.preserveShort=le}getPadWidth(A){return Math.min(this.padWidth<0?A-1:this.padWidth,A-1)}getNumNGrams(A,V){const $=this.getPadWidth(V);return Math.max(0,A+2*$-V+1)}createNGrams(A,V,$,ne,xe,le){for(let ce=0;ce<xe;++ce){const ue=this.getPadWidth(le),Te=Math.max(0,ue-ce),Me=Math.max(0,ue-(xe-(ce+1))),Re=le-(Te+Me),we=V+(Te>0?0:ce-ue);let ke=0;ke+=Te*this.leftPad.length;for(let Ye=0;Ye<Re;++Ye)ke+=A[we+Ye].length;ke+=Me*this.rightPad.length;const Ue=Te+Me+Re-1;ke+=Ue*this.separator.length,$[ne+ce]=new Uint8Array(ke);const Ge=$[ne+ce];let We=0;const Xe=Ye=>Ye.forEach(je=>Ge[We++]=je);for(let Ye=0;Ye<Te;++Ye)Xe(this.leftPad),Xe(this.separator);for(let Ye=0;Ye<Re-1;++Ye)Xe(A[we+Ye]),Xe(this.separator);if(Re>0){Xe(A[we+Re-1]);for(let Ye=0;Ye<Me;++Ye)Xe(this.separator),Xe(this.rightPad)}else{for(let Ye=0;Ye<Me-1;++Ye)Xe(this.rightPad),Xe(this.separator);Xe(this.rightPad)}}}compute(A,V){const $=A.length,ne=V.length;if(ne>0){let ue=V[0];if(ue!==0)throw new Error("First split value must be 0, got "+ue);for(let Te=1;Te<ne;++Te){let Me=V[Te]>=ue;if(Me=Me&&V[Te]<=$,!Me)throw new Error("Invalid split value "+V[Te]+", must be in ["+ue+", "+$+"]");ue=V[Te]}if(ue!==$)throw new Error("Last split value must be data size. Expected "+$+", got "+ue)}const xe=ne-1,le=x("int32",ne);if($===0||ne===0){const ue=new Array($);for(let Te=0;Te<=xe;++Te)le[Te]=0;return[ue,le]}le[0]=0;for(let ue=1;ue<=xe;++ue){const Te=V[ue]-V[ue-1];let Me=0;this.nGramWidths.forEach(Re=>{Me+=this.getNumNGrams(Te,Re)}),this.preserveShort&&Te>0&&Me===0&&(Me=1),le[ue]=le[ue-1]+Me}const ce=new Array(le[xe]);for(let ue=0;ue<xe;++ue){const Te=V[ue];let Me=le[ue];if(this.nGramWidths.forEach(Re=>{const we=V[ue+1]-V[ue],ke=this.getNumNGrams(we,Re);this.createNGrams(A,Te,ce,Me,ke,Re),Me+=ke}),this.preserveShort&&Me===le[ue]){const Re=V[ue+1]-V[ue];if(Re===0)continue;const we=Re+2*this.padWidth,ke=1;this.createNGrams(A,Te,ce,Me,ke,we)}}return[ce,le]}}function o8(W,A,V,$,ne,xe,le,ce){return new o7(V,$,ne,xe,le,ce).compute(W,A)}function o9(W,A,V,$){if(!W.length)return;if(A.length===0){for(let xe=0;xe<W.length;++xe)$.push(W.subarray(xe,xe+1));return}if(A.length===1){const xe=A[0];let le=W.indexOf(xe);for(;le!==-1;){const ce=W.subarray(0,le);(!V||ce.length!==0)&&$.push(ce),W=W.subarray(le+1),le=W.indexOf(xe)}(!V||W.length!==0)&&$.push(W);return}let ne=0;for(let xe=0;xe<W.length+1;xe++)if(xe===W.length||A.indexOf(W[xe])!==-1){const le=W.subarray(ne,xe);(!V||le.length!==0)&&$.push(le),ne=xe+1}}function oC(W,A,V){const $=W.length,ne=[];let xe=0,le=0;const ce=new Array($);for(let we=0;we<$;++we){const ke=ne.length;o9(W[we],A,V,ne);const Ue=ne.length-ke;ce[we]=Ue,xe+=Ue,le=Math.max(le,Ue)}const ue=x("int32",xe*2),Te=new Array(xe),Me=[$,le];let Re=0;for(let we=0;we<$;++we)for(let ke=0;ke<ce[we];++ke)ue[Re*2]=we,ue[Re*2+1]=ke,Te[Re]=ne[Re],++Re;return[ue,Te,Me]}function om(W,A){const V=x("int32",W.length);for(let $=0;$<W.length;++$)V[$]=Na(W[$]).modulo(A).getLowBitsUnsigned();return V}const oN=gA((W,A)=>W-A),oJ=gq((W,A,V,$)=>({real:W-V,imag:A-$})),of=gv(mc,oN,oJ),oi={kernelName:mc,backendName:"cpu",kernelFunc:of};function oO(W,A){const V=new Array(W.rank);for(let ne=0;ne<V.length;ne++)V[ne]=W.shape[ne]*A[ne];const $=t7(V,W.dtype);for(let ne=0;ne<$.values.length;++ne){const xe=$.indexToLoc(ne),le=new Array(W.rank);for(let ue=0;ue<le.length;ue++)le[ue]=xe[ue]%W.shape[ue];const ce=W.locToIndex(le);$.values[ne]=W.values[ce]}return $}const ot=(W,A)=>{const V=A.value-W.value;return V===0?W.index-A.index:V};function oB(W,A,V=0,$=W.length-1){for(;$>V;){if($-V>600){const ce=$-V+1,ue=A-V+1,Te=Math.log(ce),Me=.5*Math.exp(2*Te/3),Re=.5*Math.sqrt(Te*Me*(ce-Me)/ce)*Math.sign(ue-ce/2),we=Math.max(V,Math.floor(A-ue*Me/ce+Re)),ke=Math.min($,Math.floor(A+(ce-ue)*Me/ce+Re));oB(W,A,we,ke)}const ne=W[A];let xe=V,le=$;for(P(W,V,A),ot(W[$],ne)>0&&P(W,V,$);xe<le;){for(P(W,xe,le),xe++,le--;ot(W[xe],ne)<0;)xe=xe+1;for(;ot(W[le],ne)>0;)le=le-1}ot(W[V],ne)===0?P(W,V,le):(le=le+1,P(W,le,$)),le<=A&&(V=le+1),A<=le&&($=le-1)}}function oS(W,A,V,$,ne){const xe=A[A.length-1],[le,ce]=[W.length/xe,xe],ue=H(V,le*$),Te=H("int32",le*$);for(let Re=0;Re<le;Re++){const we=Re*ce,ke=W.subarray(we,we+ce);let Ue=new Array(ke.length);ke.forEach((Ye,je)=>Ue[je]={value:Ye,index:je}),$<Ue.length&&(oB(Ue,$),Ue=Ue.slice(0,$)),ne&&Ue.sort(ot);const Ge=Re*$,We=ue.subarray(Ge,Ge+$),Xe=Te.subarray(Ge,Ge+$);for(let Ye=0;Ye<$;Ye++)We[Ye]=Ue[Ye].value,Xe[Ye]=Ue[Ye].index}const Me=A.slice();return Me[Me.length-1]=$,[t7(Me,V,ue),t7(Me,"int32",Te)]}function od(W,A,V,$){const ne=n(A,V)[0],xe=[1,V[0],1];for(let Ue=0;Ue<ne;Ue++)xe[0]*=V[Ue];xe[1]=V[ne];for(let Ue=ne+1;Ue<V.length;Ue++)xe[2]*=V[Ue];const le=new Map,ce=new Int32Array(V[ne]),ue=new J8(xe,$,W),Te=[],Me=xe[0]===1&&xe[2]===1;for(let Ue=0;Ue<V[ne];Ue++){let Ge;if(Me)Ge=W[Ue].toString();else{const Xe=[];for(let Ye=0;Ye<xe[0];Ye++)for(let je=0;je<xe[2];je++)Xe.push(ue.get(Ye,Ue,je));Ge=Xe.join(",")}const We=le.get(Ge);if(We!=null)ce[Ue]=We;else{const Xe=le.size;le.set(Ge,Xe),ce[Ue]=Xe,Te.push(Ue)}}const Re=xe.slice();Re[1]=le.size;const we=new J8(Re,$);Te.forEach((Ue,Ge)=>{for(let We=0;We<xe[0];We++)for(let Xe=0;Xe<xe[2];Xe++)we.set(ue.get(We,Ue,Xe),We,Ge,Xe)});const ke=V.slice();return ke[ne]=Re[1],{outputValues:we.values,outputShape:ke,indices:ce}}var oV=Object.freeze({__proto__:null,addImpl:gl,bincountImpl:gH,bincountReduceImpl:gk,bitwiseAndImpl:gz,castImpl:gR,ceilImpl:gu,concatImpl:gY,equalImpl:gM,expImpl:gh,expm1Impl:gj,floorDivImpl:Z2,floorImpl:gr,gatherNdImpl:Z3,gatherV2Impl:Z4,greaterEqualImpl:Z6,greaterImpl:Z5,lessEqualImpl:ZN,lessImpl:Z9,linSpaceImpl:Zi,logImpl:ZO,maxImpl:Zt,maximumImpl:ZB,minimumImpl:ZV,multiplyImpl:ZE,negImpl:Zo,notEqualImpl:Zs,prodImpl:ZA,raggedGatherImpl:ZT,raggedRangeImpl:Zq,raggedTensorToTensorImpl:ZH,rangeImpl:Zk,rsqrtImpl:Zz,scatterImpl:Zx,sigmoidImpl:ZU,simpleAbsImpl:gF,sliceImpl:ZY,sparseFillEmptyRowsImpl:Zj,sparseReshapeImpl:Zr,sparseSegmentReductionImpl:o0,sqrtImpl:o1,squaredDifferenceImpl:o4,staticRegexReplaceImpl:o5,stridedSliceImpl:o6,stringNGramsImpl:o8,stringSplitImpl:oC,stringToHashBucketFastImpl:om,subImpl:oN,tileImpl:oO,topKImpl:oS,transposeImpl:ZF,uniqueImpl:od});const{addImpl:ob,bincountImpl:oP,bincountReduceImpl:oE,bitwiseAndImpl:oD,castImpl:og,ceilImpl:oZ,concatImpl:oo,equalImpl:oe,expImpl:oQ,expm1Impl:os,floorImpl:oF,gatherNdImpl:oI,gatherV2Impl:oy,greaterImpl:oA,greaterEqualImpl:ow,lessImpl:oX,lessEqualImpl:oc,linSpaceImpl:oW,logImpl:oR,maxImpl:oK,maximumImpl:oT,minimumImpl:ov,multiplyImpl:oq,negImpl:ol,notEqualImpl:oa,prodImpl:on,raggedGatherImpl:oL,raggedRangeImpl:oH,raggedTensorToTensorImpl:ok,rangeImpl:oz,rsqrtImpl:ox,scatterImpl:oU,sigmoidImpl:oG,simpleAbsImpl:ou,sliceImpl:oY,sparseFillEmptyRowsImpl:oM,sparseReshapeImpl:oh,sparseSegmentReductionImpl:oj,sqrtImpl:or,staticRegexReplaceImpl:e0,stridedSliceImpl:e1,stringNGramsImpl:e2,stringSplitImpl:e3,stringToHashBucketFastImpl:e4,subImpl:e5,tileImpl:e6,topKImpl:e7,transposeImpl:e8,uniqueImpl:e9}=oV;function eC(W,A){return["x","y","z","w","u","v"].slice(0,A).map(V=>W+"."+V)}function em(W,A){return A===1?[W]:eC(W,A)}function eN(W,A){if(W===1)return"rc";let V="";for(let $=0;$<W;$++)V+=A[$],$<W-1&&(V+=",");return V}class eJ{constructor(A){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=A,this.rank=A.length,this.enableShapeUniforms=Dr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const V=em("rc",this.rank),$=Dz(this.rank),ne=this.getOutOfBoundsCondition(V),xe=this.getSetup(V),le=this.getOutput(V);this.userCode=`
        void main() {
          `+$+` rc = getOutputCoords();

          if(`+ne+`) {
            setOutput(vec4(0));
          } else {
            `+xe+`

            setOutput(vec4(`+le+`));
          }
        }
      `}}getSourceCoordsArr(A){const V=[];for(let $=0;$<=1;$++)for(let ne=0;ne<=1;ne++){let xe=($===0?"r":"rp1")+", "+(ne===0?"c":"cp1");for(let le=2;le<this.rank;le++)xe=A[A.length-1-le]+","+xe;V.push(xe)}return V}getOutOfBoundsCondition(A){if(this.rank===1)return"rc > "+(this.enableShapeUniforms?"outShape":this.outputShape[0]);let V="";for(let $=this.rank-2;$<this.rank;$++)V+=A[$]+" >= "+(this.enableShapeUniforms?"outShape["+$+"]":this.outputShape[$]),$<this.rank-1&&(V+="||");return V}getSetup(A){if(this.rank===1)return"";const V=A.slice(-2),$=this.enableShapeUniforms?"outShape["+this.rank+" - 1]":this.outputShape[this.rank-1],ne=this.enableShapeUniforms?"outShape["+this.rank+" - 2]":this.outputShape[this.rank-2];return`
      int r = `+V[0]+`;
      int c = `+V[1]+`;
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= `+$+`;
      bool rEdge = rp1 >= `+ne+`;
    `}getOutput(A){const V=this.getSourceCoordsArr(A);return this.rank===1?"getA(rc), (rc + 1 >= "+(this.enableShapeUniforms?"outShape":this.outputShape[0])+" ? 0. : getA(rc + 1)), 0, 0":"getA("+V[0]+`),
            cEdge ? 0. : getA(`+V[1]+`),
            rEdge ? 0. : getA(`+V[2]+`),
            rEdge || cEdge ? 0. : getA(`+V[3]+")"}}class ef{constructor(A,V){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=A,this.enableShapeUniforms=Dr(this.outputShape.length);let $="";for(let ne=0;ne<4;ne++){let xe="thisRC = rc;";ne%2===1&&(xe+="thisRC.z += 1;"),ne>1&&(xe+="thisRC.y += 1;"),$+=`
        `+xe+`
        `+(ne>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+`
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[`+ne+`] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        `+(ne>0?"}":"")+`
      `}this.userCode=`
      `+ei(V,this.enableShapeUniforms)+`
      `+(this.enableShapeUniforms?D8():D7(A))+`

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = `+(this.enableShapeUniforms?"outShape[1]":A[1])+`;
        int cols = `+(this.enableShapeUniforms?"outShape[2]":A[2])+`;

        `+$+`

        setOutput(result);
      }
    `}}function ei(W,A){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      `+(A?D6(["r","c","d"],"inputShape"):D3(["r","c","d"],W))+`
      return ivec3(r, c, d);
    }
  `}class eO{constructor(A){this.gpgpu=A,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(A,V,$){const ne=eV(V,$),xe=eb(A,ne,$);xe in this.freeTextures||(this.freeTextures[xe]=[]),xe in this.usedTextures||(this.usedTextures[xe]=[]);const le=eB(A,ne,this.gpgpu.gl,this.gpgpu.textureConfig,$);if(this.freeTextures[xe].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=le,this.log();const ue=this.freeTextures[xe].pop();return this.usedTextures[xe].push(ue),ue}let ce;return ne===E7.PACKED_2X2_FLOAT32?ce=this.gpgpu.createPackedMatrixTexture(A[0],A[1]):ne===E7.PACKED_2X2_FLOAT16?ce=this.gpgpu.createFloat16PackedMatrixTexture(A[0],A[1]):ne===E7.UNPACKED_FLOAT32?ce=this.gpgpu.createFloat32MatrixTexture(A[0],A[1]):ne===E7.UNPACKED_FLOAT16?ce=this.gpgpu.createFloat16MatrixTexture(A[0],A[1]):ne===E7.PACKED_4X1_UNSIGNED_BYTE&&(ce=this.gpgpu.createUnsignedBytesMatrixTexture(A[0],A[1])),this.usedTextures[xe].push(ce),this.numUsedTextures++,this._numBytesAllocated+=le,this.log(),ce}releaseTexture(A,V,$,ne){if(this.freeTextures==null)return;const xe=eV($,ne),le=eb(V,xe,ne);le in this.freeTextures||(this.freeTextures[le]=[]);const ce=eB(V,xe,this.gpgpu.gl,this.gpgpu.textureConfig,ne),ue=Cd().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");ue!==-1&&this._numBytesAllocated>ue?(this.gpgpu.deleteMatrixTexture(A.texture),this._numBytesAllocated-=ce):(this.freeTextures[le].push(A),this.numFreeTextures++,this._numBytesFree+=ce),this.numUsedTextures--;const Te=this.usedTextures[le],Me=Te&&Te.indexOf(A);if(Me==null||Me<0)throw new Error("Cannot release a texture that was never provided by this texture manager");Te[Me]=Te[Te.length-1],Te.pop(),this.log()}log(){if(!this.logEnabled)return;const A=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+A+")");const V=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log("Bytes unused: "+this._numBytesFree+" ("+Math.round(100*V)+"%)")}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const A in this.freeTextures)this.freeTextures[A].forEach(V=>{this.gpgpu.deleteMatrixTexture(V.texture)});for(const A in this.usedTextures)this.usedTextures[A].forEach(V=>{this.gpgpu.deleteMatrixTexture(V.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function et(W,A){const V=W;if(A===V.R32F)return 4;if(A===V.R16F)return 2;if(A===V.RGBA32F||A===W.RGBA)return 16;if(A===V.RGBA16F)return 8;if(A===V.RGBA8)return 4;throw new Error("Unknown internal format "+A)}function eB(W,A,V,$,ne){const xe=eS(A,$);let le;if(ne){const[ue,Te]=Em(W[0],W[1]);le=ue*Te}else{const[ue,Te]=E8(W[0],W[1]);le=ue*Te}const ce=et(V,xe);return le*ce}function eS(W,A){switch(W){case E7.PACKED_2X2_FLOAT32:return gt(A);case E7.PACKED_2X2_FLOAT16:return gS(A);case E7.UNPACKED_FLOAT32:return gm(A);case E7.UNPACKED_FLOAT16:return gJ(A);case E7.PACKED_4X1_UNSIGNED_BYTE:return gi(A);default:throw new Error("Unknown physical texture type "+W)}}function ed(W){return Cd().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?W?E7.PACKED_2X2_FLOAT32:E7.UNPACKED_FLOAT32:W?E7.PACKED_2X2_FLOAT16:E7.UNPACKED_FLOAT16}function eV(W,A){if(W===E6.UPLOAD)return E7.PACKED_2X2_FLOAT32;if(W===E6.RENDER||W==null)return ed(A);if(W===E6.DOWNLOAD||W===E6.PIXELS)return E7.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+W)}function eb(W,A,V){return W[0]+"_"+W[1]+"_"+A+"_"+V}class eP{constructor(A,V){this.variableNames=["A"],this.outputShape=A,this.enableShapeUniforms=Dr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        `+V+`
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const eE="if (isnan(x)) return x;",eD="return x;",eg="return abs(x);",eZ="return (x >= 0.0) ? x : (exp(x) - 1.0);",eo=eE+`
  return (x < 0.0) ? 0.0 : x;
`,ee=eE+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,eQ="return x;",es="return 1.0 / (1.0 + exp(-1.0 * x));",eF="return x;",eI=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,ey=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,eA=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ep="return 1.0 / (1.0 + exp(-1.0 * x));";class ew{constructor(A,V){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=A,this.enableShapeUniforms=Dr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        `+V+`
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class eX{constructor(A){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=A,this.enableShapeUniforms=Dr(this.outputShape.length);const V=A.length,$=em("rc",V),ne=Dz(V),xe=eN(V,$),le=$.slice(-2),ce=V<=1?"rc":"vec2("+le.join(",")+")";this.userCode=`
      void main() {
        `+ne+` rc = getOutputCoords();
        vec4 packedInput = getA(`+xe+`);

        setOutput(getChannel(packedInput, `+ce+`));
      }
    `}}const ec=SQ,eW=1e-7,eR=1e-4,eK={};function eT(W){return W in eK||(eK[W]={}),eK[W]}const ev=Cd().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),eq=600;function el(){return Cd().global.screen==null?1024:Cd().global.screen.height*Cd().global.screen.width*window.devicePixelRatio*eq/1024/1024}class ea extends i{nextDataId(){return ea.nextDataId++}constructor(A){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Cd().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let V;if(A!=null){if(A instanceof ge)V=A;else{const $=E2(Cd().getNumber("WEBGL_VERSION"),A);V=new ge($)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const $=E2(Cd().getNumber("WEBGL_VERSION"));V=new ge($),this.binaryCache=eT(Cd().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=V,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new eO(this.gpgpu),this.numMBBeforeWarning=el(),this.texData=new f(this,Ju())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(A,V,$,ne,xe,le){const ce=this.makeTensorInfo(V,$),ue=this.texData.get(ce.dataId);ue.isPacked=!1,ue.texture={texture:A,texShape:[ne,xe]},ue.texShape=[ne,xe];const Te=El(V),Me=new g5(Te,!1,le),Re=this.runWebGLProgram(Me,[ce],$,[[ne,xe]]);return Re.shape=V,ue.texture=null,this.disposeIntermediateTensorInfo(ce),Re.dataId}write(A,V,$){if((Cd().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Cd().getBool("DEBUG"))&&this.checkNumericalProblems(A),$==="complex64"&&A!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const ne={id:this.nextDataId()};return this.texData.set(ne,{shape:V,dtype:$,values:A,usage:E6.UPLOAD,refCount:1}),ne}refCount(A){return this.texData.has(A)?this.texData.get(A).refCount:0}incRef(A){const V=this.texData.get(A);V.refCount++}decRef(A){if(this.texData.has(A)){const V=this.texData.get(A);V.refCount--}}move(A,V,$,ne,xe){if(Cd().getBool("DEBUG")&&this.checkNumericalProblems(V),ne==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(A,{shape:$,dtype:ne,values:V,usage:E6.UPLOAD,refCount:xe})}disposeIntermediateTensorInfo(A){this.disposeData(A.dataId)}readSync(A){const V=this.texData.get(A),{values:$,dtype:ne,complexTensorInfos:xe,slice:le,shape:ce,isPacked:ue}=V;if(le!=null){let we;ue?we=new ew(ce,eQ):we=new eP(ce,eQ);const ke=this.runWebGLProgram(we,[{dataId:A,shape:ce,dtype:ne}],ne),Ue=this.readSync(ke.dataId);return this.disposeIntermediateTensorInfo(ke),Ue}if($!=null)return this.convertAndCacheOnCPU(A);if(ne==="string")return $;const Te=this.activeTimers!=null;let Me;Te&&(Me=Nk());let Re;if(ne==="complex64"){const we=this.readSync(xe.real.dataId),ke=this.readSync(xe.imag.dataId);Re=du(we,ke)}else Re=this.getValuesFromTexture(A);return Te&&(this.downloadWaitMs+=Nk()-Me),this.convertAndCacheOnCPU(A,Re)}async read(A){if(this.pendingRead.has(A)){const Ue=this.pendingRead.get(A);return new Promise(Ge=>Ue.push(Ge))}const V=this.texData.get(A),{values:$,shape:ne,slice:xe,dtype:le,complexTensorInfos:ce,isPacked:ue}=V;if(xe!=null){let Ue;ue?Ue=new ew(ne,eQ):Ue=new eP(ne,eQ);const Ge=this.runWebGLProgram(Ue,[{dataId:A,shape:ne,dtype:le}],le),We=this.read(Ge.dataId);return this.disposeIntermediateTensorInfo(Ge),We}if($!=null)return this.convertAndCacheOnCPU(A);if(Cd().getBool("DEBUG")&&!Cd().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Cd().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let Te=null,Me;if(le!=="complex64"&&Cd().get("WEBGL_BUFFER_SUPPORTED")){Me=this.decode(A);const Ue=this.texData.get(Me.dataId);Te=this.gpgpu.createBufferFromTexture(Ue.texture.texture,...EC(ne))}this.pendingRead.set(A,[]),le!=="complex64"&&await this.gpgpu.createAndWaitForFence();let Re;if(le==="complex64"){const Ue=await Promise.all([this.read(ce.real.dataId),this.read(ce.imag.dataId)]),Ge=Ue[0],We=Ue[1];Re=du(Ge,We)}else if(Te==null)Re=this.getValuesFromTexture(A);else{const Ue=F(ne);Re=this.gpgpu.downloadFloat32MatrixFromBuffer(Te,Ue)}if(Me!=null&&this.disposeIntermediateTensorInfo(Me),Te!=null){const Ue=this.gpgpu.gl;Ef(Ue,()=>Ue.deleteBuffer(Te))}const we=this.convertAndCacheOnCPU(A,Re),ke=this.pendingRead.get(A);return this.pendingRead.delete(A),ke.forEach(Ue=>Ue(we)),this.pendingDisposal.has(A)&&(this.pendingDisposal.delete(A),this.disposeData(A)&&Ju().removeDataId(A,this),this.pendingDeletes--),we}readToGPU(A,V={}){const $=this.texData.get(A),{values:ne,shape:xe,slice:le,dtype:ce,isPacked:ue,texture:Te}=$;if(ce==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(le!=null){let ke;ue?ke=new ew(xe,eQ):ke=new eP(xe,eQ);const Ue=this.runWebGLProgram(ke,[{dataId:A,shape:xe,dtype:ce}],ce),Ge=this.readToGPU(Ue,V);return this.disposeIntermediateTensorInfo(Ue),Ge}if(Te==null)throw ne!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const Me=this.decode(A,V.customTexShape),Re=Ju().makeTensorFromTensorInfo(Me),we=this.texData.get(Me.dataId);return Object.assign({tensorRef:Re},we.texture)}bufferSync(A){const V=this.readSync(A.dataId);if(A.dtype==="string")try{const $=V.map(ne=>Nx(ne));return t7(A.shape,A.dtype,$)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return t7(A.shape,A.dtype,V)}checkNumericalProblems(A){if(A!=null)for(let V=0;V<A.length;V++){const $=A[V];if(!EB($))throw Cd().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error("The value "+$+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"):Error("The value "+$+" cannot be represented on this device.")}}getValuesFromTexture(A){const{shape:V,dtype:$,isPacked:ne}=this.texData.get(A),xe=F(V);if(Cd().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const we=this.decode(A),ke=this.texData.get(we.dataId),Ue=this.gpgpu.downloadMatrixFromPackedTexture(ke.texture.texture,...EC(V)).subarray(0,xe);return this.disposeIntermediateTensorInfo(we),Ue}const le=Cd().getBool("WEBGL_PACK")&&ne===!0,ce=le?El(V):V,ue=le?new g3(ce):new g2(ce),Te=this.runWebGLProgram(ue,[{shape:ce,dtype:$,dataId:A}],"float32"),Me=this.texData.get(Te.dataId),Re=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(Me.texture.texture,Me.texShape[0],Me.texShape[1]).subarray(0,xe);return this.disposeIntermediateTensorInfo(Te),Re}timerAvailable(){return Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(A){const V=this.activeTimers,$=[];let ne=!1;this.programTimersStack==null?(this.programTimersStack=$,ne=!0):this.activeTimers.push($),this.activeTimers=$,A();const xe=NG(this.activeTimers.map(ue=>ue.query)).filter(ue=>ue!=null),le=NG(this.activeTimers.map(ue=>ue.name)).filter(ue=>ue!=null);this.activeTimers=V,ne&&(this.programTimersStack=null);const ce={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const ue=await Promise.all(xe);ce.kernelMs=o(ue),ce.getExtraProfileInfo=()=>ue.map((Te,Me)=>({name:le[Me],ms:Te})).map(Te=>Te.name+": "+Te.ms).join(", ")}else ce.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,ce})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Nk(),endMs:null}}endTimer(A){return Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),A):(A.endMs=Nk(),A)}async getQueryTime(A){if(Cd().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(A);const V=A;return V.endMs-V.startMs}disposeData(A,V=!1){if(this.pendingDisposal.has(A))return!1;if(!this.texData.has(A))return!0;if(V?this.texData.get(A).refCount=0:this.texData.get(A).refCount--,!V&&this.texData.get(A).refCount>0)return!1;if(this.pendingRead.has(A))return this.pendingDisposal.add(A),this.pendingDeletes++,!1;this.releaseGPUData(A);const{complexTensorInfos:$}=this.texData.get(A);return $!=null&&(this.disposeData($.real.dataId,V),this.disposeData($.imag.dataId,V)),this.texData.delete(A),!0}releaseGPUData(A){const{texture:V,dtype:$,texShape:ne,usage:xe,isPacked:le,slice:ce}=this.texData.get(A),ue=ce&&ce.origDataId||A,Te=this.dataRefCount.get(ue);Te>1?this.dataRefCount.set(ue,Te-1):(this.dataRefCount.delete(ue),V!=null&&(this.numBytesInGPU-=this.computeBytes(ne,$),this.textureManager.releaseTexture(V,ne,xe,le)));const Me=this.texData.get(A);Me.texture=null,Me.texShape=null,Me.isPacked=!1,Me.slice=null}getTexture(A){return this.uploadToGPU(A),this.texData.get(A).texture.texture}getDataInfo(A){return this.texData.get(A)}shouldExecuteOnCPU(A,V=ev){return Cd().getBool("WEBGL_CPU_FORWARD")&&A.every($=>this.texData.get($.dataId).texture==null&&F($.shape)<V)}getGPGPUContext(){return this.gpgpu}where(A){mk("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const V=A.dataSync();return ec(A.shape,V)}packedUnaryOp(A,V,$){const ne=new ew(A.shape,V),xe=this.compileAndRun(ne,[A],$);return Ju().makeTensorFromTensorInfo(xe)}abs(A){if(this.shouldExecuteOnCPU([A])&&A.dtype!=="complex64"){const ne=ou(this.texData.get(A.dataId).values);return this.makeOutput(A.shape,A.dtype,ne)}if(Cd().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(A,eg,A.dtype);const V=new eP(A.shape,eg),$=this.compileAndRun(V,[A]);return Ju().makeTensorFromTensorInfo($)}makeTensorInfo(A,V,$){let ne;if(V==="string"&&$!=null&&$.length>0&&j($[0])){const xe=$.map(le=>Nz(le));ne=this.write(xe,A,V)}else ne=this.write($,A,V);return this.texData.get(ne).usage=null,{dataId:ne,shape:A,dtype:V}}makeOutput(A,V,$){return Ju().makeTensorFromTensorInfo(this.makeTensorInfo(A,V,$),this)}unpackTensor(A){const V=new eX(A.shape);return this.runWebGLProgram(V,[A],A.dtype)}packTensor(A){const V=new eJ(A.shape),$=!0;return this.runWebGLProgram(V,[A],A.dtype,null,$)}packedReshape(A,V){const $=[Ev(A.shape),...Eq(A.shape)],ne={dtype:A.dtype,shape:$,dataId:A.dataId},xe=[Ev(V),...Eq(V)],le=new ef(xe,$),ce=!0,ue=[$],Te=this.runWebGLProgram(le,[ne],A.dtype,ue,ce);return{dataId:Te.dataId,shape:V,dtype:Te.dtype}}decode(A,V){const $=this.texData.get(A),{isPacked:ne,shape:xe,dtype:le}=$;if(V!=null){const we=F(xe),ke=V[0]*V[1]*4;e(we<=ke,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const ce=El(xe);let ue;ne?ue=new g1(ce):ue=new g0(ce);const Te=!0,Me=[V??EC(ce)],Re=this.runWebGLProgram(ue,[{shape:ce,dtype:le,dataId:A}],le,Me,Te,V);return{dtype:le,shape:xe,dataId:Re.dataId}}runWebGLProgram(A,V,$,ne,xe=!1,le){const ce=this.makeTensorInfo(A.outputShape,$),ue=this.texData.get(ce.dataId);if(A.packedOutput&&(ue.isPacked=!0),A.outPackingScheme===E5.DENSE){const Xe=le??EC(A.outputShape);ue.texShape=Xe.map(Ye=>Ye*2)}if(A.outTexUsage!=null&&(ue.usage=A.outTexUsage),F(ce.shape)===0)return ue.values=H(ce.dtype,0),ce;const Te=[],Me=V.map(Xe=>{if(Xe.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let Ye=this.texData.get(Xe.dataId);if(Ye.texture==null){if(!A.packedInputs&&F(Xe.shape)<=Cd().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:Xe.shape,texData:null,isUniform:!0,uniformValues:Ye.values};A.packedInputs&&(Ye.isPacked=!0,Ye.shape=Xe.shape)}if(this.uploadToGPU(Xe.dataId),!!Ye.isPacked!=!!A.packedInputs)Xe=Ye.isPacked?this.unpackTensor(Xe):this.packTensor(Xe),Te.push(Xe),Ye=this.texData.get(Xe.dataId);else if(Ye.isPacked&&!EL(Ye.shape,Xe.shape)){const je=Xe,Ke=Xe.shape;Xe.shape=Ye.shape,Xe=this.packedReshape(Xe,Ke),Te.push(Xe),Ye=this.texData.get(Xe.dataId),je.shape=Ke}return{shape:Xe.shape,texData:Ye,isUniform:!1}});this.uploadToGPU(ce.dataId);const Re={shape:ce.shape,texData:ue,isUniform:!1},we=Dj(A,Me,Re),ke=this.getAndSaveBinary(we,()=>Du(this.gpgpu,A,Me,Re)),Ue=this.activeTimers!=null;let Ge;Ue&&(Ge=this.startTimer()),Cd().get("ENGINE_COMPILE_ONLY")||Dh(this.gpgpu,ke,Me,Re,ne),Te.forEach(Xe=>this.disposeIntermediateTensorInfo(Xe)),Ue&&(Ge=this.endTimer(Ge),this.activeTimers.push({name:A.constructor.name,query:this.getQueryTime(Ge)}));const We=Cd().getNumber("WEBGL_FLUSH_THRESHOLD");if(We>0){const Xe=Nk();Xe-this.lastGlFlushTime>We&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=Xe)}if(!Cd().getBool("WEBGL_LAZILY_UNPACK")&&ue.isPacked&&xe===!1){const Xe=this.unpackTensor(ce);return this.disposeIntermediateTensorInfo(ce),Xe}return ce}compileAndRun(A,V,$,ne,xe=!1){return $=$||V[0].dtype,this.runWebGLProgram(A,V,$,ne,xe)}getAndSaveBinary(A,V){return A in this.binaryCache||(this.binaryCache[A]=V()),this.binaryCache[A]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Cd().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(A=>{this.gpgpu.deleteProgram(this.binaryCache[A].webGLProgram),delete this.binaryCache[A]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=JY(()=>{if(!Cd().get("WEBGL_RENDER_FLOAT32_ENABLED")){const A=Cd().getBool("DEBUG");Cd().set("DEBUG",!1);const V=this.abs(tL(1e-8)).dataSync()[0];if(Cd().set("DEBUG",A),V>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?eW:eR}uploadToGPU(A){const V=this.texData.get(A),{shape:$,dtype:ne,values:xe,texture:le,usage:ce,isPacked:ue}=V;if(le!=null)return;const Te=this.activeTimers!=null;let Me;Te&&(Me=Nk());let Re=V.texShape;if(Re==null&&(Re=Ea($,ue),V.texShape=Re),xe!=null){const we=El($);let ke,Ue=Re[1],Ge=Re[0];const We=xe instanceof Uint8Array||xe instanceof Uint8ClampedArray;(ue||!We)&&([Ue,Ge]=Em(Re[0],Re[1])),ue?ke=new g6(we,We):ke=new g5(we,We);const Xe=We?[Ge,Ue]:Re,Ye=this.makeTensorInfo(Xe,ne),je=this.texData.get(Ye.dataId);We?je.usage=E6.PIXELS:je.usage=E6.UPLOAD,je.texShape=Xe,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(Ye.dataId),Ue,Ge,xe);const Ke=[[Ge,Ue]],qe=!0,$e=this.runWebGLProgram(ke,[Ye],ne,Ke,qe),vt=this.texData.get($e.dataId);V.texShape=vt.texShape,V.isPacked=vt.isPacked,V.usage=vt.usage,Cd().get("ENGINE_COMPILE_ONLY")?this.disposeData($e.dataId):(V.texture=vt.texture,V.values=null,this.texData.delete($e.dataId)),this.disposeIntermediateTensorInfo(Ye),Te&&(this.uploadWaitMs+=Nk()-Me)}else{const we=this.acquireTexture(Re,ce,ne,ue);V.texture=we}}convertAndCacheOnCPU(A,V){const $=this.texData.get(A),{dtype:ne}=$;return V!=null&&($.values=en(V,ne)),$.values}acquireTexture(A,V,$,ne){if(this.numBytesInGPU+=this.computeBytes(A,$),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const xe=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+xe+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(A,V,ne)}computeBytes(A,V){return A[0]*A[1]*M(V)}checkCompileCompletion(){for(const[,A]of Object.entries(this.binaryCache))this.checkCompletion_(A)}async checkCompileCompletionAsync(){const A=[];if(this.gpgpu.parallelCompilationExtension){for(const[,V]of Object.entries(this.binaryCache))A.push(this.checkCompletionAsync_(V));return Promise.all(A)}else{for(const[,V]of Object.entries(this.binaryCache)){const $=new Promise(ne=>{try{this.checkCompletion_(V),ne(!0)}catch(xe){throw xe}});A.push($)}return Promise.all(A)}}async checkCompletionAsync_(A){return this.gpgpu.gl.getProgramParameter(A.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(A):(await dF(),this.checkCompletionAsync_(A))}checkCompletion_(A){if(this.gpgpu.gl.getProgramParameter(A.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(A.webGLProgram)),this.gpgpu.gl.getShaderParameter(A.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(EE(A.source,this.gpgpu.gl.getShaderInfoLog(A.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const A of Object.values(this.binaryCache)){this.gpgpu.buildVao(A.webGLProgram);const{variablesLocations:V,customUniformLocations:$,infLoc:ne,nanLoc:xe,outShapeLocation:le,outShapeStridesLocation:ce,outTexShapeLocation:ue}=DY(this.gpgpu,A.program,A.webGLProgram);A.variablesLocations=V,A.customUniformLocations=$,A.infLoc=ne,A.nanLoc=xe,A.outShapeLocation=le,A.outShapeStridesLocation=ce,A.outTexShapeLocation=ue}}createTensorFromGPUData(A,V,$){A.channels=A.channels||"RGBA";const{texture:ne,height:xe,width:le,channels:ce}=A,ue=Ju().backend;if(!ue.gpgpu.gl.isTexture(ne))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const Te=ue.writeTexture(ne,V,$,xe,le,ce);return Ju().makeTensorFromDataId(Te,V,$,ue)}}ea.nextDataId=0;function en(W,A){if(A==="float32"||A==="complex64")return W;if(A==="int32"||A==="bool"){const V=A==="int32"?new Int32Array(W.length):new Uint8Array(W.length);for(let $=0;$<V.length;++$)V[$]=Math.round(W[$]);return V}else throw new Error("Unknown dtype "+A)}Jc()&&f0("webgl",()=>new ea,2);const eL="return abs(x);";function eH(W){const{inputs:A,backend:V}=W,{x:$}=A;if(V.shouldExecuteOnCPU([$])&&$.dtype!=="complex64"){const xe=V.texData.get($.dataId),le=ou(xe.values);return V.makeTensorInfo($.shape,$.dtype,le)}let ne;return Cd().getBool("WEBGL_PACK_UNARY_OPERATIONS")?ne=new ew($.shape,eL):ne=new eP($.shape,eL),V.runWebGLProgram(ne,[$],$.dtype)}const ek={kernelName:CZ,backendName:"webgl",kernelFunc:eH},ez=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class ex{constructor(A,V,$){this.variableNames=["A","B"],this.outputShape=iH(V,$),this.enableShapeUniforms=Dr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        `+A+`
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const eU=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class eG{constructor(A,V,$,ne=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=iH(V,$);const xe=this.outputShape.length;this.enableShapeUniforms=Dr(xe);let le="";if(ne)if(xe===0||F(this.outputShape)===1)le=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(le=`
          `+Dz(xe)+` coords = getOutputCoords();
        `,xe===1)this.enableShapeUniforms?le+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:le+=`
            result.y = (coords + 1) >= `+this.outputShape[0]+` ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const ce=em("coords",xe);this.enableShapeUniforms?le+=`
            bool nextRowOutOfBounds =
              (`+ce[xe-2]+" + 1) >= outShape["+xe+` - 2];
            bool nextColOutOfBounds =
              (`+ce[xe-1]+" + 1) >= outShape["+xe+` - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:le+=`
            bool nextRowOutOfBounds =
              (`+ce[xe-2]+" + 1) >= "+this.outputShape[xe-2]+`;
            bool nextColOutOfBounds =
              (`+ce[xe-1]+" + 1) >= "+this.outputShape[xe-1]+`;
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        `+A+`
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        `+le+`

        setOutput(result);
      }
    `}}function eu(W){const{inputs:A,backend:V}=W,{x:$}=A;return V.incRef($.dataId),{dataId:$.dataId,shape:$.shape,dtype:$.dtype}}const eY={kernelName:Cj,backendName:"webgl",kernelFunc:eu};function eM(W){const{inputs:A,backend:V}=W,{real:$,imag:ne}=A,xe=V.makeTensorInfo($.shape,"complex64"),le=V.texData.get(xe.dataId),ce=eu({inputs:{x:$},backend:V}),ue=eu({inputs:{x:ne},backend:V});return le.complexTensorInfos={real:ce,imag:ue},xe}const eh="return (a < 0.) ? b * a : a;",ej=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,er="return (a < 0.) ? b * a : a;",Q0=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Q1(W){const{inputs:A,backend:V}=W,{x:$,alpha:ne}=A,xe=Cd().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new eG(Q0,$.shape,ne.shape):new ex(er,$.shape,ne.shape);return V.runWebGLProgram(xe,[$,ne],"float32")}const Q2={kernelName:mS,backendName:"webgl",kernelFunc:Q1},Q3="if (isnan(x)) return x;";function Q4({opSnippet:W,packedOpSnippet:A,cpuKernelImpl:V,dtype:$}){return({inputs:ne,backend:xe})=>{const{x:le}=ne,ce=xe,ue=$||le.dtype;if(ce.shouldExecuteOnCPU([le])&&V!=null){const Re=ce.texData.get(le.dataId),we=V(Re.values,ue);return ce.makeTensorInfo(le.shape,ue,we)}const Te=Cd().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&A!=null;let Me;return Te?Me=new ew(le.shape,A):Me=new eP(le.shape,W),ce.runWebGLProgram(Me,[le],ue)}}function Q5({opSnippet:W,packedOpSnippet:A,checkOutOfBounds:V=!1,supportsComplex:$=!1,cpuKernelImpl:ne,dtype:xe}){return({inputs:le,backend:ce})=>{const{a:ue,b:Te}=le,Me=ce;if($&&ue.dtype==="complex64"){const Ue=Me.texData.get(ue.dataId),Ge=Me.texData.get(Te.dataId),[We,Xe]=[[Ue.complexTensorInfos.real,Ge.complexTensorInfos.real],[Ue.complexTensorInfos.imag,Ge.complexTensorInfos.imag]].map(je=>{const[Ke,qe]=je,$e={dataId:Ke.dataId,dtype:Ke.dtype,shape:ue.shape},vt={dataId:qe.dataId,dtype:qe.dtype,shape:Te.shape},nt=new ex(W,ue.shape,Te.shape);return Me.runWebGLProgram(nt,[$e,vt],Jb(Ke.dtype,qe.dtype))}),Ye=eM({inputs:{real:We,imag:Xe},backend:Me});return Me.disposeIntermediateTensorInfo(We),Me.disposeIntermediateTensorInfo(Xe),Ye}const Re=xe||Jb(ue.dtype,Te.dtype);if((ue.dtype==="string"||Te.dtype==="string"||Me.shouldExecuteOnCPU([ue,Te]))&&ne!=null){const Ue=Me.texData.get(ue.dataId).values,Ge=Me.texData.get(Te.dataId).values,We=ue.dtype==="string"?Ve(Ue):Ue,Xe=ue.dtype==="string"?Ve(Ge):Ge,[Ye,je]=ne(ue.shape,Te.shape,We,Xe,Re),Ke=Me.makeTensorInfo(je,Re),qe=Me.texData.get(Ke.dataId);return qe.values=Ye,Ke}const we=Cd().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&A!=null;let ke;return we?ke=new eG(A,ue.shape,Te.shape,V):ke=new ex(W,ue.shape,Te.shape),Me.runWebGLProgram(ke,[ue,Te],Re)}}function Q6(W,A=!1){if(W==="linear")return A?eF:eD;if(W==="relu")return A?ey:eo;if(W==="elu")return A?eI:eZ;if(W==="relu6")return A?eA:ee;if(W==="prelu")return A?Q0:er;if(W==="leakyrelu")return A?ej:eh;if(W==="sigmoid")return A?ep:es;throw new Error("Activation "+W+" has not been implemented for the WebGL backend.")}const Q7="return a + b;",Q8=Q5({opSnippet:Q7,packedOpSnippet:Q7,supportsComplex:!0,cpuKernelImpl:ob}),Q9={kernelName:Co,backendName:"webgl",kernelFunc:Q8};class QC{constructor(A,V){this.outputShape=[],this.outputShape=A,this.variableNames=V.map((xe,le)=>"T"+le);const $=[];this.variableNames.forEach(xe=>{$.push("float v"+xe+" = get"+xe+"AtOutCoords();")});const ne=this.variableNames.map(xe=>"v"+xe).join(" + ");this.userCode=`
      void main() {
        `+$.join(`
        `)+`

        float result = `+ne+`;
        setOutput(result);
      }
    `}}class Qm{constructor(A,V){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=A,this.variableNames=V.map((xe,le)=>"T"+le);const $=[];this.variableNames.forEach(xe=>{$.push("vec4 v"+xe+" = get"+xe+"AtOutCoords();")});const ne=this.variableNames.map(xe=>"v"+xe).join(" + ");this.userCode=`
      void main() {
        `+$.join(`
        `)+`

        vec4 result = `+ne+`;
        setOutput(result);
      }
    `}}function QN(W){const{inputs:A,backend:V}=W,$=A;if($.length===1)return eu({inputs:{x:$[0]},backend:V});if($.length>Cd().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const ce=Math.floor($.length/2),ue=QN({inputs:$.slice(0,ce),backend:V}),Te=QN({inputs:$.slice(ce),backend:V});return QN({inputs:[ue,Te],backend:V})}const ne=$.map(ce=>ce.dtype).reduce((ce,ue)=>Jb(ce,ue)),xe=$.map(ce=>ce.shape),le=Cd().getBool("WEBGL_PACK")?new Qm($[0].shape,xe):new QC($[0].shape,xe);return V.runWebGLProgram(le,$,ne)}const QJ={kernelName:Ce,backendName:"webgl",kernelFunc:QN},Qf=ez+`
  return atan(a, b);
`,Qi=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+eU+`
  return result;
`,QO=Q5({opSnippet:Qf,packedOpSnippet:Qi}),QB={kernelName:CQ,backendName:"webgl",kernelFunc:QO};class QS{constructor(A,V,$,ne=!1,xe=!1){if(this.variableNames=["x"],V==="avg"&&$)throw new Error("Cannot compute positions for average pool.");const le=A.filterWidth,ce=A.strideHeight,ue=A.strideWidth,Te=A.dilationHeight,Me=A.dilationWidth,Re=A.effectiveFilterHeight,we=A.effectiveFilterWidth,ke=A.padInfo.top,Ue=A.padInfo.left;this.outputShape=A.outShape;const Ge=V==="avg",We="((batch  * "+A.inHeight+" + xR) * "+A.inWidth+" + xC) * "+A.inChannels+" + d",Xe="(xR * "+A.inWidth+" + xC) * "+A.inChannels+" + d";let Ye="0.0";if(Ge||(Ye="-1.0 / 1e-20"),$){const nt=">=";this.userCode=`
        const ivec2 strides = ivec2(`+ce+", "+ue+`);
        const ivec2 pads = ivec2(`+ke+", "+Ue+`);

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < `+Re+`;
              wR += `+Te+`) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= `+A.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+we+`;
                wC += `+Me+`) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= `+A.inWidth+`) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value `+nt+` currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = `+(ne?xe?We:Xe:"wR * "+we+" + wC")+`;
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const je="max";let Ke=V+"("+V+"("+V+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";V==="avg"&&(Ke="avgValue / max(count, 1.0)");const qe=Math.floor(le/4)*4,$e=le%4,vt=`
      if (`+Ge+`) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = `+je+`(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(`+ce+", "+ue+`);
      const ivec2 pads = ivec2(`+ke+", "+Ue+`);
      const float initializationValue = `+Ye+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= `+A.inWidth+`) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(`+Ye+`);
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < `+Re+`;
            wR += `+Te+`) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= `+A.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+qe+`; wC += 4) {
            int xC = xCCorner + wC * `+Me+`;

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+Me+`, d),
              getValue(batch, xR, xC + 2 * `+Me+`, d),
              getValue(batch, xR, xC + 3 * `+Me+`, d)
            );

            `+vt+`
          }

          int xC = xCCorner + `+qe+`;
          if (`+($e===1)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            `+vt+`
          } else if (`+($e===2)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+Me+`, d),
              initializationValue,
              initializationValue
            );

            `+vt+`
          } else if (`+($e===3)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+Me+`, d),
              getValue(batch, xR, xC + 2 * `+Me+`, d),
              initializationValue
            );

            `+vt+`
          }
        }
        setOutput(`+Ke+`);
      }
    `}}function Qd(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A;D0(ne,"avgPool");const{filterSize:xe,strides:le,pad:ce,dimRoundingMode:ue}=$,Te=1;e(Oa(le,Te),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+le+" and dilations '"+Te+"'");const Me=OI(ne.shape,xe,le,Te,ce,ue);if(Me.filterWidth===1&&Me.filterHeight===1&&X(Me.inShape,Me.outShape))return eu({inputs:{x:ne},backend:V});const Re=new QS(Me,"avg",!1);return V.runWebGLProgram(Re,[ne],"float32")}const QV={kernelName:Cs,backendName:"webgl",kernelFunc:Qd};class Qb{constructor(A,V,$,ne=!1,xe=!1,le=!1,ce=null,ue=!1,Te=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=$,this.enableShapeUniforms=Dr(this.outputShape.length);const Me=ne?A[1]:A[2],Re=Math.ceil(Me/2),we=ne?"i * 2, rc.y":"rc.y, i * 2",ke=xe?"rc.z, i * 2":"i * 2, rc.z",Ue=ne?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],Ge=xe?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let We="",Xe="";ce&&(ue?We=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+ce+`
        }`:Te?We=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+ce+`
        }`:We=`vec4 activation(vec4 x) {
          `+ce+`
        }`,Xe="result = activation(result);");const Ye=le?"result += getBiasAtOutCoords();":"";le&&this.variableNames.push("bias"),ue&&this.variableNames.push("preluActivationWeights"),Te&&this.variableNames.push("leakyreluAlpha");let je="rc.x",Ke="rc.x";A[0]<V[0]?je="imod(rc.x, "+A[0]+")":V[0]<A[0]&&(Ke="imod(rc.x, "+V[0]+")"),this.userCode=`
      `+We+`
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = `+Re+`.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = `+je+`;
        int batchB = `+Ke+`;
        for (int i = 0; i < `+Re+`; i++) {
          vec4 a = getMatrixA(batchA, `+we+`);
          vec4 b = getMatrixB(batchB, `+ke+`);

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (`+Ue[0]+" * "+Ge[0]+`);
          result += (`+Ue[1]+" * "+Ge[1]+`);
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        `+Ye+`

        `+Xe+`

        setOutput(result);
      }
    `}}const QP={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class QE{constructor(A,V,$){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=iH(V,$),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        `+A+`
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const QD="return a * b;";function Qg(W){const{inputs:A,backend:V}=W,{a:$,b:ne}=A,xe=Jb($.dtype,ne.dtype);if($.dtype==="complex64"){const ce=V.texData.get($.dataId),ue=V.texData.get(ne.dataId),Te=new QE(QP.REAL,$.shape,ne.shape),Me=new QE(QP.IMAG,$.shape,ne.shape),Re=[{dataId:ce.complexTensorInfos.real.dataId,dtype:ce.complexTensorInfos.real.dtype,shape:$.shape},{dataId:ce.complexTensorInfos.imag.dataId,dtype:ce.complexTensorInfos.imag.dtype,shape:$.shape},{dataId:ue.complexTensorInfos.real.dataId,dtype:ue.complexTensorInfos.real.dtype,shape:ne.shape},{dataId:ue.complexTensorInfos.imag.dataId,dtype:ue.complexTensorInfos.imag.dtype,shape:ne.shape}],we=V.runWebGLProgram(Te,Re,"float32"),ke=V.runWebGLProgram(Me,Re,"float32"),Ue=eM({inputs:{real:we,imag:ke},backend:V});return V.disposeIntermediateTensorInfo(we),V.disposeIntermediateTensorInfo(ke),Ue}if(V.shouldExecuteOnCPU([$,ne])){const ce=V.texData.get($.dataId),ue=V.texData.get(ne.dataId),[Te,Me]=oq($.shape,ne.shape,ce.values,ue.values,xe),Re=V.makeTensorInfo(Me,xe),we=V.texData.get(Re.dataId);return we.values=Te,Re}let le;return Cd().getBool("WEBGL_PACK_BINARY_OPERATIONS")?le=new eG(QD,$.shape,ne.shape):le=new ex(QD,$.shape,ne.shape),V.runWebGLProgram(le,[$,ne],xe)}const QZ={kernelName:mm,backendName:"webgl",kernelFunc:Qg};function Qo(W,A,V){const $=[Ev(W.shape),...Eq(W.shape)],ne={dtype:W.dtype,shape:$,dataId:W.dataId},xe=[Ev(A),...Eq(A)],le=new ef(xe,$),ce=!0,ue=[$],Te=V.runWebGLProgram(le,[ne],W.dtype,ue,ce);return{dataId:Te.dataId,shape:A,dtype:Te.dtype}}function Qe(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{shape:xe}=$,le=V,ce=F(ne.shape),ue=l(xe,ce),Te=F(ue);e(ce===Te,()=>"The new shape ("+ue+") has "+Te+" elements and the old shape ("+ne.shape+") has "+ce+" elements. The new shape and old shape must have the same number of elements.");const Me=le.texData.get(ne.dataId);return Me.isPacked&&!EL(ne.shape,ue)&&!(Me.texture!==null&&EL(Me.shape,ue))?Qo(ne,ue,le):(le.incRef(ne.dataId),{dataId:ne.dataId,shape:ue,dtype:ne.dtype})}const QQ={kernelName:mP,backendName:"webgl",kernelFunc:Qe};class Qs{constructor(A,V){this.variableNames=["x"];const{windowSize:$,batchSize:ne,inSize:xe,outSize:le}=A;this.outputShape=[ne,le];const ce=Math.floor($/4)*4,ue=$%4;let Te="sumValue += dot(values, ones);";if(V!=null){const Re=1/V;Te="sumValue += dot(values * "+(R(Re)?Re.toPrecision(2):Re)+", ones);"}let Me="";xe%$>0&&(Me=`
        if (inIdx < 0 || inIdx >= `+xe+`) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+Me+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+$+`;

        float sumValue = 0.0;

        for (int i = 0; i < `+ce+`; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+Te+`
        }

        int inIdx = inOffset + `+ce+`;
        if (`+(ue===1)+`) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          `+Te+`
        } else if (`+(ue===2)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          `+Te+`
        } else if (`+(ue===3)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          `+Te+`
        }
        setOutput(sumValue);
      }
    `}}class QF{constructor(A,V){this.variableNames=["x"];const{windowSize:$,batchSize:ne,inSize:xe,outSize:le}=A;this.outputShape=[ne,le];let ce="0.0",ue="";V==="prod"?ce="1.0":V==="min"?(ce="1.0 / 1e-20",ue="min"):V==="max"&&(ce="-1.0 / 1e-20",ue="max");let Te=V+"("+V+"("+V+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";V==="sum"?Te="sumValue":V==="prod"?Te="prodValue":V==="all"?Te="allValue":V==="any"&&(Te="anyValue");const Me=Math.floor($/4)*4,Re=$%4;let we=`
      if (`+(V==="sum")+`) {
        sumValue += dot(values, ones);
      } else if (`+(V==="prod")+`) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = `+ue+`(values, minMaxValue);
        if (`+(V==="min")+" || "+(V==="max")+`) {
          minMaxValue = `+ue+`(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,ke="vec4";V==="all"?(ce="1.0",we=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,ke="bvec4"):V==="any"&&(ce="0.0",we=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,ke="bvec4");let Ue="";xe%$>0&&(Ue=`
        if (inIdx < 0 || inIdx >= `+xe+`) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = `+ce+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+Ue+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+$+`;

        vec4 minMaxValue = vec4(`+ce+`);
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < `+Me+`; i += 4) {
          int inIdx = inOffset + i;
          `+ke+" values = "+ke+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+we+`
        }

        int inIdx = inOffset + `+Me+`;
        if (`+(Re===1)+`) {
          `+ke+" values = "+ke+`(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          `+we+`
        } else if (`+(Re===2)+`) {
          `+ke+" values = "+ke+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          `+we+`
        } else if (`+(Re===3)+`) {
          `+ke+" values = "+ke+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          `+we+`
        }
        setOutput(`+Te+`);
      }
    `}}function QI(W){const A=[];for(;A.length===0||A[A.length-1].outSize!==1;){const V=A.length?A[A.length-1].outSize:W[1],$=dR(V);A.push({inSize:V,windowSize:$,outSize:Math.ceil(V/$)})}return A}function Qy(W,A,V,$){const ne=QI(W.shape);let xe=W;for(let le=0;le<ne.length;le++){const{inSize:ce,windowSize:ue,outSize:Te}=ne[le];let Me,Re;V==="mean"?Me=le===0?new Qs({windowSize:ue,inSize:ce,batchSize:W.shape[0],outSize:Te},ce):new Qs({windowSize:ue,inSize:ce,batchSize:W.shape[0],outSize:Te}):Me=new QF({windowSize:ue,inSize:ce,batchSize:W.shape[0],outSize:Te},V),Re=xe,xe=$.runWebGLProgram(Me,[xe],A),Re.dataId!==W.dataId&&$.disposeIntermediateTensorInfo(Re)}return xe}class QA{constructor(A,V){this.variableNames=["A"];const $=new Array(A.length);for(let le=0;le<$.length;le++)$[le]=A[V[le]];this.outputShape=$,this.rank=$.length;const ne=Dz(this.rank),xe=Qp(V);this.userCode=`
    void main() {
      `+ne+` resRC = getOutputCoords();
      setOutput(getA(`+xe+`));
    }
    `}}function Qp(W){const A=W.length;if(A>6)throw Error("Transpose for rank "+A+" is not yet supported");const V=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],$=new Array(A);for(let ne=0;ne<W.length;ne++)$[W[ne]]=V[ne];return $.join()}class Qw{constructor(A,V){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const $=new Array(A.length);for(let Me=0;Me<$.length;Me++)$[Me]=A[V[Me]];if(this.outputShape=$,this.rank=$.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");const ne=Dz(this.rank),xe=eC("rc",this.rank),le=new Array(this.rank);for(let Me=0;Me<V.length;Me++)le[V[Me]]=xe[Me];const ce="vec2("+le.slice(-2).join()+")",ue="++"+xe[this.rank-1]+" < "+$[this.rank-1],Te="getChannel(getA("+le.join()+"), "+ce+")";this.userCode=`
    void main() {
      `+ne+` rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = `+Te+`;
      if(`+ue+`) {
        result[1] = `+Te+`;
      }
      --`+xe[this.rank-1]+`;
      if(++`+xe[this.rank-2]+" < "+$[this.rank-2]+`) {
        result[2] = `+Te+`;
        if(`+ue+`) {
          result[3] = `+Te+`;
        }
      }
      setOutput(result);
    }
    `}}function QX(W,A,V){const $=Cd().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qw(W.shape,A):new QA(W.shape,A);return V.runWebGLProgram($,[W],W.dtype)}function Qc(W,A,V,$){const ne=A,xe=W.shape.length,le=n(ne,W.shape);let ce=le;const ue=tW(ce,xe),Te=ue!=null;let Me=W;Te&&(Me=QX(W,ue,$),ce=tK(ce.length,xe)),tc("sum",ce,xe);const[Re,we]=tw(Me.shape,ce);let ke=Re;V&&(ke=tX(Re,le));const Ue=F(we),Ge=F(W.shape)/Ue,We=Qe({inputs:{x:Me},attrs:{shape:[Ge,Ue]},backend:$}),Xe=JP(W.dtype),Ye=Qy(We,Xe,"sum",$),je=Qe({inputs:{x:Ye},attrs:{shape:ke},backend:$});return $.disposeIntermediateTensorInfo(We),$.disposeIntermediateTensorInfo(Ye),Te&&$.disposeIntermediateTensorInfo(Me),je}function QW(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{axis:xe,keepDims:le}=$;return Qc(ne,xe,le,V)}const QR={kernelName:my,backendName:"webgl",kernelFunc:QW};function QK(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{perm:xe}=$,le=V,ce=ne.shape.length,ue=new Array(ce);for(let Me=0;Me<ue.length;Me++)ue[Me]=ne.shape[xe[Me]];let Te;if(le.shouldExecuteOnCPU([ne])){const Me=le.texData.get(ne.dataId).values,Re=e8(Me,ne.shape,ne.dtype,xe,ue);Te=le.makeTensorInfo(ue,ne.dtype);const we=le.texData.get(Te.dataId);we.values=Re}else Te=QX(ne,xe,le);return Te}const QT={kernelName:mK,backendName:"webgl",kernelFunc:QK},Qv=1e3;function Qq({a:W,b:A,transposeA:V,transposeB:$,backend:ne,bias:xe=null,preluActivationWeights:le=null,leakyreluAlpha:ce=0,activation:ue=null}){const Te=W.shape.length,Me=A.shape.length,Re=V?W.shape[Te-2]:W.shape[Te-1],we=$?A.shape[Me-1]:A.shape[Me-2],ke=V?W.shape[Te-1]:W.shape[Te-2],Ue=$?A.shape[Me-2]:A.shape[Me-1],Ge=W.shape.slice(0,-2),We=A.shape.slice(0,-2),Xe=F(Ge),Ye=F(We),je=iH(W.shape.slice(0,-2),A.shape.slice(0,-2)).concat([ke,Ue]);e(Re===we,()=>"Error in matMul: inner shapes ("+Re+") and ("+we+") of Tensors with shapes "+W.shape+" and "+A.shape+" and transposeA="+V+" and transposeB="+$+" must match.");const Ke=V?[Xe,Re,ke]:[Xe,ke,Re],qe=$?[Ye,Ue,we]:[Ye,we,Ue],$e=Qe({inputs:{x:W},backend:ne,attrs:{shape:Ke}}),vt=Qe({inputs:{x:A},backend:ne,attrs:{shape:qe}}),nt=[$e,vt],wt=Math.max(Xe,Ye),Kt=V?$e.shape[1]:$e.shape[2],Ht=xe!=null,pi=le!=null,hi=ue==="leakyrelu",ai=ue!=null?Q6(ue,!0):null,Yi=Ht||pi||hi||ai!=null;let Wi;if((ke===1||Ue===1)&&Kt>Qv&&Yi===!1){let Hi=$e,rs=vt;V&&(Hi=QK({inputs:{x:$e},backend:ne,attrs:{perm:[0,2,1]}}),nt.push(Hi)),$&&(rs=QK({inputs:{x:vt},backend:ne,attrs:{perm:[0,2,1]}}),nt.push(rs));const Us=Ue!==1,Hs=Ue===1;let qi=Hi;Us&&(qi=Qe({inputs:{x:Hi},backend:ne,attrs:{shape:[wt,Kt,1]}}),nt.push(qi));const as=Ue===1?2:1;let li=rs;Hs&&(li=Qe({inputs:{x:rs},backend:ne,attrs:{shape:[wt,1,Kt]}}),nt.push(li));const vi=Qg({inputs:{a:qi,b:li},backend:ne});Wi=QW({inputs:{x:vi},backend:ne,attrs:{axis:as,keepDims:!0}}),nt.push(vi)}else{const Hi=Jb(W.dtype,A.dtype),rs=new Qb(Ke,qe,[wt,ke,Ue],V,$,Ht,ai,pi,hi),Us=[$e,vt];if(xe!=null&&Us.push(xe),pi&&Us.push(le),hi){const Hs=ne.makeTensorInfo([],"float32",Nn(ce,"float32"));Us.push(Hs),nt.push(Hs)}Wi=ne.runWebGLProgram(rs,Us,Hi)}const ls=Qe({inputs:{x:Wi},backend:ne,attrs:{shape:je}});nt.push(Wi);for(const Hi of nt)ne.disposeIntermediateTensorInfo(Hi);return ls}function Ql(W){const{inputs:A,backend:V,attrs:$}=W,{a:ne,b:xe}=A,{transposeA:le,transposeB:ce}=$;return Qq({a:ne,b:xe,transposeA:le,transposeB:ce,backend:V})}const Qa={kernelName:CF,backendName:"webgl",kernelFunc:Ql},Qn="return float(a != b);",QL=Q5({opSnippet:Qn,cpuKernelImpl:oa,dtype:"bool"});function QH(W){const{inputs:A,backend:V}=W,{input:$}=A,ne=V.texData.get($.dataId);return eu({inputs:{x:ne.complexTensorInfos.real},backend:V})}const Qk="return float(int(x));";function Qz(W,A){const V=new eP(W.shape,Qk),$=A.runWebGLProgram(V,[W],"int32");return{dataId:$.dataId,shape:$.shape,dtype:$.dtype}}function Qx(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{dtype:xe}=$;if(xe==="complex64"){if(ne.dtype==="complex64")return eu({inputs:{x:ne},backend:V});const le=BQ(ne.shape),ce=Qx({inputs:{x:ne},backend:V,attrs:{dtype:"float32"}}),ue=eM({inputs:{real:ce,imag:le},backend:V});return le.dispose(),V.disposeIntermediateTensorInfo(ce),ue}if(ne.dtype==="complex64"){const le=QH({inputs:{input:ne},backend:V}),ce=Qx({inputs:{x:le},backend:V,attrs:{dtype:xe}});return V.disposeIntermediateTensorInfo(le),ce}if(!Y(ne.dtype,xe)){const le=eu({inputs:{x:ne},backend:V});return{dataId:le.dataId,shape:le.shape,dtype:xe}}if(V.shouldExecuteOnCPU([ne])){const le=V.texData.get(ne.dataId).values,[ce,ue,Te]=og(le,ne.shape,ne.dtype,xe);return V.makeTensorInfo(ce,ue,Te)}if(xe==="int32")return Qz(ne,V);if(xe==="bool"){const le=V.makeTensorInfo([],"bool",H("bool",1)),ce=QL({inputs:{a:ne,b:le},backend:V});return V.disposeIntermediateTensorInfo(le),ce}throw new Error("Error in Cast: failed to cast "+ne.dtype+" to "+xe)}const QU={kernelName:CA,backendName:"webgl",kernelFunc:Qx};class QG{constructor(A){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=A,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class Qu{constructor(A){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=A,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function QY(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{clipValueMin:xe,clipValueMax:le}=$;let ce;Cd().getBool("WEBGL_PACK_CLIP")?ce=new Qu(ne.shape):ce=new QG(ne.shape);const ue=[[xe],[le]];return V.runWebGLProgram(ce,[ne],ne.dtype,ue)}const QM={kernelName:Cp,backendName:"webgl",kernelFunc:QY};class Qh{constructor(A){this.outputShape=[],this.outputShape=dy(A,1),this.variableNames=A.map((le,ce)=>"T"+ce);const V=new Array(A.length-1);V[0]=A[0][1];for(let le=1;le<V.length;le++)V[le]=V[le-1]+A[le][1];const $=["if (yC < "+V[0]+") setOutput(getT0(yR, yC));"];for(let le=1;le<V.length;le++){const ce=V[le-1];$.push("else if (yC < "+V[le]+") setOutput(getT"+le+"(yR, yC-"+ce+"));")}const ne=V.length,xe=V[V.length-1];$.push("else setOutput(getT"+ne+"(yR, yC-"+xe+"));"),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        `+$.join(`
        `)+`
      }
    `}}class Qj{constructor(A,V){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=dy(A,V);const $=this.outputShape,ne=$.length,xe=Dz(ne),le=em("coords",ne),ce=["x","y","z","w","u","v"].slice(0,ne);this.variableNames=A.map((Ge,We)=>"T"+We);const ue=new Array(A.length-1);ue[0]=A[0][V];for(let Ge=1;Ge<ue.length;Ge++)ue[Ge]=ue[Ge-1]+A[Ge][V];const Te=ce[V],Me=ce.slice(-2),Re=ce.join();let we="if ("+Te+" < "+ue[0]+`) {
        return getChannel(
            getT0(`+Re+"), vec2("+Me.join()+`));
        }`;for(let Ge=1;Ge<ue.length;Ge++){const We=ue[Ge-1];we+=`
        if (`+Te+" < "+ue[Ge]+"  && "+Te+" >= "+ue[Ge-1]+`) {
          return getChannel(
            getT`+Ge+"("+Qr(ce,Te,We)+`),
            vec2(`+Qr(Me,Te,We)+`));
        }`}const ke=ue.length,Ue=ue[ue.length-1];we+=`
        return getChannel(
          getT`+ke+"("+Qr(ce,Te,Ue)+`),
          vec2(`+Qr(Me,Te,Ue)+"));",this.userCode=`
      float getValue(`+ce.map(Ge=>"int "+Ge)+`) {
        `+we+`
      }

      void main() {
        `+xe+` coords = getOutputCoords();
        vec4 result = vec4(getValue(`+le+`), 0., 0., 0.);

        `+le[ne-1]+" = "+le[ne-1]+` + 1;
        if (`+le[ne-1]+" < "+$[ne-1]+`) {
          result.g = getValue(`+le+`);
        }

        `+le[ne-2]+" = "+le[ne-2]+` + 1;
        if (`+le[ne-2]+" < "+$[ne-2]+`) {
          result.a = getValue(`+le+`);
        }

        `+le[ne-1]+" = "+le[ne-1]+` - 1;
        if (`+le[ne-2]+" < "+$[ne-2]+` &&
            `+le[ne-1]+" < "+$[ne-1]+`) {
          result.b = getValue(`+le+`);
        }
        setOutput(result);
      }
    `}}function Qr(W,A,V){const $=W.indexOf(A);return W.map((ne,xe)=>xe===$?ne+" - "+V:ne).join()}function s0(W){const{inputs:A,backend:V}=W,{input:$}=A,ne=V.texData.get($.dataId);return eu({inputs:{x:ne.complexTensorInfos.imag},backend:V})}function s1(W,A,V){const $=W[0].dtype;if($==="complex64"){const ke=W.map(Ye=>QH({inputs:{input:Ye},backend:V})),Ue=W.map(Ye=>s0({inputs:{input:Ye},backend:V})),Ge=s1(ke,A,V),We=s1(Ue,A,V),Xe=eM({inputs:{real:Ge,imag:We},backend:V});return ke.forEach(Ye=>V.disposeIntermediateTensorInfo(Ye)),Ue.forEach(Ye=>V.disposeIntermediateTensorInfo(Ye)),V.disposeIntermediateTensorInfo(Ge),V.disposeIntermediateTensorInfo(We),Xe}let ne=V.shouldExecuteOnCPU(W);if($==="string"&&(ne=!0),ne){const ke=W.map(Ke=>{const qe=[-1,F(Ke.shape.slice(A))];return Qe({inputs:{x:Ke},backend:V,attrs:{shape:qe}})}),Ue=ke.map(Ke=>({vals:V.readSync(Ke.dataId),shape:Ke.shape})),Ge=dy(ke.map(Ke=>Ke.shape),1),We=ke[0].shape[0]===1,Xe=oo(Ue,Ge,$,We),Ye=dy(W.map(Ke=>Ke.shape),A),je=V.makeTensorInfo(Ye,$,Xe);return ke.forEach(Ke=>V.disposeIntermediateTensorInfo(Ke)),je}const xe=W.filter(ke=>F(ke.shape)>0),le=Cd().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&xe[0].shape.length>1;if(xe.length===1){const ke=le?new eP(W[0].shape,eQ):new ew(W[0].shape,eQ);return V.runWebGLProgram(ke,W,$)}const ce=Cd().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(xe.length>ce){const ke=[];for(let Ge=0;Ge<xe.length;Ge+=ce){const We=xe.slice(Ge,Ge+ce);ke.push(s1(We,A,V))}const Ue=s1(ke,A,V);for(const Ge of ke)V.disposeIntermediateTensorInfo(Ge);return Ue}if(le){const ke=new Qj(xe.map(Ue=>Ue.shape),A);return V.runWebGLProgram(ke,xe,$)}const{tensors2D:ue,outShape:Te}=s2(xe,A,V),Me=new Qh(ue.map(ke=>ke.shape)),Re=V.runWebGLProgram(Me,ue,$);ue.forEach(ke=>V.disposeIntermediateTensorInfo(ke));const we=Qe({inputs:{x:Re},attrs:{shape:Te},backend:V});return V.disposeIntermediateTensorInfo(Re),we}function s2(W,A,V){const $=dy(W.map(ne=>ne.shape),A);return{tensors2D:W.map(ne=>Qe({inputs:{x:ne},attrs:{shape:[-1,F(ne.shape.slice(A))]},backend:V})),outShape:$}}function s3(W){const{inputs:A,backend:V,attrs:$}=W,{axis:ne}=$,xe=n(ne,A[0].shape)[0],le=A.map(Te=>Te.shape);dI(le,xe);const ce=dy(A.map(Te=>Te.shape),xe);if(F(ce)===0)return V.makeTensorInfo(ce,A[0].dtype,[]);const ue=A.filter(Te=>F(Te.shape)>0);return ue.length===1?eu({inputs:{x:ue[0]},backend:V}):s1(ue,xe,V)}const s4={kernelName:Cc,backendName:"webgl",kernelFunc:s3};class s5{constructor(A,V=!1,$=null,ne=!1,xe=!1){this.variableNames=["x","W"],this.outputShape=A.outShape;const le=A.padInfo.top,ce=A.padInfo.left,ue=A.strideHeight,Te=A.strideWidth,Me=A.dilationHeight,Re=A.dilationWidth,we=A.filterHeight,ke=A.filterWidth,Ue=Math.floor(A.inChannels/4)*4,Ge=A.inChannels%4,We=A.dataFormat==="channelsLast",Xe=We?1:2,Ye=We?2:3,je=We?3:1;let Ke="",qe="";$&&(ne?Ke=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+$+`
        }`:xe?Ke=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+$+`
        }`:Ke=`
          float activation(float x) {
            `+$+`
          }
        `,qe="result = activation(result);");const $e=V?"result += getBiasAtOutCoords();":"";V&&this.variableNames.push("bias"),ne&&this.variableNames.push("preluActivationWeights"),xe&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+Ke+`

      const ivec2 strides = ivec2(`+ue+", "+Te+`);
      const ivec2 pads = ivec2(`+le+", "+ce+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[`+je+`];

        ivec2 xRCCorner =
            ivec2(coords[`+Xe+"], coords["+Ye+`]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+we+`; wR++) {
          int xR = xRCorner + wR * `+Me+`;

          if (xR < 0 || xR >= `+A.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+ke+`; wC++) {
            int xC = xCCorner + wC * `+Re+`;

            if (xC < 0 || xC >= `+A.inWidth+`) {
              continue;
            }

            for (int d1 = 0; d1 < `+Ue+`; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (`+We+`) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (`+(Ge===1)+`) {

              if (`+We+`) {
                dotProd +=
                    getX(batch, xR, xC, `+Ue+`) *
                    getW(wR, wC, `+Ue+`, d2);
              } else {
                dotProd +=
                    getX(batch, `+Ue+`, xR, xC) *
                    getW(wR, wC, `+Ue+`, d2);
              }

            } else if (`+(Ge===2)+`) {
              vec2 wValues = vec2(
                getW(wR, wC, `+Ue+`, d2),
                getW(wR, wC, `+Ue+` + 1, d2)
              );

              if (`+We+`) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, `+Ue+`),
                  getX(batch, xR, xC, `+Ue+` + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, `+Ue+`, xR, xC),
                  getX(batch, `+Ue+` + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (`+(Ge===3)+`) {
              vec3 wValues = vec3(
                getW(wR, wC, `+Ue+`, d2),
                getW(wR, wC, `+Ue+` + 1, d2),
                getW(wR, wC, `+Ue+` + 2, d2)
              );

              if (`+We+`) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, `+Ue+`),
                  getX(batch, xR, xC, `+Ue+` + 1),
                  getX(batch, xR, xC, `+Ue+` + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, `+Ue+`, xR, xC),
                  getX(batch, `+Ue+` + 1, xR, xC),
                  getX(batch, `+Ue+` + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        `+$e+`
        `+qe+`
        setOutput(result);
      }
    `}}class s6{constructor(A,V=!1,$=null,ne=!1,xe=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=A.outShape,this.enableShapeUniforms=Dr(this.outputShape.length);const le=A.padInfo.left,ce=A.strideWidth,ue=A.dilationWidth,Te=A.filterHeight,Me=A.filterWidth,Re=Me;let we=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let We=0;We<Me;We++)we+=`
           vec4 xTexelC`+We*2+`;
           int xTexelC`+We*2+`Ready;
           vec4 xTexelC`+(We*2+1)+`;
           int xTexelC`+(We*2+1)+`Ready;
           vec4 xC`+We+";";we+=`
     for (int r = 0; r < `+Te+`; r++) {
      for (int d1 = 0; d1 < `+A.inChannels+`; d1 += 2) {
       `;for(let We=0;We<Me;We++)we+=`
           xTexelC`+We*2+` = vec4(0.0);
           xTexelC`+We*2+`Ready = 0;
           xTexelC`+(We*2+1)+` = vec4(0.0);
           xTexelC`+(We*2+1)+`Ready = 0;
           xC`+We+" = vec4(0.0);";we+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let We=0;We<(Re+1)/2;We++){const Xe=We*2;if(we+=`
           xC = xCCorner + `+Xe*ue+`;
           `,ce===1){if(Xe<Me&&(le%2===1?(we+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+Xe+`Ready == 0) {
                   xTexelC`+Xe+` = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+Xe+`.zw = vec2(0.0);
                   }
                   xTexelC`+Xe+`Ready = 1;
                 }
               `,ue===1&&Xe>0?we+=`
                 xC`+Xe+" = vec4(xTexelC"+(Xe-2)+".zw, xTexelC"+Xe+`.xy);
                 `:we+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC`+Xe+" = vec4(previous.zw, xTexelC"+Xe+`.xy);
                   } else {
                     xC`+Xe+" = vec4(0.0, 0.0, xTexelC"+Xe+`.xy);
                   }
                   `):we+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC`+Xe+`Ready == 0) {
                   xTexelC`+Xe+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+Xe+`.zw = vec2(0.0);
                   }
                   xTexelC`+Xe+`Ready = 1;
                 }

                 xC`+Xe+" = xTexelC"+Xe+`;
                 `,Xe+1<Me)){const Ye=le%2===0?B(ue):ue;ue%2===0&&le%2===1||ue%2!==0&&le%2!==1?(we+=`
                   xCOffset = xC + imod(pads[1], 2) + `+Ye+`;

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Xe+1)+`Ready == 0) {
                     xTexelC`+(Xe+1)+` = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC`+(Xe+1)+`.zw = vec2(0.0);
                     }
                     xTexelC`+(Xe+1)+`Ready = 1;
                   }
                   `,ue>1?we+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC`+(Xe+1)+" = vec4(previous.zw, xTexelC"+(Xe+1)+`.xy);
                     } else {
                      xC`+(Xe+1)+" = vec4(0.0, 0.0, xTexelC"+(Xe+1)+`.xy);
                     }
                     `:we+=`
                     xC`+(Xe+1)+" = vec4(xTexelC"+Xe+".zw, xTexelC"+(Xe+1)+`.xy);
                     `):Ye===1?we+=`
                     xC`+(Xe+1)+" = xTexelC"+Xe+`;
                     `:we+=`
                     xCOffset = xC + `+Ye+`;

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Xe+1)+`Ready == 0) {
                       xTexelC`+(Xe+1)+` = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC`+(Xe+1)+`.zw = vec2(0.0);
                       }
                       xTexelC`+(Xe+1)+`Ready = 1;
                     }

                     xC`+(Xe+1)+" = xTexelC"+(Xe+1)+`;
                     `}}else Xe<Me&&(le%2===1?(we+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+Xe+`Ready == 0) {
                   xTexelC`+Xe+` = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+Xe+`.zw = vec2(0.0);
                   }
                   xTexelC`+Xe+`Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(Xe+1)+`Ready == 0) {
                   xTexelC`+(Xe+1)+` = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC`+(Xe+1)+`.zw = vec2(0.0);
                   }
                   xTexelC`+(Xe+1)+`Ready = 1;
                 }

                 xC`+Xe+" = vec4(xTexelC"+Xe+".zw, xTexelC"+(Xe+1)+`.zw);
               `,Xe+1<Me&&(we+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC`+(Xe+1)+" = vec4(xTexelC"+(Xe+1)+`.xy, final.xy);
                 `)):(we+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC`+Xe+`Ready == 0) {
                   xTexelC`+Xe+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+Xe+`.zw = vec2(0.0);
                   }
                   xTexelC`+Xe+`Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Xe+1)+`Ready == 0) {
                   xTexelC`+(Xe+1)+` = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+(Xe+1)+`.zw = vec2(0.);
                   }
                   xTexelC`+(Xe+1)+`Ready = 1;
                 }

                 xC`+Xe+` = vec4(
                   xTexelC`+Xe+".xy, xTexelC"+(Xe+1)+`.xy);
               `,Xe+1<Me&&(we+=`
                   xC`+(Xe+1)+" = vec4(xTexelC"+Xe+".zw, xTexelC"+(Xe+1)+`.zw);
                 `)));Xe<Me&&(we+=`
             wTexel = getW(r, `+Xe+`, d1, d2);
             dotProd += xC`+Xe+`.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < `+A.inChannels+`) {
               dotProd += xC`+Xe+`.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,Xe+1<Me&&(we+=`
               wTexel = getW(r, `+(Xe+1)+`, d1, d2);
               dotProd += xC`+(Xe+1)+`.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < `+A.inChannels+`) {
                 dotProd += xC`+(Xe+1)+`.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}we+=`
     }
   `,we+=`
     }
   `,we+=`
     }
   `;let ke="",Ue="";$&&(ne?ke=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           `+$+`
         }`:xe?ke=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           `+$+`
         }`:ke=`vec4 activation(vec4 x) {
           `+$+`
         }`,Ue="result = activation(result);");const Ge=V?"result += getBiasAtOutCoords();":"";V&&this.variableNames.push("bias"),ne&&this.variableNames.push("preluActivationWeights"),xe&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       `+ke+`

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         `+we+`

         vec4 result = dotProd - vec4(0.000000000000001);
         `+Ge+`
         `+Ue+`
         setOutput(result);
       }
     `}}class s7{constructor(A,V){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=A,this.enableShapeUniforms=Dr(this.outputShape.length);const{dataFormat:$}=V,ne=D2(),xe=$==="channelsLast",le=xe?1:2,ce=xe?2:3,ue=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < "+A[2]+" && pos < "+A[1]+") {";let Te="";for(let Me=0;Me<=1;Me++)for(let Re=0;Re<=1;Re++)Te+=`
          blockIndex = rc.z + `+Re+`;
          pos = rc.y + `+Me+`;

          `+ue+`
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[`+le+`] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[`+ce+`] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (`+xe+`) {
                  innerDims = vec2(d1, ch);
                  result[`+(Me*2+Re)+`] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[`+(Me*2+Re)+`] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        `+Te+`

        `+ne.output+` = result;
      }
    `}}function s8(W,A){const V=W.length;return V>=3?A?[...W.slice(0,-3),W[V-3]*W[V-2],W[V-1]]:[...W.slice(0,-3),W[V-3],W[V-2]*W[V-1]]:!A&&V===1&&W[0]>1?[W[0],1]:null}function s9({x:W,filter:A,convInfo:V,backend:$,bias:ne=null,preluActivationWeights:xe=null,leakyreluAlpha:le=0,activation:ce=null}){const ue=W.shape,Te=$.texData.get(W.dataId),Me=V.inChannels,Re=ue[0]*ue[1]*ue[2],we=V.outChannels,ke=V.dataFormat==="channelsLast",Ue=!1,Ge=!1;let We;const Xe=[];if(xe!=null){const Ye=s8(xe.shape,ke);Ye!=null&&(xe=Qe({inputs:{x:xe},backend:$,attrs:{shape:Ye}}),Xe.push(xe))}if(ne!=null){const Ye=s8(ne.shape,ke);Ye!=null&&(ne=Qe({inputs:{x:ne},backend:$,attrs:{shape:Ye}}),Xe.push(ne))}if(!((Re===1||we===1)&&Me>Qv)&&Te.isPacked&&ke&&Te.texture!=null&&ue[2]%2!==0&&X(Te.shape.slice(-3),ue.slice(-3))){const Ye=ue[0]*ue[1]*(ue[2]+1),je={dataId:W.dataId,shape:[1,Ye,V.inChannels],dtype:W.dtype},Ke=Te.shape;Te.shape=Te.shape.slice(),Te.shape[Te.shape.length-2]++,e(EL(Te.shape,je.shape),()=>"packed reshape "+Te.shape+" to "+je.shape+" isn't free");const qe=Qe({inputs:{x:A},backend:$,attrs:{shape:[1,V.inChannels,V.outChannels]}});Xe.push(qe);const $e=Qq({a:je,b:qe,backend:$,transposeA:Ue,transposeB:Ge,bias:ne,activation:ce,preluActivationWeights:xe,leakyreluAlpha:le}),vt=$.texData.get($e.dataId);e(vt.isPacked,()=>"batchMatMul result is expected to be packed"),Te.shape=Ke,vt.shape=V.outShape,We=eu({inputs:{x:$e},backend:$}),We.shape=V.outShape,Xe.push($e)}else{const Ye=V.outHeight*V.outWidth,je=Qe({inputs:{x:W},backend:$,attrs:{shape:ke?[V.batchSize,Ye,V.inChannels]:[V.batchSize,V.inChannels,Ye]}}),Ke=Qe({inputs:{x:A},backend:$,attrs:{shape:[1,V.inChannels,V.outChannels]}}),qe=Qq({a:ke?je:Ke,b:ke?Ke:je,transposeA:!ke,transposeB:Ge,backend:$,bias:ne,activation:ce,preluActivationWeights:xe,leakyreluAlpha:le});We=Qe({inputs:{x:qe},backend:$,attrs:{shape:V.outShape}}),Xe.push(je),Xe.push(Ke),Xe.push(qe)}for(const Ye of Xe)$.disposeIntermediateTensorInfo(Ye);return We}function sC({x:W,filter:A,convInfo:V,backend:$,bias:ne=null,preluActivationWeights:xe=null,leakyreluAlpha:le=0,activation:ce=null}){const{filterWidth:ue,filterHeight:Te,inChannels:Me,outWidth:Re,outHeight:we,dataFormat:ke}=V,Ue=ke==="channelsLast",Ge=ue*Te*Me,We=we*Re,Xe=[V.batchSize,Ge,We],Ye=!0,je=!1,Ke=[];if(xe!=null){const Hi=s8(xe.shape,Ue);Hi!=null&&(xe=Qe({inputs:{x:xe},backend:$,attrs:{shape:Hi}}),Ke.push(xe))}if(ne!=null){const Hi=s8(ne.shape,Ue);Hi!=null&&(ne=Qe({inputs:{x:ne},backend:$,attrs:{shape:Hi}}),Ke.push(ne))}const qe=Qe({inputs:{x:A},backend:$,attrs:{shape:[1,Ge,F(A.shape)/Ge]}});Ke.push(qe);const $e=new s7(Xe,V),vt=[W.shape,[V.padInfo.top,V.padInfo.left],[V.strideHeight,V.strideWidth],[V.dilationHeight,V.dilationWidth],[V.inChannels],[V.filterWidth*V.inChannels],[V.outWidth]],nt=$.runWebGLProgram($e,[W],"float32",vt),wt=Qe({inputs:{x:nt},backend:$,attrs:{shape:Xe}});Ke.push(nt),Ke.push(wt);const Kt=ne!=null,Ht=xe!=null,pi=ce==="leakyrelu",hi=ce?Q6(ce,!0):null,ai=new Qb(Ue?wt.shape:qe.shape,Ue?qe.shape:wt.shape,Ue?[V.batchSize,We,V.outChannels]:[V.batchSize,V.outChannels,We],Ye,je,Kt,hi,Ht,pi),Yi=Ue?[wt,qe]:[qe,wt];if(ne&&Yi.push(ne),Ht&&Yi.push(xe),pi){const Hi=$.makeTensorInfo([],"float32",Nn(le,"float32"));Yi.push(Hi),Ke.push(Hi)}const Wi=$.runWebGLProgram(ai,Yi,"float32"),ls=Qe({inputs:{x:Wi},backend:$,attrs:{shape:V.outShape}});Ke.push(Wi);for(const Hi of Ke)$.disposeIntermediateTensorInfo(Hi);return ls}function sm(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne,filter:xe}=A,{strides:le,pad:ce,dataFormat:ue,dilations:Te,dimRoundingMode:Me}=$,Re=OL(ue),we=OA(ne.shape,xe.shape,le,Te,ce,Me,!1,Re);let ke;if(we.filterHeight===1&&we.filterWidth===1&&we.dilationHeight===1&&we.dilationWidth===1&&we.strideHeight===1&&we.strideWidth===1&&(we.padInfo.type==="SAME"||we.padInfo.type==="VALID"))ke=s9({x:ne,filter:xe,convInfo:we,backend:V});else if(we.strideWidth<=2&&Re==="channelsLast"&&Cd().getBool("WEBGL_EXP_CONV")){const Ge=new s6(we),We=[[we.padInfo.top,we.padInfo.left],[we.strideHeight,we.strideWidth],[we.dilationHeight,we.dilationWidth],[we.inHeight,we.inWidth]];ke=V.runWebGLProgram(Ge,[ne,xe],"float32",We)}else if(Cd().getBool("WEBGL_CONV_IM2COL"))ke=sC({x:ne,filter:xe,convInfo:we,backend:V});else{const Ge=new s5(we);ke=V.runWebGLProgram(Ge,[ne,xe],"float32")}const Ue=Qe({inputs:{x:ke},backend:V,attrs:{shape:we.outShape}});return V.disposeIntermediateTensorInfo(ke),Ue}const sN={kernelName:CW,backendName:"webgl",kernelFunc:sm};class sJ{constructor(A){this.variableNames=["dy","W"],this.outputShape=A.inShape;const V=A.filterHeight,$=A.filterWidth,ne=A.strideHeight,xe=A.strideWidth,le=A.dataFormat==="channelsLast",ce=V-1-A.padInfo.top,ue=$-1-A.padInfo.left,Te=le?1:2,Me=le?2:3,Re=le?3:1;this.userCode=`
      const ivec2 pads = ivec2(`+ce+", "+ue+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[`+Re+`];

        ivec2 dyCorner = ivec2(coords[`+Te+"], coords["+Me+`]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+V+`; wR++) {
          float dyR = float(dyRCorner + wR) / `+ne+`.0;

          if (dyR < 0.0 || dyR >= `+A.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = `+V+` - 1 - wR;

          for (int wC = 0; wC < `+$+`; wC++) {
            float dyC = float(dyCCorner + wC) / `+xe+`.0;

            if (dyC < 0.0 || dyC >= `+A.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = `+$+` - 1 - wC;

            for (int d2 = 0; d2 < `+A.outChannels+`; d2++) {

              if (`+le+`) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class sf{constructor(A){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=A.inShape,this.enableShapeUniforms=Dr(this.outputShape.length);const V=A.filterHeight,$=A.filterWidth,ne=V-1-A.padInfo.top,xe=$-1-A.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(`+ne+", "+xe+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < `+V+`; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= `+A.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = `+V+` - 1 - wR;

          for (int wC = 0; wC < `+$+`; wC++) {
            int wCPerm = `+$+` - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < `+A.outWidth+`.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < `+A.outWidth+`.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < `+A.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < `+A.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < `+A.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function si(W){const{inputs:A,backend:V,attrs:$}=W,{dy:ne,filter:xe}=A,{inputShape:le,strides:ce,pad:ue,dataFormat:Te,dimRoundingMode:Me}=$,Re=OL(Te),we=OA(le,xe.shape,ce,1,ue,Me,!1,Re);if(Cd().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&Re==="channelsLast"){const ke=[[we.strideHeight,we.strideWidth]],Ue=new sf(we);return V.runWebGLProgram(Ue,[ne,xe],"float32",ke)}else{const ke=new sJ(we);return V.runWebGLProgram(ke,[ne,xe],"float32")}}const sO={kernelName:CK,backendName:"webgl",kernelFunc:si},st=Q3+`
  return cos(x);
`,sB=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  `+eU+`
  return result;
`,sS=Q4({opSnippet:st,packedOpSnippet:sB}),sd={kernelName:CT,backendName:"webgl",kernelFunc:sS};class sV{constructor(A,V,$,ne,xe){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[le,ce,ue,Te]=A,[Me]=V,[Re,we]=$;this.outputShape=[Me,Re,we,Te];const ke=ne==="bilinear"?1:0,[Ue,Ge]=[ce-1+".0",ue-1+".0"],[We,Xe,Ye]=Re>1?[""+(ce-1)/(Re-1),"(y2-y1) * height_ratio","y1*"+Ue+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+Ue],[je,Ke,qe]=we>1?[""+(ue-1)/(we-1),"(x2-x1) * width_ratio","x1*"+Ge+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+Ge];this.userCode=`
      const float height_ratio = float(`+We+`);
      const float width_ratio = float(`+je+`);
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= `+le+`) {
          return;
        }

        float height_scale = `+Xe+`;
        float width_scale = `+Ke+`;

        float in_y = `+Ye+`;
        if( in_y < 0.0 || in_y > `+Ue+` ) {
          setOutput(float(`+xe+`));
          return;
        }
        float in_x = `+qe+`;
        if( in_x < 0.0 || in_x > `+Ge+` ) {
          setOutput(float(`+xe+`));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(`+ke+` == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const sb=W=>{const{inputs:A,backend:V,attrs:$}=W,{image:ne,boxes:xe,boxInd:le}=A,{cropSize:ce,method:ue,extrapolationValue:Te}=$,Me=new sV(ne.shape,xe.shape,ce,ue,Te);return V.runWebGLProgram(Me,[ne,xe,le],"float32")},sP={kernelName:Cv,backendName:"webgl",kernelFunc:sb};class sE{constructor(A,V,$){this.variableNames=["x"],this.outputShape=[],this.outputShape=A,this.blockSize=V,this.dataFormat=$,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = `+this.getHeightCoordString()+`;
      int w = `+this.getWidthCoordString()+`;
      int d = `+this.getDepthCoordString()+`;

      int in_h = h / `+V+`;
      int offset_h = imod(h, `+V+`);
      int in_w = w / `+V+`;
      int offset_w = imod(w, `+V+`);
      int offset_d = (offset_h * `+V+` + offset_w) *
        `+this.getOutputDepthSize()+`;
      int in_d = d + offset_d;

      float result = `+this.getInputSamplingString()+`;
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function sD(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{blockSize:xe,dataFormat:le}=$,ce=ne.shape[0],ue=le==="NHWC"?ne.shape[1]:ne.shape[2],Te=le==="NHWC"?ne.shape[2]:ne.shape[3],Me=le==="NHWC"?ne.shape[3]:ne.shape[1],Re=ue*xe,we=Te*xe,ke=Me/(xe*xe),Ue=le==="NHWC"?[ce,Re,we,ke]:[ce,ke,Re,we],Ge=new sE(Ue,xe,le);return V.runWebGLProgram(Ge,[ne],ne.dtype)}const sg={kernelName:Cq,backendName:"webgl",kernelFunc:sD};class sZ{constructor(A,V=!1,$=null,ne=!1,xe=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=A.outShape,this.enableShapeUniforms=Dr(this.outputShape.length);const le=A.filterHeight,ce=A.filterWidth,ue=A.outChannels/A.inChannels;let Te="",Me="";$&&(ne?Te=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+$+`
        }`:xe?Te=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+$+`
        }`:Te=`
          float activation(float x) {
            `+$+`
          }
        `,Me="result = activation(result);");const Re=V?"result += getBiasAtOutCoords();":"";V&&this.variableNames.push("bias"),ne&&this.variableNames.push("preluActivationWeights"),xe&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+Te+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+ue+`;
        int q = d2 - d1 * `+ue+`;

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < `+le+`; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < `+ce+`; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        `+Re+`
        `+Me+`
        setOutput(result);
      }
    `}}class so{constructor(A,V=!1,$=null,ne=!1,xe=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=A.outShape,this.enableShapeUniforms=Dr(this.outputShape.length);const le=A.outChannels/A.inChannels,ce=A.padInfo.left,ue=A.strideWidth,Te=A.dilationWidth,Me=A.filterHeight,Re=A.filterWidth,we=Re;let ke=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let Xe=0;Xe<Re;Xe++)ke+=`
          vec4 xTexelC`+Xe*2+`;
          int xTexelC`+Xe*2+`Ready;
          vec4 xTexelC`+(Xe*2+1)+`;
          int xTexelC`+(Xe*2+1)+`Ready;
          vec4 xC`+Xe+";";ke+=`
    for (int r = 0; r < `+Me+`; r++) {
      `;for(let Xe=0;Xe<Re;Xe++)ke+=`
          xTexelC`+Xe*2+` = vec4(0.0);
          xTexelC`+Xe*2+`Ready = 0;
          xTexelC`+(Xe*2+1)+` = vec4(0.0);
          xTexelC`+(Xe*2+1)+`Ready = 0;
          xC`+Xe+" = vec4(0.0);";ke+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let Xe=0;Xe<(we+1)/2;Xe++){const Ye=Xe*2;if(ke+=`
          xC = xCCorner + `+Ye*Te+`;
          `,ue===1){if(Ye<Re&&(ce%2===1?(ke+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+Ye+`Ready == 0) {
                  xTexelC`+Ye+` = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+Ye+`.zw = vec2(0.0);
                  }
                  xTexelC`+Ye+`Ready = 1;
                }
              `,Te===1&&Ye>0?ke+=`
                xC`+Ye+" = vec4(xTexelC"+(Ye-2)+".zw, xTexelC"+Ye+`.xy);
                `:ke+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC`+Ye+" = vec4(previous.zw, xTexelC"+Ye+`.xy);
                  } else {
                    xC`+Ye+" = vec4(0.0, 0.0, xTexelC"+Ye+`.xy);
                  }
                  `):ke+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC`+Ye+`Ready == 0) {
                  xTexelC`+Ye+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+Ye+`.zw = vec2(0.0);
                  }
                  xTexelC`+Ye+`Ready = 1;
                }

                xC`+Ye+" = xTexelC"+Ye+`;
                `,Ye+1<Re)){const je=ce%2===0?B(Te):Te;Te%2===0&&ce%2===1||Te%2!==0&&ce%2!==1?(ke+=`
                  xCOffset = xC + imod(pads[1], 2) + `+je+`;

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Ye+1)+`Ready == 0) {
                    xTexelC`+(Ye+1)+` = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC`+(Ye+1)+`.zw = vec2(0.0);
                    }
                    xTexelC`+(Ye+1)+`Ready = 1;
                  }
                  `,Te>1?ke+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC`+(Ye+1)+" = vec4(previous.zw, xTexelC"+(Ye+1)+`.xy);
                    } else {
                     xC`+(Ye+1)+" = vec4(0.0, 0.0, xTexelC"+(Ye+1)+`.xy);
                    }
                    `:ke+=`
                    xC`+(Ye+1)+" = vec4(xTexelC"+Ye+".zw, xTexelC"+(Ye+1)+`.xy);
                    `):je===1?ke+=`
                    xC`+(Ye+1)+" = xTexelC"+Ye+`;
                    `:ke+=`
                    xCOffset = xC + `+je+`;

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Ye+1)+`Ready == 0) {
                      xTexelC`+(Ye+1)+` = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC`+(Ye+1)+`.zw = vec2(0.0);
                      }
                      xTexelC`+(Ye+1)+`Ready = 1;
                    }

                    xC`+(Ye+1)+" = xTexelC"+(Ye+1)+`;
                    `}}else Ye<Re&&(ce%2===1?(ke+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+Ye+`Ready == 0) {
                  xTexelC`+Ye+` = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+Ye+`.zw = vec2(0.0);
                  }
                  xTexelC`+Ye+`Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(Ye+1)+`Ready == 0) {
                  xTexelC`+(Ye+1)+` = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC`+(Ye+1)+`.zw = vec2(0.0);
                  }
                  xTexelC`+(Ye+1)+`Ready = 1;
                }

                xC`+Ye+" = vec4(xTexelC"+Ye+".zw, xTexelC"+(Ye+1)+`.zw);
              `,Ye+1<Re&&(ke+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC`+(Ye+1)+" = vec4(xTexelC"+(Ye+1)+`.xy, final.xy);
                `)):(ke+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC`+Ye+`Ready == 0) {
                  xTexelC`+Ye+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+Ye+`.zw = vec2(0.0);
                  }
                  xTexelC`+Ye+`Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Ye+1)+`Ready == 0) {
                  xTexelC`+(Ye+1)+` = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+(Ye+1)+`.zw = vec2(0.);
                  }
                  xTexelC`+(Ye+1)+`Ready = 1;
                }

                xC`+Ye+` = vec4(
                  xTexelC`+Ye+".xy, xTexelC"+(Ye+1)+`.xy);
              `,Ye+1<Re&&(ke+=`
                  xC`+(Ye+1)+" = vec4(xTexelC"+Ye+".zw, xTexelC"+(Ye+1)+`.zw);
                `)));Ye<Re&&(ke+=`
            wTexel = getW(r, `+Ye+`, d1, q);
            dotProd += xC`+Ye+` * vec4(wTexel.xz, wTexel.xz);
          `,Ye+1<Re&&(ke+=`
              wTexel = getW(r, `+(Ye+1)+`, d1, q);
              dotProd += xC`+(Ye+1)+` * vec4(wTexel.xz, wTexel.xz);
            `))}ke+=`
    }
  `,ke+=`
      }
    `;let Ue="",Ge="";$&&(ne?Ue=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+$+`
        }`:xe?Ue=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+$+`
        }`:Ue=`vec4 activation(vec4 x) {
          `+$+`
        }`,Ge="result = activation(result);");const We=V?"result += getBiasAtOutCoords();":"";V&&this.variableNames.push("bias"),ne&&this.variableNames.push("preluActivationWeights"),xe&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+Ue+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+le+`;
        int q = d2 - d1 * `+le+`;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        `+ke+`

        vec4 result = dotProd - vec4(0.000000000000001);
        `+We+`
        `+Ge+`
        setOutput(result);
      }
    `}}function se(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne,filter:xe}=A,{strides:le,pad:ce,dilations:ue,dimRoundingMode:Te}=$;let Me=ue;Me==null&&(Me=[1,1]),e(Oa(le,Me),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+le+" and dilations '"+Me+"'");const Re=OA(ne.shape,xe.shape,le,Me,ce,Te,!0);let we;Cd().getBool("WEBGL_PACK_DEPTHWISECONV")&&Re.strideWidth<=2&&Re.outChannels/Re.inChannels===1?we=new so(Re):we=new sZ(Re);const ke=[[Re.padInfo.top,Re.padInfo.left],[Re.strideHeight,Re.strideWidth],[Re.dilationHeight,Re.dilationWidth],[Re.inHeight,Re.inWidth]];return V.runWebGLProgram(we,[ne,xe],"float32",ke)}const sQ={kernelName:Cl,backendName:"webgl",kernelFunc:se};function ss(W){const{inputs:A,attrs:V,backend:$}=W,{dim:ne}=V,{input:xe}=A,le=xe.shape.length,ce=xe.shape.slice();let ue=ne;return ne<0&&(e(-(le+1)<=ne,()=>"Axis must be in the interval ["+-(le+1)+", "+le+"]"),ue=le+ne+1),ce.splice(ue,0,1),Qe({inputs:{x:xe},backend:$,attrs:{shape:ce}})}const sF={kernelName:Cz,backendName:"webgl",kernelFunc:ss};class sI{constructor(A,V){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=A,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function sy(W){const{backend:A,attrs:V}=W,{shape:$,value:ne}=V;let{dtype:xe}=V;if(xe=xe||C2(ne),xe==="string"){const le=x(xe,F($));return le.fill(ne),A.makeTensorInfo($,xe,le)}else{const le=new sI($,ne),ce=[[ne]];return A.runWebGLProgram(le,[],xe,ce)}}const sA={kernelName:Cx,backendName:"webgl",kernelFunc:sy},sp="return floor(x);",sw=Q4({opSnippet:sp,packedOpSnippet:sp,cpuKernelImpl:oF}),sX={kernelName:CG,backendName:"webgl",kernelFunc:sw};class sc{constructor(A){this.variableNames=["A"];const V=D2(),[$,ne]=A;this.outputShape=A,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+ne+".0, "+$+`.0);

        vec4 values = `+V.texture2D+`(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class sW{constructor(A){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const V=D2(),[$,ne]=A;this.outputShape=A,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(`+ne+".0, "+$+`.0);
            vec4 values = `+V.texture2D+`(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        `+V.output+` = result;
      }
    `}}const sR={kernelName:ml,backendName:"webgl",kernelFunc:sv};let sK,sT=Cd().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function sv(W){const{inputs:A,backend:V,attrs:$}=W;let{pixels:ne}=A;const{numChannels:xe}=$,le=typeof HTMLVideoElement<"u"&&ne instanceof HTMLVideoElement,ce=typeof HTMLImageElement<"u"&&ne instanceof HTMLImageElement,[ue,Te]=le?[ne.videoWidth,ne.videoHeight]:[ne.width,ne.height],Me=[Te,ue],Re=[Te,ue,xe];if(ce||le){const Ge=Cd().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(sK==null||Ge!==sT)&&(sT=Ge,sK=document.createElement("canvas").getContext("2d",{willReadFrequently:sT})),sK.canvas.width=ue,sK.canvas.height=Te,sK.drawImage(ne,0,0,ue,Te),ne=sK.canvas}const we=V.makeTensorInfo(Me,"int32");V.texData.get(we.dataId).usage=E6.PIXELS,V.gpgpu.uploadPixelDataToTexture(V.getTexture(we.dataId),ne);const ke=Cd().getBool("WEBGL_PACK")?new sW(Re):new sc(Re),Ue=V.runWebGLProgram(ke,[we],"int32");return V.disposeData(we.dataId),Ue}function sq(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne,filter:xe,bias:le,preluActivationWeights:ce}=A,{strides:ue,pad:Te,dataFormat:Me,dilations:Re,dimRoundingMode:we,activation:ke,leakyreluAlpha:Ue}=$,Ge=OL(Me),We=OA(ne.shape,xe.shape,ue,Re,Te,we,!1,Ge);let Xe;const Ye=[],je=le!=null,Ke=ce!=null,qe=ke==="leakyrelu",$e=()=>{const nt=[ne,xe],wt=(Kt,Ht)=>{if(Ht==="NCHW"&&Kt.shape.length===1&&Kt.shape[0]!==1){const pi=Qe({inputs:{x:Kt},backend:V,attrs:{shape:[Kt.shape[0],1,1]}});return Ye.push(pi),pi}return Kt};if(je&&nt.push(wt(le,Me)),Ke&&nt.push(wt(ce,Me)),qe){const Kt=V.makeTensorInfo([],"float32",Nn(Ue,"float32"));nt.push(Kt),Ye.push(Kt)}return nt};if(We.filterHeight===1&&We.filterWidth===1&&We.dilationHeight===1&&We.dilationWidth===1&&We.strideHeight===1&&We.strideWidth===1&&(We.padInfo.type==="SAME"||We.padInfo.type==="VALID"))Xe=s9({x:ne,filter:xe,convInfo:We,backend:V,bias:le,activation:ke,preluActivationWeights:ce,leakyreluAlpha:Ue});else if(We.strideWidth<=2&&Ge==="channelsLast"&&Cd().getBool("WEBGL_EXP_CONV")){const nt=ke?Q6(ke,!0):null,wt=new s6(We,je,nt,Ke,qe),Kt=[[We.padInfo.top,We.padInfo.left],[We.strideHeight,We.strideWidth],[We.dilationHeight,We.dilationWidth],[We.inHeight,We.inWidth]],Ht=$e();Xe=V.runWebGLProgram(wt,Ht,"float32",Kt)}else if(Cd().getBool("WEBGL_CONV_IM2COL"))Xe=sC({x:ne,filter:xe,convInfo:We,backend:V,bias:le,activation:ke,preluActivationWeights:ce,leakyreluAlpha:Ue});else{const nt=ke?Q6(ke,!1):null,wt=new s5(We,je,nt,Ke,qe),Kt=$e();Xe=V.runWebGLProgram(wt,Kt,"float32")}const vt=Qe({inputs:{x:Xe},backend:V,attrs:{shape:We.outShape}});return Ye.push(Xe),Ye.forEach(nt=>V.disposeIntermediateTensorInfo(nt)),vt}const sl={kernelName:mL,backendName:"webgl",kernelFunc:sq};function sa(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne,filter:xe,bias:le,preluActivationWeights:ce}=A,{strides:ue,pad:Te,dilations:Me,dimRoundingMode:Re,activation:we,leakyreluAlpha:ke}=$,Ue=[];let Ge=Me;Ge==null&&(Ge=[1,1]),e(Oa(ue,Ge),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+ue+" and dilations '"+Ge+"'");const We=OA(ne.shape,xe.shape,ue,Ge,Te,Re,!0),Xe=Cd().getBool("WEBGL_PACK_DEPTHWISECONV")&&We.strideWidth<=2&&We.outChannels/We.inChannels===1,Ye=we?Q6(we,Xe):null,je=[ne,xe],Ke=le!=null,qe=ce!=null,$e=we==="leakyrelu";if(Ke&&je.push(le),qe&&je.push(ce),$e){const Kt=V.makeTensorInfo([],"float32",Nn(ke,"float32"));je.push(Kt),Ue.push(Kt)}let vt;Xe?vt=new so(We,Ke,Ye,qe,$e):vt=new sZ(We,Ke,Ye,qe,$e);const nt=[[We.padInfo.top,We.padInfo.left],[We.strideHeight,We.strideWidth],[We.dilationHeight,We.dilationWidth],[We.inHeight,We.inWidth]],wt=V.runWebGLProgram(vt,je,"float32",nt);return Ue.forEach(Kt=>V.disposeIntermediateTensorInfo(Kt)),wt}const sn={kernelName:mH,backendName:"webgl",kernelFunc:sa};class sL{constructor(A,V){this.variableNames=["A","indices"],this.outputShape=V,this.rank=V.length;const $=Dz(this.rank),ne=sH(A);this.userCode=`
      void main() {
        `+$+` resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < `+A[2]+`) ? 1.0 : 0.0;
        setOutput(inBounds * getA(`+ne+`));
      }
    `}}function sH(W,A){const V=["resRC.x","resRC.y","resRC.z","resRC.w"],$=[];for(let ne=0;ne<W.length;ne++)ne===2?$.push("index"):$.push(""+V[ne]);return $.join()}function sk(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne,indices:xe}=A,{axis:le,batchDims:ce}=$,ue=n(le,ne.shape)[0];if(Cd().get("DEBUG")){const Ye=V.readSync(xe.dataId),je=ne.shape[ue];for(let Ke=0;Ke<Ye.length;++Ke){const qe=Ye[Ke];e(qe<=je-1&&qe>=0,()=>"GatherV2: the index value "+qe+" is not in [0, "+(je-1)+"]")}}const Te=VZ(ne,xe,ue,ce),Me=F(xe.shape),Re=[],we=Qe({inputs:{x:ne},backend:V,attrs:{shape:[Te.batchSize,Te.outerSize,Te.dimSize,Te.sliceSize]}}),ke=Qe({inputs:{x:xe},backend:V,attrs:{shape:[Te.batchSize,Me/Te.batchSize]}});Re.push(we),Re.push(ke);const Ue=[Te.batchSize,Te.outerSize,Me/Te.batchSize,Te.sliceSize];if(V.shouldExecuteOnCPU([ne,xe])||ne.dtype==="string"){const Ye=V.bufferSync(ke),je=V.bufferSync(we),Ke=oy(je,Ye,Ue);return Re.forEach(qe=>V.disposeIntermediateTensorInfo(qe)),V.makeTensorInfo(Te.outputShape,Ke.dtype,Ke.values)}const Ge=new sL(we.shape,Ue),We=V.runWebGLProgram(Ge,[we,ke],we.dtype);Re.push(We);const Xe=Qe({inputs:{x:We},backend:V,attrs:{shape:Te.outputShape}});return Re.forEach(Ye=>V.disposeIntermediateTensorInfo(Ye)),Xe}const sz={kernelName:CY,backendName:"webgl",kernelFunc:sk},sx="return float(a >= b);",sU=`
  return vec4(greaterThanEqual(a, b));
`,sG=Q5({opSnippet:sx,packedOpSnippet:sU,dtype:"bool",cpuKernelImpl:ow}),su={kernelName:Ch,backendName:"webgl",kernelFunc:sG},sY="return float(a < b);",sM=`
  return vec4(lessThan(a, b));
`,sh=Q5({opSnippet:sY,packedOpSnippet:sM,cpuKernelImpl:oX,dtype:"bool"}),sj={kernelName:m1,backendName:"webgl",kernelFunc:sh},F0="return float(a <= b);",F1=`
  return vec4(lessThanEqual(a, b));
`,F2=Q5({opSnippet:F0,packedOpSnippet:F1,cpuKernelImpl:oc,dtype:"bool"}),F3={kernelName:m2,backendName:"webgl",kernelFunc:F2},F4="return float(a >= 1.0 && b >= 1.0);",F5=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,F6=Q5({opSnippet:F4,packedOpSnippet:F5,dtype:"bool"}),F7={kernelName:m3,backendName:"webgl",kernelFunc:F6},F8="return float(a >= 1.0 || b >= 1.0);",F9=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,FC=Q5({opSnippet:F8,packedOpSnippet:F9,dtype:"bool"}),Fm={kernelName:m4,backendName:"webgl",kernelFunc:FC};function FN(W,A,V,$){const ne=F(A),xe=F(W.shape)/ne,le=Qe({inputs:{x:W},attrs:{shape:[xe,ne]},backend:$}),ce=Qy(le,W.dtype,"max",$),ue=Qe({inputs:{x:ce},attrs:{shape:V},backend:$});return $.disposeIntermediateTensorInfo(le),$.disposeIntermediateTensorInfo(ce),ue}function FJ(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{reductionIndices:xe,keepDims:le}=$,ce=ne.shape.length,ue=n(xe,ne.shape);let Te=ue;const Me=tW(Te,ce),Re=Me!=null,we=V.shouldExecuteOnCPU([ne]);let ke=ne;if(Re){if(we){const Ye=V.texData.get(ke.dataId).values,je=new Array(ce);for(let $e=0;$e<je.length;$e++)je[$e]=ne.shape[Me[$e]];const Ke=e8(Ye,ne.shape,ne.dtype,Me,je);ke=V.makeTensorInfo(je,ne.dtype);const qe=V.texData.get(ke.dataId);qe.values=Ke}else ke=QX(ne,Me,V);Te=tK(Te.length,ce)}tc("max",Te,ce);const[Ue,Ge]=tw(ke.shape,Te);let We=Ue;le&&(We=tX(Ue,ue));let Xe;if(we){const Ye=V.texData.get(ke.dataId).values,je=oK(Ye,F(Ge),We,ne.dtype);Xe=V.makeTensorInfo(We,ne.dtype);const Ke=V.texData.get(Xe.dataId);Ke.values=je}else Xe=FN(ke,Ge,We,V);return Re&&V.disposeIntermediateTensorInfo(ke),Xe}const Ff={kernelName:m5,backendName:"webgl",kernelFunc:FJ};function Fi(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A;D0(ne,"maxPool");const{filterSize:xe,strides:le,pad:ce,dimRoundingMode:ue}=$,Te=1;e(Oa(le,Te),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+le+" and dilations '"+Te+"'");const Me=OI(ne.shape,xe,le,Te,ce,ue);if(Me.filterWidth===1&&Me.filterHeight===1&&X(Me.inShape,Me.outShape))return eu({inputs:{x:ne},backend:V});const Re=new QS(Me,"max",!1);return V.runWebGLProgram(Re,[ne],ne.dtype)}const FO={kernelName:m7,backendName:"webgl",kernelFunc:Fi},Ft=ez+`
  return max(a, b);
`,FB=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+eU+`
  return result;
`,FS=Q5({opSnippet:Ft,packedOpSnippet:FB,cpuKernelImpl:oT}),Fd={kernelName:m6,backendName:"webgl",kernelFunc:FS};function FV(W,A,V,$){const ne=F(A),xe=F(W.shape)/ne,le=Qe({inputs:{x:W},attrs:{shape:[xe,ne]},backend:$}),ce=Qy(le,"float32","mean",$),ue=Qe({inputs:{x:ce},attrs:{shape:V},backend:$});return $.disposeIntermediateTensorInfo(le),$.disposeIntermediateTensorInfo(ce),ue}const Fb={kernelName:m8,backendName:"webgl",kernelFunc:({inputs:W,attrs:A,backend:V})=>{const{x:$}=W,{keepDims:ne,axis:xe}=A,le=V,ce=$.shape.length,ue=n(xe,$.shape);let Te=ue;const Me=tW(Te,ce),Re=Me!=null,we=le.shouldExecuteOnCPU([$]),ke=[];let Ue=$;if(Re){if(we){const je=le.texData.get(Ue.dataId).values,Ke=new Array(ce);for(let vt=0;vt<Ke.length;vt++)Ke[vt]=$.shape[Me[vt]];const qe=e8(je,$.shape,$.dtype,Me,Ke);Ue=le.makeTensorInfo(Ke,$.dtype);const $e=le.texData.get(Ue.dataId);$e.values=qe}else Ue=QX($,Me,le);ke.push(Ue),Te=tK(Te.length,ce)}tc("sum",Te,ce);const[Ge,We]=tw(Ue.shape,Te);let Xe=Ge;ne&&(Xe=tX(Ge,ue));const Ye=FV(Ue,We,Xe,le);for(const je of ke)le.disposeIntermediateTensorInfo(je);return Ye}};function FP(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{axis:xe,keepDims:le}=$,ce=ne.shape.length,ue=n(xe,ne.shape);let Te=ue;const Me=tW(Te,ce);let Re=ne;Me!=null&&(Re=QK({inputs:{x:ne},backend:V,attrs:{perm:Me}}),Te=tK(Te.length,ne.shape.length)),tc("min",Te,ce);const[we,ke]=tw(Re.shape,Te),Ue=F(ke),Ge=Qe({inputs:{x:Re},backend:V,attrs:{shape:[-1,Ue]}}),We=Qy(Ge,Ge.dtype,"min",V);let Xe;if(le){const Ye=tX(we,ue);Xe=Qe({inputs:{x:We},backend:V,attrs:{shape:Ye}})}else Xe=Qe({inputs:{x:We},backend:V,attrs:{shape:we}});return V.disposeIntermediateTensorInfo(Ge),V.disposeIntermediateTensorInfo(We),Me!=null&&V.disposeIntermediateTensorInfo(Re),Xe}const FE={kernelName:m9,backendName:"webgl",kernelFunc:FP},FD=ez+`
  return min(a, b);
`,Fg=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+eU+`
  return result;
`,FZ=Q5({opSnippet:FD,packedOpSnippet:Fg,cpuKernelImpl:ov}),Fo={kernelName:mC,backendName:"webgl",kernelFunc:FZ},Fe=eE+`
  return -x;
`,FQ=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Fs(W){const{inputs:A,backend:V}=W,{x:$}=A;if(V.shouldExecuteOnCPU([$])){const xe=V.texData.get($.dataId),[le,ce]=ol(xe.values,$.shape,$.dtype);return V.makeTensorInfo(ce,$.dtype,le)}let ne;return Cd().getBool("WEBGL_PACK_UNARY_OPERATIONS")?ne=new ew($.shape,FQ):ne=new eP($.shape,Fe),V.runWebGLProgram(ne,[$],$.dtype)}const FF={kernelName:mN,backendName:"webgl",kernelFunc:Fs};function FI(W){const{inputs:A,backend:V,attrs:$}=W,{axis:ne}=$;if(A.length===1)return ss({inputs:{input:A[0]},backend:V,attrs:{dim:ne}});const xe=A[0].shape,le=A[0].dtype;A.forEach(Me=>{Q(xe,Me.shape,"All tensors passed to stack must have matching shapes"),e(le===Me.dtype,()=>"All tensors passed to stack must have matching dtypes")});const ce=[],ue=A.map(Me=>{const Re=ss({inputs:{input:Me},backend:V,attrs:{dim:ne}});return ce.push(Re),Re}),Te=s3({inputs:ue,backend:V,attrs:{axis:ne}});return ce.forEach(Me=>V.disposeIntermediateTensorInfo(Me)),Te}const Fy={kernelName:mO,backendName:"webgl",kernelFunc:FI};class FA{constructor(A,V,$){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=V.map((Te,Me)=>Te[0]+A[Me]+Te[1]);const ne=A.length,xe=Dz(ne),le=V.map(Te=>Te[0]).join(","),ce=V.map((Te,Me)=>Te[0]+A[Me]).join(","),ue=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,ne);if(ne===1){this.userCode=`
        int start = `+le+`;
        int end = `+ce+`;

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      `+xe+" start = "+xe+"("+le+`);
      `+xe+" end = "+xe+"("+ce+`);

      void main() {
        `+xe+` outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          `+xe+` coords = outC - start;
          setOutput(getX(`+ue+`));
        }
      }
    `}}class Fp{constructor(A,V,$){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=V.map((Ge,We)=>Ge[0]+A[We]+Ge[1]);const ne=A.length,xe=Dz(ne),le=V.map(Ge=>Ge[0]).join(","),ce=V.map((Ge,We)=>Ge[0]+A[We]).join(","),ue=em("rc",ne),Te=em("source",ne),Me=ue[ne-1]+" < "+this.outputShape[ne-1],Re=ne===1?"source":"vec2("+Te.slice(-2).join()+")",we=[xe+" rc = outputLoc;",ue[ne-1]+` += 1;
       if(`+Me+`) {
      `,ne===1?"":`}
       rc = outputLoc;
       `+ue[ne-2]+` += 1;
       if(`+ue[ne-2]+" < "+this.outputShape[ne-2]+") {",ne===1?"":"  "+ue[ne-1]+` += 1;
         if(`+Me+") {"],ke=ne===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let Ue="";for(let Ge=0,We=ne===1?2:4;Ge<We;Ge++)Ue+=`
        `+we[Ge]+`
        if (`+ke+`) {
          result[`+Ge+`] = float(value);
        } else {
          `+xe+` source = rc - start;
          result[`+Ge+"] = getChannel(getX("+Te.join()+"), "+Re+`);
        }
      `;Ue+=ne===1?"} ":"}}",this.userCode=`
      const `+xe+" start = "+xe+"("+le+`);
      const `+xe+" end = "+xe+"("+ce+`);

      void main() {
        `+xe+` outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        `+Ue+`
        setOutput(result);
      }
    `}}const Fw=W=>{const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{paddings:xe,constantValue:le}=$;if(F(ne.shape)===0){const Te=xe.map((Me,Re)=>Me[0]+ne.shape[Re]+Me[1]);return sy({backend:V,attrs:{shape:Te,value:le,dtype:ne.dtype}})}const ce=Cd().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Fp(ne.shape,xe,le):new FA(ne.shape,xe,le),ue=[[le]];return V.runWebGLProgram(ce,[ne],ne.dtype,ue)},FX={kernelName:mt,backendName:"webgl",kernelFunc:Fw},Fc=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,FW=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+eU+`
  return result;
`,FR=Q5({opSnippet:Fc,packedOpSnippet:FW}),FK={kernelName:mB,backendName:"webgl",kernelFunc:FR},FT=W=>{const{backend:A,attrs:V}=W,{start:$,stop:ne,step:xe,dtype:le}=V,ce=oz($,ne,xe,le);return A.makeTensorInfo([ce.length],le,ce)},Fv={kernelName:md,backendName:"webgl",kernelFunc:FT},Fq=`
if (a == b) {
  return 1.0;
};
return a / b;`,Fl=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Fa=Q5({opSnippet:Fq,packedOpSnippet:Fl,checkOutOfBounds:!0}),Fn={kernelName:CL,backendName:"webgl",kernelFunc:Fa},FL=eE+`
  return (x < 0.0) ? 0.0 : x;
`,FH=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Fk=Q4({opSnippet:FL,packedOpSnippet:FH}),Fz={kernelName:mb,backendName:"webgl",kernelFunc:Fk},Fx=eE+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,FU=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,FG=Q4({opSnippet:Fx,packedOpSnippet:FU}),Fu={kernelName:mg,backendName:"webgl",kernelFunc:FG};class FY{constructor(A,V,$,ne,xe){this.variableNames=["A"],this.outputShape=[];const[le,ce,ue,Te]=A;this.outputShape=[le,V,$,Te];const Me=[ne&&V>1?ce-1:ce,ne&&$>1?ue-1:ue],Re=[ne&&V>1?V-1:V,ne&&$>1?$-1:$];let we;xe?we="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":we="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          `+Me[0]/Re[0]+`,
          `+Me[1]/Re[1]+`);
      const vec2 inputShapeRC = vec2(`+ce+".0, "+ue+`.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = `+we+`;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class FM{constructor(A,V,$,ne,xe){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[le,ce,ue,Te]=A;this.outputShape=[le,V,$,Te];const Me=[ne&&V>1?ce-1:ce,ne&&$>1?ue-1:ue],Re=[ne&&V>1?V-1:V,ne&&$>1?$-1:$];let we;xe?we="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":we="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          `+Me[0]/Re[0]+`,
          `+Me[1]/Re[1]+`,
          `+Me[1]/Re[1]+`);
      const vec3 inputShapeRC = vec3(`+ce+".0, "+ue+`.0,
                                     `+ue+`.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = `+we+`;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < `+(Te-1)+`;
        bool hasNextRow = coords.z < `+($-1)+`;

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function Fh(W){const{inputs:A,backend:V,attrs:$}=W,{images:ne}=A,{alignCorners:xe,halfPixelCenters:le,size:ce}=$,[ue,Te]=ce,Me=Cd().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new FM(ne.shape,ue,Te,xe,le):new FY(ne.shape,ue,Te,xe,le);return V.runWebGLProgram(Me,[ne],"float32")}const Fj={kernelName:mD,backendName:"webgl",kernelFunc:Fh};class Fr{constructor(A,V){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const $=A[1],ne=A[2];this.outputShape=A;let xe="";typeof V=="number"?xe="float outputValue = "+V.toFixed(2)+";":xe=`
        vec3 fill = vec3(`+V.join(",")+`);
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          `+xe+`
          if(coordX >= 0 && coordX < `+ne+" && coordY >= 0 && coordY < "+$+`) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const I0={kernelName:ma,backendName:"webgl",kernelFunc:({inputs:W,attrs:A,backend:V})=>{const{image:$}=W,{radians:ne,fillValue:xe,center:le}=A,ce=V,ue=new Fr($.shape,xe),[Te,Me]=dK(le,$.shape[1],$.shape[2]),Re=[[Te,Me,Math.sin(ne),Math.cos(ne)]];return ce.runWebGLProgram(ue,[$],$.dtype,Re)}},I1=Q3+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,I2=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,I3=Q4({opSnippet:I1,packedOpSnippet:I2,cpuKernelImpl:oG}),I4={kernelName:mF,backendName:"webgl",kernelFunc:I3},I5=Q3+`
  return sin(x);
`,I6=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  `+eU+`
  return result;
`,I7=Q4({opSnippet:I5,packedOpSnippet:I6}),I8={kernelName:ms,backendName:"webgl",kernelFunc:I7};class I9{constructor(A){this.variableNames=["source"],this.outputShape=A,this.rank=A.length;const V=Dz(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const $=Im(this.rank);let ne;const xe=A.map((le,ce)=>"sourceLoc."+IC[ce]+" = start["+ce+"] + coords."+IC[ce]+";");ne=`
        `+V+` sourceLoc;
        `+V+` coords = getOutputCoords();
        `+xe.join(`
`)+`
      `,this.userCode=`
      void main() {
        `+ne+`
        setOutput(getSource(`+$+`));
      }
    `}}const IC=["x","y","z","w","u","v"];function Im(W){if(W===1)return"sourceLoc";if(W<=6)return IC.slice(0,W).map(A=>"sourceLoc."+A).join(",");throw Error("Slicing for rank "+W+" is not yet supported")}class IN{constructor(A){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=A,this.rank=A.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const V=Dz(this.rank),$=em("coords",this.rank),ne=em("sourceLoc",this.rank),xe=this.rank===1?"sourceLoc":"vec2("+ne.slice(-2).join()+")",le="getChannel(getSource("+ne.join()+"), "+xe+")",ce=`
      result.x = `+le+`;
      if (++`+$[this.rank-1]+" < "+A[this.rank-1]+`) {
        ++`+ne[this.rank-1]+`;
        result.y = `+le+`;
        --`+ne[this.rank-1]+`;
      }
    `,ue=this.rank===1?"":`
      --`+$[this.rank-1]+`;
      if (++`+$[this.rank-2]+" < "+A[this.rank-2]+`) {
        ++`+ne[this.rank-2]+`;
        result.z = `+le+`;
        if (++`+$[this.rank-1]+" < "+A[this.rank-1]+`) {
          ++`+ne[this.rank-1]+`;
          result.w = `+le+`;
        }
      }
    `,Te=this.rank<=4?`sourceLoc = coords +
            `+V+"("+A.map((Me,Re)=>"start["+Re+"]").join()+");":A.map((Me,Re)=>ne[Re]+" = "+$[Re]+" + start["+Re+"];").join(`
`);this.userCode=`
      void main() {
        `+V+` coords = getOutputCoords();
        `+V+` sourceLoc;
        `+Te+`
        vec4 result = vec4(0.);
        `+ce+`
        `+ue+`
        setOutput(result);
      }
    `}}function IJ(W,A,V,$){const ne=$.texData.get(W.dataId),xe=$.makeTensorInfo(V,W.dtype),le=$.texData.get(xe.dataId);Object.assign(le,ne),le.refCount=1,le.shape=V,le.dtype=W.dtype;let ce=ON(A,C5(W.shape));ne.slice&&(ce+=ne.slice.flatOffset),le.slice={flatOffset:ce,origDataId:ne.slice&&ne.slice.origDataId||W.dataId};const ue=$.dataRefCount.get(le.slice.origDataId)||1;return $.dataRefCount.set(le.slice.origDataId,ue+1),xe}function If(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{begin:xe,size:le}=$,[ce,ue]=OJ(ne,xe,le);if(ir(ne,ce,ue),F(ue)===0)return V.makeTensorInfo(ue,ne.dtype,[]);if(V.shouldExecuteOnCPU([ne])||ne.dtype==="string"){const Re=V.texData.get(ne.dataId),we=oY(Re.values,ce,ue,ne.shape,ne.dtype);return V.makeTensorInfo(ue,ne.dtype,we)}const{isPacked:Te}=V.texData.get(ne.dataId),Me=Om(ne.shape,ce,ue);if(Te||!Me){const Re=Cd().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new IN(ue):new I9(ue),we=[ce];return V.runWebGLProgram(Re,[ne],ne.dtype,we)}return V.uploadToGPU(ne.dataId),IJ(ne,ce,ue,V)}const Ii={kernelName:mQ,backendName:"webgl",kernelFunc:If},IO="return sqrt(x);",It=Q4({opSnippet:IO,packedOpSnippet:IO,cpuKernelImpl:or}),IB={kernelName:mI,backendName:"webgl",kernelFunc:It},IS="return x * x;",Id=Q4({opSnippet:IS}),IV={kernelName:mw,backendName:"webgl",kernelFunc:Id};class Ib{constructor(A,V,$){this.variableNames=["x"],this.outputShape=$;const ne=$.length,xe=Dz($.length),le=Dz($.length);let ce="";if(ne===1)ce="coords * strides + begin";else{let ue=0;ce=$.map((Te,Me)=>(ue++,$.length===1?"coords * strides["+Me+"] + begin["+Me+"]":"coords["+(ue-1)+"] * strides["+Me+"] + begin["+Me+"]")).join(",")}this.userCode=`
      `+xe+" begin = "+xe+"("+A+`);
      `+xe+" strides = "+xe+"("+V+`);

      void main() {
        `+le+` coords = getOutputCoords();
        setOutput(getX(`+ce+`));
      }
    `}}function IP(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{begin:xe,end:le,strides:ce,beginMask:ue,endMask:Te,ellipsisMask:Me,newAxisMask:Re,shrinkAxisMask:we}=$,{finalShapeSparse:ke,finalShape:Ue,isIdentity:Ge,sliceDim0:We,isSimpleSlice:Xe,begin:Ye,end:je,strides:Ke}=Of(ne.shape,xe,le,ce,ue,Te,Me,Re,we);let qe;if(Ge)qe=Qe({inputs:{x:ne},backend:V,attrs:{shape:Ue}});else if(We||Xe){e(ne.shape.length>=1,()=>"Input must have rank at least 1, got: "+ne.shape.length);const vt=O1(Ye,je,Ke),nt=If({inputs:{x:ne},backend:V,attrs:{begin:Ye,size:vt}});qe=Qe({inputs:{x:nt},backend:V,attrs:{shape:Ue}}),V.disposeIntermediateTensorInfo(nt)}else if(V.shouldExecuteOnCPU([ne])){const vt=V.readSync(ne.dataId),nt=t7(ne.shape,ne.dtype,vt),wt=e1(ke,nt,Ke,Ye);qe=V.makeTensorInfo(Ue,ne.dtype,wt.values)}else{const vt=new Ib(Ye,Ke,ke);qe=V.runWebGLProgram(vt,[ne],ne.dtype)}const $e=Qe({inputs:{x:qe},backend:V,attrs:{shape:Ue}});return V.disposeIntermediateTensorInfo(qe),$e}const IE={kernelName:mX,backendName:"webgl",kernelFunc:IP},ID="return a - b;",Ig=Q5({opSnippet:ID,packedOpSnippet:ID,supportsComplex:!0,cpuKernelImpl:e5}),IZ={kernelName:mc,backendName:"webgl",kernelFunc:Ig};class Io{constructor(A,V){this.variableNames=["A"];const $=new Array(A.length);for(let le=0;le<$.length;le++)$[le]=A[le]*V[le];this.outputShape=$,this.rank=$.length;const ne=Dz(this.rank),xe=Ie(A);this.userCode=`
      void main() {
        `+ne+` resRC = getOutputCoords();
        setOutput(getA(`+xe+`));
      }
    `}}function Ie(W){const A=W.length;if(A>5)throw Error("Tile for rank "+A+" is not yet supported");if(A===1)return"imod(resRC, "+W[0]+")";const V=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],$=[];for(let ne=0;ne<W.length;ne++)$.push("imod("+V[ne]+", "+W[ne]+")");return $.join()}function IQ(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{reps:xe}=$;if(ne.dtype==="string"||ne.shape.length>5){const ce=V.readSync(ne.dataId),ue=ne.dtype==="string"?ce.map(Re=>Nx(Re)):ce,Te=t7(ne.shape,ne.dtype,ue),Me=e6(Te,xe);return V.makeTensorInfo(Me.shape,Me.dtype,Me.values)}const le=new Io(ne.shape,xe);return V.runWebGLProgram(le,[ne],ne.dtype)}const Is={kernelName:mW,backendName:"webgl",kernelFunc:IQ};class IF{constructor(A,V,$,ne,xe,le){this.variableNames=["Image","Transforms"],this.outputShape=le;const ce=$==="nearest"?1:2;let ue;switch(ne){case"constant":ue=1;break;case"reflect":ue=2;break;case"wrap":ue=3;break;case"nearest":ue=4;break;default:ue=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(`+ue+` == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+ue+` == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+ue+` == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < `+A+" && 0 <= coordX && coordX < "+V+`) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(`+xe+`);
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(`+xe+`);
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(`+V+`));
                float mapY = mapCoord(inY, float(`+A+`));

                if (`+ce+` == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function II(W){const{inputs:A,backend:V,attrs:$}=W,{image:ne,transforms:xe}=A,{interpolation:le,fillMode:ce,fillValue:ue,outputShape:Te}=$,[Me,Re,we,ke]=ne.shape,[Ue,Ge]=Te??[Re,we],We=[Me,Ue,Ge,ke],Xe=new IF(Re,we,le,ce,ue,We);return V.runWebGLProgram(Xe,[ne,xe],"float32")}const Iy={kernelName:mR,backendName:"webgl",kernelFunc:II};function IA(W){const{inputs:A,backend:V}=W,{x:$}=A;if($.dtype==="complex64"){const ne=QH({inputs:{input:$},backend:V}),xe=IA({inputs:{x:ne},backend:V}),le=s0({inputs:{input:$},backend:V}),ce=IA({inputs:{x:le},backend:V}),ue=eM({inputs:{real:xe,imag:ce},backend:V});return V.disposeIntermediateTensorInfo(ne),V.disposeIntermediateTensorInfo(xe),V.disposeIntermediateTensorInfo(le),V.disposeIntermediateTensorInfo(ce),ue}else return sy({attrs:{shape:$.shape,dtype:$.dtype,value:$.dtype==="string"?"":0},backend:V})}const Ip={kernelName:mv,backendName:"webgl",kernelFunc:IA};function Iw(W){const{inputs:A,backend:V,attrs:$}=W,{a:ne,b:xe,bias:le,preluActivationWeights:ce}=A,{transposeA:ue,transposeB:Te,activation:Me,leakyreluAlpha:Re}=$;return Qq({a:ne,b:xe,transposeA:ue,transposeB:Te,backend:V,bias:le,preluActivationWeights:ce,leakyreluAlpha:Re,activation:Me})}const IX={kernelName:mn,backendName:"webgl",kernelFunc:Iw},Ic=SQ;class IW extends i{nextDataId(){return IW.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new f(this,Ju())}write(A,V,$){this.firstUse&&(this.firstUse=!1,Cd().get("IS_NODE")&&mk(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const ne={id:this.nextDataId()};return this.data.set(ne,{values:A,dtype:$,refCount:1}),ne}makeTensorInfo(A,V,$){let ne;if(V==="string"&&$!=null&&$.length>0&&j($[0])){const xe=$.map(le=>Nz(le));ne=this.write(xe,A,V)}else ne=this.write($,A,V);return{dataId:ne,shape:A,dtype:V}}refCount(A){return this.data.has(A)?this.data.get(A).refCount:0}incRef(A){const V=this.data.get(A);V.refCount++}decRef(A){if(this.data.has(A)){const V=this.data.get(A);V.refCount--}}move(A,V,$,ne,xe){this.data.set(A,{values:V,dtype:ne,refCount:xe})}numDataIds(){return this.data.numDataIds()}async read(A){return this.readSync(A)}readSync(A){const{dtype:V,complexTensorInfos:$}=this.data.get(A);if(V==="complex64"){const ne=this.readSync($.real.dataId),xe=this.readSync($.imag.dataId);return du(ne,xe)}return C8(this.data.get(A).values,V)}bufferSync(A){const V=this.readSync(A.dataId);if(A.dtype==="string")try{const $=V.map(ne=>Nx(ne));return t7(A.shape,A.dtype,$)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return t7(A.shape,A.dtype,V)}makeOutput(A,V,$){return Ju().makeTensorFromTensorInfo(this.makeTensorInfo(V,$,A),this)}disposeData(A,V=!1){if(this.data.has(A)){if(this.data.get(A).refCount--,!V&&this.data.get(A).refCount>0)return!1;const{complexTensorInfos:$}=this.data.get(A);$!=null&&(this.disposeData($.real.dataId,!0),this.disposeData($.imag.dataId,!0)),this.data.delete(A)}return!0}disposeIntermediateTensorInfo(A){this.disposeData(A.dataId)}async time(A){const V=Nk();return A(),{kernelMs:Nk()-V}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(A){gs([A],"where");const V=this.readSync(A.dataId);return Ic(A.shape,V)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}IW.nextDataId=0,f0("cpu",()=>new IW,1);function IR(W){const{inputs:A,backend:V}=W,$=A;gs(A,"addN");const ne=$.map(ce=>V.data.get(ce.dataId).values),xe=t7($[0].shape,$[0].dtype),le=xe.values;for(let ce=0;ce<$.length;ce++){const ue=ne[ce];for(let Te=0;Te<le.length;Te++)le[Te]+=ue[Te]}return V.makeTensorInfo(xe.shape,xe.dtype,xe.values)}const IK={kernelName:Ce,backendName:"cpu",kernelFunc:IR},IT=gA((W,A)=>Math.atan2(W,A)),Iv=gv(CQ,IT),Iq={kernelName:CQ,backendName:"cpu",kernelFunc:Iv};function Il(W,A,V,$,ne,xe){const le=ne.strideHeight,ce=ne.strideWidth,ue=ne.dilationHeight,Te=ne.dilationWidth,Me=ne.effectiveFilterHeight,Re=ne.effectiveFilterWidth,we=ne.padInfo.top,ke=ne.padInfo.left,Ue=xe==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,Ge=t7(ne.outShape,V),We=Ge.values,Xe=ne.outShape[1]*ne.outShape[2]*ne.outShape[3],Ye=ne.outShape[2]*ne.outShape[3],je=ne.outShape[3];for(let Ke=0;Ke<ne.batchSize;++Ke){const qe=Ke*Xe,$e=Ke*$[0];for(let vt=0;vt<ne.inChannels;++vt)for(let nt=0;nt<ne.outHeight;++nt){const wt=nt*le-we,Kt=Math.max(0,wt),Ht=Math.min(ne.inHeight,Me+wt),pi=qe+nt*Ye;for(let hi=0;hi<ne.outWidth;++hi){const ai=hi*ce-ke,Yi=Math.max(0,ai),Wi=Math.min(ne.inWidth,Re+ai);let ls=Ue,Hi=0,rs=0;for(let Hs=Kt;Hs<Ht;Hs+=ue){const qi=$e+Hs*$[1];for(let as=Yi;as<Wi;as+=Te){const li=qi+as*$[2],vi=W[li+vt];xe==="max"&&vi>ls?ls=vi:xe==="avg"&&(Hi+=vi,rs++)}if(isNaN(ls))break}const Us=pi+hi*je+vt;We[Us]=xe==="avg"?Hi/rs:ls}}}return Ge}function Ia(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A;gs(ne,"avgPool");const{filterSize:xe,strides:le,pad:ce,dimRoundingMode:ue}=$,Te=1;e(Oa(le,Te),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+le+" and dilations '"+Te+"'");const Me=OI(ne.shape,xe,le,Te,ce,ue);let Re;if(Me.filterWidth===1&&Me.filterHeight===1&&X(Me.inShape,Me.outShape))Re=gX({inputs:{x:ne},backend:V});else{const we=V.data.get(ne.dataId).values,ke=C5(ne.shape),Ue=Il(we,ne.shape,ne.dtype,ke,Me,"avg");Re=V.makeTensorInfo(Me.outShape,ne.dtype,Ue.values)}return Re}const In={kernelName:Cs,backendName:"cpu",kernelFunc:Ia};function IL(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{shape:xe}=$,le=F(ne.shape),ce=l(xe,le),ue=F(ce);e(le===ue,()=>"The new shape ("+ce+") has "+ue+" elements and the old shape ("+ne.shape+") has "+le+" elements. The new shape and old shape must have the same number of elements."),V.incRef(ne.dataId);const Te=V.data.get(ne.dataId);if(Te.complexTensorInfos!=null){const Me=Te.complexTensorInfos.real,Re=Te.complexTensorInfos.imag;Me.shape=ce,Re.shape=ce}return{dataId:ne.dataId,shape:ce,dtype:ne.dtype}}const IH={kernelName:mP,backendName:"cpu",kernelFunc:IL};function Ik(W){const{inputs:A,backend:V,attrs:$}=W,{a:ne,b:xe}=A,{transposeA:le,transposeB:ce}=$;gs([ne,xe],"matMul");const ue=ne.shape.length,Te=xe.shape.length,Me=le?ne.shape[ue-2]:ne.shape[ue-1],Re=ce?xe.shape[Te-1]:xe.shape[Te-2],we=le?ne.shape[ue-1]:ne.shape[ue-2],ke=ce?xe.shape[Te-2]:xe.shape[Te-1],Ue=ne.shape.slice(0,-2),Ge=xe.shape.slice(0,-2),We=F(Ue),Xe=F(Ge),Ye=iH(ne.shape.slice(0,-2),xe.shape.slice(0,-2)).concat([we,ke]);e(Me===Re,()=>"Error in matMul: inner shapes ("+Me+") and ("+Re+") of Tensors with shapes "+ne.shape+" and "+xe.shape+" and transposeA="+le+" and transposeB="+ce+" must match.");const je=le?[We,Me,we]:[We,we,Me],Ke=ce?[Xe,ke,Re]:[Xe,Re,ke],qe=IL({inputs:{x:ne},backend:V,attrs:{shape:je}}),$e=IL({inputs:{x:xe},backend:V,attrs:{shape:Ke}}),vt=le?qe.shape[1]:qe.shape[2],nt=le?qe.shape[2]:qe.shape[1],wt=ce?$e.shape[1]:$e.shape[2],Kt=Math.max(We,Xe),Ht=V.data.get(qe.dataId).values,pi=V.data.get($e.dataId).values,hi=C5(qe.shape),ai=C5($e.shape),[Yi,Wi,ls]=le?[hi[0],1,hi[1]]:[hi[0],hi[1],1],[Hi,rs,Us]=ce?[1,ai[1],ai[0]]:[ai[1],1,ai[0]],Hs=nt*wt,qi=t7([Kt,nt,wt],qe.dtype),as=qi.values,li=V.blockSize;for(let vi=0;vi<Kt;vi++){const Ui=vi%We,hs=vi%Xe;for(let Xs=0;Xs<nt;Xs+=li){const cr=Math.min(Xs+li,nt);for(let Ks=0;Ks<wt;Ks+=li){const $s=Math.min(Ks+li,wt);for(let hr=0;hr<vt;hr+=li){const rn=Math.min(hr+li,vt);for(let Rr=Xs;Rr<cr;Rr++)for(let Yr=Ks;Yr<$s;Yr++){let Tn=0;for(let Mn=hr;Mn<rn;Mn++){const Un=Ht[Ui*Yi+Rr*Wi+Mn*ls],qn=pi[Mn*Hi+Yr*rs+hs*Us];Tn+=Un*qn}as[vi*Hs+(Rr*wt+Yr)]+=Tn}}}}}return V.disposeIntermediateTensorInfo(qe),V.disposeIntermediateTensorInfo($e),V.makeTensorInfo(Ye,qi.dtype,qi.values)}const Iz={kernelName:CF,backendName:"cpu",kernelFunc:Ik},Ix=gU(Cp,(W,A)=>{const V=A;return W>V.clipValueMax?V.clipValueMax:W<V.clipValueMin?V.clipValueMin:W}),IU={kernelName:Cp,backendName:"cpu",kernelFunc:Ix};function IG(W){const{inputs:A,backend:V}=W,{input:$}=A,ne=V.data.get($.dataId).complexTensorInfos.imag,xe=V.data.get(ne.dataId).values;return V.makeTensorInfo(ne.shape,ne.dtype,xe)}function Iu(W){const{inputs:A,backend:V,attrs:$}=W,{axis:ne}=$,xe=n(ne,A[0].shape)[0],le=A.map(Ge=>Ge.shape);dI(le,xe);let ce=dy(A.map(Ge=>Ge.shape),xe);if(F(ce)===0)return V.makeTensorInfo(ce,A[0].dtype,[]);const ue=A.filter(Ge=>F(Ge.shape)>0);if(ue.length===1)return gX({inputs:{x:ue[0]},backend:V});if(ue[0].dtype==="complex64"){const Ge=ue.map(Ke=>gW({inputs:{input:Ke},backend:V})),We=ue.map(Ke=>IG({inputs:{input:Ke},backend:V})),Xe=Iu({inputs:Ge,backend:V,attrs:{axis:xe}}),Ye=Iu({inputs:We,backend:V,attrs:{axis:xe}}),je=gp({inputs:{real:Xe,imag:Ye},backend:V});return Ge.forEach(Ke=>V.disposeIntermediateTensorInfo(Ke)),We.forEach(Ke=>V.disposeIntermediateTensorInfo(Ke)),V.disposeIntermediateTensorInfo(Xe),V.disposeIntermediateTensorInfo(Ye),je}const Te=ue.map(Ge=>{const We=[-1,F(Ge.shape.slice(xe))];return IL({inputs:{x:Ge},backend:V,attrs:{shape:We}})}),Me=Te.map(Ge=>({vals:V.data.get(Ge.dataId).values,shape:Ge.shape}));ce=dy(Te.map(Ge=>Ge.shape),1);const Re=Te[0].shape[0]===1,we=gY(Me,ce,A[0].dtype,Re),ke=dy(ue.map(Ge=>Ge.shape),xe),Ue=V.makeTensorInfo(ke,A[0].dtype,we);return Te.forEach(Ge=>V.disposeIntermediateTensorInfo(Ge)),Ue}const IY={kernelName:Cc,backendName:"cpu",kernelFunc:Iu};function IM(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne,filter:xe}=A,{strides:le,pad:ce,dataFormat:ue,dilations:Te,dimRoundingMode:Me}=$;gs([ne,xe],"conv2d");const Re=OL(ue),we=OA(ne.shape,xe.shape,le,Te,ce,Me,!1,Re),ke=we.filterHeight,Ue=we.filterWidth,Ge=we.dilationHeight,We=we.dilationWidth,Xe=we.padInfo.left,Ye=we.padInfo.top,je=we.dataFormat==="channelsLast",Ke=new J8(we.outShape,ne.dtype),qe=C5(ne.shape),$e=C5(xe.shape),vt=qe[0],nt=je?qe[1]:qe[2],wt=je?qe[2]:1,Kt=je?1:qe[1],Ht=Ke.strides[0],pi=je?Ke.strides[1]:Ke.strides[2],hi=je?Ke.strides[2]:1,ai=je?1:Ke.strides[1],Yi=V.data.get(ne.dataId).values,Wi=V.data.get(xe.dataId).values,ls=Ke.values;for(let Hi=0;Hi<we.batchSize;++Hi){const rs=Hi*vt,Us=Hi*Ht;for(let Hs=0;Hs<we.outHeight;++Hs){const qi=Us+Hs*pi,as=Hs*we.strideHeight-Ye;for(let li=0;li<ke;++li){const vi=as+li*Ge;if(vi<0||vi>=we.inHeight)continue;const Ui=li*$e[0],hs=rs+vi*nt;for(let Xs=0;Xs<we.outWidth;++Xs){const cr=qi+Xs*hi,Ks=Xs*we.strideWidth-Xe;for(let $s=0;$s<Ue;++$s){const hr=Ks+$s*We;if(hr<0||hr>=we.inWidth)continue;const rn=Ui+$s*$e[1],Rr=hs+hr*wt;let Yr=rn;for(let Tn=0;Tn<we.inChannels;++Tn){const Mn=Yi[Rr+Tn*Kt];for(let Un=0;Un<we.outChannels;++Un)ls[cr+Un*ai]+=Mn*Wi[Yr+Un];Yr+=we.outChannels}}}}}}return V.makeTensorInfo(Ke.shape,Ke.dtype,ls)}const Ih={kernelName:CW,backendName:"cpu",kernelFunc:IM};function Ij(W){const{inputs:A,backend:V,attrs:$}=W,{dy:ne,filter:xe}=A,{inputShape:le,strides:ce,pad:ue,dataFormat:Te,dimRoundingMode:Me}=$;gs([ne,xe],"conv2dBackpropInput");const Re=C5(xe.shape),we=C5(ne.shape);let ke=OL(Te);const Ue=OA(le,xe.shape,ce,1,ue,Me,!1,ke),Ge=new J8(Ue.inShape,"float32"),We=Ge.values,Xe=V.data.get(ne.dataId).values,Ye=V.data.get(xe.dataId).values,[je,Ke,qe]=Re,{batchSize:$e,filterHeight:vt,filterWidth:nt,inChannels:wt,inHeight:Kt,inWidth:Ht,outChannels:pi,outHeight:hi,outWidth:ai,strideHeight:Yi,strideWidth:Wi}=Ue;ke=Ue.dataFormat;const ls=vt-1-Ue.padInfo.top,Hi=nt-1-Ue.padInfo.left,rs=ke==="channelsLast",Us=Ge.strides[0],Hs=rs?Ge.strides[1]:Ge.strides[2],qi=rs?Ge.strides[2]:1,as=rs?1:Ge.strides[1],li=we[0],vi=rs?we[1]:we[2],Ui=rs?we[2]:1,hs=rs?1:we[1];for(let Xs=0;Xs<$e;++Xs)for(let cr=0;cr<wt;++cr)for(let Ks=0;Ks<Kt;++Ks){const $s=Ks-ls,hr=Math.max(0,Math.ceil($s/Yi)),rn=Math.min(hi,(vt+$s)/Yi);for(let Rr=0;Rr<Ht;++Rr){const Yr=Rr-Hi,Tn=Math.max(0,Math.ceil(Yr/Wi)),Mn=Math.min(ai,(nt+Yr)/Wi);let Un=0;for(let $n=hr;$n<rn;++$n){const cs=$n*Yi-$s;for(let a0=Tn;a0<Mn;++a0){const ux=a0*Wi-Yr,Yx=li*Xs+vi*$n+Ui*a0,ka=je*(vt-1-cs)+Ke*(nt-1-ux)+qe*cr;for(let cn=0;cn<pi;++cn){const Kr=Xe[Yx+hs*cn],px=Ye[ka+cn];Un+=Kr*px}}}const qn=Us*Xs+Hs*Ks+qi*Rr+as*cr;We[qn]=Un}}return V.makeTensorInfo(Ge.shape,Ge.dtype,Ge.values)}const Ir={kernelName:CK,backendName:"cpu",kernelFunc:Ij},y0=gU(CT,W=>Math.cos(W)),y1={kernelName:CT,backendName:"cpu",kernelFunc:y0};function y2(W){const{inputs:A,backend:V,attrs:$}=W,{image:ne,boxes:xe,boxInd:le}=A,{cropSize:ce,method:ue,extrapolationValue:Te}=$,[Me,Re,we,ke]=ne.shape,Ue=xe.shape[0],[Ge,We]=ce,Xe=t7([Ue,Ge,We,ke],"float32"),Ye=V.data.get(xe.dataId).values,je=V.data.get(le.dataId).values,Ke=V.data.get(ne.dataId).values,qe=C5(ne.shape),$e=C5(Xe.shape);for(let vt=0;vt<Ue;vt++){const nt=vt*4,wt=Ye[nt],Kt=Ye[nt+1],Ht=Ye[nt+2],pi=Ye[nt+3],hi=je[vt];if(hi>=Me)continue;const ai=Ge>1?(Ht-wt)*(Re-1)/(Ge-1):0,Yi=We>1?(pi-Kt)*(we-1)/(We-1):0;for(let Wi=0;Wi<Ge;Wi++){const ls=Ge>1?wt*(Re-1)+Wi*ai:.5*(wt+Ht)*(Re-1);if(ls<0||ls>Re-1){for(let Hi=0;Hi<We;Hi++)for(let rs=0;rs<ke;rs++){const Us=rs+Hi*$e[2]+Wi*$e[1]+vt*$e[0];Xe.values[Us]=Te}continue}if(ue==="bilinear"){const Hi=Math.floor(ls),rs=Math.ceil(ls),Us=ls-Hi;for(let Hs=0;Hs<We;Hs++){const qi=We>1?Kt*(we-1)+Hs*Yi:.5*(Kt+pi)*(we-1);if(qi<0||qi>we-1){for(let Ui=0;Ui<ke;Ui++){const hs=Ui+Hs*$e[2]+Wi*$e[1]+vt*$e[0];Xe.values[hs]=Te}continue}const as=Math.floor(qi),li=Math.ceil(qi),vi=qi-as;for(let Ui=0;Ui<ke;Ui++){let hs=Ui+as*qe[2]+Hi*qe[1]+hi*qe[0];const Xs=Ke[hs];hs=Ui+li*qe[2]+Hi*qe[1]+hi*qe[0];const cr=Ke[hs];hs=Ui+as*qe[2]+rs*qe[1]+hi*qe[0];const Ks=Ke[hs];hs=Ui+li*qe[2]+rs*qe[1]+hi*qe[0];const $s=Ke[hs],hr=Xs+(cr-Xs)*vi,rn=Ks+($s-Ks)*vi;hs=Ui+Hs*$e[2]+Wi*$e[1]+vt*$e[0],Xe.values[hs]=hr+(rn-hr)*Us}}}else for(let Hi=0;Hi<We;++Hi){const rs=We>1?Kt*(we-1)+Hi*Yi:.5*(Kt+pi)*(we-1);if(rs<0||rs>we-1){for(let qi=0;qi<ke;qi++){const as=qi+Hi*$e[2]+Wi*$e[1]+vt*$e[0];Xe.values[as]=Te}continue}const Us=Math.round(rs),Hs=Math.round(ls);for(let qi=0;qi<ke;qi++){const as=qi+Us*qe[2]+Hs*qe[1]+hi*qe[0],li=qi+Hi*$e[2]+Wi*$e[1]+vt*$e[0];Xe.values[li]=Ke[as]}}}}return V.makeTensorInfo(Xe.shape,Xe.dtype,Xe.values)}const y3={kernelName:Cv,backendName:"cpu",kernelFunc:y2};function y4(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{blockSize:xe,dataFormat:le}=$;e(le==="NHWC",()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+le);const ce=ne.shape[0],ue=ne.shape[1],Te=ne.shape[2],Me=ne.shape[3],Re=ue*xe,we=Te*xe,ke=Me/(xe*xe),Ue=V.data.get(ne.dataId).values,Ge=new Float32Array(ce*Re*we*ke);let We=0;for(let Xe=0;Xe<ce;++Xe)for(let Ye=0;Ye<Re;++Ye){const je=Math.floor(Ye/xe),Ke=Ye%xe;for(let qe=0;qe<we;++qe){const $e=Math.floor(qe/xe),vt=qe%xe,nt=(Ke*xe+vt)*ke;for(let wt=0;wt<ke;++wt){const Kt=wt+nt+Me*($e+Te*(je+ue*Xe));Ge[We++]=Ue[Kt]}}}return V.makeTensorInfo([ce,Re,we,ke],ne.dtype,Ge)}const y5={kernelName:Cq,backendName:"cpu",kernelFunc:y4};function y6(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne,filter:xe}=A,{strides:le,pad:ce,dilations:ue,dimRoundingMode:Te}=$;gs([ne,xe],"depthwiseConv2DNative");const Me=C5(ne.shape),Re=C5(xe.shape);let we=ue;we==null&&(we=[1,1]),e(Oa(le,we),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+le+" and dilations '"+we+"'");const ke=OA(ne.shape,xe.shape,le,we,ce,Te,!0),{filterHeight:Ue,filterWidth:Ge,dilationHeight:We,dilationWidth:Xe,padInfo:Ye}=ke,je=Ye.left,Ke=Ye.top,qe=ke.outChannels/ke.inChannels,$e=new J8(ke.outShape,ne.dtype),vt=V.data.get(ne.dataId).values,nt=V.data.get(xe.dataId).values,wt=$e.values;for(let Kt=0;Kt<ke.batchSize;++Kt){const Ht=Kt*Me[0],pi=Kt*$e.strides[0];for(let hi=0;hi<ke.outHeight;++hi){const ai=pi+hi*$e.strides[1],Yi=hi*ke.strideHeight-Ke;for(let Wi=0;Wi<Ue;++Wi){const ls=Yi+Wi*We;if(ls<0||ls>=ke.inHeight)continue;const Hi=Wi*Re[0],rs=Ht+ls*Me[1];for(let Us=0;Us<ke.outWidth;++Us){const Hs=ai+Us*$e.strides[2],qi=Us*ke.strideWidth-je;for(let as=0;as<Ge;++as){const li=qi+as*Xe;if(li<0||li>=ke.inWidth)continue;const vi=Hi+as*Re[1],Ui=rs+li*ke.inChannels;let hs=Hs,Xs=vi;for(let cr=0;cr<ke.inChannels;++cr){const Ks=vt[Ui+cr];for(let $s=0;$s<qe;++$s)wt[hs+$s]+=Ks*nt[Xs+$s];hs+=qe,Xs+=qe}}}}}}return V.makeTensorInfo($e.shape,$e.dtype,$e.values)}const y7={kernelName:Cl,backendName:"cpu",kernelFunc:y6};function y8(W){const{inputs:A,backend:V,attrs:$}=W,{input:ne}=A,{dim:xe}=$,le=ne.shape.length,ce=ne.shape.slice();let ue=xe;return xe<0&&(e(-(le+1)<=xe,()=>"Axis must be in the interval ["+-(le+1)+", "+le+"]"),ue=le+xe+1),ce.splice(ue,0,1),IL({inputs:{x:ne},backend:V,attrs:{shape:ce}})}const y9={kernelName:Cz,backendName:"cpu",kernelFunc:y8};function yC(W){const{backend:A,attrs:V}=W,{shape:$,value:ne,dtype:xe}=V,le=xe||C2(ne),ce=x(le,F($));return yN(ce,ne,le),A.makeTensorInfo($,le,ce)}const ym={kernelName:Cx,backendName:"cpu",kernelFunc:yC};function yN(W,A,V){W.fill(A)}const yJ=gU(Ck,W=>W>=0?W:Math.exp(W)-1);function yf(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{alpha:xe}=$;gs([ne],"leakyRelu");const le=F(ne.shape),ce=V.data.get(ne.dataId).values,ue=H("float32",le);for(let Te=0;Te<ce.length;Te++)ue[Te]=ce[Te]<0?xe*ce[Te]:ce[Te];return V.makeTensorInfo(ne.shape,"float32",ue)}const yi=gA((W,A)=>W<0?A*W:W);function yO(W){const{inputs:A,backend:V}=W,{x:$,alpha:ne}=A;gs([$,ne],"prelu");const xe=V.data.get($.dataId).values,le=V.data.get(ne.dataId).values,[ce,ue]=yi($.shape,ne.shape,xe,le,"float32");return V.makeTensorInfo(ue,"float32",ce)}const yt={kernelName:mS,backendName:"cpu",kernelFunc:yO},yB=gU(mb,W=>Math.max(0,W)),yS={kernelName:mb,backendName:"cpu",kernelFunc:yB},yd=gU(mg,W=>Math.min(Math.max(0,W),6)),yV={kernelName:mg,backendName:"cpu",kernelFunc:yd};function yb(W,A,V,$,ne){if(V==="linear")return gX({inputs:{x:A},backend:W});if(V==="relu")return yB({inputs:{x:A},backend:W});if(V==="elu")return yJ({inputs:{x:A},backend:W});if(V==="relu6")return yd({inputs:{x:A},backend:W});if(V==="prelu")return yO({inputs:{x:A,alpha:$},backend:W});if(V==="leakyrelu")return yf({inputs:{x:A},backend:W,attrs:{alpha:ne}});if(V==="sigmoid")return ZG({inputs:{x:A},backend:W});throw new Error("Activation "+V+" has not been implemented for the CPU backend.")}function yP(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne,filter:xe,bias:le,preluActivationWeights:ce}=A,{strides:ue,pad:Te,dataFormat:Me,dilations:Re,dimRoundingMode:we,activation:ke,leakyreluAlpha:Ue}=$;let Ge=IM({inputs:{x:ne,filter:xe},backend:V,attrs:{strides:ue,pad:Te,dataFormat:Me,dilations:Re,dimRoundingMode:we}});if(le){const We=Ge;if(Me==="NCHW"&&le.shape.length===1&&le.shape[0]!==1){const Xe=IL({inputs:{x:le},backend:V,attrs:{shape:[le.shape[0],1,1]}});Ge=gn({inputs:{a:Ge,b:Xe},backend:V}),V.disposeIntermediateTensorInfo(Xe)}else Ge=gn({inputs:{a:Ge,b:le},backend:V});V.disposeIntermediateTensorInfo(We)}if(ke){const We=Ge;if(Me==="NCHW"&&ke==="prelu"&&ce.shape.length===1&&ce.shape[0]!==1){const Xe=IL({inputs:{x:ce},backend:V,attrs:{shape:[ce.shape[0],1,1]}});Ge=yb(V,Ge,ke,Xe,Ue),V.disposeIntermediateTensorInfo(Xe)}else Ge=yb(V,Ge,ke,ce,Ue);V.disposeIntermediateTensorInfo(We)}return Ge}const yE={kernelName:mL,backendName:"cpu",kernelFunc:yP};function yD(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne,filter:xe,bias:le,preluActivationWeights:ce}=A,{strides:ue,pad:Te,dataFormat:Me,dilations:Re,dimRoundingMode:we,activation:ke,leakyreluAlpha:Ue}=$;let Ge=y6({inputs:{x:ne,filter:xe},backend:V,attrs:{strides:ue,pad:Te,dataFormat:Me,dilations:Re,dimRoundingMode:we}});if(le){const We=Ge;Ge=gn({inputs:{a:Ge,b:le},backend:V}),V.disposeIntermediateTensorInfo(We)}if(ke){const We=Ge;Ge=yb(V,Ge,ke,ce,Ue),V.disposeIntermediateTensorInfo(We)}return Ge}const yg={kernelName:mH,backendName:"cpu",kernelFunc:yD};function yZ(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne,indices:xe}=A,{axis:le,batchDims:ce}=$;gs([ne,xe],"gatherV2");const ue=n(le,ne.shape)[0],Te=V.data.get(xe.dataId).values,Me=ne.shape[ue];for(let Ke=0;Ke<Te.length;++Ke){const qe=Te[Ke];e(qe<=Me-1&&qe>=0,()=>"GatherV2: the index value "+qe+" is not in [0, "+(Me-1)+"]")}let Re=ce;ce==null&&(Re=0);const we=F(xe.shape),ke=VZ(ne,xe,ue,Re),Ue=IL({inputs:{x:ne},backend:V,attrs:{shape:[ke.batchSize,ke.outerSize,ke.dimSize,ke.sliceSize]}}),Ge=IL({inputs:{x:xe},backend:V,attrs:{shape:[ke.batchSize,we/ke.batchSize]}}),We=[ke.batchSize,ke.outerSize,we/ke.batchSize,ke.sliceSize],Xe=V.bufferSync(Ge),Ye=V.bufferSync(Ue),je=Z4(Ye,Xe,We);return V.disposeIntermediateTensorInfo(Ue),V.disposeIntermediateTensorInfo(Ge),V.makeTensorInfo(ke.outputShape,je.dtype,je.values)}const yo={kernelName:CY,backendName:"cpu",kernelFunc:yZ},ye=gA((W,A)=>W&&A),yQ=gv(m3,ye,null,"bool"),ys={kernelName:m3,backendName:"cpu",kernelFunc:yQ},yF=gA((W,A)=>W||A),yI=gv(m4,yF,null,"bool"),yy={kernelName:m4,backendName:"cpu",kernelFunc:yI};function yA(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{reductionIndices:xe,keepDims:le}=$,ce=V;let ue=ne.shape;const Te=ue.length,Me=n(xe,ue);let Re=Me;const we=tW(Re,Te);let ke=ce.data.get(ne.dataId).values;if(we!=null){const Ke=new Array(Te);for(let qe=0;qe<Ke.length;qe++)Ke[qe]=ue[we[qe]];ke=ZF(ke,ue,ne.dtype,we,Ke),Re=tK(Re.length,Te),ue=Ke}gs(ne,"max"),tc("max",Re,Te);const[Ue,Ge]=tw(ue,Re),We=F(Ge),Xe=Zt(ke,We,Ue,ne.dtype),Ye=ce.write(Xe,Ue,ne.dtype);let je=Ue;return le&&(je=tX(Ue,Me)),{dataId:Ye,shape:je,dtype:ne.dtype}}const yp={kernelName:m5,backendName:"cpu",kernelFunc:yA};function yw(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A;gs(ne,"maxPool");const{filterSize:xe,strides:le,pad:ce,dimRoundingMode:ue}=$,Te=1;e(Oa(le,Te),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+le+" and dilations '"+Te+"'");const Me=OI(ne.shape,xe,le,Te,ce,ue);let Re;if(Me.filterWidth===1&&Me.filterHeight===1&&X(Me.inShape,Me.outShape))Re=gX({inputs:{x:ne},backend:V});else{const we=V.data.get(ne.dataId).values,ke=C5(ne.shape),Ue=Il(we,ne.shape,ne.dtype,ke,Me,"max");Re=V.makeTensorInfo(Me.outShape,ne.dtype,Ue.values)}return Re}const yX={kernelName:m7,backendName:"cpu",kernelFunc:yw},yc=gA((W,A)=>W/A),yW=gv(CL,yc),yR={kernelName:CL,backendName:"cpu",kernelFunc:yW};function yK(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{axis:xe,keepDims:le}=$;gs(ne,"sum");let ce;ne.dtype==="bool"?ce=gK({inputs:{x:ne},backend:V,attrs:{dtype:"int32"}}):ce=gX({inputs:{x:ne},backend:V});const ue=ce.shape.length,Te=n(xe,ce.shape),Me=tW(Te,ue);let Re=Te,we=ce;Me!=null&&(we=ZI({inputs:{x:ce},backend:V,attrs:{perm:Me}}),Re=tK(Re.length,ue)),tc("sum",Re,we.shape.length);const[ke,Ue]=tw(we.shape,Re),Ge=Jb(we.dtype,"int32");let We=gw(V,ke,Ge);const Xe=F(Ue),Ye=V.data.get(We.dataId).values,je=V.data.get(we.dataId).values;for(let Ke=0;Ke<Ye.length;++Ke){const qe=Ke*Xe;let $e=0;for(let vt=0;vt<Xe;++vt)$e+=je[qe+vt];Ye[Ke]=$e}if(le){const Ke=tX(We.shape,Te),qe=We;We=IL({inputs:{x:We},backend:V,attrs:{shape:Ke}}),V.disposeIntermediateTensorInfo(qe)}return V.disposeIntermediateTensorInfo(ce),Me!=null&&V.disposeIntermediateTensorInfo(we),We}const yT={kernelName:my,backendName:"cpu",kernelFunc:yK};function yv(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{axis:xe,keepDims:le}=$,ce=n(xe,ne.shape),ue=tw(ne.shape,ce)[1],Te=F(ue),Me=[],Re=V.makeTensorInfo([],"float32",new Float32Array([Te]));Me.push(Re);const we=gK({inputs:{x:ne},backend:V,attrs:{dtype:"float32"}});Me.push(we);const ke=yW({inputs:{a:we,b:Re},backend:V});Me.push(ke);const Ue=yK({inputs:{x:ke},backend:V,attrs:{axis:xe,keepDims:le}});return Me.forEach(Ge=>V.disposeIntermediateTensorInfo(Ge)),Ue}const yq={kernelName:m8,backendName:"cpu",kernelFunc:yv};function yl(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{axis:xe,keepDims:le}=$;gs(ne,"min");const ce=n(xe,ne.shape);let ue=ce;const Te=tW(ue,ne.shape.length);let Me=ne;Te!=null&&(Me=ZI({inputs:{x:ne},backend:V,attrs:{perm:Te}}),ue=tK(ue.length,ne.shape.length)),tc("min",ue,Me.shape.length);const[Re,we]=tw(Me.shape,ue),ke=F(we),Ue=CC(F(Re),Me.dtype),Ge=V.data.get(Me.dataId).values;for(let Xe=0;Xe<Ue.length;++Xe){const Ye=Xe*ke;let je=Ge[Ye];for(let Ke=0;Ke<ke;++Ke){const qe=Ge[Ye+Ke];(Number.isNaN(qe)||qe<je)&&(je=qe)}Ue[Xe]=je}Te!=null&&V.disposeIntermediateTensorInfo(Me);const We=V.makeTensorInfo(Re,Me.dtype,Ue);if(le){const Xe=tX(Re,ce),Ye=IL({inputs:{x:We},backend:V,attrs:{shape:Xe}});return V.disposeIntermediateTensorInfo(We),Ye}return We}const ya={kernelName:m9,backendName:"cpu",kernelFunc:yl};function yn(W){const{inputs:A,backend:V,attrs:$}=W,{axis:ne}=$;if(A.length===1)return y8({inputs:{input:A[0]},backend:V,attrs:{dim:ne}});const xe=A[0].shape,le=A[0].dtype;A.forEach(Me=>{Q(xe,Me.shape,"All tensors passed to stack must have matching shapes"),e(le===Me.dtype,()=>"All tensors passed to stack must have matching dtypes")});const ce=[],ue=A.map(Me=>{const Re=y8({inputs:{input:Me},backend:V,attrs:{dim:ne}});return ce.push(Re),Re}),Te=Iu({inputs:ue,backend:V,attrs:{axis:ne}});return ce.forEach(Me=>V.disposeIntermediateTensorInfo(Me)),Te}const yL={kernelName:mO,backendName:"cpu",kernelFunc:yn};function yH(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{paddings:xe,constantValue:le}=$;gs(ne,"pad");const ce=xe.map((Xe,Ye)=>Xe[0]+ne.shape[Ye]+Xe[1]),ue=xe.map(Xe=>Xe[0]),Te=V.data.get(ne.dataId).values,Me=F(ne.shape),Re=ne.shape.length,we=C5(ne.shape),ke=F(ce),Ue=ce.length,Ge=C5(ce),We=H(ne.dtype,ke);le!==0&&We.fill(le);for(let Xe=0;Xe<Me;Xe++){const Ye=CJ(Xe,Re,we).map((Ke,qe)=>Ke+ue[qe]),je=CN(Ye,Ue,Ge);We[je]=Te[Xe]}return{dataId:V.write(We,ce,ne.dtype),shape:ce,dtype:ne.dtype}}const yk={kernelName:mt,backendName:"cpu",kernelFunc:yH},yz=gA((W,A)=>Math.pow(W,A)),yx=gv(mB,yz),yU={kernelName:mB,backendName:"cpu",kernelFunc:yx};function yG(W){const{backend:A,attrs:V}=W,{start:$,stop:ne,dtype:xe,step:le}=V,ce=Zk($,ne,le,xe);return A.makeTensorInfo([ce.length],xe,ce)}const yu={kernelName:md,backendName:"cpu",kernelFunc:yG};function yY(W){const{inputs:A,backend:V,attrs:$}=W,{images:ne}=A,{alignCorners:xe,halfPixelCenters:le,size:ce}=$;gs(ne,"resizeBilinear");const ue=C5(ne.shape),[Te,Me]=ce,[Re,we,ke,Ue]=ne.shape,Ge=V.data.get(ne.dataId).values,We=new Float32Array(F([Re,Te,Me,Ue])),Xe=[xe&&Te>1?we-1:we,xe&&Me>1?ke-1:ke],Ye=[xe&&Te>1?Te-1:Te,xe&&Me>1?Me-1:Me];let je=0;const Ke=Xe[0]/Ye[0],qe=Xe[1]/Ye[1];for(let $e=0;$e<Re;$e++)for(let vt=0;vt<Te;vt++){let nt;le?nt=Ke*(vt+.5)-.5:nt=Ke*vt;const wt=Math.max(0,Math.floor(nt)),Kt=nt-wt,Ht=Math.min(we-1,Math.ceil(nt)),pi=$e*ue[0]+wt*ue[1],hi=$e*ue[0]+Ht*ue[1];for(let ai=0;ai<Me;ai++){let Yi;le?Yi=qe*(ai+.5)-.5:Yi=qe*ai;const Wi=Math.max(0,Math.floor(Yi)),ls=Yi-Wi,Hi=Math.min(ke-1,Math.ceil(Yi)),rs=pi+Wi*ue[2],Us=hi+Wi*ue[2],Hs=pi+Hi*ue[2],qi=hi+Hi*ue[2];for(let as=0;as<Ue;as++){const li=Ge[rs+as],vi=Ge[Us+as],Ui=Ge[Hs+as],hs=Ge[qi+as],Xs=li+(Ui-li)*ls,cr=vi+(hs-vi)*ls,Ks=Xs+(cr-Xs)*Kt;We[je++]=Ks}}}return V.makeTensorInfo([Re,Te,Me,Ue],"float32",We)}const yM={kernelName:mD,backendName:"cpu",kernelFunc:yY},yh={kernelName:ma,backendName:"cpu",kernelFunc:({inputs:W,attrs:A,backend:V})=>{const{image:$}=W,{radians:ne,fillValue:xe,center:le}=A,ce=V,ue=H($.dtype,F($.shape)),[Te,Me,Re,we]=$.shape,[ke,Ue]=dK(le,Me,Re),Ge=255,We=Math.sin(ne),Xe=Math.cos(ne),Ye=ce.data.get($.dataId).values;for(let je=0;je<Te;je++){const Ke=je*Re*Me*we;for(let qe=0;qe<Me;qe++){const $e=qe*(Re*we);for(let vt=0;vt<Re;vt++){const nt=vt*we;for(let wt=0;wt<we;wt++){const Kt=[Te,qe,vt,wt],Ht=Kt[2],pi=Kt[1];let hi=(Ht-ke)*Xe-(pi-Ue)*We,ai=(Ht-ke)*We+(pi-Ue)*Xe;hi=Math.round(hi+ke),ai=Math.round(ai+Ue);let Yi=xe;if(typeof xe!="number"&&(wt===3?Yi=Ge:Yi=xe[wt]),hi>=0&&hi<Re&&ai>=0&&ai<Me){const ls=ai*(Re*we),Hi=hi*we,rs=Ke+ls+Hi+wt;Yi=Ye[rs]}const Wi=Ke+$e+nt+wt;ue[Wi]=Yi}}}}return{dataId:ce.write(ue,$.shape,$.dtype),shape:$.shape,dtype:$.dtype}}},yj=gU(ms,W=>Math.sin(W)),yr={kernelName:ms,backendName:"cpu",kernelFunc:yj},A0={kernelName:mw,backendName:"cpu",kernelFunc:({inputs:W,backend:A})=>{const{x:V}=W,$=A;gs(V,"square");const ne=$.data.get(V.dataId).values,xe=new Float32Array(ne.length);for(let le=0;le<ne.length;++le){const ce=ne[le];xe[le]=ce*ce}return{dataId:$.write(xe,V.shape,V.dtype),shape:V.shape,dtype:V.dtype}}};function A1(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{begin:xe,end:le,strides:ce,beginMask:ue,endMask:Te,ellipsisMask:Me,newAxisMask:Re,shrinkAxisMask:we}=$;gs(ne,"stridedSlice");const{finalShapeSparse:ke,finalShape:Ue,isIdentity:Ge,sliceDim0:We,isSimpleSlice:Xe,begin:Ye,end:je,strides:Ke}=Of(ne.shape,xe,le,ce,ue,Te,Me,Re,we);let qe;if(Ge)qe=IL({inputs:{x:ne},backend:V,attrs:{shape:Ue}});else if(We||Xe){e(ne.shape.length>=1,()=>"Input must have rank at least 1, got: "+ne.shape.length);const $e=O1(Ye,je,Ke),vt=ZM({inputs:{x:ne},backend:V,attrs:{begin:Ye,size:$e}});qe=IL({inputs:{x:vt},backend:V,attrs:{shape:Ue}}),V.disposeIntermediateTensorInfo(vt)}else{const $e=V.bufferSync(ne),vt=o6(ke,$e,Ke,Ye);qe=V.makeTensorInfo(Ue,vt.dtype,vt.values)}return qe}const A2={kernelName:mX,backendName:"cpu",kernelFunc:A1};function A3(W){const{inputs:A,backend:V,attrs:$}=W,{x:ne}=A,{reps:xe}=$;gs(ne,"tile");const le=oO(V.bufferSync(ne),xe);return V.makeTensorInfo(le.shape,le.dtype,le.values)}const A4={kernelName:mW,backendName:"cpu",kernelFunc:A3};function A5(W){const{inputs:A,attrs:V,backend:$}=W,{image:ne,transforms:xe}=A,{interpolation:le,fillMode:ce,fillValue:ue,outputShape:Te}=V,[Me,Re,we,ke]=ne.shape,[Ue,Ge]=Te??[Re,we],We=[Me,Ue,Ge,ke],Xe=C5(ne.shape),Ye=Xe[0],je=Xe[1],Ke=Xe[2],qe=C5(We),$e=qe[0],vt=qe[1],nt=qe[2],wt=H(ne.dtype,F(We));wt.fill(ue);const Kt=$.data.get(ne.dataId).values,Ht=$.data.get(xe.dataId).values;for(let pi=0;pi<Me;++pi){const hi=xe.shape[0]===1?Ht:Ht.subarray(pi*8,pi*8+8);for(let ai=0;ai<Ue;++ai)for(let Yi=0;Yi<Ge;++Yi)for(let Wi=0;Wi<ke;++Wi){let ls;const Hi=hi[6]*Yi+hi[7]*ai+1;if(Hi===0)continue;const rs=(hi[0]*Yi+hi[1]*ai+hi[2])/Hi,Us=(hi[3]*Yi+hi[4]*ai+hi[5])/Hi,Hs=A7(rs,we,ce),qi=A7(Us,Re,ce);switch(le){case"nearest":ls=AJ(Kt,Re,we,Ye,je,Ke,pi,qi,Hs,Wi,ue);break;case"bilinear":ls=Af(Kt,Re,we,Ye,je,Ke,pi,qi,Hs,Wi,ue);break;default:throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got "+le)}const as=pi*$e+ai*vt+Yi*nt+Wi;wt[as]=ls}return $.makeTensorInfo(We,ne.dtype,wt)}return{dataId:$.write(wt,We,ne.dtype),shape:ne.shape,dtype:ne.dtype}}const A6={kernelName:mR,backendName:"cpu",kernelFunc:A5};function A7(W,A,V){switch(V){case"reflect":return A8(W,A);case"wrap":return A9(W,A);case"nearest":return Am(W,A);case"constant":default:return AC(W)}}function A8(W,A){let V=W;if(V<0)if(A<=1)V=0;else{const $=2*A;V<$&&(V=$*Math.trunc(-V/$)+V),V=V<-A?V+$:-V-1}else if(V>A-1)if(A<=1)V=0;else{const $=2*A;V-=$*Math.trunc(V/$),V>=A&&(V=$-V-1)}return t(0,V,A-1)}function A9(W,A){let V=W;if(V<0)if(A<=1)V=0;else{const $=A-1;V+=A*(Math.trunc(-V/$)+1)}else if(V>A-1)if(A<=1)V=0;else{const $=A-1;V-=A*Math.trunc(V/$)}return t(0,V,A-1)}function AC(W,A){return W}function Am(W,A){return t(0,W,A-1)}function AN(W,A,V,$,ne,xe,le,ce,ue,Te,Me){const Re=le*$+ce*ne+ue*xe+Te;return 0<=ce&&ce<A&&0<=ue&&ue<V?W[Re]:Me}function AJ(W,A,V,$,ne,xe,le,ce,ue,Te,Me){const Re=Math.round(ce),we=Math.round(ue);return AN(W,A,V,$,ne,xe,le,Re,we,Te,Me)}function Af(W,A,V,$,ne,xe,le,ce,ue,Te,Me){const Re=Math.floor(ce),we=Math.floor(ue),ke=Re+1,Ue=we+1,Ge=(Ue-ue)*AN(W,A,V,$,ne,xe,le,Re,we,Te,Me)+(ue-we)*AN(W,A,V,$,ne,xe,le,Re,Ue,Te,Me),We=(Ue-ue)*AN(W,A,V,$,ne,xe,le,ke,we,Te,Me)+(ue-we)*AN(W,A,V,$,ne,xe,le,ke,Ue,Te,Me);return(ke-ce)*Ge+(ce-Re)*We}function Ai(W){const{inputs:A,backend:V}=W,{x:$}=A;if($.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if($.dtype==="complex64"){const ne=gW({inputs:{input:$},backend:V}),xe=Ai({inputs:{x:ne},backend:V}),le=IG({inputs:{input:$},backend:V}),ce=Ai({inputs:{x:le},backend:V}),ue=gp({inputs:{real:xe,imag:ce},backend:V});return V.disposeIntermediateTensorInfo(ne),V.disposeIntermediateTensorInfo(xe),V.disposeIntermediateTensorInfo(le),V.disposeIntermediateTensorInfo(ce),ue}else return yC({backend:V,attrs:{shape:$.shape,value:0,dtype:$.dtype}})}const AO={kernelName:mv,backendName:"cpu",kernelFunc:Ai};function At(W){const{inputs:A,backend:V,attrs:$}=W,{a:ne,b:xe,bias:le,preluActivationWeights:ce}=A,{transposeA:ue,transposeB:Te,activation:Me,leakyreluAlpha:Re}=$;let we,ke,Ue;const Ge=[];we=Ik({inputs:{a:ne,b:xe},attrs:{transposeA:ue,transposeB:Te},backend:V}),le&&(ke=gn({inputs:{a:we,b:le},backend:V}),Ge.push(we),we=ke),Me&&(Ue=yb(V,we,Me,ce,Re),Ge.push(we),we=Ue);for(const We of Ge)V.disposeIntermediateTensorInfo(We);return we}const AB={kernelName:mn,backendName:"cpu",kernelFunc:At};mM(ek),mM(Q9),mM(QJ),mM(QB),mM(QV),mM(Qa),mM(QU),mM(QM),mM(s4),mM(sN),mM(sO),mM(sd),mM(sP),mM(sg),mM(sQ),mM(sF),mM(sA),mM(sX),mM(sR),mM(sl),mM(sn),mM(sz),mM(su),mM(eY),mM(sj),mM(F3),mM(F7),mM(Fm),mM(Ff),mM(FO),mM(Fd),mM(Fb),mM(FE),mM(Fo),mM(QZ),mM(FF),mM(Fy),mM(FX),mM(FK),mM(Q2),mM(Fv),mM(Fn),mM(Fz),mM(Fu),mM(QQ),mM(Fj),mM(I0),mM(I4),mM(I8),mM(Ii),mM(IB),mM(IV),mM(IE),mM(IZ),mM(QR),mM(Is),mM(Iy),mM(QT),mM(Ip),mM(IX),mM(gy),mM(gL),mM(IK),mM(Iq),mM(In),mM(Iz),mM(gT),mM(IU),mM(IY),mM(Ih),mM(Ir),mM(y1),mM(y3),mM(y5),mM(y7),mM(y9),mM(ym),mM(Z1),mM(yE),mM(yg),mM(yo),mM(Z8),mM(gc),mM(Zm),mM(Zf),mM(ys),mM(yy),mM(yp),mM(yX),mM(Zd),mM(yq),mM(ya),mM(ZP),mM(ZZ),mM(ZQ),mM(yL),mM(yk),mM(yU),mM(yt),mM(yu),mM(yR),mM(yS),mM(yV),mM(IH),mM(yM),mM(yh),mM(Zu),mM(yr),mM(Zh),mM(o3),mM(A0),mM(A2),mM(oi),mM(yT),mM(A4),mM(A6),mM(Zy),mM(AO),mM(AB);var AS={};(function(p1){var p2=p1;typeof mr<"u"&&(mr.numeric=p2),p2.version="1.2.6",p2.bench=function(W,A){var V,$,ne,xe;for(typeof A>"u"&&(A=15),ne=.5,V=new Date;;){for(ne*=2,xe=ne;xe>3;xe-=4)W(),W(),W(),W();for(;xe>0;)W(),xe--;if($=new Date,$-V>A)break}for(xe=ne;xe>3;xe-=4)W(),W(),W(),W();for(;xe>0;)W(),xe--;return $=new Date,1e3*(3*ne-1)/($-V)},p2._myIndexOf=function(W){var A=this.length,V;for(V=0;V<A;++V)if(this[V]===W)return V;return-1},p2.myIndexOf=Array.prototype.indexOf?Array.prototype.indexOf:p2._myIndexOf,p2.Function=Function,p2.precision=4,p2.largeArray=50,p2.prettyPrint=function(W){function A(ne){if(ne===0)return"0";if(isNaN(ne))return"NaN";if(ne<0)return"-"+A(-ne);if(isFinite(ne)){var xe=Math.floor(Math.log(ne)/Math.log(10)),le=ne/Math.pow(10,xe),ce=le.toPrecision(p2.precision);return parseFloat(ce)===10&&(xe++,le=1,ce=le.toPrecision(p2.precision)),parseFloat(ce).toString()+"e"+xe.toString()}return"Infinity"}var V=[];function $(ne){var xe;if(typeof ne>"u")return V.push(Array(p2.precision+8).join(" ")),!1;if(typeof ne=="string")return V.push('"'+ne+'"'),!1;if(typeof ne=="boolean")return V.push(ne.toString()),!1;if(typeof ne=="number"){var le=A(ne),ce=ne.toPrecision(p2.precision),ue=parseFloat(ne.toString()).toString(),Te=[le,ce,ue,parseFloat(ce).toString(),parseFloat(ue).toString()];for(xe=1;xe<Te.length;xe++)Te[xe].length<le.length&&(le=Te[xe]);return V.push(Array(p2.precision+8-le.length).join(" ")+le),!1}if(ne===null)return V.push("null"),!1;if(typeof ne=="function"){V.push(ne.toString());var Me=!1;for(xe in ne)ne.hasOwnProperty(xe)&&(Me?V.push(`,
`):V.push(`
{`),Me=!0,V.push(xe),V.push(`: 
`),$(ne[xe]));return Me&&V.push(`}
`),!0}if(ne instanceof Array){if(ne.length>p2.largeArray)return V.push("...Large Array..."),!0;var Me=!1;for(V.push("["),xe=0;xe<ne.length;xe++)xe>0&&(V.push(","),Me&&V.push(`
 `)),Me=$(ne[xe]);return V.push("]"),!0}V.push("{");var Me=!1;for(xe in ne)ne.hasOwnProperty(xe)&&(Me&&V.push(`,
`),Me=!0,V.push(xe),V.push(`: 
`),$(ne[xe]));return V.push("}"),!0}return $(W),V.join("")},p2.parseDate=function(W){function A(V){if(typeof V=="string")return Date.parse(V.replace(/-/g,"/"));if(!(V instanceof Array))throw new Error("parseDate: parameter must be arrays of strings");var $=[],ne;for(ne=0;ne<V.length;ne++)$[ne]=A(V[ne]);return $}return A(W)},p2.parseFloat=function(W){function A(V){if(typeof V=="string")return parseFloat(V);if(!(V instanceof Array))throw new Error("parseFloat: parameter must be arrays of strings");var $=[],ne;for(ne=0;ne<V.length;ne++)$[ne]=A(V[ne]);return $}return A(W)},p2.parseCSV=function(W){var A=W.split(`
`),V,$,ne=[],xe=/(([^'",]*)|('[^']*')|("[^"]*")),/g,le=/^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/,ce=function(Re){return Re.substr(0,Re.length-1)},ue=0;for($=0;$<A.length;$++){var Te=(A[$]+",").match(xe),Me;if(Te.length>0){for(ne[ue]=[],V=0;V<Te.length;V++)Me=ce(Te[V]),le.test(Me)?ne[ue][V]=parseFloat(Me):ne[ue][V]=Me;ue++}}return ne},p2.toCSV=function(W){var A=p2.dim(W),V,$,ne,xe,le;for(ne=A[0],A[1],le=[],V=0;V<ne;V++){for(xe=[],$=0;$<ne;$++)xe[$]=W[V][$].toString();le[V]=xe.join(", ")}return le.join(`
`)+`
`},p2.getURL=function(W){var A=new XMLHttpRequest;return A.open("GET",W,!1),A.send(),A},p2.imageURL=function(W){function A(We){var Xe=We.length,Ye,je,Ke,qe,$e,vt,nt,wt,Kt="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",Ht="";for(Ye=0;Ye<Xe;Ye+=3)je=We[Ye],Ke=We[Ye+1],qe=We[Ye+2],$e=je>>2,vt=((je&3)<<4)+(Ke>>4),nt=((Ke&15)<<2)+(qe>>6),wt=qe&63,Ye+1>=Xe?nt=wt=64:Ye+2>=Xe&&(wt=64),Ht+=Kt.charAt($e)+Kt.charAt(vt)+Kt.charAt(nt)+Kt.charAt(wt);return Ht}function V(We,Xe,Ye){typeof Xe>"u"&&(Xe=0),typeof Ye>"u"&&(Ye=We.length);var je=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],Ke=-1,qe=0;We.length;var $e;for($e=Xe;$e<Ye;$e++)qe=(Ke^We[$e])&255,Ke=Ke>>>8^je[qe];return Ke^-1}var $=W[0].length,ne=W[0][0].length,xe,le,ce,ue,Te,Me,Re,we,ke,Ue,Ge=[137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,ne>>24&255,ne>>16&255,ne>>8&255,ne&255,$>>24&255,$>>16&255,$>>8&255,$&255,8,2,0,0,0,-1,-2,-3,-4,-5,-6,-7,-8,73,68,65,84,8,29];for(Ue=V(Ge,12,29),Ge[29]=Ue>>24&255,Ge[30]=Ue>>16&255,Ge[31]=Ue>>8&255,Ge[32]=Ue&255,xe=1,le=0,Re=0;Re<$;Re++){for(Re<$-1?Ge.push(0):Ge.push(1),Te=3*ne+1+(Re===0)&255,Me=3*ne+1+(Re===0)>>8&255,Ge.push(Te),Ge.push(Me),Ge.push(~Te&255),Ge.push(~Me&255),Re===0&&Ge.push(0),we=0;we<ne;we++)for(ce=0;ce<3;ce++)Te=W[ce][Re][we],Te>255?Te=255:Te<0?Te=0:Te=Math.round(Te),xe=(xe+Te)%65521,le=(le+xe)%65521,Ge.push(Te);Ge.push(0)}return ke=(le<<16)+xe,Ge.push(ke>>24&255),Ge.push(ke>>16&255),Ge.push(ke>>8&255),Ge.push(ke&255),ue=Ge.length-41,Ge[33]=ue>>24&255,Ge[34]=ue>>16&255,Ge[35]=ue>>8&255,Ge[36]=ue&255,Ue=V(Ge,37),Ge.push(Ue>>24&255),Ge.push(Ue>>16&255),Ge.push(Ue>>8&255),Ge.push(Ue&255),Ge.push(0),Ge.push(0),Ge.push(0),Ge.push(0),Ge.push(73),Ge.push(69),Ge.push(78),Ge.push(68),Ge.push(174),Ge.push(66),Ge.push(96),Ge.push(130),"data:image/png;base64,"+A(Ge)},p2._dim=function(W){for(var A=[];typeof W=="object";)A.push(W.length),W=W[0];return A},p2.dim=function(W){var A,V;return typeof W=="object"?(A=W[0],typeof A=="object"?(V=A[0],typeof V=="object"?p2._dim(W):[W.length,A.length]):[W.length]):[]},p2.mapreduce=function(W,A){return Function("x","accum","_s","_k",'if(typeof accum === "undefined") accum = '+A+`;
if(typeof x === "number") { var xi = x; `+W+`; return accum; }
if(typeof _s === "undefined") _s = numeric.dim(x);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i,xi;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) {
        accum = arguments.callee(x[i],accum,_s,_k+1);
    }    return accum;
}
for(i=_n-1;i>=1;i-=2) { 
    xi = x[i];
    `+W+`;
    xi = x[i-1];
    `+W+`;
}
if(i === 0) {
    xi = x[i];
    `+W+`
}
return accum;`)},p2.mapreduce2=function(W,A){return Function("x",`var n = x.length;
var i,xi;
`+A+`;
for(i=n-1;i!==-1;--i) { 
    xi = x[i];
    `+W+`;
}
return accum;`)},p2.same=function W(A,V){var $,ne;if(!(A instanceof Array)||!(V instanceof Array)||(ne=A.length,ne!==V.length))return!1;for($=0;$<ne;$++)if(A[$]!==V[$])if(typeof A[$]=="object"){if(!W(A[$],V[$]))return!1}else return!1;return!0},p2.rep=function(W,A,V){typeof V>"u"&&(V=0);var $=W[V],ne=Array($),xe;if(V===W.length-1){for(xe=$-2;xe>=0;xe-=2)ne[xe+1]=A,ne[xe]=A;return xe===-1&&(ne[0]=A),ne}for(xe=$-1;xe>=0;xe--)ne[xe]=p2.rep(W,A,V+1);return ne},p2.dotMMsmall=function(W,A){var V,$,ne,xe,le,ce,ue,Te,Me,Re,we;for(xe=W.length,le=A.length,ce=A[0].length,ue=Array(xe),V=xe-1;V>=0;V--){for(Te=Array(ce),Me=W[V],ne=ce-1;ne>=0;ne--){for(Re=Me[le-1]*A[le-1][ne],$=le-2;$>=1;$-=2)we=$-1,Re+=Me[$]*A[$][ne]+Me[we]*A[we][ne];$===0&&(Re+=Me[0]*A[0][ne]),Te[ne]=Re}ue[V]=Te}return ue},p2._getCol=function(W,A,V){var $=W.length,ne;for(ne=$-1;ne>0;--ne)V[ne]=W[ne][A],--ne,V[ne]=W[ne][A];ne===0&&(V[0]=W[0][A])},p2.dotMMbig=function(W,A){var V=p2._getCol,$=A.length,ne=Array($),xe=W.length,le=A[0].length,ce=new Array(xe),ue,Te=p2.dotVV,Me,Re;for(--$,--xe,Me=xe;Me!==-1;--Me)ce[Me]=Array(le);for(--le,Me=le;Me!==-1;--Me)for(V(A,Me,ne),Re=xe;Re!==-1;--Re)ue=W[Re],ce[Re][Me]=Te(ue,ne);return ce},p2.dotMV=function(W,A){var V=W.length;A.length;var $,ne=Array(V),xe=p2.dotVV;for($=V-1;$>=0;$--)ne[$]=xe(W[$],A);return ne},p2.dotVM=function(W,A){var V,$,ne,xe,le,ce,ue;for(ne=W.length,xe=A[0].length,le=Array(xe),$=xe-1;$>=0;$--){for(ce=W[ne-1]*A[ne-1][$],V=ne-2;V>=1;V-=2)ue=V-1,ce+=W[V]*A[V][$]+W[ue]*A[ue][$];V===0&&(ce+=W[0]*A[0][$]),le[$]=ce}return le},p2.dotVV=function(W,A){var V,$=W.length,ne,xe=W[$-1]*A[$-1];for(V=$-2;V>=1;V-=2)ne=V-1,xe+=W[V]*A[V]+W[ne]*A[ne];return V===0&&(xe+=W[0]*A[0]),xe},p2.dot=function(W,A){var V=p2.dim;switch(V(W).length*1e3+V(A).length){case 2002:return A.length<10?p2.dotMMsmall(W,A):p2.dotMMbig(W,A);case 2001:return p2.dotMV(W,A);case 1002:return p2.dotVM(W,A);case 1001:return p2.dotVV(W,A);case 1e3:return p2.mulVS(W,A);case 1:return p2.mulSV(W,A);case 0:return W*A;default:throw new Error("numeric.dot only works on vectors and matrices")}},p2.diag=function(W){var A,V,$,ne=W.length,xe=Array(ne),le;for(A=ne-1;A>=0;A--){for(le=Array(ne),V=A+2,$=ne-1;$>=V;$-=2)le[$]=0,le[$-1]=0;for($>A&&(le[$]=0),le[A]=W[A],$=A-1;$>=1;$-=2)le[$]=0,le[$-1]=0;$===0&&(le[0]=0),xe[A]=le}return xe},p2.getDiag=function(W){var A=Math.min(W.length,W[0].length),V,$=Array(A);for(V=A-1;V>=1;--V)$[V]=W[V][V],--V,$[V]=W[V][V];return V===0&&($[0]=W[0][0]),$},p2.identity=function(W){return p2.diag(p2.rep([W],1))},p2.pointwise=function(W,A,V){typeof V>"u"&&(V="");var $=[],ne,xe=/\[i\]$/,le,ce="",ue=!1;for(ne=0;ne<W.length;ne++)xe.test(W[ne])?(le=W[ne].substring(0,W[ne].length-3),ce=le):le=W[ne],le==="ret"&&(ue=!0),$.push(le);return $[W.length]="_s",$[W.length+1]="_k",$[W.length+2]='if(typeof _s === "undefined") _s = numeric.dim('+ce+`);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i`+(ue?"":", ret = Array(_n)")+`;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(`+W.join(",")+`,_s,_k+1);
    return ret;
}
`+V+`
for(i=_n-1;i!==-1;--i) {
    `+A+`
}
return ret;`,Function.apply(null,$)},p2.pointwise2=function(W,A,V){typeof V>"u"&&(V="");var $=[],ne,xe=/\[i\]$/,le,ce="",ue=!1;for(ne=0;ne<W.length;ne++)xe.test(W[ne])?(le=W[ne].substring(0,W[ne].length-3),ce=le):le=W[ne],le==="ret"&&(ue=!0),$.push(le);return $[W.length]="var _n = "+ce+`.length;
var i`+(ue?"":", ret = Array(_n)")+`;
`+V+`
for(i=_n-1;i!==-1;--i) {
`+A+`
}
return ret;`,Function.apply(null,$)},p2._biforeach=function W(A,V,$,ne,xe){if(ne===$.length-1){xe(A,V);return}var le,ce=$[ne];for(le=ce-1;le>=0;le--)W(typeof A=="object"?A[le]:A,typeof V=="object"?V[le]:V,$,ne+1,xe)},p2._biforeach2=function W(A,V,$,ne,xe){if(ne===$.length-1)return xe(A,V);var le,ce=$[ne],ue=Array(ce);for(le=ce-1;le>=0;--le)ue[le]=W(typeof A=="object"?A[le]:A,typeof V=="object"?V[le]:V,$,ne+1,xe);return ue},p2._foreach=function W(A,V,$,ne){if($===V.length-1){ne(A);return}var xe,le=V[$];for(xe=le-1;xe>=0;xe--)W(A[xe],V,$+1,ne)},p2._foreach2=function W(A,V,$,ne){if($===V.length-1)return ne(A);var xe,le=V[$],ce=Array(le);for(xe=le-1;xe>=0;xe--)ce[xe]=W(A[xe],V,$+1,ne);return ce},p2.ops2={add:"+",sub:"-",mul:"*",div:"/",mod:"%",and:"&&",or:"||",eq:"===",neq:"!==",lt:"<",gt:">",leq:"<=",geq:">=",band:"&",bor:"|",bxor:"^",lshift:"<<",rshift:">>",rrshift:">>>"},p2.opseq={addeq:"+=",subeq:"-=",muleq:"*=",diveq:"/=",modeq:"%=",lshifteq:"<<=",rshifteq:">>=",rrshifteq:">>>=",bandeq:"&=",boreq:"|=",bxoreq:"^="},p2.mathfuns=["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan","isNaN","isFinite"],p2.mathfuns2=["atan2","pow","max","min"],p2.ops1={neg:"-",not:"!",bnot:"~",clone:""},p2.mapreducers={any:["if(xi) return true;","var accum = false;"],all:["if(!xi) return false;","var accum = true;"],sum:["accum += xi;","var accum = 0;"],prod:["accum *= xi;","var accum = 1;"],norm2Squared:["accum += xi*xi;","var accum = 0;"],norminf:["accum = max(accum,abs(xi));","var accum = 0, max = Math.max, abs = Math.abs;"],norm1:["accum += abs(xi)","var accum = 0, abs = Math.abs;"],sup:["accum = max(accum,xi);","var accum = -Infinity, max = Math.max;"],inf:["accum = min(accum,xi);","var accum = Infinity, min = Math.min;"]},function(){var W,A;for(W=0;W<p2.mathfuns2.length;++W)A=p2.mathfuns2[W],p2.ops2[A]=A;for(W in p2.ops2)if(p2.ops2.hasOwnProperty(W)){A=p2.ops2[W];var V,$,ne="";p2.myIndexOf.call(p2.mathfuns2,W)!==-1?(ne="var "+A+" = Math."+A+`;
`,V=function(xe,le,ce){return xe+" = "+A+"("+le+","+ce+")"},$=function(xe,le){return xe+" = "+A+"("+xe+","+le+")"}):(V=function(xe,le,ce){return xe+" = "+le+" "+A+" "+ce},p2.opseq.hasOwnProperty(W+"eq")?$=function(xe,le){return xe+" "+A+"= "+le}:$=function(xe,le){return xe+" = "+xe+" "+A+" "+le}),p2[W+"VV"]=p2.pointwise2(["x[i]","y[i]"],V("ret[i]","x[i]","y[i]"),ne),p2[W+"SV"]=p2.pointwise2(["x","y[i]"],V("ret[i]","x","y[i]"),ne),p2[W+"VS"]=p2.pointwise2(["x[i]","y"],V("ret[i]","x[i]","y"),ne),p2[W]=Function(`var n = arguments.length, i, x = arguments[0], y;
var VV = numeric.`+W+"VV, VS = numeric."+W+"VS, SV = numeric."+W+`SV;
var dim = numeric.dim;
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof x === "object") {
      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);
      else x = numeric._biforeach2(x,y,dim(x),0,VS);
  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);
  else `+$("x","y")+`
}
return x;
`),p2[A]=p2[W],p2[W+"eqV"]=p2.pointwise2(["ret[i]","x[i]"],$("ret[i]","x[i]"),ne),p2[W+"eqS"]=p2.pointwise2(["ret[i]","x"],$("ret[i]","x"),ne),p2[W+"eq"]=Function(`var n = arguments.length, i, x = arguments[0], y;
var V = numeric.`+W+"eqV, S = numeric."+W+`eqS
var s = numeric.dim(x);
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);
  else numeric._biforeach(x,y,s,0,S);
}
return x;
`)}for(W=0;W<p2.mathfuns2.length;++W)A=p2.mathfuns2[W],delete p2.ops2[A];for(W=0;W<p2.mathfuns.length;++W)A=p2.mathfuns[W],p2.ops1[A]=A;for(W in p2.ops1)p2.ops1.hasOwnProperty(W)&&(ne="",A=p2.ops1[W],p2.myIndexOf.call(p2.mathfuns,W)!==-1&&Math.hasOwnProperty(A)&&(ne="var "+A+" = Math."+A+`;
`),p2[W+"eqV"]=p2.pointwise2(["ret[i]"],"ret[i] = "+A+"(ret[i]);",ne),p2[W+"eq"]=Function("x",'if(typeof x !== "object") return '+A+`x
var i;
var V = numeric.`+W+`eqV;
var s = numeric.dim(x);
numeric._foreach(x,s,0,V);
return x;
`),p2[W+"V"]=p2.pointwise2(["x[i]"],"ret[i] = "+A+"(x[i]);",ne),p2[W]=Function("x",'if(typeof x !== "object") return '+A+`(x)
var i;
var V = numeric.`+W+`V;
var s = numeric.dim(x);
return numeric._foreach2(x,s,0,V);
`));for(W=0;W<p2.mathfuns.length;++W)A=p2.mathfuns[W],delete p2.ops1[A];for(W in p2.mapreducers)p2.mapreducers.hasOwnProperty(W)&&(A=p2.mapreducers[W],p2[W+"V"]=p2.mapreduce2(A[0],A[1]),p2[W]=Function("x","s","k",A[1]+`if(typeof x !== "object") {    xi = x;
`+A[0]+`;
    return accum;
}if(typeof s === "undefined") s = numeric.dim(x);
if(typeof k === "undefined") k = 0;
if(k === s.length-1) return numeric.`+W+`V(x);
var xi;
var n = x.length, i;
for(i=n-1;i!==-1;--i) {
   xi = arguments.callee(x[i]);
`+A[0]+`;
}
return accum;
`))}(),p2.truncVV=p2.pointwise(["x[i]","y[i]"],"ret[i] = round(x[i]/y[i])*y[i];","var round = Math.round;"),p2.truncVS=p2.pointwise(["x[i]","y"],"ret[i] = round(x[i]/y)*y;","var round = Math.round;"),p2.truncSV=p2.pointwise(["x","y[i]"],"ret[i] = round(x/y[i])*y[i];","var round = Math.round;"),p2.trunc=function(W,A){return typeof W=="object"?typeof A=="object"?p2.truncVV(W,A):p2.truncVS(W,A):typeof A=="object"?p2.truncSV(W,A):Math.round(W/A)*A},p2.inv=function(Ue){var A=p2.dim(Ue),V=Math.abs,$=A[0],ne=A[1],xe=p2.clone(Ue),le,ce,ue=p2.identity($),Te,Me,Re,we,ke,Ue;for(we=0;we<ne;++we){var Ge=-1,We=-1;for(Re=we;Re!==$;++Re)ke=V(xe[Re][we]),ke>We&&(Ge=Re,We=ke);for(ce=xe[Ge],xe[Ge]=xe[we],xe[we]=ce,Me=ue[Ge],ue[Ge]=ue[we],ue[we]=Me,Ue=ce[we],ke=we;ke!==ne;++ke)ce[ke]/=Ue;for(ke=ne-1;ke!==-1;--ke)Me[ke]/=Ue;for(Re=$-1;Re!==-1;--Re)if(Re!==we){for(le=xe[Re],Te=ue[Re],Ue=le[we],ke=we+1;ke!==ne;++ke)le[ke]-=ce[ke]*Ue;for(ke=ne-1;ke>0;--ke)Te[ke]-=Me[ke]*Ue,--ke,Te[ke]-=Me[ke]*Ue;ke===0&&(Te[0]-=Me[0]*Ue)}}return ue},p2.det=function(W){var A=p2.dim(W);if(A.length!==2||A[0]!==A[1])throw new Error("numeric: det() only works on square matrices");var V=A[0],$=1,ne,xe,le,ce=p2.clone(W),ue,Te,Me,Re,we;for(xe=0;xe<V-1;xe++){for(le=xe,ne=xe+1;ne<V;ne++)Math.abs(ce[ne][xe])>Math.abs(ce[le][xe])&&(le=ne);for(le!==xe&&(Re=ce[le],ce[le]=ce[xe],ce[xe]=Re,$*=-1),ue=ce[xe],ne=xe+1;ne<V;ne++){for(Te=ce[ne],Me=Te[xe]/ue[xe],le=xe+1;le<V-1;le+=2)we=le+1,Te[le]-=ue[le]*Me,Te[we]-=ue[we]*Me;le!==V&&(Te[le]-=ue[le]*Me)}if(ue[xe]===0)return 0;$*=ue[xe]}return $*ce[xe][xe]},p2.transpose=function(W){var A,V,$=W.length,ne=W[0].length,xe=Array(ne),le,ce,ue;for(V=0;V<ne;V++)xe[V]=Array($);for(A=$-1;A>=1;A-=2){for(ce=W[A],le=W[A-1],V=ne-1;V>=1;--V)ue=xe[V],ue[A]=ce[V],ue[A-1]=le[V],--V,ue=xe[V],ue[A]=ce[V],ue[A-1]=le[V];V===0&&(ue=xe[0],ue[A]=ce[0],ue[A-1]=le[0])}if(A===0){for(le=W[0],V=ne-1;V>=1;--V)xe[V][0]=le[V],--V,xe[V][0]=le[V];V===0&&(xe[0][0]=le[0])}return xe},p2.negtranspose=function(W){var A,V,$=W.length,ne=W[0].length,xe=Array(ne),le,ce,ue;for(V=0;V<ne;V++)xe[V]=Array($);for(A=$-1;A>=1;A-=2){for(ce=W[A],le=W[A-1],V=ne-1;V>=1;--V)ue=xe[V],ue[A]=-ce[V],ue[A-1]=-le[V],--V,ue=xe[V],ue[A]=-ce[V],ue[A-1]=-le[V];V===0&&(ue=xe[0],ue[A]=-ce[0],ue[A-1]=-le[0])}if(A===0){for(le=W[0],V=ne-1;V>=1;--V)xe[V][0]=-le[V],--V,xe[V][0]=-le[V];V===0&&(xe[0][0]=-le[0])}return xe},p2._random=function W(A,V){var $,ne=A[V],xe=Array(ne),le;if(V===A.length-1){for(le=Math.random,$=ne-1;$>=1;$-=2)xe[$]=le(),xe[$-1]=le();return $===0&&(xe[0]=le()),xe}for($=ne-1;$>=0;$--)xe[$]=W(A,V+1);return xe},p2.random=function(W){return p2._random(W,0)},p2.norm2=function(W){return Math.sqrt(p2.norm2Squared(W))},p2.linspace=function(W,A,V){if(typeof V>"u"&&(V=Math.max(Math.round(A-W)+1,1)),V<2)return V===1?[W]:[];var $,ne=Array(V);for(V--,$=V;$>=0;$--)ne[$]=($*A+(V-$)*W)/V;return ne},p2.getBlock=function(W,A,V){var $=p2.dim(W);function ne(xe,le){var ce,ue=A[le],Te=V[le]-ue,Me=Array(Te);if(le===$.length-1){for(ce=Te;ce>=0;ce--)Me[ce]=xe[ce+ue];return Me}for(ce=Te;ce>=0;ce--)Me[ce]=ne(xe[ce+ue],le+1);return Me}return ne(W,0)},p2.setBlock=function(W,A,V,$){var ne=p2.dim(W);function xe(le,ce,ue){var Te,Me=A[ue],Re=V[ue]-Me;if(ue===ne.length-1)for(Te=Re;Te>=0;Te--)le[Te+Me]=ce[Te];for(Te=Re;Te>=0;Te--)xe(le[Te+Me],ce[Te],ue+1)}return xe(W,$,0),W},p2.getRange=function(W,A,V){var $=A.length,ne=V.length,xe,le,ce=Array($),ue,Te;for(xe=$-1;xe!==-1;--xe)for(ce[xe]=Array(ne),ue=ce[xe],Te=W[A[xe]],le=ne-1;le!==-1;--le)ue[le]=Te[V[le]];return ce},p2.blockMatrix=function(W){var A=p2.dim(W);if(A.length<4)return p2.blockMatrix([W]);var V=A[0],$=A[1],ne,xe,le,ce,ue;for(ne=0,xe=0,le=0;le<V;++le)ne+=W[le][0].length;for(ce=0;ce<$;++ce)xe+=W[0][ce][0].length;var Te=Array(ne);for(le=0;le<ne;++le)Te[le]=Array(xe);var Me=0,Re,we,ke,Ue,Ge;for(le=0;le<V;++le){for(Re=xe,ce=$-1;ce!==-1;--ce)for(ue=W[le][ce],Re-=ue[0].length,ke=ue.length-1;ke!==-1;--ke)for(Ge=ue[ke],we=Te[Me+ke],Ue=Ge.length-1;Ue!==-1;--Ue)we[Re+Ue]=Ge[Ue];Me+=W[le][0].length}return Te},p2.tensor=function(W,A){if(typeof W=="number"||typeof A=="number")return p2.mul(W,A);var V=p2.dim(W),$=p2.dim(A);if(V.length!==1||$.length!==1)throw new Error("numeric: tensor product is only defined for vectors");var ne=V[0],xe=$[0],le=Array(ne),ce,ue,Te,Me;for(ue=ne-1;ue>=0;ue--){for(ce=Array(xe),Me=W[ue],Te=xe-1;Te>=3;--Te)ce[Te]=Me*A[Te],--Te,ce[Te]=Me*A[Te],--Te,ce[Te]=Me*A[Te],--Te,ce[Te]=Me*A[Te];for(;Te>=0;)ce[Te]=Me*A[Te],--Te;le[ue]=ce}return le},p2.T=function(W,A){this.x=W,this.y=A},p2.t=function(W,A){return new p2.T(W,A)},p2.Tbinop=function(W,A,V,$,ne){if(p2.indexOf,typeof ne!="string"){var xe;ne="";for(xe in p2)p2.hasOwnProperty(xe)&&(W.indexOf(xe)>=0||A.indexOf(xe)>=0||V.indexOf(xe)>=0||$.indexOf(xe)>=0)&&xe.length>1&&(ne+="var "+xe+" = numeric."+xe+`;
`)}return Function(["y"],`var x = this;
if(!(y instanceof numeric.T)) { y = new numeric.T(y); }
`+ne+`
if(x.y) {  if(y.y) {    return new numeric.T(`+$+`);
  }
  return new numeric.T(`+V+`);
}
if(y.y) {
  return new numeric.T(`+A+`);
}
return new numeric.T(`+W+`);
`)},p2.T.prototype.add=p2.Tbinop("add(x.x,y.x)","add(x.x,y.x),y.y","add(x.x,y.x),x.y","add(x.x,y.x),add(x.y,y.y)"),p2.T.prototype.sub=p2.Tbinop("sub(x.x,y.x)","sub(x.x,y.x),neg(y.y)","sub(x.x,y.x),x.y","sub(x.x,y.x),sub(x.y,y.y)"),p2.T.prototype.mul=p2.Tbinop("mul(x.x,y.x)","mul(x.x,y.x),mul(x.x,y.y)","mul(x.x,y.x),mul(x.y,y.x)","sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))"),p2.T.prototype.reciprocal=function(){var W=p2.mul,A=p2.div;if(this.y){var V=p2.add(W(this.x,this.x),W(this.y,this.y));return new p2.T(A(this.x,V),A(p2.neg(this.y),V))}return new T(A(1,this.x))},p2.T.prototype.div=function(W){if(W instanceof p2.T||(W=new p2.T(W)),W.y)return this.mul(W.reciprocal());var A=p2.div;return this.y?new p2.T(A(this.x,W.x),A(this.y,W.x)):new p2.T(A(this.x,W.x))},p2.T.prototype.dot=p2.Tbinop("dot(x.x,y.x)","dot(x.x,y.x),dot(x.x,y.y)","dot(x.x,y.x),dot(x.y,y.x)","sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))"),p2.T.prototype.transpose=function(){var W=p2.transpose,A=this.x,V=this.y;return V?new p2.T(W(A),W(V)):new p2.T(W(A))},p2.T.prototype.transjugate=function(){var W=p2.transpose,A=this.x,V=this.y;return V?new p2.T(W(A),p2.negtranspose(V)):new p2.T(W(A))},p2.Tunop=function(W,A,V){return typeof V!="string"&&(V=""),Function(`var x = this;
`+V+`
if(x.y) {  `+A+`;
}
`+W+`;
`)},p2.T.prototype.exp=p2.Tunop("return new numeric.T(ex)","return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))","var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;"),p2.T.prototype.conj=p2.Tunop("return new numeric.T(x.x);","return new numeric.T(x.x,numeric.neg(x.y));"),p2.T.prototype.neg=p2.Tunop("return new numeric.T(neg(x.x));","return new numeric.T(neg(x.x),neg(x.y));","var neg = numeric.neg;"),p2.T.prototype.sin=p2.Tunop("return new numeric.T(numeric.sin(x.x))","return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));"),p2.T.prototype.cos=p2.Tunop("return new numeric.T(numeric.cos(x.x))","return x.exp().add(x.neg().exp()).div(2);"),p2.T.prototype.abs=p2.Tunop("return new numeric.T(numeric.abs(x.x));","return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));","var mul = numeric.mul;"),p2.T.prototype.log=p2.Tunop("return new numeric.T(numeric.log(x.x));",`var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();
return new numeric.T(numeric.log(r.x),theta.x);`),p2.T.prototype.norm2=p2.Tunop("return numeric.norm2(x.x);",`var f = numeric.norm2Squared;
return Math.sqrt(f(x.x)+f(x.y));`),p2.T.prototype.inv=function(){var W=this;if(typeof W.y>"u")return new p2.T(p2.inv(W.x));var A=W.x.length,Ue,Ge,We,V=p2.identity(A),$=p2.rep([A,A],0),ne=p2.clone(W.x),xe=p2.clone(W.y),le,ce,ue,Te,Me,Re,we,ke,Ue,Ge,We,Xe,Ye,je,Ke,qe,$e,vt;for(Ue=0;Ue<A;Ue++){for(je=ne[Ue][Ue],Ke=xe[Ue][Ue],Xe=je*je+Ke*Ke,We=Ue,Ge=Ue+1;Ge<A;Ge++)je=ne[Ge][Ue],Ke=xe[Ge][Ue],Ye=je*je+Ke*Ke,Ye>Xe&&(We=Ge,Xe=Ye);for(We!==Ue&&(vt=ne[Ue],ne[Ue]=ne[We],ne[We]=vt,vt=xe[Ue],xe[Ue]=xe[We],xe[We]=vt,vt=V[Ue],V[Ue]=V[We],V[We]=vt,vt=$[Ue],$[Ue]=$[We],$[We]=vt),le=ne[Ue],ce=xe[Ue],Me=V[Ue],Re=$[Ue],je=le[Ue],Ke=ce[Ue],Ge=Ue+1;Ge<A;Ge++)qe=le[Ge],$e=ce[Ge],le[Ge]=(qe*je+$e*Ke)/Xe,ce[Ge]=($e*je-qe*Ke)/Xe;for(Ge=0;Ge<A;Ge++)qe=Me[Ge],$e=Re[Ge],Me[Ge]=(qe*je+$e*Ke)/Xe,Re[Ge]=($e*je-qe*Ke)/Xe;for(Ge=Ue+1;Ge<A;Ge++){for(ue=ne[Ge],Te=xe[Ge],we=V[Ge],ke=$[Ge],je=ue[Ue],Ke=Te[Ue],We=Ue+1;We<A;We++)qe=le[We],$e=ce[We],ue[We]-=qe*je-$e*Ke,Te[We]-=$e*je+qe*Ke;for(We=0;We<A;We++)qe=Me[We],$e=Re[We],we[We]-=qe*je-$e*Ke,ke[We]-=$e*je+qe*Ke}}for(Ue=A-1;Ue>0;Ue--)for(Me=V[Ue],Re=$[Ue],Ge=Ue-1;Ge>=0;Ge--)for(we=V[Ge],ke=$[Ge],je=ne[Ge][Ue],Ke=xe[Ge][Ue],We=A-1;We>=0;We--)qe=Me[We],$e=Re[We],we[We]-=je*qe-Ke*$e,ke[We]-=je*$e+Ke*qe;return new p2.T(V,$)},p2.T.prototype.get=function(W){var A=this.x,V=this.y,$=0,ne,xe=W.length;if(V){for(;$<xe;)ne=W[$],A=A[ne],V=V[ne],$++;return new p2.T(A,V)}for(;$<xe;)ne=W[$],A=A[ne],$++;return new p2.T(A)},p2.T.prototype.set=function(W,A){var V=this.x,$=this.y,ne=0,xe,le=W.length,ce=A.x,ue=A.y;if(le===0)return ue?this.y=ue:$&&(this.y=void 0),this.x=V,this;if(ue){for($||($=p2.rep(p2.dim(V),0),this.y=$);ne<le-1;)xe=W[ne],V=V[xe],$=$[xe],ne++;return xe=W[ne],V[xe]=ce,$[xe]=ue,this}if($){for(;ne<le-1;)xe=W[ne],V=V[xe],$=$[xe],ne++;return xe=W[ne],V[xe]=ce,ce instanceof Array?$[xe]=p2.rep(p2.dim(ce),0):$[xe]=0,this}for(;ne<le-1;)xe=W[ne],V=V[xe],ne++;return xe=W[ne],V[xe]=ce,this},p2.T.prototype.getRows=function(W,A){var V=A-W+1,$,ne=Array(V),xe,le=this.x,ce=this.y;for($=W;$<=A;$++)ne[$-W]=le[$];if(ce){for(xe=Array(V),$=W;$<=A;$++)xe[$-W]=ce[$];return new p2.T(ne,xe)}return new p2.T(ne)},p2.T.prototype.setRows=function(W,A,V){var $,ne=this.x,xe=this.y,le=V.x,ce=V.y;for($=W;$<=A;$++)ne[$]=le[$-W];if(ce)for(xe||(xe=p2.rep(p2.dim(ne),0),this.y=xe),$=W;$<=A;$++)xe[$]=ce[$-W];else if(xe)for($=W;$<=A;$++)xe[$]=p2.rep([le[$-W].length],0);return this},p2.T.prototype.getRow=function(W){var A=this.x,V=this.y;return V?new p2.T(A[W],V[W]):new p2.T(A[W])},p2.T.prototype.setRow=function(W,A){var V=this.x,$=this.y,ne=A.x,xe=A.y;return V[W]=ne,xe?($||($=p2.rep(p2.dim(V),0),this.y=$),$[W]=xe):$&&($=p2.rep([ne.length],0)),this},p2.T.prototype.getBlock=function(W,A){var V=this.x,$=this.y,ne=p2.getBlock;return $?new p2.T(ne(V,W,A),ne($,W,A)):new p2.T(ne(V,W,A))},p2.T.prototype.setBlock=function(W,A,V){V instanceof p2.T||(V=new p2.T(V));var $=this.x,ne=this.y,xe=p2.setBlock,le=V.x,ce=V.y;if(ce)return ne||(this.y=p2.rep(p2.dim(this),0),ne=this.y),xe($,W,A,le),xe(ne,W,A,ce),this;xe($,W,A,le),ne&&xe(ne,W,A,p2.rep(p2.dim(le),0))},p2.T.rep=function(W,A){var V=p2.T;A instanceof V||(A=new V(A));var $=A.x,ne=A.y,xe=p2.rep;return ne?new V(xe(W,$),xe(W,ne)):new V(xe(W,$))},p2.T.diag=function(W){W instanceof p2.T||(W=new p2.T(W));var A=W.x,V=W.y,$=p2.diag;return V?new p2.T($(A),$(V)):new p2.T($(A))},p2.T.eig=function(){if(this.y)throw new Error("eig: not implemented for complex matrices.");return p2.eig(this.x)},p2.T.identity=function(W){return new p2.T(p2.identity(W))},p2.T.prototype.getDiag=function(){var W=p2,A=this.x,V=this.y;return V?new W.T(W.getDiag(A),W.getDiag(V)):new W.T(W.getDiag(A))},p2.house=function(W){var A=p2.clone(W),V=W[0]>=0?1:-1,$=V*p2.norm2(W);A[0]+=$;var ne=p2.norm2(A);if(ne===0)throw new Error("eig: internal error");return p2.div(A,ne)},p2.toUpperHessenberg=function(W){var A=p2.dim(W);if(A.length!==2||A[0]!==A[1])throw new Error("numeric: toUpperHessenberg() only works on square matrices");var V=A[0],$,ne,xe,le,ce,ue=p2.clone(W),Te,Me,Re,we,ke=p2.identity(V),Ue;for(ne=0;ne<V-2;ne++){for(le=Array(V-ne-1),$=ne+1;$<V;$++)le[$-ne-1]=ue[$][ne];if(p2.norm2(le)>0){for(ce=p2.house(le),Te=p2.getBlock(ue,[ne+1,ne],[V-1,V-1]),Me=p2.tensor(ce,p2.dot(ce,Te)),$=ne+1;$<V;$++)for(Re=ue[$],we=Me[$-ne-1],xe=ne;xe<V;xe++)Re[xe]-=2*we[xe-ne];for(Te=p2.getBlock(ue,[0,ne+1],[V-1,V-1]),Me=p2.tensor(p2.dot(Te,ce),ce),$=0;$<V;$++)for(Re=ue[$],we=Me[$],xe=ne+1;xe<V;xe++)Re[xe]-=2*we[xe-ne-1];for(Te=Array(V-ne-1),$=ne+1;$<V;$++)Te[$-ne-1]=ke[$];for(Me=p2.tensor(ce,p2.dot(ce,Te)),$=ne+1;$<V;$++)for(Ue=ke[$],we=Me[$-ne-1],xe=0;xe<V;xe++)Ue[xe]-=2*we[xe]}}return{H:ue,Q:ke}},p2.epsilon=2220446049250313e-31,p2.QRFrancis=function(W,A){typeof A>"u"&&(A=1e4),W=p2.clone(W),p2.clone(W);var V=p2.dim(W),$=V[0],ne,xe,le,ce,ue,Te,Me,Re,we,ke=p2.identity($),Ue,Ge,We,Xe,Ye,je,Ke,qe,$e;if($<3)return{Q:ke,B:[[0,$-1]]};var vt=p2.epsilon;for($e=0;$e<A;$e++){for(Ke=0;Ke<$-1;Ke++)if(Math.abs(W[Ke+1][Ke])<vt*(Math.abs(W[Ke][Ke])+Math.abs(W[Ke+1][Ke+1]))){var nt=p2.QRFrancis(p2.getBlock(W,[0,0],[Ke,Ke]),A),wt=p2.QRFrancis(p2.getBlock(W,[Ke+1,Ke+1],[$-1,$-1]),A);for(We=Array(Ke+1),je=0;je<=Ke;je++)We[je]=ke[je];for(Xe=p2.dot(nt.Q,We),je=0;je<=Ke;je++)ke[je]=Xe[je];for(We=Array($-Ke-1),je=Ke+1;je<$;je++)We[je-Ke-1]=ke[je];for(Xe=p2.dot(wt.Q,We),je=Ke+1;je<$;je++)ke[je]=Xe[je-Ke-1];return{Q:ke,B:nt.B.concat(p2.add(wt.B,Ke+1))}}if(le=W[$-2][$-2],ce=W[$-2][$-1],ue=W[$-1][$-2],Te=W[$-1][$-1],Re=le+Te,Me=le*Te-ce*ue,we=p2.getBlock(W,[0,0],[2,2]),Re*Re>=4*Me){var Kt,Ht;Kt=.5*(Re+Math.sqrt(Re*Re-4*Me)),Ht=.5*(Re-Math.sqrt(Re*Re-4*Me)),we=p2.add(p2.sub(p2.dot(we,we),p2.mul(we,Kt+Ht)),p2.diag(p2.rep([3],Kt*Ht)))}else we=p2.add(p2.sub(p2.dot(we,we),p2.mul(we,Re)),p2.diag(p2.rep([3],Me)));for(ne=[we[0][0],we[1][0],we[2][0]],xe=p2.house(ne),We=[W[0],W[1],W[2]],Xe=p2.tensor(xe,p2.dot(xe,We)),je=0;je<3;je++)for(Ge=W[je],Ye=Xe[je],qe=0;qe<$;qe++)Ge[qe]-=2*Ye[qe];for(We=p2.getBlock(W,[0,0],[$-1,2]),Xe=p2.tensor(p2.dot(We,xe),xe),je=0;je<$;je++)for(Ge=W[je],Ye=Xe[je],qe=0;qe<3;qe++)Ge[qe]-=2*Ye[qe];for(We=[ke[0],ke[1],ke[2]],Xe=p2.tensor(xe,p2.dot(xe,We)),je=0;je<3;je++)for(Ue=ke[je],Ye=Xe[je],qe=0;qe<$;qe++)Ue[qe]-=2*Ye[qe];var pi;for(Ke=0;Ke<$-2;Ke++){for(qe=Ke;qe<=Ke+1;qe++)if(Math.abs(W[qe+1][qe])<vt*(Math.abs(W[qe][qe])+Math.abs(W[qe+1][qe+1]))){var nt=p2.QRFrancis(p2.getBlock(W,[0,0],[qe,qe]),A),wt=p2.QRFrancis(p2.getBlock(W,[qe+1,qe+1],[$-1,$-1]),A);for(We=Array(qe+1),je=0;je<=qe;je++)We[je]=ke[je];for(Xe=p2.dot(nt.Q,We),je=0;je<=qe;je++)ke[je]=Xe[je];for(We=Array($-qe-1),je=qe+1;je<$;je++)We[je-qe-1]=ke[je];for(Xe=p2.dot(wt.Q,We),je=qe+1;je<$;je++)ke[je]=Xe[je-qe-1];return{Q:ke,B:nt.B.concat(p2.add(wt.B,qe+1))}}for(pi=Math.min($-1,Ke+3),ne=Array(pi-Ke),je=Ke+1;je<=pi;je++)ne[je-Ke-1]=W[je][Ke];for(xe=p2.house(ne),We=p2.getBlock(W,[Ke+1,Ke],[pi,$-1]),Xe=p2.tensor(xe,p2.dot(xe,We)),je=Ke+1;je<=pi;je++)for(Ge=W[je],Ye=Xe[je-Ke-1],qe=Ke;qe<$;qe++)Ge[qe]-=2*Ye[qe-Ke];for(We=p2.getBlock(W,[0,Ke+1],[$-1,pi]),Xe=p2.tensor(p2.dot(We,xe),xe),je=0;je<$;je++)for(Ge=W[je],Ye=Xe[je],qe=Ke+1;qe<=pi;qe++)Ge[qe]-=2*Ye[qe-Ke-1];for(We=Array(pi-Ke),je=Ke+1;je<=pi;je++)We[je-Ke-1]=ke[je];for(Xe=p2.tensor(xe,p2.dot(xe,We)),je=Ke+1;je<=pi;je++)for(Ue=ke[je],Ye=Xe[je-Ke-1],qe=0;qe<$;qe++)Ue[qe]-=2*Ye[qe]}}throw new Error("numeric: eigenvalue iteration does not converge -- increase maxiter?")},p2.eig=function(W,A){var V=p2.toUpperHessenberg(W),$=p2.QRFrancis(V.H,A),ne=p2.T,pi=W.length,xe,le,ce=$.B,ue=p2.dot($.Q,p2.dot(V.H,p2.transpose($.Q))),Te=new ne(p2.dot($.Q,V.Q)),Me,Re=ce.length,we,ke,Ue,Ge,We,Xe,Ye,je,Ke,qe,$e,vt,nt,wt,Kt=Math.sqrt;for(le=0;le<Re;le++)if(xe=ce[le][0],xe!==ce[le][1]){if(we=xe+1,ke=ue[xe][xe],Ue=ue[xe][we],Ge=ue[we][xe],We=ue[we][we],Ue===0&&Ge===0)continue;Xe=-ke-We,Ye=ke*We-Ue*Ge,je=Xe*Xe-4*Ye,je>=0?(Xe<0?Ke=-.5*(Xe-Kt(je)):Ke=-.5*(Xe+Kt(je)),nt=(ke-Ke)*(ke-Ke)+Ue*Ue,wt=Ge*Ge+(We-Ke)*(We-Ke),nt>wt?(nt=Kt(nt),$e=(ke-Ke)/nt,vt=Ue/nt):(wt=Kt(wt),$e=Ge/wt,vt=(We-Ke)/wt),Me=new ne([[vt,-$e],[$e,vt]]),Te.setRows(xe,we,Me.dot(Te.getRows(xe,we)))):(Ke=-.5*Xe,qe=.5*Kt(-je),nt=(ke-Ke)*(ke-Ke)+Ue*Ue,wt=Ge*Ge+(We-Ke)*(We-Ke),nt>wt?(nt=Kt(nt+qe*qe),$e=(ke-Ke)/nt,vt=Ue/nt,Ke=0,qe/=nt):(wt=Kt(wt+qe*qe),$e=Ge/wt,vt=(We-Ke)/wt,Ke=qe/wt,qe=0),Me=new ne([[vt,-$e],[$e,vt]],[[Ke,qe],[qe,-Ke]]),Te.setRows(xe,we,Me.dot(Te.getRows(xe,we))))}var Ht=Te.dot(W).dot(Te.transjugate()),pi=W.length,hi=p2.T.identity(pi);for(we=0;we<pi;we++)if(we>0)for(le=we-1;le>=0;le--){var ai=Ht.get([le,le]),Yi=Ht.get([we,we]);if(p2.neq(ai.x,Yi.x)||p2.neq(ai.y,Yi.y))Ke=Ht.getRow(le).getBlock([le],[we-1]),qe=hi.getRow(we).getBlock([le],[we-1]),hi.set([we,le],Ht.get([le,we]).neg().sub(Ke.dot(qe)).div(ai.sub(Yi)));else{hi.setRow(we,hi.getRow(le));continue}}for(we=0;we<pi;we++)Ke=hi.getRow(we),hi.setRow(we,Ke.div(Ke.norm2()));return hi=hi.transpose(),hi=Te.transjugate().dot(hi),{lambda:Ht.getDiag(),E:hi}},p2.ccsSparse=function(W){var A=W.length,le,V,$,ne,xe=[];for($=A-1;$!==-1;--$){V=W[$];for(ne in V){for(ne=parseInt(ne);ne>=xe.length;)xe[xe.length]=0;V[ne]!==0&&xe[ne]++}}var le=xe.length,ce=Array(le+1);for(ce[0]=0,$=0;$<le;++$)ce[$+1]=ce[$]+xe[$];var ue=Array(ce[le]),Te=Array(ce[le]);for($=A-1;$!==-1;--$){V=W[$];for(ne in V)V[ne]!==0&&(xe[ne]--,ue[ce[ne]+xe[ne]]=$,Te[ce[ne]+xe[ne]]=V[ne])}return[ce,ue,Te]},p2.ccsFull=function(W){var A=W[0],V=W[1],$=W[2],ne=p2.ccsDim(W),xe=ne[0],le=ne[1],ce,ue,Te,Me,Re=p2.rep([xe,le],0);for(ce=0;ce<le;ce++)for(Te=A[ce],Me=A[ce+1],ue=Te;ue<Me;++ue)Re[V[ue]][ce]=$[ue];return Re},p2.ccsTSolve=function(W,A,V,$,ne){var xe=W[0],le=W[1],ce=W[2],ue=xe.length-1,Te=Math.max,Me=0;typeof $>"u"&&(V=p2.rep([ue],0)),typeof $>"u"&&($=p2.linspace(0,V.length-1)),typeof ne>"u"&&(ne=[]);function Re(je){var Ke;if(V[je]===0){for(V[je]=1,Ke=xe[je];Ke<xe[je+1];++Ke)Re(le[Ke]);ne[Me]=je,++Me}}var we,ke,Ue,Ge,We,Xe,Ye;for(we=$.length-1;we!==-1;--we)Re($[we]);for(ne.length=Me,we=ne.length-1;we!==-1;--we)V[ne[we]]=0;for(we=$.length-1;we!==-1;--we)ke=$[we],V[ke]=A[ke];for(we=ne.length-1;we!==-1;--we){for(ke=ne[we],Ue=xe[ke],Ge=Te(xe[ke+1],Ue),We=Ue;We!==Ge;++We)if(le[We]===ke){V[ke]/=ce[We];break}for(Ye=V[ke],We=Ue;We!==Ge;++We)Xe=le[We],Xe!==ke&&(V[Xe]-=Ye*ce[We])}return V},p2.ccsDFS=function(W){this.k=Array(W),this.k1=Array(W),this.j=Array(W)},p2.ccsDFS.prototype.dfs=function(W,A,V,$,ne,xe){var le=0,ce,ue=ne.length,Te=this.k,Me=this.k1,Re=this.j,we,ke;if($[W]===0)for($[W]=1,Re[0]=W,Te[0]=we=A[W],Me[0]=ke=A[W+1];;)if(we>=ke){if(ne[ue]=Re[le],le===0)return;++ue,--le,we=Te[le],ke=Me[le]}else ce=xe[V[we]],$[ce]===0?($[ce]=1,Te[le]=we,++le,Re[le]=ce,we=A[ce],Me[le]=ke=A[ce+1]):++we},p2.ccsLPSolve=function(W,A,V,$,ne,xe,le){var ce=W[0],ue=W[1],Te=W[2];ce.length-1;var Me=A[0],Re=A[1],we=A[2],ke,Ue,Ge,We,Xe,Ye,je,Ke,qe;for(Ue=Me[ne],Ge=Me[ne+1],$.length=0,ke=Ue;ke<Ge;++ke)le.dfs(xe[Re[ke]],ce,ue,V,$,xe);for(ke=$.length-1;ke!==-1;--ke)V[$[ke]]=0;for(ke=Ue;ke!==Ge;++ke)We=xe[Re[ke]],V[We]=we[ke];for(ke=$.length-1;ke!==-1;--ke){for(We=$[ke],Xe=ce[We],Ye=ce[We+1],je=Xe;je<Ye;++je)if(xe[ue[je]]===We){V[We]/=Te[je];break}for(qe=V[We],je=Xe;je<Ye;++je)Ke=xe[ue[je]],Ke!==We&&(V[Ke]-=qe*Te[je])}return V},p2.ccsLUP1=function(W,A){var V=W[0].length-1,$=[p2.rep([V+1],0),[],[]],ne=[p2.rep([V+1],0),[],[]],xe=$[0],le=$[1],ce=$[2],ue=ne[0],Te=ne[1],Me=ne[2],Re=p2.rep([V],0),we=p2.rep([V],0),ke,Ue,Ge,We,Xe,Ye,je,Ke=p2.ccsLPSolve,qe=Math.abs,$e=p2.linspace(0,V-1),vt=p2.linspace(0,V-1),nt=new p2.ccsDFS(V);for(typeof A>"u"&&(A=1),ke=0;ke<V;++ke){for(Ke($,W,Re,we,ke,vt,nt),We=-1,Xe=-1,Ue=we.length-1;Ue!==-1;--Ue)Ge=we[Ue],!(Ge<=ke)&&(Ye=qe(Re[Ge]),Ye>We&&(Xe=Ge,We=Ye));for(qe(Re[ke])<A*We&&(Ue=$e[ke],We=$e[Xe],$e[ke]=We,vt[We]=ke,$e[Xe]=Ue,vt[Ue]=Xe,We=Re[ke],Re[ke]=Re[Xe],Re[Xe]=We),We=xe[ke],Xe=ue[ke],je=Re[ke],le[We]=$e[ke],ce[We]=1,++We,Ue=we.length-1;Ue!==-1;--Ue)Ge=we[Ue],Ye=Re[Ge],we[Ue]=0,Re[Ge]=0,Ge<=ke?(Te[Xe]=Ge,Me[Xe]=Ye,++Xe):(le[We]=$e[Ge],ce[We]=Ye/je,++We);xe[ke+1]=We,ue[ke+1]=Xe}for(Ue=le.length-1;Ue!==-1;--Ue)le[Ue]=vt[le[Ue]];return{L:$,U:ne,P:$e,Pinv:vt}},p2.ccsDFS0=function(W){this.k=Array(W),this.k1=Array(W),this.j=Array(W)},p2.ccsDFS0.prototype.dfs=function(W,A,V,$,ne,xe,le){var ce=0,ue,Te=ne.length,Me=this.k,Re=this.k1,we=this.j,ke,Ue;if($[W]===0)for($[W]=1,we[0]=W,Me[0]=ke=A[xe[W]],Re[0]=Ue=A[xe[W]+1];;){if(isNaN(ke))throw new Error("Ow!");if(ke>=Ue){if(ne[Te]=xe[we[ce]],ce===0)return;++Te,--ce,ke=Me[ce],Ue=Re[ce]}else ue=V[ke],$[ue]===0?($[ue]=1,Me[ce]=ke,++ce,we[ce]=ue,ue=xe[ue],ke=A[ue],Re[ce]=Ue=A[ue+1]):++ke}},p2.ccsLPSolve0=function(W,A,V,$,ne,xe,le,ce){var ue=W[0],Te=W[1],Me=W[2];ue.length-1;var Re=A[0],we=A[1],ke=A[2],Ue,Ge,We,Xe,Ye,je,Ke,qe,$e;for(Ge=Re[ne],We=Re[ne+1],$.length=0,Ue=Ge;Ue<We;++Ue)ce.dfs(we[Ue],ue,Te,V,$,xe,le);for(Ue=$.length-1;Ue!==-1;--Ue)Xe=$[Ue],V[le[Xe]]=0;for(Ue=Ge;Ue!==We;++Ue)Xe=we[Ue],V[Xe]=ke[Ue];for(Ue=$.length-1;Ue!==-1;--Ue){for(Xe=$[Ue],qe=le[Xe],Ye=ue[Xe],je=ue[Xe+1],Ke=Ye;Ke<je;++Ke)if(Te[Ke]===qe){V[qe]/=Me[Ke];break}for($e=V[qe],Ke=Ye;Ke<je;++Ke)V[Te[Ke]]-=$e*Me[Ke];V[qe]=$e}},p2.ccsLUP0=function(W,A){var V=W[0].length-1,$=[p2.rep([V+1],0),[],[]],ne=[p2.rep([V+1],0),[],[]],xe=$[0],le=$[1],ce=$[2],ue=ne[0],Te=ne[1],Me=ne[2],Re=p2.rep([V],0),we=p2.rep([V],0),ke,Ue,Ge,We,Xe,Ye,je,Ke=p2.ccsLPSolve0,qe=Math.abs,$e=p2.linspace(0,V-1),vt=p2.linspace(0,V-1),nt=new p2.ccsDFS0(V);for(typeof A>"u"&&(A=1),ke=0;ke<V;++ke){for(Ke($,W,Re,we,ke,vt,$e,nt),We=-1,Xe=-1,Ue=we.length-1;Ue!==-1;--Ue)Ge=we[Ue],!(Ge<=ke)&&(Ye=qe(Re[$e[Ge]]),Ye>We&&(Xe=Ge,We=Ye));for(qe(Re[$e[ke]])<A*We&&(Ue=$e[ke],We=$e[Xe],$e[ke]=We,vt[We]=ke,$e[Xe]=Ue,vt[Ue]=Xe),We=xe[ke],Xe=ue[ke],je=Re[$e[ke]],le[We]=$e[ke],ce[We]=1,++We,Ue=we.length-1;Ue!==-1;--Ue)Ge=we[Ue],Ye=Re[$e[Ge]],we[Ue]=0,Re[$e[Ge]]=0,Ge<=ke?(Te[Xe]=Ge,Me[Xe]=Ye,++Xe):(le[We]=$e[Ge],ce[We]=Ye/je,++We);xe[ke+1]=We,ue[ke+1]=Xe}for(Ue=le.length-1;Ue!==-1;--Ue)le[Ue]=vt[le[Ue]];return{L:$,U:ne,P:$e,Pinv:vt}},p2.ccsLUP=p2.ccsLUP0,p2.ccsDim=function(W){return[p2.sup(W[1])+1,W[0].length-1]},p2.ccsGetBlock=function(W,A,V){var $=p2.ccsDim(W),ne=$[0],xe=$[1];typeof A>"u"?A=p2.linspace(0,ne-1):typeof A=="number"&&(A=[A]),typeof V>"u"?V=p2.linspace(0,xe-1):typeof V=="number"&&(V=[V]);var le,ce=A.length,ue,Te=V.length,Me,Re,we,ke=p2.rep([xe],0),Ue=[],Ge=[],We=[ke,Ue,Ge],Xe=W[0],Ye=W[1],je=W[2],Ke=p2.rep([ne],0),qe=0,$e=p2.rep([ne],0);for(ue=0;ue<Te;++ue){Re=V[ue];var vt=Xe[Re],nt=Xe[Re+1];for(le=vt;le<nt;++le)Me=Ye[le],$e[Me]=1,Ke[Me]=je[le];for(le=0;le<ce;++le)we=A[le],$e[we]&&(Ue[qe]=le,Ge[qe]=Ke[A[le]],++qe);for(le=vt;le<nt;++le)Me=Ye[le],$e[Me]=0;ke[ue+1]=qe}return We},p2.ccsDot=function(W,A){var V=W[0],$=W[1],ne=W[2],xe=A[0],le=A[1],ce=A[2],ue=p2.ccsDim(W),Te=p2.ccsDim(A),Me=ue[0];ue[1];var Re=Te[1],we=p2.rep([Me],0),ke=p2.rep([Me],0),Ue=Array(Me),Ge=p2.rep([Re],0),We=[],Xe=[],Ye=[Ge,We,Xe],je,Ke,qe,$e,vt,nt,wt,Kt,Ht,pi,hi;for(qe=0;qe!==Re;++qe){for($e=xe[qe],vt=xe[qe+1],Ht=0,Ke=$e;Ke<vt;++Ke)for(pi=le[Ke],hi=ce[Ke],nt=V[pi],wt=V[pi+1],je=nt;je<wt;++je)Kt=$[je],ke[Kt]===0&&(Ue[Ht]=Kt,ke[Kt]=1,Ht=Ht+1),we[Kt]=we[Kt]+ne[je]*hi;for($e=Ge[qe],vt=$e+Ht,Ge[qe+1]=vt,Ke=Ht-1;Ke!==-1;--Ke)hi=$e+Ke,je=Ue[Ke],We[hi]=je,Xe[hi]=we[je],ke[je]=0,we[je]=0;Ge[qe+1]=Ge[qe]+Ht}return Ye},p2.ccsLUPSolve=function(W,A){var V=W.L,$=W.U;W.P;var ne=A[0],xe=!1;typeof ne!="object"&&(A=[[0,A.length],p2.linspace(0,A.length-1),A],ne=A[0],xe=!0);var le=A[1],ce=A[2],ue=V[0].length-1,Te=ne.length-1,Me=p2.rep([ue],0),Re=Array(ue),we=p2.rep([ue],0),ke=Array(ue),Ue=p2.rep([Te+1],0),Ge=[],We=[],Xe=p2.ccsTSolve,Ye,je,Ke,qe,$e,vt,nt=0;for(Ye=0;Ye<Te;++Ye){for($e=0,Ke=ne[Ye],qe=ne[Ye+1],je=Ke;je<qe;++je)vt=W.Pinv[le[je]],ke[$e]=vt,we[vt]=ce[je],++$e;for(ke.length=$e,Xe(V,we,Me,ke,Re),je=ke.length-1;je!==-1;--je)we[ke[je]]=0;if(Xe($,Me,we,Re,ke),xe)return we;for(je=Re.length-1;je!==-1;--je)Me[Re[je]]=0;for(je=ke.length-1;je!==-1;--je)vt=ke[je],Ge[nt]=vt,We[nt]=we[vt],we[vt]=0,++nt;Ue[Ye+1]=nt}return[Ue,Ge,We]},p2.ccsbinop=function(W,A){return typeof A>"u"&&(A=""),Function("X","Y",`var Xi = X[0], Xj = X[1], Xv = X[2];
var Yi = Y[0], Yj = Y[1], Yv = Y[2];
var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;
var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];
var x = numeric.rep([m],0),y = numeric.rep([m],0);
var xk,yk,zk;
var i,j,j0,j1,k,p=0;
`+A+`for(i=0;i<n;++i) {
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Xj[j];
    x[k] = 1;
    Zj[p] = k;
    ++p;
  }
  j0 = Yi[i]; j1 = Yi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Yj[j];
    y[k] = Yv[j];
    if(x[k] === 0) {
      Zj[p] = k;
      ++p;
    }
  }
  Zi[i+1] = p;
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];
  j0 = Zi[i]; j1 = Zi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Zj[j];
    xk = x[k];
    yk = y[k];
`+W+`
    Zv[j] = zk;
  }
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;
  j0 = Yi[i]; j1 = Yi[i+1];
  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;
}
return [Zi,Zj,Zv];`)},function(){var p9,pC,pm,pN;for(p9 in p2.ops2)isFinite(eval("1"+p2.ops2[p9]+"0"))?pC="[Y[0],Y[1],numeric."+p9+"(X,Y[2])]":pC="NaN",isFinite(eval("0"+p2.ops2[p9]+"1"))?pm="[X[0],X[1],numeric."+p9+"(X[2],Y)]":pm="NaN",isFinite(eval("1"+p2.ops2[p9]+"0"))&&isFinite(eval("0"+p2.ops2[p9]+"1"))?pN="numeric.ccs"+p9+"MM(X,Y)":pN="NaN",p2["ccs"+p9+"MM"]=p2.ccsbinop("zk = xk "+p2.ops2[p9]+"yk;"),p2["ccs"+p9]=Function("X","Y",'if(typeof X === "number") return '+pC+`;
if(typeof Y === "number") return `+pm+`;
return `+pN+`;
`)}(),p2.ccsScatter=function W(A){var V=A[0],$=A[1],ne=A[2],xe=p2.sup($)+1,le=V.length,ce=p2.rep([xe],0),ue=Array(le),Te=Array(le),Me=p2.rep([xe],0),Re;for(Re=0;Re<le;++Re)Me[$[Re]]++;for(Re=0;Re<xe;++Re)ce[Re+1]=ce[Re]+Me[Re];var we=ce.slice(0),ke,Ue;for(Re=0;Re<le;++Re)Ue=$[Re],ke=we[Ue],ue[ke]=V[Re],Te[ke]=ne[Re],we[Ue]=we[Ue]+1;return[ce,ue,Te]},p2.ccsGather=function W(A){var V=A[0],$=A[1],ne=A[2],xe=V.length-1,le=$.length,ce=Array(le),ue=Array(le),Te=Array(le),Me,Re,we,ke,Ue;for(Ue=0,Me=0;Me<xe;++Me)for(we=V[Me],ke=V[Me+1],Re=we;Re!==ke;++Re)ue[Ue]=Me,ce[Ue]=$[Re],Te[Ue]=ne[Re],++Ue;return[ce,ue,Te]},p2.sdim=function W(A,V,$){if(typeof V>"u"&&(V=[]),typeof A!="object")return V;typeof $>"u"&&($=0),$ in V||(V[$]=0),A.length>V[$]&&(V[$]=A.length);var ne;for(ne in A)A.hasOwnProperty(ne)&&W(A[ne],V,$+1);return V},p2.sclone=function W(A,V,$){typeof V>"u"&&(V=0),typeof $>"u"&&($=p2.sdim(A).length);var ne,xe=Array(A.length);if(V===$-1){for(ne in A)A.hasOwnProperty(ne)&&(xe[ne]=A[ne]);return xe}for(ne in A)A.hasOwnProperty(ne)&&(xe[ne]=W(A[ne],V+1,$));return xe},p2.sdiag=function W(A){var V=A.length,$,ne=Array(V),xe;for($=V-1;$>=1;$-=2)xe=$-1,ne[$]=[],ne[$][$]=A[$],ne[xe]=[],ne[xe][xe]=A[xe];return $===0&&(ne[0]=[],ne[0][0]=A[$]),ne},p2.sidentity=function W(A){return p2.sdiag(p2.rep([A],1))},p2.stranspose=function W(A){var V=[];A.length;var $,ne,xe;for($ in A)if(A.hasOwnProperty($)){xe=A[$];for(ne in xe)xe.hasOwnProperty(ne)&&(typeof V[ne]!="object"&&(V[ne]=[]),V[ne][$]=xe[ne])}return V},p2.sLUP=function W(A,V){throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.")},p2.sdotMM=function W(A,V){var $=A.length;V.length;var ne=p2.stranspose(V),xe=ne.length,le,ce,ue,Te,Me,Re,we=Array($),ke;for(ue=$-1;ue>=0;ue--){for(ke=[],le=A[ue],Me=xe-1;Me>=0;Me--){Re=0,ce=ne[Me];for(Te in le)le.hasOwnProperty(Te)&&Te in ce&&(Re+=le[Te]*ce[Te]);Re&&(ke[Me]=Re)}we[ue]=ke}return we},p2.sdotMV=function W(A,V){var $=A.length,ne,xe,le,ce=Array($),ue;for(xe=$-1;xe>=0;xe--){ne=A[xe],ue=0;for(le in ne)ne.hasOwnProperty(le)&&V[le]&&(ue+=ne[le]*V[le]);ue&&(ce[xe]=ue)}return ce},p2.sdotVM=function W(A,V){var $,ne,xe,le,ce=[];for($ in A)if(A.hasOwnProperty($)){xe=V[$],le=A[$];for(ne in xe)xe.hasOwnProperty(ne)&&(ce[ne]||(ce[ne]=0),ce[ne]+=le*xe[ne])}return ce},p2.sdotVV=function W(A,V){var $,ne=0;for($ in A)A[$]&&V[$]&&(ne+=A[$]*V[$]);return ne},p2.sdot=function W(A,V){var $=p2.sdim(A).length,ne=p2.sdim(V).length,xe=$*1e3+ne;switch(xe){case 0:return A*V;case 1001:return p2.sdotVV(A,V);case 2001:return p2.sdotMV(A,V);case 1002:return p2.sdotVM(A,V);case 2002:return p2.sdotMM(A,V);default:throw new Error("numeric.sdot not implemented for tensors of order "+$+" and "+ne)}},p2.sscatter=function W(A){var V=A[0].length,$,ne,xe,le=A.length,ce=[],ue;for(ne=V-1;ne>=0;--ne)if(A[le-1][ne]){for(ue=ce,xe=0;xe<le-2;xe++)$=A[xe][ne],ue[$]||(ue[$]=[]),ue=ue[$];ue[A[xe][ne]]=A[xe+1][ne]}return ce},p2.sgather=function W(A,V,$){typeof V>"u"&&(V=[]),typeof $>"u"&&($=[]);var ne,xe,le;ne=$.length;for(xe in A)if(A.hasOwnProperty(xe))if($[ne]=parseInt(xe),le=A[xe],typeof le=="number"){if(le){if(V.length===0)for(xe=ne+1;xe>=0;--xe)V[xe]=[];for(xe=ne;xe>=0;--xe)V[xe].push($[xe]);V[ne+1].push(le)}}else W(le,V,$);return $.length>ne&&$.pop(),V},p2.cLU=function W(A){var V=A[0],$=A[1],ne=A[2],wt=V.length,xe=0,le,ce,ue,Te,Me,Re;for(le=0;le<wt;le++)V[le]>xe&&(xe=V[le]);xe++;var we=Array(xe),ke=Array(xe),Ue=p2.rep([xe],1/0),Ge=p2.rep([xe],-1/0),je,Ke,We;for(ue=0;ue<wt;ue++)le=V[ue],ce=$[ue],ce<Ue[le]&&(Ue[le]=ce),ce>Ge[le]&&(Ge[le]=ce);for(le=0;le<xe-1;le++)Ge[le]>Ge[le+1]&&(Ge[le+1]=Ge[le]);for(le=xe-1;le>=1;le--)Ue[le]<Ue[le-1]&&(Ue[le-1]=Ue[le]);var Xe=0,Ye=0;for(le=0;le<xe;le++)ke[le]=p2.rep([Ge[le]-Ue[le]+1],0),we[le]=p2.rep([le-Ue[le]],0),Xe+=le-Ue[le]+1,Ye+=Ge[le]-le+1;for(ue=0;ue<wt;ue++)le=V[ue],ke[le][$[ue]-Ue[le]]=ne[ue];for(le=0;le<xe-1;le++)for(Te=le-Ue[le],je=ke[le],ce=le+1;Ue[ce]<=le&&ce<xe;ce++)if(Me=le-Ue[ce],Re=Ge[le]-le,Ke=ke[ce],We=Ke[Me]/je[Te],We){for(ue=1;ue<=Re;ue++)Ke[ue+Me]-=We*je[ue+Te];we[ce][le-Ue[ce]]=We}var je=[],Ke=[],qe=[],$e=[],vt=[],nt=[],wt,Kt,Ht;for(wt=0,Kt=0,le=0;le<xe;le++){for(Te=Ue[le],Me=Ge[le],Ht=ke[le],ce=le;ce<=Me;ce++)Ht[ce-Te]&&(je[wt]=le,Ke[wt]=ce,qe[wt]=Ht[ce-Te],wt++);for(Ht=we[le],ce=Te;ce<le;ce++)Ht[ce-Te]&&($e[Kt]=le,vt[Kt]=ce,nt[Kt]=Ht[ce-Te],Kt++);$e[Kt]=le,vt[Kt]=le,nt[Kt]=1,Kt++}return{U:[je,Ke,qe],L:[$e,vt,nt]}},p2.cLUsolve=function W(A,V){var $=A.L,ne=A.U,xe=p2.clone(V),le=$[0],ce=$[1],ue=$[2],Te=ne[0],Me=ne[1],Re=ne[2],we=Te.length;le.length;var ke=xe.length,Ue,Ge;for(Ge=0,Ue=0;Ue<ke;Ue++){for(;ce[Ge]<Ue;)xe[Ue]-=ue[Ge]*xe[ce[Ge]],Ge++;Ge++}for(Ge=we-1,Ue=ke-1;Ue>=0;Ue--){for(;Me[Ge]>Ue;)xe[Ue]-=Re[Ge]*xe[Me[Ge]],Ge--;xe[Ue]/=Re[Ge],Ge--}return xe},p2.cgrid=function W(A,V){typeof A=="number"&&(A=[A,A]);var $=p2.rep(A,-1),ne,xe,le;if(typeof V!="function")switch(V){case"L":V=function(ce,ue){return ce>=A[0]/2||ue<A[1]/2};break;default:V=function(ce,ue){return!0};break}for(le=0,ne=1;ne<A[0]-1;ne++)for(xe=1;xe<A[1]-1;xe++)V(ne,xe)&&($[ne][xe]=le,le++);return $},p2.cdelsq=function W(A){var V=[[-1,0],[0,-1],[0,1],[1,0]],$=p2.dim(A),ne=$[0],xe=$[1],le,ce,ue,Te,Me,Re=[],we=[],ke=[];for(le=1;le<ne-1;le++)for(ce=1;ce<xe-1;ce++)if(!(A[le][ce]<0)){for(ue=0;ue<4;ue++)Te=le+V[ue][0],Me=ce+V[ue][1],!(A[Te][Me]<0)&&(Re.push(A[le][ce]),we.push(A[Te][Me]),ke.push(-1));Re.push(A[le][ce]),we.push(A[le][ce]),ke.push(4)}return[Re,we,ke]},p2.cdotMV=function W(A,V){var $,ne=A[0],xe=A[1],le=A[2],ce,ue=ne.length,Te;for(Te=0,ce=0;ce<ue;ce++)ne[ce]>Te&&(Te=ne[ce]);for(Te++,$=p2.rep([Te],0),ce=0;ce<ue;ce++)$[ne[ce]]+=le[ce]*V[xe[ce]];return $},p2.Spline=function W(A,V,$,ne,xe){this.x=A,this.yl=V,this.yr=$,this.kl=ne,this.kr=xe},p2.Spline.prototype._at=function W(ue,V){var $=this.x,ne=this.yl,xe=this.yr,le=this.kl,ce=this.kr,ue,Te,Me,Re,we=p2.add,ke=p2.sub,Ue=p2.mul;Te=ke(Ue(le[V],$[V+1]-$[V]),ke(xe[V+1],ne[V])),Me=we(Ue(ce[V+1],$[V]-$[V+1]),ke(xe[V+1],ne[V])),Re=(ue-$[V])/($[V+1]-$[V]);var Ge=Re*(1-Re);return we(we(we(Ue(1-Re,ne[V]),Ue(Re,xe[V+1])),Ue(Te,Ge*(1-Re))),Ue(Me,Ge*Re))},p2.Spline.prototype.at=function W(A){if(typeof A=="number"){var V=this.x,ce=V.length,$,ne,xe,le=Math.floor;for($=0,ne=ce-1;ne-$>1;)xe=le(($+ne)/2),V[xe]<=A?$=xe:ne=xe;return this._at(A,$)}var ce=A.length,ue,Te=Array(ce);for(ue=ce-1;ue!==-1;--ue)Te[ue]=this.at(A[ue]);return Te},p2.Spline.prototype.diff=function W(){var A=this.x,V=this.yl,$=this.yr,ne=this.kl,xe=this.kr,le=V.length,ce,ue,Te,Me=ne,Re=xe,we=Array(le),ke=Array(le),Ue=p2.add,Ge=p2.mul,We=p2.div,Xe=p2.sub;for(ce=le-1;ce!==-1;--ce)ue=A[ce+1]-A[ce],Te=Xe($[ce+1],V[ce]),we[ce]=We(Ue(Ge(Te,6),Ge(ne[ce],-4*ue),Ge(xe[ce+1],-2*ue)),ue*ue),ke[ce+1]=We(Ue(Ge(Te,-6),Ge(ne[ce],2*ue),Ge(xe[ce+1],4*ue)),ue*ue);return new p2.Spline(A,Me,Re,we,ke)},p2.Spline.prototype.roots=function W(){function A(rs){return rs*rs}var We=[],V=this.x,$=this.yl,ne=this.yr,xe=this.kl,le=this.kr;typeof $[0]=="number"&&($=[$],ne=[ne],xe=[xe],le=[le]);var ce=$.length,ue=V.length-1,Te,Me,Re,we,ke,Ue,Ge,We=Array(ce),Xe,Ye,je,Ke,qe,$e,vt,nt,wt,Kt,Ht,pi,hi,ai,Yi,Wi,ls=Math.sqrt;for(Te=0;Te!==ce;++Te){for(we=$[Te],ke=ne[Te],Ue=xe[Te],Ge=le[Te],Xe=[],Me=0;Me!==ue;Me++){for(Me>0&&ke[Me]*we[Me]<0&&Xe.push(V[Me]),wt=V[Me+1]-V[Me],V[Me],Ke=we[Me],qe=ke[Me+1],Ye=Ue[Me]/wt,je=Ge[Me+1]/wt,nt=A(Ye-je+3*(Ke-qe))+12*je*Ke,$e=je+3*Ke+2*Ye-3*qe,vt=3*(je+Ye+2*(Ke-qe)),nt<=0?(Ht=$e/vt,Ht>V[Me]&&Ht<V[Me+1]?Kt=[V[Me],Ht,V[Me+1]]:Kt=[V[Me],V[Me+1]]):(Ht=($e-ls(nt))/vt,pi=($e+ls(nt))/vt,Kt=[V[Me]],Ht>V[Me]&&Ht<V[Me+1]&&Kt.push(Ht),pi>V[Me]&&pi<V[Me+1]&&Kt.push(pi),Kt.push(V[Me+1])),ai=Kt[0],Ht=this._at(ai,Me),Re=0;Re<Kt.length-1;Re++){if(Yi=Kt[Re+1],pi=this._at(Yi,Me),Ht===0){Xe.push(ai),ai=Yi,Ht=pi;continue}if(pi===0||Ht*pi>0){ai=Yi,Ht=pi;continue}for(var Hi=0;Wi=(Ht*Yi-pi*ai)/(Ht-pi),!(Wi<=ai||Wi>=Yi);)if(hi=this._at(Wi,Me),hi*pi>0)Yi=Wi,pi=hi,Hi===-1&&(Ht*=.5),Hi=-1;else if(hi*Ht>0)ai=Wi,Ht=hi,Hi===1&&(pi*=.5),Hi=1;else break;Xe.push(Wi),ai=Kt[Re+1],Ht=this._at(ai,Me)}pi===0&&Xe.push(Yi)}We[Te]=Xe}return typeof this.yl[0]=="number"?We[0]:We},p2.spline=function W(A,V,$,ne){var xe=A.length,le=[],ce=[],ue=[],Te,Me=p2.sub,Re=p2.mul,we=p2.add;for(Te=xe-2;Te>=0;Te--)ce[Te]=A[Te+1]-A[Te],ue[Te]=Me(V[Te+1],V[Te]);(typeof $=="string"||typeof ne=="string")&&($=ne="periodic");var ke=[[],[],[]];switch(typeof $){case"undefined":le[0]=Re(3/(ce[0]*ce[0]),ue[0]),ke[0].push(0,0),ke[1].push(0,1),ke[2].push(2/ce[0],1/ce[0]);break;case"string":le[0]=we(Re(3/(ce[xe-2]*ce[xe-2]),ue[xe-2]),Re(3/(ce[0]*ce[0]),ue[0])),ke[0].push(0,0,0),ke[1].push(xe-2,0,1),ke[2].push(1/ce[xe-2],2/ce[xe-2]+2/ce[0],1/ce[0]);break;default:le[0]=$,ke[0].push(0),ke[1].push(0),ke[2].push(1);break}for(Te=1;Te<xe-1;Te++)le[Te]=we(Re(3/(ce[Te-1]*ce[Te-1]),ue[Te-1]),Re(3/(ce[Te]*ce[Te]),ue[Te])),ke[0].push(Te,Te,Te),ke[1].push(Te-1,Te,Te+1),ke[2].push(1/ce[Te-1],2/ce[Te-1]+2/ce[Te],1/ce[Te]);switch(typeof ne){case"undefined":le[xe-1]=Re(3/(ce[xe-2]*ce[xe-2]),ue[xe-2]),ke[0].push(xe-1,xe-1),ke[1].push(xe-2,xe-1),ke[2].push(1/ce[xe-2],2/ce[xe-2]);break;case"string":ke[1][ke[1].length-1]=0;break;default:le[xe-1]=ne,ke[0].push(xe-1),ke[1].push(xe-1),ke[2].push(1);break}typeof le[0]!="number"?le=p2.transpose(le):le=[le];var Ue=Array(le.length);if(typeof $=="string")for(Te=Ue.length-1;Te!==-1;--Te)Ue[Te]=p2.ccsLUPSolve(p2.ccsLUP(p2.ccsScatter(ke)),le[Te]),Ue[Te][xe-1]=Ue[Te][0];else for(Te=Ue.length-1;Te!==-1;--Te)Ue[Te]=p2.cLUsolve(p2.cLU(ke),le[Te]);return typeof V[0]=="number"?Ue=Ue[0]:Ue=p2.transpose(Ue),new p2.Spline(A,V,V,Ue,Ue)},p2.fftpow2=function W(A,V){var $=A.length;if($!==1){var ne=Math.cos,xe=Math.sin,le,ce,ue=Array($/2),Te=Array($/2),Me=Array($/2),Re=Array($/2);for(ce=$/2,le=$-1;le!==-1;--le)--ce,Me[ce]=A[le],Re[ce]=V[le],--le,ue[ce]=A[le],Te[ce]=V[le];W(ue,Te),W(Me,Re),ce=$/2;var we,ke=-6.283185307179586/$,Ue,Ge;for(le=$-1;le!==-1;--le)--ce,ce===-1&&(ce=$/2-1),we=ke*le,Ue=ne(we),Ge=xe(we),A[le]=ue[ce]+Ue*Me[ce]-Ge*Re[ce],V[le]=Te[ce]+Ue*Re[ce]+Ge*Me[ce]}},p2._ifftpow2=function W(A,V){var $=A.length;if($!==1){var ne=Math.cos,xe=Math.sin,le,ce,ue=Array($/2),Te=Array($/2),Me=Array($/2),Re=Array($/2);for(ce=$/2,le=$-1;le!==-1;--le)--ce,Me[ce]=A[le],Re[ce]=V[le],--le,ue[ce]=A[le],Te[ce]=V[le];W(ue,Te),W(Me,Re),ce=$/2;var we,ke=6.283185307179586/$,Ue,Ge;for(le=$-1;le!==-1;--le)--ce,ce===-1&&(ce=$/2-1),we=ke*le,Ue=ne(we),Ge=xe(we),A[le]=ue[ce]+Ue*Me[ce]-Ge*Re[ce],V[le]=Te[ce]+Ue*Re[ce]+Ge*Me[ce]}},p2.ifftpow2=function W(A,V){p2._ifftpow2(A,V),p2.diveq(A,A.length),p2.diveq(V,V.length)},p2.convpow2=function W(A,V,$,ne){p2.fftpow2(A,V),p2.fftpow2($,ne);var xe,le=A.length,ce,ue,Te,Me;for(xe=le-1;xe!==-1;--xe)ce=A[xe],Te=V[xe],ue=$[xe],Me=ne[xe],A[xe]=ce*ue-Te*Me,V[xe]=ce*Me+Te*ue;p2.ifftpow2(A,V)},p2.T.prototype.fft=function W(){var A=this.x,V=this.y,$=A.length,ne=Math.log,xe=ne(2),le=Math.ceil(ne(2*$-1)/xe),ce=Math.pow(2,le),ue=p2.rep([ce],0),Te=p2.rep([ce],0),Me=Math.cos,Re=Math.sin,we,ke=-3.141592653589793/$,Ue,Ge=p2.rep([ce],0),We=p2.rep([ce],0);for(we=0;we<$;we++)Ge[we]=A[we];if(typeof V<"u")for(we=0;we<$;we++)We[we]=V[we];for(ue[0]=1,we=1;we<=ce/2;we++)Ue=ke*we*we,ue[we]=Me(Ue),Te[we]=Re(Ue),ue[ce-we]=Me(Ue),Te[ce-we]=Re(Ue);var Xe=new p2.T(Ge,We),Ye=new p2.T(ue,Te);return Xe=Xe.mul(Ye),p2.convpow2(Xe.x,Xe.y,p2.clone(Ye.x),p2.neg(Ye.y)),Xe=Xe.mul(Ye),Xe.x.length=$,Xe.y.length=$,Xe},p2.T.prototype.ifft=function W(){var A=this.x,V=this.y,$=A.length,ne=Math.log,xe=ne(2),le=Math.ceil(ne(2*$-1)/xe),ce=Math.pow(2,le),ue=p2.rep([ce],0),Te=p2.rep([ce],0),Me=Math.cos,Re=Math.sin,we,ke=3.141592653589793/$,Ue,Ge=p2.rep([ce],0),We=p2.rep([ce],0);for(we=0;we<$;we++)Ge[we]=A[we];if(typeof V<"u")for(we=0;we<$;we++)We[we]=V[we];for(ue[0]=1,we=1;we<=ce/2;we++)Ue=ke*we*we,ue[we]=Me(Ue),Te[we]=Re(Ue),ue[ce-we]=Me(Ue),Te[ce-we]=Re(Ue);var Xe=new p2.T(Ge,We),Ye=new p2.T(ue,Te);return Xe=Xe.mul(Ye),p2.convpow2(Xe.x,Xe.y,p2.clone(Ye.x),p2.neg(Ye.y)),Xe=Xe.mul(Ye),Xe.x.length=$,Xe.y.length=$,Xe.div($)},p2.gradient=function W(A,V){var $=V.length,ne=A(V);if(isNaN(ne))throw new Error("gradient: f(x) is a NaN!");var Re=Math.max,xe,le=p2.clone(V),ce,ue,Te=Array($);p2.div,p2.sub;var Me,Re=Math.max,we=.001,ke=Math.abs,Ue=Math.min,Ge,We,Xe,Ye=0,je,Ke,qe;for(xe=0;xe<$;xe++)for(var $e=Re(1e-6*ne,1e-8);;){if(++Ye,Ye>20)throw new Error("Numerical gradient fails");if(le[xe]=V[xe]+$e,ce=A(le),le[xe]=V[xe]-$e,ue=A(le),le[xe]=V[xe],isNaN(ce)||isNaN(ue)){$e/=16;continue}if(Te[xe]=(ce-ue)/(2*$e),Ge=V[xe]-$e,We=V[xe],Xe=V[xe]+$e,je=(ce-ne)/$e,Ke=(ne-ue)/$e,qe=Re(ke(Te[xe]),ke(ne),ke(ce),ke(ue),ke(Ge),ke(We),ke(Xe),1e-8),Me=Ue(Re(ke(je-Te[xe]),ke(Ke-Te[xe]),ke(je-Ke))/qe,$e/qe),Me>we)$e/=16;else break}return Te},p2.uncmin=function W(A,V,$,ne,xe,le,ce){var ue=p2.gradient;typeof ce>"u"&&(ce={}),typeof $>"u"&&($=1e-8),typeof ne>"u"&&(ne=function(Hs){return ue(A,Hs)}),typeof xe>"u"&&(xe=1e3),V=p2.clone(V);var Te=V.length,Me=A(V),Re,we;if(isNaN(Me))throw new Error("uncmin: f(x0) is a NaN!");var ke=Math.max,Ue=p2.norm2;$=ke($,p2.epsilon);var Ge,We,Xe,Ye=ce.Hinv||p2.identity(Te),je=p2.dot;p2.inv;var Ke=p2.sub,qe=p2.add,$e=p2.tensor,vt=p2.div,nt=p2.mul,wt=p2.all,Kt=p2.isFinite,Ht=p2.neg,pi=0,hi,ai,Yi,Wi,ls,Hi,rs,Us="";for(We=ne(V);pi<xe;){if(typeof le=="function"&&le(pi,V,Me,We,Ye)){Us="Callback returned true";break}if(!wt(Kt(We))){Us="Gradient has Infinity or NaN";break}if(Ge=Ht(je(Ye,We)),!wt(Kt(Ge))){Us="Search direction has Infinity or NaN";break}if(rs=Ue(Ge),rs<$){Us="Newton step smaller than tol";break}for(Hi=1,we=je(We,Ge),ai=V;pi<xe&&!(Hi*rs<$);){if(hi=nt(Ge,Hi),ai=qe(V,hi),Re=A(ai),Re-Me>=.1*Hi*we||isNaN(Re)){Hi*=.5,++pi;continue}break}if(Hi*rs<$){Us="Line search step size smaller than tol";break}if(pi===xe){Us="maxit reached during line search";break}Xe=ne(ai),Yi=Ke(Xe,We),ls=je(Yi,hi),Wi=je(Ye,Yi),Ye=Ke(qe(Ye,nt((ls+je(Yi,Wi))/(ls*ls),$e(hi,hi))),vt(qe($e(Wi,hi),$e(hi,Wi)),ls)),V=ai,Me=Re,We=Xe,++pi}return{solution:V,f:Me,gradient:We,invHessian:Ye,iterations:pi,message:Us}},p2.Dopri=function W(A,V,$,ne,xe,le,ce){this.x=A,this.y=V,this.f=$,this.ymid=ne,this.iterations=xe,this.events=ce,this.message=le},p2.Dopri.prototype._at=function W(Ge,V){function $(nt){return nt*nt}var ne=this,xe=ne.x,le=ne.y,ce=ne.f,ue=ne.ymid;xe.length;var Te,Me,Re,we,ke,Ue,Ge,We,Xe=.5,Ye=p2.add,je=p2.mul,Ke=p2.sub,qe,$e,vt;return Te=xe[V],Me=xe[V+1],we=le[V],ke=le[V+1],We=Me-Te,Re=Te+Xe*We,Ue=ue[V],qe=Ke(ce[V],je(we,1/(Te-Re)+2/(Te-Me))),$e=Ke(ce[V+1],je(ke,1/(Me-Re)+2/(Me-Te))),vt=[$(Ge-Me)*(Ge-Re)/$(Te-Me)/(Te-Re),$(Ge-Te)*$(Ge-Me)/$(Te-Re)/$(Me-Re),$(Ge-Te)*(Ge-Re)/$(Me-Te)/(Me-Re),(Ge-Te)*$(Ge-Me)*(Ge-Re)/$(Te-Me)/(Te-Re),(Ge-Me)*$(Ge-Te)*(Ge-Re)/$(Te-Me)/(Me-Re)],Ye(Ye(Ye(Ye(je(we,vt[0]),je(Ue,vt[1])),je(ke,vt[2])),je(qe,vt[3])),je($e,vt[4]))},p2.Dopri.prototype.at=function W(A){var V,$,ne,xe=Math.floor;if(typeof A!="number"){var le=A.length,ce=Array(le);for(V=le-1;V!==-1;--V)ce[V]=this.at(A[V]);return ce}var ue=this.x;for(V=0,$=ue.length-1;$-V>1;)ne=xe(.5*(V+$)),ue[ne]<=A?V=ne:$=ne;return this._at(A,V)},p2.dopri=function W(A,V,$,ne,xe,le,ce){typeof xe>"u"&&(xe=1e-6),typeof le>"u"&&(le=1e3);var ue=[A],Te=[$],Me=[ne(A,$)],Re,we,ke,Ue,Ge,We,Xe=[],Ye=1/5,je=[3/40,9/40],Ke=[44/45,-56/15,32/9],qe=[19372/6561,-25360/2187,64448/6561,-212/729],$e=[9017/3168,-355/33,46732/5247,49/176,-5103/18656],vt=[35/384,0,500/1113,125/192,-2187/6784,11/84],nt=[.5*6025192743/30085553152,0,.5*51252292925/65400821598,.5*-2691868925/45128329728,.5*187940372067/1594534317056,.5*-1776094331/19743644256,.5*11237099/235043384],wt=[1/5,3/10,4/5,8/9,1,1],Kt=[-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40],Ht=0,pi,hi,ai=(V-A)/10,Yi=0,Wi=p2.add,ls=p2.mul,Hi,rs,Us=Math.min,Hs=Math.abs,qi=p2.norminf,as=Math.pow,li=p2.any,vi=p2.lt,Ui=p2.and;p2.sub;var hs,Xs,cr,Ks=new p2.Dopri(ue,Te,Me,Xe,-1,"");for(typeof ce=="function"&&(hs=ce(A,$));A<V&&Yi<le;){if(++Yi,A+ai>V&&(ai=V-A),Re=ne(A+wt[0]*ai,Wi($,ls(Ye*ai,Me[Ht]))),we=ne(A+wt[1]*ai,Wi(Wi($,ls(je[0]*ai,Me[Ht])),ls(je[1]*ai,Re))),ke=ne(A+wt[2]*ai,Wi(Wi(Wi($,ls(Ke[0]*ai,Me[Ht])),ls(Ke[1]*ai,Re)),ls(Ke[2]*ai,we))),Ue=ne(A+wt[3]*ai,Wi(Wi(Wi(Wi($,ls(qe[0]*ai,Me[Ht])),ls(qe[1]*ai,Re)),ls(qe[2]*ai,we)),ls(qe[3]*ai,ke))),Ge=ne(A+wt[4]*ai,Wi(Wi(Wi(Wi(Wi($,ls($e[0]*ai,Me[Ht])),ls($e[1]*ai,Re)),ls($e[2]*ai,we)),ls($e[3]*ai,ke)),ls($e[4]*ai,Ue))),Hi=Wi(Wi(Wi(Wi(Wi($,ls(Me[Ht],ai*vt[0])),ls(we,ai*vt[2])),ls(ke,ai*vt[3])),ls(Ue,ai*vt[4])),ls(Ge,ai*vt[5])),We=ne(A+ai,Hi),pi=Wi(Wi(Wi(Wi(Wi(ls(Me[Ht],ai*Kt[0]),ls(we,ai*Kt[2])),ls(ke,ai*Kt[3])),ls(Ue,ai*Kt[4])),ls(Ge,ai*Kt[5])),ls(We,ai*Kt[6])),typeof pi=="number"?rs=Hs(pi):rs=qi(pi),rs>xe){if(ai=.2*ai*as(xe/rs,.25),A+ai===A){Ks.msg="Step size became too small";break}continue}if(Xe[Ht]=Wi(Wi(Wi(Wi(Wi(Wi($,ls(Me[Ht],ai*nt[0])),ls(we,ai*nt[2])),ls(ke,ai*nt[3])),ls(Ue,ai*nt[4])),ls(Ge,ai*nt[5])),ls(We,ai*nt[6])),++Ht,ue[Ht]=A+ai,Te[Ht]=Hi,Me[Ht]=We,typeof ce=="function"){var $s,hr=A,rn=A+.5*ai,Rr;if(Xs=ce(rn,Xe[Ht-1]),cr=Ui(vi(hs,0),vi(0,Xs)),li(cr)||(hr=rn,rn=A+ai,hs=Xs,Xs=ce(rn,Hi),cr=Ui(vi(hs,0),vi(0,Xs))),li(cr)){for(var Yr,Tn,Mn=0,Un=1,qn=1;;){if(typeof hs=="number")Rr=(qn*Xs*hr-Un*hs*rn)/(qn*Xs-Un*hs);else for(Rr=rn,hi=hs.length-1;hi!==-1;--hi)hs[hi]<0&&Xs[hi]>0&&(Rr=Us(Rr,(qn*Xs[hi]*hr-Un*hs[hi]*rn)/(qn*Xs[hi]-Un*hs[hi])));if(Rr<=hr||Rr>=rn)break;$s=Ks._at(Rr,Ht-1),Tn=ce(Rr,$s),Yr=Ui(vi(hs,0),vi(0,Tn)),li(Yr)?(rn=Rr,Xs=Tn,cr=Yr,qn=1,Mn===-1?Un*=.5:Un=1,Mn=-1):(hr=Rr,hs=Tn,Un=1,Mn===1?qn*=.5:qn=1,Mn=1)}return Hi=Ks._at(.5*(A+Rr),Ht-1),Ks.f[Ht]=ne(Rr,$s),Ks.x[Ht]=Rr,Ks.y[Ht]=$s,Ks.ymid[Ht-1]=Hi,Ks.events=cr,Ks.iterations=Yi,Ks}}A+=ai,$=Hi,hs=Xs,ai=Us(.8*ai*as(xe/rs,.25),4*ai)}return Ks.iterations=Yi,Ks},p2.LU=function(W,A){A=A||!1;var V=Math.abs,$,ne,xe,le,ce,ue,Te,Me,Re,we=W.length,ke=we-1,Ue=new Array(we);for(A||(W=p2.clone(W)),xe=0;xe<we;++xe){for(Te=xe,ue=W[xe],Re=V(ue[xe]),ne=xe+1;ne<we;++ne)le=V(W[ne][xe]),Re<le&&(Re=le,Te=ne);for(Ue[xe]=Te,Te!=xe&&(W[xe]=W[Te],W[Te]=ue,ue=W[xe]),ce=ue[xe],$=xe+1;$<we;++$)W[$][xe]/=ce;for($=xe+1;$<we;++$){for(Me=W[$],ne=xe+1;ne<ke;++ne)Me[ne]-=Me[xe]*ue[ne],++ne,Me[ne]-=Me[xe]*ue[ne];ne===ke&&(Me[ne]-=Me[xe]*ue[ne])}}return{LU:W,P:Ue}},p2.LUsolve=function W(A,V){var $,ne,xe=A.LU,le=xe.length,ce=p2.clone(V),ue=A.P,Te,Me,Re;for($=le-1;$!==-1;--$)ce[$]=V[$];for($=0;$<le;++$)for(Te=ue[$],ue[$]!==$&&(Re=ce[$],ce[$]=ce[Te],ce[Te]=Re),Me=xe[$],ne=0;ne<$;++ne)ce[$]-=ce[ne]*Me[ne];for($=le-1;$>=0;--$){for(Me=xe[$],ne=$+1;ne<le;++ne)ce[$]-=ce[ne]*Me[ne];ce[$]/=Me[$]}return ce},p2.solve=function W(A,V,$){return p2.LUsolve(p2.LU(A,$),V)},p2.echelonize=function W(A){var V=p2.dim(A),$=V[0],ne=V[1],xe=p2.identity($),le=Array($),ce,ue,Te,Me,Re,we,ke,Ue,Ge=Math.abs,We=p2.diveq;for(A=p2.clone(A),ce=0;ce<$;++ce){for(Te=0,Re=A[ce],we=xe[ce],ue=1;ue<ne;++ue)Ge(Re[Te])<Ge(Re[ue])&&(Te=ue);for(le[ce]=Te,We(we,Re[Te]),We(Re,Re[Te]),ue=0;ue<$;++ue)if(ue!==ce){for(ke=A[ue],Ue=ke[Te],Me=ne-1;Me!==-1;--Me)ke[Me]-=Re[Me]*Ue;for(ke=xe[ue],Me=$-1;Me!==-1;--Me)ke[Me]-=we[Me]*Ue}}return{I:xe,A,P:le}},p2.__solveLP=function W(A,V,$,ne,xe,le,ce){var ue=p2.sum;p2.log;var Te=p2.mul,Me=p2.sub,Re=p2.dot,we=p2.div,ke=p2.add,Ue=A.length,Ge=$.length,We,Xe=!1,Ye=0,je=1;p2.transpose(V),p2.svd;var Ke=p2.transpose;p2.leq;var qe=Math.sqrt,$e=Math.abs;p2.muleq,p2.norminf,p2.any;var vt=Math.min,nt=p2.all,wt=p2.gt,Kt=Array(Ue),Ht=Array(Ge);p2.rep([Ge],1);var pi,hi=p2.solve,ai=Me($,Re(V,le)),Yi,Wi=Re(A,A),ls;for(Yi=Ye;Yi<xe;++Yi){var Hi,rs;for(Hi=Ge-1;Hi!==-1;--Hi)Ht[Hi]=we(V[Hi],ai[Hi]);var Us=Ke(Ht);for(Hi=Ue-1;Hi!==-1;--Hi)Kt[Hi]=ue(Us[Hi]);je=.25*$e(Wi/Re(A,Kt));var Hs=100*qe(Wi/Re(Kt,Kt));for((!isFinite(je)||je>Hs)&&(je=Hs),ls=ke(A,Te(je,Kt)),pi=Re(Us,Ht),Hi=Ue-1;Hi!==-1;--Hi)pi[Hi][Hi]+=1;rs=hi(pi,we(ls,je),!0);var qi=we(ai,Re(V,rs)),as=1;for(Hi=Ge-1;Hi!==-1;--Hi)qi[Hi]<0&&(as=vt(as,-.999*qi[Hi]));if(We=Me(le,Te(rs,as)),ai=Me($,Re(V,We)),!nt(wt(ai,0)))return{solution:le,message:"",iterations:Yi};if(le=We,je<ne)return{solution:We,message:"",iterations:Yi};if(ce){var li=Re(A,ls),vi=Re(V,ls);for(Xe=!0,Hi=Ge-1;Hi!==-1;--Hi)if(li*vi[Hi]<0){Xe=!1;break}}else le[Ue-1]>=0?Xe=!1:Xe=!0;if(Xe)return{solution:We,message:"Unbounded",iterations:Yi}}return{solution:le,message:"maximum iteration count exceeded",iterations:Yi}},p2._solveLP=function W(A,V,$,ne,xe){var le=A.length,ce=$.length,Ue;p2.sum,p2.log,p2.mul;var ue=p2.sub,Te=p2.dot;p2.div,p2.add;var Me=p2.rep([le],0).concat([1]),Re=p2.rep([ce,1],-1),we=p2.blockMatrix([[V,Re]]),ke=$,Ue=p2.rep([le],0).concat(Math.max(0,p2.sup(p2.neg($)))+1),Ge=p2.__solveLP(Me,we,ke,ne,xe,Ue,!1),We=p2.clone(Ge.solution);We.length=le;var Xe=p2.inf(ue($,Te(V,We)));if(Xe<0)return{solution:NaN,message:"Infeasible",iterations:Ge.iterations};var Ye=p2.__solveLP(A,V,$,ne,xe-Ge.iterations,We,!0);return Ye.iterations+=Ge.iterations,Ye},p2.solveLP=function W(A,V,$,ne,xe,le,ce){if(typeof ce>"u"&&(ce=1e3),typeof le>"u"&&(le=p2.epsilon),typeof ne>"u")return p2._solveLP(A,V,$,le,ce);var ue=ne.length,Te=ne[0].length,Me=V.length,Re=p2.echelonize(ne),we=p2.rep([Te],0),ke=Re.P,Ue=[],Ge;for(Ge=ke.length-1;Ge!==-1;--Ge)we[ke[Ge]]=1;for(Ge=Te-1;Ge!==-1;--Ge)we[Ge]===0&&Ue.push(Ge);var We=p2.getRange,Xe=p2.linspace(0,ue-1),Ye=p2.linspace(0,Me-1),je=We(ne,Xe,Ue),Ke=We(V,Ye,ke),qe=We(V,Ye,Ue),$e=p2.dot,vt=p2.sub,nt=$e(Ke,Re.I),wt=vt(qe,$e(nt,je)),Kt=vt($,$e(nt,xe)),Ht=Array(ke.length),pi=Array(Ue.length);for(Ge=ke.length-1;Ge!==-1;--Ge)Ht[Ge]=A[ke[Ge]];for(Ge=Ue.length-1;Ge!==-1;--Ge)pi[Ge]=A[Ue[Ge]];var hi=vt(pi,$e(Ht,$e(Re.I,je))),ai=p2._solveLP(hi,wt,Kt,le,ce),Yi=ai.solution;if(Yi!==Yi)return ai;var Wi=$e(Re.I,vt(xe,$e(je,Yi))),ls=Array(A.length);for(Ge=ke.length-1;Ge!==-1;--Ge)ls[ke[Ge]]=Wi[Ge];for(Ge=Ue.length-1;Ge!==-1;--Ge)ls[Ue[Ge]]=Yi[Ge];return{solution:ls,message:ai.message,iterations:ai.iterations}},p2.MPStoLP=function W(A){A instanceof String&&A.split(`
`);var V=0,$=["Initial state","NAME","ROWS","COLUMNS","RHS","BOUNDS","ENDATA"],ne=A.length,xe,le,ce,ue=0,Te={},Me=[],Re=0,we={},ke=0,Ue,Ge=[],We=[],Xe=[];function Ye(vt){throw new Error("MPStoLP: "+vt+`
Line `+xe+": "+A[xe]+`
Current state: `+$[V]+`
`)}for(xe=0;xe<ne;++xe){ce=A[xe];var je=ce.match(/\S*/g),Ke=[];for(le=0;le<je.length;++le)je[le]!==""&&Ke.push(je[le]);if(Ke.length!==0){for(le=0;le<$.length&&ce.substr(0,$[le].length)!==$[le];++le);if(le<$.length){if(V=le,le===1&&(Ue=Ke[1]),le===6)return{name:Ue,c:Ge,A:p2.transpose(We),b:Xe,rows:Te,vars:we};continue}switch(V){case 0:case 1:Ye("Unexpected line");case 2:switch(Ke[0]){case"N":ue===0?ue=Ke[1]:Ye("Two or more N rows");break;case"L":Te[Ke[1]]=Re,Me[Re]=1,Xe[Re]=0,++Re;break;case"G":Te[Ke[1]]=Re,Me[Re]=-1,Xe[Re]=0,++Re;break;case"E":Te[Ke[1]]=Re,Me[Re]=0,Xe[Re]=0,++Re;break;default:Ye("Parse error "+p2.prettyPrint(Ke))}break;case 3:we.hasOwnProperty(Ke[0])||(we[Ke[0]]=ke,Ge[ke]=0,We[ke]=p2.rep([Re],0),++ke);var qe=we[Ke[0]];for(le=1;le<Ke.length;le+=2){if(Ke[le]===ue){Ge[qe]=parseFloat(Ke[le+1]);continue}var $e=Te[Ke[le]];We[qe][$e]=(Me[$e]<0?-1:1)*parseFloat(Ke[le+1])}break;case 4:for(le=1;le<Ke.length;le+=2)Xe[Te[Ke[le]]]=(Me[Te[Ke[le]]]<0?-1:1)*parseFloat(Ke[le+1]);break;case 5:break;case 6:Ye("Internal error")}}}Ye("Reached end of file without ENDATA")},p2.seedrandom={pow:Math.pow,random:Math.random},function(W,A,V,$,ne,xe,le){A.seedrandom=function(Re,we){var ke=[],Ue;return Re=Te(ue(we?[Re,W]:arguments.length?Re:[new Date().getTime(),W,window],3),ke),Ue=new ce(ke),Te(Ue.S,W),A.random=function(){for(var Ge=Ue.g($),We=le,Xe=0;Ge<ne;)Ge=(Ge+Xe)*V,We*=V,Xe=Ue.g(1);for(;Ge>=xe;)Ge/=2,We/=2,Xe>>>=1;return(Ge+Xe)/We},Re};function ce(Re){var we,ke,Ue=this,Ge=Re.length,We=0,Xe=Ue.i=Ue.j=Ue.m=0;for(Ue.S=[],Ue.c=[],Ge||(Re=[Ge++]);We<V;)Ue.S[We]=We++;for(We=0;We<V;We++)we=Ue.S[We],Xe=Me(Xe+we+Re[We%Ge]),ke=Ue.S[Xe],Ue.S[We]=ke,Ue.S[Xe]=we;Ue.g=function(Ye){var je=Ue.S,Ke=Me(Ue.i+1),qe=je[Ke],$e=Me(Ue.j+qe),vt=je[$e];je[Ke]=vt,je[$e]=qe;for(var nt=je[Me(qe+vt)];--Ye;)Ke=Me(Ke+1),qe=je[Ke],$e=Me($e+qe),vt=je[$e],je[Ke]=vt,je[$e]=qe,nt=nt*V+je[Me(qe+vt)];return Ue.i=Ke,Ue.j=$e,nt},Ue.g(V)}function ue(Re,we,ke,Ue,Ge){if(ke=[],Ge=typeof Re,we&&Ge=="object"){for(Ue in Re)if(Ue.indexOf("S")<5)try{ke.push(ue(Re[Ue],we-1))}catch{}}return ke.length?ke:Re+(Ge!="string"?"\0":"")}function Te(Re,we,ke,Ue){for(Re+="",ke=0,Ue=0;Ue<Re.length;Ue++)we[Me(Ue)]=Me((ke^=we[Me(Ue)]*19)+Re.charCodeAt(Ue));Re="";for(Ue in we)Re+=String.fromCharCode(we[Ue]);return Re}function Me(Re){return Re&V-1}le=A.pow(V,$),ne=A.pow(2,ne),xe=ne*2,Te(A.random(),W)}([],p2.seedrandom,256,6,52),function(W){function A(ue){if(typeof ue!="object")return ue;var Te=[],Me,Re=ue.length;for(Me=0;Me<Re;Me++)Te[Me+1]=A(ue[Me]);return Te}function V(ue){if(typeof ue!="object")return ue;var Te=[],Me,Re=ue.length;for(Me=1;Me<Re;Me++)Te[Me-1]=V(ue[Me]);return Te}function $(ue,Te,Me){var Re,we,ke,Ue,Ge;for(ke=1;ke<=Me;ke=ke+1){for(ue[ke][ke]=1/ue[ke][ke],Ge=-ue[ke][ke],Re=1;Re<ke;Re=Re+1)ue[Re][ke]=Ge*ue[Re][ke];if(Ue=ke+1,Me<Ue)break;for(we=Ue;we<=Me;we=we+1)for(Ge=ue[ke][we],ue[ke][we]=0,Re=1;Re<=ke;Re=Re+1)ue[Re][we]=ue[Re][we]+Ge*ue[Re][ke]}}function ne(ue,Te,Me,Re){var we,ke,Ue,Ge;for(ke=1;ke<=Me;ke=ke+1){for(Ge=0,we=1;we<ke;we=we+1)Ge=Ge+ue[we][ke]*Re[we];Re[ke]=(Re[ke]-Ge)/ue[ke][ke]}for(Ue=1;Ue<=Me;Ue=Ue+1)for(ke=Me+1-Ue,Re[ke]=Re[ke]/ue[ke][ke],Ge=-Re[ke],we=1;we<ke;we=we+1)Re[we]=Re[we]+Ge*ue[we][ke]}function xe(ue,Te,Me,Re){var we,ke,Ue,Ge,We,Xe;for(ke=1;ke<=Me;ke=ke+1){if(Re[1]=ke,Xe=0,Ue=ke-1,Ue<1){if(Xe=ue[ke][ke]-Xe,Xe<=0)break;ue[ke][ke]=Math.sqrt(Xe)}else{for(Ge=1;Ge<=Ue;Ge=Ge+1){for(We=ue[Ge][ke],we=1;we<Ge;we=we+1)We=We-ue[we][ke]*ue[we][Ge];We=We/ue[Ge][Ge],ue[Ge][ke]=We,Xe=Xe+We*We}if(Xe=ue[ke][ke]-Xe,Xe<=0)break;ue[ke][ke]=Math.sqrt(Xe)}Re[1]=0}}function le(ue,Te,Me,Re,we,ke,Ue,Ge,We,Xe,Ye,je,Ke,qe,$e,vt){var nt,wt,Kt,Ht,pi,hi,ai,Yi,Wi,ls,Hi,rs,Us,Hs,qi,as,li,vi,Ui,hs,Xs,cr,Ks,$s,hr,rn,Rr;Us=Math.min(Re,Xe),Kt=2*Re+Us*(Us+5)/2+2*Xe+1,$s=1e-60;do $s=$s+$s,hr=1+.1*$s,rn=1+.2*$s;while(hr<=1||rn<=1);for(nt=1;nt<=Re;nt=nt+1)$e[nt]=Te[nt];for(nt=Re+1;nt<=Kt;nt=nt+1)$e[nt]=0;for(nt=1;nt<=Xe;nt=nt+1)je[nt]=0;if(pi=[],vt[1]===0){if(xe(ue,Me,Re,pi),pi[1]!==0){vt[1]=2;return}ne(ue,Me,Re,Te),$(ue,Me,Re)}else{for(wt=1;wt<=Re;wt=wt+1)for(we[wt]=0,nt=1;nt<=wt;nt=nt+1)we[wt]=we[wt]+ue[nt][wt]*Te[nt];for(wt=1;wt<=Re;wt=wt+1)for(Te[wt]=0,nt=wt;nt<=Re;nt=nt+1)Te[wt]=Te[wt]+ue[wt][nt]*we[nt]}for(ke[1]=0,wt=1;wt<=Re;wt=wt+1)for(we[wt]=Te[wt],ke[1]=ke[1]+$e[wt]*we[wt],$e[wt]=0,nt=wt+1;nt<=Re;nt=nt+1)ue[nt][wt]=0;for(ke[1]=-ke[1]/2,vt[1]=0,ai=Re,Yi=ai+Re,Hi=Yi+Us,Wi=Hi+Us+1,ls=Wi+Us*(Us+1)/2,Hs=ls+Xe,nt=1;nt<=Xe;nt=nt+1){for(as=0,wt=1;wt<=Re;wt=wt+1)as=as+Ue[wt][nt]*Ue[wt][nt];$e[Hs+nt]=Math.sqrt(as)}Ke=0,qe[1]=0,qe[2]=0;function Yr(){for(qe[1]=qe[1]+1,Kt=ls,nt=1;nt<=Xe;nt=nt+1){for(Kt=Kt+1,as=-Ge[nt],wt=1;wt<=Re;wt=wt+1)as=as+Ue[wt][nt]*we[wt];if(Math.abs(as)<$s&&(as=0),nt>Ye)$e[Kt]=as;else if($e[Kt]=-Math.abs(as),as>0){for(wt=1;wt<=Re;wt=wt+1)Ue[wt][nt]=-Ue[wt][nt];Ge[nt]=-Ge[nt]}}for(nt=1;nt<=Ke;nt=nt+1)$e[ls+je[nt]]=0;for(rs=0,qi=0,nt=1;nt<=Xe;nt=nt+1)$e[ls+nt]<qi*$e[Hs+nt]&&(rs=nt,qi=$e[ls+nt]/$e[Hs+nt]);return rs===0?999:0}function Tn(){for(nt=1;nt<=Re;nt=nt+1){for(as=0,wt=1;wt<=Re;wt=wt+1)as=as+ue[wt][nt]*Ue[wt][rs];$e[nt]=as}for(Ht=ai,nt=1;nt<=Re;nt=nt+1)$e[Ht+nt]=0;for(wt=Ke+1;wt<=Re;wt=wt+1)for(nt=1;nt<=Re;nt=nt+1)$e[Ht+nt]=$e[Ht+nt]+ue[nt][wt]*$e[wt];for(cr=!0,nt=Ke;nt>=1;nt=nt-1){for(as=$e[nt],Kt=Wi+nt*(nt+3)/2,Ht=Kt-nt,wt=nt+1;wt<=Ke;wt=wt+1)as=as-$e[Kt]*$e[Yi+wt],Kt=Kt+wt;if(as=as/$e[Ht],$e[Yi+nt]=as,je[nt]<Ye||as<0)break;cr=!1,hi=nt}if(!cr)for(li=$e[Hi+hi]/$e[Yi+hi],nt=1;nt<=Ke&&!(je[nt]<Ye||$e[Yi+nt]<0);nt=nt+1)qi=$e[Hi+nt]/$e[Yi+nt],qi<li&&(li=qi,hi=nt);for(as=0,nt=ai+1;nt<=ai+Re;nt=nt+1)as=as+$e[nt]*$e[nt];if(Math.abs(as)<=$s){if(cr)return vt[1]=1,999;for(nt=1;nt<=Ke;nt=nt+1)$e[Hi+nt]=$e[Hi+nt]-li*$e[Yi+nt];return $e[Hi+Ke+1]=$e[Hi+Ke+1]+li,700}else{for(as=0,nt=1;nt<=Re;nt=nt+1)as=as+$e[ai+nt]*Ue[nt][rs];for(vi=-$e[ls+rs]/as,Ks=!0,cr||li<vi&&(vi=li,Ks=!1),nt=1;nt<=Re;nt=nt+1)we[nt]=we[nt]+vi*$e[ai+nt],Math.abs(we[nt])<$s&&(we[nt]=0);for(ke[1]=ke[1]+vi*as*(vi/2+$e[Hi+Ke+1]),nt=1;nt<=Ke;nt=nt+1)$e[Hi+nt]=$e[Hi+nt]-vi*$e[Yi+nt];if($e[Hi+Ke+1]=$e[Hi+Ke+1]+vi,Ks){for(Ke=Ke+1,je[Ke]=rs,Kt=Wi+(Ke-1)*Ke/2+1,nt=1;nt<=Ke-1;nt=nt+1)$e[Kt]=$e[nt],Kt=Kt+1;if(Ke===Re)$e[Kt]=$e[Re];else{for(nt=Re;nt>=Ke+1&&!($e[nt]===0||(Ui=Math.max(Math.abs($e[nt-1]),Math.abs($e[nt])),hs=Math.min(Math.abs($e[nt-1]),Math.abs($e[nt])),$e[nt-1]>=0?qi=Math.abs(Ui*Math.sqrt(1+hs*hs/(Ui*Ui))):qi=-Math.abs(Ui*Math.sqrt(1+hs*hs/(Ui*Ui))),Ui=$e[nt-1]/qi,hs=$e[nt]/qi,Ui===1));nt=nt-1)if(Ui===0)for($e[nt-1]=hs*qi,wt=1;wt<=Re;wt=wt+1)qi=ue[wt][nt-1],ue[wt][nt-1]=ue[wt][nt],ue[wt][nt]=qi;else for($e[nt-1]=qi,Xs=hs/(1+Ui),wt=1;wt<=Re;wt=wt+1)qi=Ui*ue[wt][nt-1]+hs*ue[wt][nt],ue[wt][nt]=Xs*(ue[wt][nt-1]+qi)-ue[wt][nt],ue[wt][nt-1]=qi;$e[Kt]=$e[Ke]}}else{for(as=-Ge[rs],wt=1;wt<=Re;wt=wt+1)as=as+we[wt]*Ue[wt][rs];if(rs>Ye)$e[ls+rs]=as;else if($e[ls+rs]=-Math.abs(as),as>0){for(wt=1;wt<=Re;wt=wt+1)Ue[wt][rs]=-Ue[wt][rs];Ge[rs]=-Ge[rs]}return 700}}return 0}function Mn(){if(Kt=Wi+hi*(hi+1)/2+1,Ht=Kt+hi,$e[Ht]===0||(Ui=Math.max(Math.abs($e[Ht-1]),Math.abs($e[Ht])),hs=Math.min(Math.abs($e[Ht-1]),Math.abs($e[Ht])),$e[Ht-1]>=0?qi=Math.abs(Ui*Math.sqrt(1+hs*hs/(Ui*Ui))):qi=-Math.abs(Ui*Math.sqrt(1+hs*hs/(Ui*Ui))),Ui=$e[Ht-1]/qi,hs=$e[Ht]/qi,Ui===1))return 798;if(Ui===0){for(nt=hi+1;nt<=Ke;nt=nt+1)qi=$e[Ht-1],$e[Ht-1]=$e[Ht],$e[Ht]=qi,Ht=Ht+nt;for(nt=1;nt<=Re;nt=nt+1)qi=ue[nt][hi],ue[nt][hi]=ue[nt][hi+1],ue[nt][hi+1]=qi}else{for(Xs=hs/(1+Ui),nt=hi+1;nt<=Ke;nt=nt+1)qi=Ui*$e[Ht-1]+hs*$e[Ht],$e[Ht]=Xs*($e[Ht-1]+qi)-$e[Ht],$e[Ht-1]=qi,Ht=Ht+nt;for(nt=1;nt<=Re;nt=nt+1)qi=Ui*ue[nt][hi]+hs*ue[nt][hi+1],ue[nt][hi+1]=Xs*(ue[nt][hi]+qi)-ue[nt][hi+1],ue[nt][hi]=qi}return 0}function Un(){for(Ht=Kt-hi,nt=1;nt<=hi;nt=nt+1)$e[Ht]=$e[Kt],Kt=Kt+1,Ht=Ht+1;return $e[Hi+hi]=$e[Hi+hi+1],je[hi]=je[hi+1],hi=hi+1,hi<Ke?797:0}function qn(){return $e[Hi+Ke]=$e[Hi+Ke+1],$e[Hi+Ke+1]=0,je[Ke]=0,Ke=Ke-1,qe[2]=qe[2]+1,0}for(Rr=0;;){if(Rr=Yr(),Rr===999)return;for(;Rr=Tn(),Rr!==0;){if(Rr===999)return;if(Rr===700)if(hi===Ke)qn();else{for(;Mn(),Rr=Un(),Rr===797;);qn()}}}}function ce(ue,Te,Me,Re,we,ke){ue=A(ue),Te=A(Te),Me=A(Me);var Ue,Ge,We,Xe,Ye,je=[],Ke=[],qe=[],$e=[],vt=[],nt;if(we=we||0,ke=ke?A(ke):[void 0,0],Re=Re?A(Re):[],Ge=ue.length-1,We=Me[1].length-1,!Re)for(Ue=1;Ue<=We;Ue=Ue+1)Re[Ue]=0;for(Ue=1;Ue<=We;Ue=Ue+1)Ke[Ue]=0;for(Xe=0,Ye=Math.min(Ge,We),Ue=1;Ue<=Ge;Ue=Ue+1)qe[Ue]=0;for(je[1]=0,Ue=1;Ue<=2*Ge+Ye*(Ye+5)/2+2*We+1;Ue=Ue+1)$e[Ue]=0;for(Ue=1;Ue<=2;Ue=Ue+1)vt[Ue]=0;return le(ue,Te,Ge,Ge,qe,je,Me,Re,Ge,We,we,Ke,Xe,vt,$e,ke),nt="",ke[1]===1&&(nt="constraints are inconsistent, no solution!"),ke[1]===2&&(nt="matrix D in quadratic function is not positive definite!"),{solution:V(qe),value:V(je),unconstrained_solution:V(Te),iterations:V(vt),iact:V(Ke),message:nt}}W.solveQP=ce}(p2),p2.svd=function W(A){var V,$=p2.epsilon,ne=1e-64/$,xe=50,le=0,ce=0,ue=0,Te=0,Me=0,Re=p2.clone(A),we=Re.length,ke=Re[0].length;if(we<ke)throw"Need more rows than columns";var Ue=new Array(ke),Ge=new Array(ke);for(ce=0;ce<ke;ce++)Ue[ce]=Ge[ce]=0;var We=p2.rep([ke,ke],0);function Xe(pi,hi){return pi=Math.abs(pi),hi=Math.abs(hi),pi>hi?pi*Math.sqrt(1+hi*hi/pi/pi):hi==0?pi:hi*Math.sqrt(1+pi*pi/hi/hi)}var Ye=0,je=0,Ke=0,qe=0,$e=0,vt=0,nt=0;for(ce=0;ce<ke;ce++){for(Ue[ce]=je,nt=0,Me=ce+1,ue=ce;ue<we;ue++)nt+=Re[ue][ce]*Re[ue][ce];if(nt<=ne)je=0;else for(Ye=Re[ce][ce],je=Math.sqrt(nt),Ye>=0&&(je=-je),Ke=Ye*je-nt,Re[ce][ce]=Ye-je,ue=Me;ue<ke;ue++){for(nt=0,Te=ce;Te<we;Te++)nt+=Re[Te][ce]*Re[Te][ue];for(Ye=nt/Ke,Te=ce;Te<we;Te++)Re[Te][ue]+=Ye*Re[Te][ce]}for(Ge[ce]=je,nt=0,ue=Me;ue<ke;ue++)nt=nt+Re[ce][ue]*Re[ce][ue];if(nt<=ne)je=0;else{for(Ye=Re[ce][ce+1],je=Math.sqrt(nt),Ye>=0&&(je=-je),Ke=Ye*je-nt,Re[ce][ce+1]=Ye-je,ue=Me;ue<ke;ue++)Ue[ue]=Re[ce][ue]/Ke;for(ue=Me;ue<we;ue++){for(nt=0,Te=Me;Te<ke;Te++)nt+=Re[ue][Te]*Re[ce][Te];for(Te=Me;Te<ke;Te++)Re[ue][Te]+=nt*Ue[Te]}}$e=Math.abs(Ge[ce])+Math.abs(Ue[ce]),$e>qe&&(qe=$e)}for(ce=ke-1;ce!=-1;ce+=-1){if(je!=0){for(Ke=je*Re[ce][ce+1],ue=Me;ue<ke;ue++)We[ue][ce]=Re[ce][ue]/Ke;for(ue=Me;ue<ke;ue++){for(nt=0,Te=Me;Te<ke;Te++)nt+=Re[ce][Te]*We[Te][ue];for(Te=Me;Te<ke;Te++)We[Te][ue]+=nt*We[Te][ce]}}for(ue=Me;ue<ke;ue++)We[ce][ue]=0,We[ue][ce]=0;We[ce][ce]=1,je=Ue[ce],Me=ce}for(ce=ke-1;ce!=-1;ce+=-1){for(Me=ce+1,je=Ge[ce],ue=Me;ue<ke;ue++)Re[ce][ue]=0;if(je!=0){for(Ke=Re[ce][ce]*je,ue=Me;ue<ke;ue++){for(nt=0,Te=Me;Te<we;Te++)nt+=Re[Te][ce]*Re[Te][ue];for(Ye=nt/Ke,Te=ce;Te<we;Te++)Re[Te][ue]+=Ye*Re[Te][ce]}for(ue=ce;ue<we;ue++)Re[ue][ce]=Re[ue][ce]/je}else for(ue=ce;ue<we;ue++)Re[ue][ce]=0;Re[ce][ce]+=1}for($=$*qe,Te=ke-1;Te!=-1;Te+=-1)for(var wt=0;wt<xe;wt++){var Kt=!1;for(Me=Te;Me!=-1;Me+=-1){if(Math.abs(Ue[Me])<=$){Kt=!0;break}if(Math.abs(Ge[Me-1])<=$)break}if(!Kt){le=0,nt=1;var Ht=Me-1;for(ce=Me;ce<Te+1&&(Ye=nt*Ue[ce],Ue[ce]=le*Ue[ce],!(Math.abs(Ye)<=$));ce++)for(je=Ge[ce],Ke=Xe(Ye,je),Ge[ce]=Ke,le=je/Ke,nt=-Ye/Ke,ue=0;ue<we;ue++)$e=Re[ue][Ht],vt=Re[ue][ce],Re[ue][Ht]=$e*le+vt*nt,Re[ue][ce]=-$e*nt+vt*le}if(vt=Ge[Te],Me==Te){if(vt<0)for(Ge[Te]=-vt,ue=0;ue<ke;ue++)We[ue][Te]=-We[ue][Te];break}if(wt>=xe-1)throw"Error: no convergence.";for(qe=Ge[Me],$e=Ge[Te-1],je=Ue[Te-1],Ke=Ue[Te],Ye=(($e-vt)*($e+vt)+(je-Ke)*(je+Ke))/(2*Ke*$e),je=Xe(Ye,1),Ye<0?Ye=((qe-vt)*(qe+vt)+Ke*($e/(Ye-je)-Ke))/qe:Ye=((qe-vt)*(qe+vt)+Ke*($e/(Ye+je)-Ke))/qe,le=1,nt=1,ce=Me+1;ce<Te+1;ce++){for(je=Ue[ce],$e=Ge[ce],Ke=nt*je,je=le*je,vt=Xe(Ye,Ke),Ue[ce-1]=vt,le=Ye/vt,nt=Ke/vt,Ye=qe*le+je*nt,je=-qe*nt+je*le,Ke=$e*nt,$e=$e*le,ue=0;ue<ke;ue++)qe=We[ue][ce-1],vt=We[ue][ce],We[ue][ce-1]=qe*le+vt*nt,We[ue][ce]=-qe*nt+vt*le;for(vt=Xe(Ye,Ke),Ge[ce-1]=vt,le=Ye/vt,nt=Ke/vt,Ye=le*je+nt*$e,qe=-nt*je+le*$e,ue=0;ue<we;ue++)$e=Re[ue][ce-1],vt=Re[ue][ce],Re[ue][ce-1]=$e*le+vt*nt,Re[ue][ce]=-$e*nt+vt*le}Ue[Me]=0,Ue[Te]=Ye,Ge[Te]=qe}for(ce=0;ce<Ge.length;ce++)Ge[ce]<$&&(Ge[ce]=0);for(ce=0;ce<ke;ce++)for(ue=ce-1;ue>=0;ue--)if(Ge[ue]<Ge[ce]){for(le=Ge[ue],Ge[ue]=Ge[ce],Ge[ce]=le,Te=0;Te<Re.length;Te++)V=Re[Te][ce],Re[Te][ce]=Re[Te][ue],Re[Te][ue]=V;for(Te=0;Te<We.length;Te++)V=We[Te][ce],We[Te][ce]=We[Te][ue],We[Te][ue]=V;ce=ue}return{U:Re,S:Ge,V:We}}})(AS);class Ad{constructor(){this.bodyTracks=[],this.poseFilters=[],this.angle=.08333333333333333*Math.PI,this.ratio=1.7777777777777777,this.near=1,this.poseScore=.6,this.alignScore=.9,this.alignVisibility=.9,this.skipCount=2,this.skipMax=2}async process(A,V){var $,ne;if(this.bodyTracks.length<1&&this.skipCount<this.skipMax)return this.skipCount++,[];this.skipCount=0;const xe=JY(()=>{const we=ip(iU(A,3),"float32"),ke=BS(OP(we,255*.5),1);return B0(ke,0)}),[le,ce]=[xe.shape[1],xe.shape[2]];if(this.bodyTracks.length===0){const we=await(($=this.bodyDetector)==null?void 0:$.process(xe))||[];this.bodyTracks=we.map(ke=>({center:ke.points[0],top:ke.points[1]})),this.bodyTracks.forEach(()=>this.poseFilters.push(new Vz))}const ue=this.bodyTracks.length>0?((ne=this.poseDetector)==null?void 0:ne.process(xe,this.bodyTracks))||[]:[];ue.forEach((we,ke)=>{var Ue;if(V!==void 0){const Ge=ce/le,We=we.top[0]-we.center[0],Xe=(we.top[1]-we.center[1])/Ge,Ye=Math.sqrt(We*We+Xe*Xe)*2*(1+Ge)*.5;ue[ke]=this.poseFilters[ke].filter(we,V,1/Ye)}(Ue=this.poseAligner)==null||Ue.alignPoints(ue[ke].keypoints)}),xe.dispose();let Te=[],Me=[],Re=[];for(let we=0;we<this.bodyTracks.length;we++){const ke={center:[this.bodyTracks[we].center[0]*ce,this.bodyTracks[we].center[1]*le],top:[this.bodyTracks[we].top[0]*ce,this.bodyTracks[we].top[1]*le]};let Ue={center:[ue[we].center[0]*ce,ue[we].center[1]*le],top:[ue[we].top[0]*ce,ue[we].top[1]*le]};const Ge=[ke,Ue].map(We=>{const{center:Xe,top:Ye}=We,je=[Ye[0]-Xe[0],Ye[1]-Xe[1]],Ke=Math.sqrt(je[0]*je[0]+je[1]*je[1]);return[[Xe[0]-Ke,Xe[1]-Ke],[Xe[0]+Ke,Xe[1]+Ke]]});VU(Ge[0],Ge[1])>.5&&ue[we].score>this.poseScore&&(Te.push({center:[...ue[we].center],top:[...ue[we].top]}),Me.push(this.poseFilters[we]),Re.push(ue[we]))}return this.bodyTracks=Te,this.poseFilters=Me,Re}setCamera(A,V,$=1){var ne;this.angle=A,this.ratio=V,this.near=$,(ne=this.poseAligner)==null||ne.setCamera(A,V,$)}async init(A,V="./",$=!1,ne=!1,xe="webgl"){const le=await VM(A,V,$),ce=new le.ParseLoader(V);if($||(await ce.remove("pose.wasm"),await ce.remove("poseutils.wasm")),!await ce.loadDict(["pose.wasm","poseutils.wasm"])||!await ce.load("pose.wasm")||!ce.parse())return;Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!0),JG(),await Jj(xe);const ue={weightUrlConverter:async we=>we,fetchFunc:async we=>{const ke=new Blob([ce.file(we)]);return fetch(URL.createObjectURL(ke))}},Te=await Ph("bodymodel.def",ue),Me=await Ph("posemodel.def",ue);if(this.bodyDetector=new VT(Te),this.poseDetector=new Vq(Me,ne),!await ce.load("poseutils.wasm"))return;const Re=await Vh({wasmBinary:ce.data()});ce.delete(),Re.PoseAligner.prototype.alignPoints=function(we){const ke=new Re.VectorFloat,Ue=new Re.VectorFloat,Ge=new Re.VectorFloat,We=new Re.VectorFloat;we.forEach(Ye=>{ke.push_back(Ye.pixel[0]),ke.push_back(Ye.pixel[1]),ke.push_back(Ye.pixel[2]),Ue.push_back(Ye.metric[0]),Ue.push_back(Ye.metric[1]),Ue.push_back(Ye.metric[2]),Ge.push_back(Ye.score),We.push_back(Ye.visibility)});const Xe=this.align(ke,Ue,Ge,We);we.forEach((Ye,je)=>{Ye.metric=[Xe.get(je*3),Xe.get(je*3+1),Xe.get(je*3+2)]}),ke.delete(),Ue.delete(),Ge.delete(),We.delete(),Xe.delete()},this.poseModule=Re,this.poseAligner=new this.poseModule.PoseAligner,this.poseAligner.setThresh(this.alignScore,this.alignVisibility)}reset(){var A;this.bodyTracks=[],this.poseFilters=[],this.skipCount=this.skipMax,(A=this.poseDetector)==null||A.reset()}async prepare(){var A,V;Cd().set("ENGINE_COMPILE_ONLY",!0),await((A=this.bodyDetector)==null?void 0:A.prepare()),await((V=this.poseDetector)==null?void 0:V.prepare());const $=f1();$ instanceof ea&&($.checkCompileCompletion(),$.getUniformLocations()),Cd().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var A,V,$;this.reset(),(A=this.bodyDetector)==null||A.dispose(),delete this.bodyDetector,(V=this.poseDetector)==null||V.dispose(),delete this.poseDetector,($=this.poseAligner)==null||$.delete(),delete this.poseAligner}}function AV(W,A){const V=2*Math.tan(.5*A.angle),$=A.ratio*V,ne=W.map(ue=>({pixel:[(ue.pixel[0]-.5)*$,(ue.pixel[1]-.5)*V],world:ue.world})),xe=[];ne.forEach(ue=>xe.push([0,1,-ue.pixel[1],ue.world[1]-ue.pixel[1]*ue.world[2]],[-1,0,ue.pixel[0],ue.pixel[0]*ue.world[2]-ue.world[0]]));const{V:le}=AS.svd(xe),ce=le[3][3];return[le[0][3]/ce,le[1][3]/ce,le[2][3]/ce]}var Ab=Object.defineProperty,AP=Object.getOwnPropertySymbols,AE=Object.prototype.hasOwnProperty,AD=Object.prototype.propertyIsEnumerable,Ag=(W,A,V)=>A in W?Ab(W,A,{enumerable:!0,configurable:!0,writable:!0,value:V}):W[A]=V,AZ=(W,A)=>{for(var V in A||(A={}))AE.call(A,V)&&Ag(W,V,A[V]);if(AP)for(var V of AP(A))AD.call(A,V)&&Ag(W,V,A[V]);return W};class Ao{constructor(A){this.model=A,this.facesMax=3,this.iouThresh=.3,this.scoreThresh=.5,this.keypointCount=6,this.model=A,this.modelSize=A.inputs[0].shape?{width:A.inputs[0].shape[2],height:A.inputs[0].shape[1]}:{width:128,height:128},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchors=Sg(this.anchorsData),this.size=SD([this.modelSize.width,this.modelSize.height])}async process(A,V){let $={x:0,y:0};const[ne,xe,le]=JY(()=>{const Ge={width:A.shape[2],height:A.shape[1]},We=Ge.width/Ge.height;let Xe=AZ({},Ge),Ye={x:0,y:0};We>this.modelRatio?(Xe.height=Ge.width/this.modelRatio,Ye.y=Math.floor((Xe.height-Ge.height)*.5),$.y=Ye.y/Xe.height):We<this.modelRatio&&(Xe.width=Ge.height*this.modelRatio,Ye.x=Math.floor((Xe.width-Ge.width)*.5),$.x=Ye.x/Xe.width);const je=BA(A,[[0,0],[Ye.y,Ye.y],[Ye.x,Ye.x],[0,0]],0),Ke=dQ.resizeBilinear(je,[this.modelSize.height,this.modelSize.width]),qe=OS(OD(Ke,2),-1),$e=SB(this.model.execute(qe,"objects")),vt=t0($e,[0,0],[-1,1]),nt=SB(Oj(vt)),wt=this.decodeBoxes($e,this.anchors,this.size);return[$e,wt,nt]}),ce=await dQ.nonMaxSuppressionAsync(xe,le,this.facesMax,this.iouThresh,this.scoreThresh),ue=await ce.data();ce.dispose();const Te=[];for(let Ge=0;Ge<ue.length;Ge++){const We=ue[Ge];Te.push({box:t0(xe,[We,0],[1,-1]),score:t0(le,We,1),anchorI:We,points:V?t0(ne,[We,5],[1,-1]):void 0})}const Me=await Promise.all(Te.map(async Ge=>{var We,Xe;const Ye=await Ge.box.data(),je=await Ge.score.data(),Ke=await((We=Ge.points)==null?void 0:We.data());return Ge.box.dispose(),Ge.score.dispose(),(Xe=Ge.points)==null||Xe.dispose(),{box:Ye,score:je[0],anchorI:Ge.anchorI,points:Ke}})),Re={width:1-2*$.x,height:1-2*$.y};$.x/=Re.width,$.y/=Re.height;const we=this.modelSize.width*Re.width,ke=this.modelSize.height*Re.height,Ue=[];for(let Ge=0;Ge<Me.length;Ge++){const We=Me[Ge].box,Xe=this.anchorsData[Me[Ge].anchorI],Ye=Me[Ge].points,je=[];for(let Ke=0;Ke<this.keypointCount&&Ye;Ke++)je.push({x:(Ye[Ke*2+0]+Xe[0])/we-$.x,y:(Ye[Ke*2+1]+Xe[1])/ke-$.y});Ue.push({box:[[We[0]/we-$.x,We[1]/ke-$.y],[We[2]/we-$.x,We[3]/ke-$.y]],score:Me[Ge].score,keypoints:Ye&&je})}return ne.dispose(),xe.dispose(),le.dispose(),Ue}decodeBoxes(A,V,$){const ne=t0(A,[0,1],[-1,2]),xe=OS(ne,V),le=t0(A,[0,3],[-1,2]),ce=OP(le,2),ue=BS(xe,ce),Te=OS(xe,ce);return tN([ue,Te],1)}buildAnchors(A){const V=[8,16],$=[2,6],ne=[];for(let xe=0;xe<V.length;xe++){const le=V[xe],ce=Math.floor((A.height+le-1)/le),ue=Math.floor((A.width+le-1)/le),Te=$[xe];for(let Me=0;Me<ce;Me++){const Re=le*(Me+.5);for(let we=0;we<ue;we++){const ke=le*(we+.5);for(let Ue=0;Ue<Te;Ue++)ne.push([ke,Re])}}}return ne}async prepare(){const{width:A,height:V}=this.modelSize,$=BQ([1,V,A,3]),ne=this.model.execute($,"objects");await ne.data(),$.dispose(),ne.dispose()}dispose(){this.model.dispose(),this.anchors.dispose()}}var Ae=(W=>(W[W.EyeR=0]="EyeR",W[W.EyeL=1]="EyeL",W[W.Nose=2]="Nose",W[W.Mouth=3]="Mouth",W[W.EarR=4]="EarR",W[W.EarL=5]="EarL",W))(Ae||{});class AQ{constructor(A){this.model=A,this.boxFactor=1.5,this.symmetryPoints=[13,168],this.modelSize=A.inputs[0].shape?{width:A.inputs[0].shape[2],height:A.inputs[0].shape[1]}:{width:192,height:192},this.modelHighP=this.model.outputs.length===7}process(A,V){const $=V.map(ce=>{const{box:ue,symmetry:Te}=ce,Me=.5*(this.boxFactor-1),Re={x:Me*(ue[1][0]-ue[0][0]),y:Me*(ue[1][1]-ue[0][1])};return{box:[[ue[0][0]-Re.x,ue[0][1]-Re.y],[ue[1][0]+Re.x,ue[1][1]+Re.y]],symmetry:Te}}),[ne,xe]=[A.shape[1],A.shape[2]],{modelSize:le}=this;return $.map(ce=>{const{box:ue,symmetry:Te}=ce,Me=Math.atan2((Te[1].x-Te[0].x)*xe,(Te[0].y-Te[1].y)*ne),Re=[.5*(ue[0][0]+ue[1][0]),.5*(ue[0][1]+ue[1][1])],we={width:ue[1][0]-ue[0][0],height:ue[1][1]-ue[0][1]},ke=[ue[0][1]*ne,ue[0][0]*xe,ue[1][1]*ne,ue[1][0]*xe],Ue=this.rotatedRect(A,ke,Me,le),Ge=this.modelHighP?["output_mesh_identity","output_faceflag","output_lips","Identity_1:0","Identity_5:0","Identity_2:0","Identity_6:0"]:["output_mesh","output_faceflag"],[We,Xe,Ye,je,Ke,qe,$e]=this.model.execute(Ue,Ge),vt=We.dataSync(),nt=Xe.dataSync()[0];let wt=[];for(let rs=0;rs<vt.length/3;rs++)wt.push([vt[rs*3+0],vt[rs*3+1],vt[rs*3+2]]);if(Ye){const rs=Ye.dataSync();AF(wt,rs,Ay)}if(je&&Ke){const rs=je.dataSync(),Us=Ke.dataSync();AF(wt,rs,AA),AF(wt,Us,Ap)}if(qe&&$e){const rs=qe.dataSync(),Us=$e.dataSync(),Hs=[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173].map(as=>wt[as]),qi=[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398].map(as=>wt[as]);for(let as=0;as<rs.length/2;as++){const li=[rs[as*2+0],rs[as*2+1]];wt.push([li[0],li[1],AI(li,Hs)])}for(let as=0;as<Us.length/2;as++){const li=[Us[as*2+0],Us[as*2+1]];wt.push([li[0],li[1],AI(li,qi)])}}const Kt=[we.width*xe/le.width,we.height*ne/le.height],Ht=wt.map(rs=>[(rs[0]-le.width/2)*Kt[0],(rs[1]-le.height/2)*Kt[1],rs[2]*Kt[0]]),pi=Math.sin(Me),hi=Math.cos(Me),ai=Ht.map(rs=>[(rs[0]*hi-rs[1]*pi)/xe+Re[0],(rs[0]*pi+rs[1]*hi)/ne+Re[1],rs[2]/xe]),Yi=ai.map(rs=>rs[0]),Wi=ai.map(rs=>rs[1]),ls=[Math.min(...Yi),Math.min(...Wi)],Hi=[Math.max(...Yi),Math.max(...Wi)];return Ue.dispose(),We.dispose(),Xe.dispose(),Ye?.dispose(),je?.dispose(),Ke?.dispose(),qe?.dispose(),$e?.dispose(),{keypoints:ai,score:nt,box:[[ls[0],ls[1]],[Hi[0],Hi[1]]]}})}rotatedRect(A,V,$,ne){const[xe,le]=[V[2]-V[0],V[3]-V[1]],[ce,ue]=[(V[2]+V[0])*.5,(V[3]+V[1])*.5],[Te,Me]=[xe/ne.height,le/ne.width],[Re,we]=[Math.cos($),Math.sin($)],ke=[Re*Me,-we*Te,(-Re*le+we*xe)*.5+ue,we*Me,Re*Te,(-we*le-Re*xe)*.5+ce,0,0];return dQ.transform(A,[ke],"bilinear","constant",0,[ne.height,ne.width])}async prepare(){const{width:A,height:V}=this.modelSize,$=BQ([1,V,A,3]),ne=this.model.execute($);await Promise.all(ne.map(async xe=>{await xe.data(),xe.dispose()})),$.dispose()}dispose(){this.model.dispose()}}function As(W,A){return W.keypoints.forEach(V=>{V[0]*=A,V[1]*=A,V[2]*=A}),W.box[0][0]*=A,W.box[0][1]*=A,W.box[1][0]*=A,W.box[1][1]*=A,W}function AF(W,A,V){for(let $=0;$<V.length;$++)W[V[$]][0]=A[$*2+0],W[V[$]][1]=A[$*2+1]}function AI(W,A){let V=0,$=Number.MAX_VALUE;for(let ne=0;ne<A.length;ne++){const xe=[A[ne][0]-W[0],A[ne][1]-W[1]],le=xe[0]*xe[0]+xe[1]*xe[1];le<$&&($=le,V=ne)}return A[V][2]}const Ay=[61,146,91,181,84,17,314,405,321,375,291,185,40,39,37,0,267,269,270,409,78,95,88,178,87,14,317,402,318,324,308,191,80,81,82,13,312,311,310,415,76,77,90,180,85,16,315,404,320,307,306,184,74,73,72,11,302,303,304,408,62,96,89,179,86,15,316,403,319,325,292,183,42,41,38,12,268,271,272,407],AA=[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173,130,25,110,24,23,22,26,112,243,247,30,29,27,28,56,190,226,31,228,229,230,231,232,233,244,113,225,224,223,222,221,189,35,124,46,53,52,65,143,111,117,118,119,120,121,128,245,156,70,63,105,66,107,55,193],Ap=[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398,359,255,339,254,253,252,256,341,463,467,260,259,257,258,286,414,446,261,448,449,450,451,452,453,464,342,445,444,443,442,441,413,265,353,276,283,282,295,372,340,346,347,348,349,350,357,465,383,300,293,334,296,336,285,417];var Aw=Object.defineProperty,AX=Object.getOwnPropertySymbols,Ac=Object.prototype.hasOwnProperty,AW=Object.prototype.propertyIsEnumerable,AR=(W,A,V)=>A in W?Aw(W,A,{enumerable:!0,configurable:!0,writable:!0,value:V}):W[A]=V,AK=(W,A)=>{for(var V in A||(A={}))Ac.call(A,V)&&AR(W,V,A[V]);if(AX)for(var V of AX(A))AW.call(A,V)&&AR(W,V,A[V]);return W};class AT{constructor(A,V=!1){this.model=A,this.modelSize=A.inputs[0].shape?{width:A.inputs[0].shape[2],height:A.inputs[0].shape[1]}:{width:256,height:256},this.modelRatio=this.modelSize.width/this.modelSize.height,V&&(this.maskFilter=new Vv(this.modelSize))}process(A,V){var $,ne;const{modelSize:xe}=this,le=A.shape[2]/A.shape[1],ce=this.modelRatio/le,ue={width:V[1][0]-V[0][0],height:V[1][1]-V[0][1]},Te={x:(V[1][0]+V[0][0])*.5,y:(V[1][1]+V[0][1])*.5};ue.width/ue.height>ce?ue.height=ue.width/ce:ue.width=ue.height*ce;const Me=[Te.y-ue.height*.5,Te.x-ue.width*.5,Te.y+ue.height*.5,Te.x+ue.width*.5],Re=dQ.cropAndResize(A,[Me],[0],[xe.height,xe.width]),we=($=this.model)==null?void 0:$.execute(Re),ke=t0(we,[0,0,0,1],-1),Ue=SB(ke),Ge=((ne=this.maskFilter)==null?void 0:ne.process(Ue))||Ue,We=OD(Ge,255),Xe=new Uint8Array(We.dataSync());return Re.dispose(),we.dispose(),ke.dispose(),Ue.dispose(),We.dispose(),{buffer:Xe,size:AK({},this.modelSize),box:[[Me[1],Me[0]],[Me[3],Me[2]]]}}resize(A){if(this.modelSize.width===A.width&&this.modelSize.height===A.height)return;const{model:V}=this,$=[Math.round(A.height/16),Math.round(A.width/16)];V.weights["StatefulPartitionedCall/model/up_sampling2d/mul"][0]=SD([$[0]*2,$[1]*2],"int32"),V.weights["StatefulPartitionedCall/model/up_sampling2d_1/mul"][0]=SD([$[0]*4,$[1]*4],"int32"),V.weights["StatefulPartitionedCall/model/up_sampling2d_2/mul"][0]=SD([$[0]*8,$[1]*8],"int32"),V.weights["StatefulPartitionedCall/model/segment/stack/1"][0]=SD([$[0]*16],"int32"),V.weights["StatefulPartitionedCall/model/segment/stack/2"][0]=SD([$[1]*16],"int32");const ne=V.executor;ne._inputs[0].attrParams.shape.value[1]=$[0]*16,ne._inputs[0].attrParams.shape.value[2]=$[1]*16;const xe=V.executor.graph.nodes,le=(ce,ue)=>{const Te=xe["StatefulPartitionedCall/model/"+ce].attrParams;Te.kernelSize.value[1]=ue[0],Te.kernelSize.value[2]=ue[1],Te.strides.value[1]=ue[0],Te.strides.value[2]=ue[1]};le("average_pooling2d/AvgPool",[$[0]*4,$[1]*4]),le("average_pooling2d_1/AvgPool",[$[0],$[1]]),le("average_pooling2d_2/AvgPool",[$[0],$[1]]),le("average_pooling2d_3/AvgPool",[$[0],$[1]]),le("average_pooling2d_4/AvgPool",[$[0],$[1]]),le("average_pooling2d_5/AvgPool",[$[0],$[1]]),le("average_pooling2d_6/AvgPool",[$[0],$[1]]),le("average_pooling2d_7/AvgPool",[$[0]*2,$[1]*2]),le("average_pooling2d_8/AvgPool",[$[0]*4,$[1]*4]),le("average_pooling2d_9/AvgPool",[$[0]*8,$[1]*8]),this.modelSize=A,this.modelRatio=A.width/A.height}size(){return this.modelSize}reset(){var A;(A=this.maskFilter)==null||A.reset()}async prepare(){var A;const{width:V,height:$}=this.modelSize,ne=BQ([1,$,V,3]),xe=this.model.execute(ne),le=t0(xe,[0,0,0,1],-1),ce=SB(le);await(((A=this.maskFilter)==null?void 0:A.process(ce))||ce).data(),ne.dispose(),xe.dispose(),le.dispose(),ce.dispose()}dispose(){var A;this.model.dispose(),(A=this.maskFilter)==null||A.dispose(),delete this.maskFilter}}var Av=(()=>{var W=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(A={}){var V=A,$,ne;V.ready=new Promise((ct,_t)=>{$=ct,ne=_t});var xe=Object.assign({},V),le=!0,ce="";function ue(ct){return V.locateFile?V.locateFile(ct,ce):ce+ct}typeof document<"u"&&document.currentScript&&(ce=document.currentScript.src),W&&(ce=W),ce.startsWith("blob:")?ce="":ce=ce.substr(0,ce.replace(/[?#].*/,"").lastIndexOf("/")+1),V.print||console.log.bind(console);var Te=V.printErr||console.error.bind(console);Object.assign(V,xe),xe=null,V.arguments&&V.arguments,V.thisProgram&&V.thisProgram,V.quit&&V.quit;var Me;V.wasmBinary&&(Me=V.wasmBinary);var Re,we=!1,ke,Ue,Ge,We,Xe,Ye,je,Ke;function qe(){var ct=Re.buffer;V.HEAP8=ke=new Int8Array(ct),V.HEAP16=Ge=new Int16Array(ct),V.HEAPU8=Ue=new Uint8Array(ct),V.HEAPU16=We=new Uint16Array(ct),V.HEAP32=Xe=new Int32Array(ct),V.HEAPU32=Ye=new Uint32Array(ct),V.HEAPF32=je=new Float32Array(ct),V.HEAPF64=Ke=new Float64Array(ct)}var $e=[],vt=[],nt=[];function wt(){if(V.preRun)for(typeof V.preRun=="function"&&(V.preRun=[V.preRun]);V.preRun.length;)pi(V.preRun.shift());Xs($e)}function Kt(){Xs(vt)}function Ht(){if(V.postRun)for(typeof V.postRun=="function"&&(V.postRun=[V.postRun]);V.postRun.length;)ai(V.postRun.shift());Xs(nt)}function pi(ct){$e.unshift(ct)}function hi(ct){vt.unshift(ct)}function ai(ct){nt.unshift(ct)}var Yi=0,Wi=null;function ls(ct){var _t;Yi++,(_t=V.monitorRunDependencies)==null||_t.call(V,Yi)}function Hi(ct){var _t;if(Yi--,(_t=V.monitorRunDependencies)==null||_t.call(V,Yi),Yi==0&&Wi){var kt=Wi;Wi=null,kt()}}function rs(ct){var _t;(_t=V.onAbort)==null||_t.call(V,ct),ct="Aborted("+ct+")",Te(ct),we=!0,ct+=". Build with -sASSERTIONS for more info.";var kt=new WebAssembly.RuntimeError(ct);throw ne(kt),kt}var Us="data:application/octet-stream;base64,",Hs=ct=>ct.startsWith(Us),qi;qi="faceutils.wasm",Hs(qi)||(qi=ue(qi));function as(ct){if(ct==qi&&Me)return new Uint8Array(Me);throw"both async and sync fetching of the wasm failed"}function li(ct){return!Me&&le&&typeof fetch=="function"?fetch(ct,{credentials:"same-origin"}).then(_t=>{if(!_t.ok)throw"failed to load wasm binary file at '"+ct+"'";return _t.arrayBuffer()}).catch(()=>as(ct)):Promise.resolve().then(()=>as(ct))}function vi(ct,_t,kt){return li(ct).then(Yt=>WebAssembly.instantiate(Yt,_t)).then(kt,Yt=>{Te("failed to asynchronously prepare wasm: "+Yt),rs(Yt)})}function Ui(ct,_t,kt,Yt){return!ct&&typeof WebAssembly.instantiateStreaming=="function"&&!Hs(_t)&&typeof fetch=="function"?fetch(_t,{credentials:"same-origin"}).then(ri=>{var $t=WebAssembly.instantiateStreaming(ri,kt);return $t.then(Yt,function(Mi){return Te("wasm streaming compile failed: "+Mi),Te("falling back to ArrayBuffer instantiation"),vi(_t,kt,Yt)})}):vi(_t,kt,Yt)}function hs(){var ct={a:Gs};function _t(Yt,ri){return r0=Yt.exports,Re=r0.y,qe(),lx=r0.C,hi(r0.z),Hi(),r0}ls();function kt(Yt){_t(Yt.instance)}if(V.instantiateWasm)try{return V.instantiateWasm(ct,_t)}catch(Yt){Te("Module.instantiateWasm callback failed with error: "+Yt),ne(Yt)}return Ui(Me,qi,ct,kt).catch(ne),{}}var Xs=ct=>{for(;ct.length>0;)ct.shift()(V)};V.noExitRuntime;class cr{constructor(_t){this.excPtr=_t,this.ptr=_t-24}set_type(_t){Ye[this.ptr+4>>2]=_t}get_type(){return Ye[this.ptr+4>>2]}set_destructor(_t){Ye[this.ptr+8>>2]=_t}get_destructor(){return Ye[this.ptr+8>>2]}set_caught(_t){_t=_t?1:0,ke[this.ptr+12]=_t}get_caught(){return ke[this.ptr+12]!=0}set_rethrown(_t){_t=_t?1:0,ke[this.ptr+13]=_t}get_rethrown(){return ke[this.ptr+13]!=0}init(_t,kt){this.set_adjusted_ptr(0),this.set_type(_t),this.set_destructor(kt)}set_adjusted_ptr(_t){Ye[this.ptr+16>>2]=_t}get_adjusted_ptr(){return Ye[this.ptr+16>>2]}get_exception_ptr(){var _t=lt(this.get_type());if(_t)return Ye[this.excPtr>>2];var kt=this.get_adjusted_ptr();return kt!==0?kt:this.excPtr}}var Ks=0,$s=(ct,_t,kt)=>{var Yt=new cr(ct);throw Yt.init(_t,kt),Ks=ct,Ks},hr={},rn=ct=>{for(;ct.length;){var _t=ct.pop(),kt=ct.pop();kt(_t)}};function Rr(ct){return this.fromWireType(Ye[ct>>2])}var Yr={},Tn={},Mn={},Un,qn=ct=>{throw new Un(ct)},$n=(ct,_t,kt)=>{ct.forEach(function(ki){Mn[ki]=_t});function Yt(ki){var _s=kt(ki);_s.length!==ct.length&&qn("Mismatched type converter count");for(var ns=0;ns<ct.length;++ns)l0(ct[ns],_s[ns])}var ri=new Array(_t.length),$t=[],Mi=0;_t.forEach((ki,_s)=>{Tn.hasOwnProperty(ki)?ri[_s]=Tn[ki]:($t.push(ki),Yr.hasOwnProperty(ki)||(Yr[ki]=[]),Yr[ki].push(()=>{ri[_s]=Tn[ki],++Mi,Mi===$t.length&&Yt(ri)}))}),$t.length===0&&Yt(ri)},cs=ct=>{var _t=hr[ct];delete hr[ct];var kt=_t.elements,Yt=kt.length,ri=kt.map(ki=>ki.getterReturnType).concat(kt.map(ki=>ki.setterArgumentType)),$t=_t.rawConstructor,Mi=_t.rawDestructor;$n([ct],ri,ki=>(kt.forEach((_s,ns)=>{var Ts=ki[ns],$r=_s.getter,nn=_s.getterContext,vn=ki[ns+Yt],Rn=_s.setter,xr=_s.setterContext;_s.read=at=>Ts.fromWireType($r(nn,at)),_s.write=(at,Lr)=>{var us=[];Rn(xr,at,vn.toWireType(us,Lr)),rn(us)}}),[{name:_t.name,fromWireType:_s=>{for(var ns=new Array(Yt),Ts=0;Ts<Yt;++Ts)ns[Ts]=kt[Ts].read(_s);return Mi(_s),ns},toWireType:(_s,ns)=>{if(Yt!==ns.length)throw new TypeError("Incorrect number of tuple elements for "+_t.name+": expected="+Yt+", actual="+ns.length);for(var Ts=$t(),$r=0;$r<Yt;++$r)kt[$r].write(Ts,ns[$r]);return _s!==null&&_s.push(Mi,Ts),Ts},argPackAdvance:h0,readValueFromPointer:Rr,destructorFunction:Mi}]))},a0={},ux=ct=>{var _t=a0[ct];delete a0[ct];var kt=_t.rawConstructor,Yt=_t.rawDestructor,ri=_t.fields,$t=ri.map(Mi=>Mi.getterReturnType).concat(ri.map(Mi=>Mi.setterArgumentType));$n([ct],$t,Mi=>{var ki={};return ri.forEach((_s,ns)=>{var Ts=_s.fieldName,$r=Mi[ns],nn=_s.getter,vn=_s.getterContext,Rn=Mi[ns+ri.length],xr=_s.setter,at=_s.setterContext;ki[Ts]={read:Lr=>$r.fromWireType(nn(vn,Lr)),write:(Lr,us)=>{var jt=[];xr(at,Lr,Rn.toWireType(jt,us)),rn(jt)}}}),[{name:_t.name,fromWireType:_s=>{var ns={};for(var Ts in ki)ns[Ts]=ki[Ts].read(_s);return Yt(_s),ns},toWireType:(_s,ns)=>{for(var Ts in ki)if(!(Ts in ns))throw new TypeError('Missing field: "'+Ts+'"');var $r=kt();for(Ts in ki)ki[Ts].write($r,ns[Ts]);return _s!==null&&_s.push(Yt,$r),$r},argPackAdvance:h0,readValueFromPointer:Rr,destructorFunction:Yt}]})},Yx=(ct,_t,kt,Yt,ri)=>{},ka=()=>{for(var ct=new Array(256),_t=0;_t<256;++_t)ct[_t]=String.fromCharCode(_t);cn=ct},cn,Kr=ct=>{for(var _t="",kt=ct;Ue[kt];)_t+=cn[Ue[kt++]];return _t},px,xn=ct=>{throw new px(ct)};function Kx(ct,_t,kt={}){var Yt=_t.name;if(ct||xn('type "'+Yt+'" must have a positive integer typeid pointer'),Tn.hasOwnProperty(ct)){if(kt.ignoreDuplicateRegistrations)return;xn("Cannot register type '"+Yt+"' twice")}if(Tn[ct]=_t,delete Mn[ct],Yr.hasOwnProperty(ct)){var ri=Yr[ct];delete Yr[ct],ri.forEach($t=>$t())}}function l0(ct,_t,kt={}){if(!("argPackAdvance"in _t))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Kx(ct,_t,kt)}var h0=8,wl=(ct,_t,kt,Yt)=>{_t=Kr(_t),l0(ct,{name:_t,fromWireType:function(ri){return!!ri},toWireType:function(ri,$t){return $t?kt:Yt},argPackAdvance:h0,readValueFromPointer:function(ri){return this.fromWireType(Ue[ri])},destructorFunction:null})},vh=ct=>({count:ct.count,deleteScheduled:ct.deleteScheduled,preservePointerOnDelete:ct.preservePointerOnDelete,ptr:ct.ptr,ptrType:ct.ptrType,smartPtr:ct.smartPtr,smartPtrType:ct.smartPtrType}),Xo=ct=>{function _t(kt){return kt.$$.ptrType.registeredClass.name}xn(_t(ct)+" instance already deleted")},h2=!1,Ri=ct=>{},Rh=ct=>{ct.smartPtr?ct.smartPtrType.rawDestructor(ct.smartPtr):ct.ptrType.registeredClass.rawDestructor(ct.ptr)},kn=ct=>{ct.count.value-=1;var _t=ct.count.value===0;_t&&Rh(ct)},c0=(ct,_t,kt)=>{if(_t===kt)return ct;if(kt.baseClass===void 0)return null;var Yt=c0(ct,_t,kt.baseClass);return Yt===null?null:kt.downcast(Yt)},va={},Ux=()=>Object.keys(Ti).length,no=()=>{var ct=[];for(var _t in Ti)Ti.hasOwnProperty(_t)&&ct.push(Ti[_t]);return ct},H0=[],j2=()=>{for(;H0.length;){var ct=H0.pop();ct.$$.deleteScheduled=!1,ct.delete()}},Mr,Yo=ct=>{Mr=ct,H0.length&&Mr&&Mr(j2)},ur=()=>{V.getInheritedInstanceCount=Ux,V.getLiveInheritedInstances=no,V.flushPendingDeletes=j2,V.setDelayFunction=Yo},Ti={},q2=(ct,_t)=>{for(_t===void 0&&xn("ptr should not be undefined");ct.baseClass;)_t=ct.upcast(_t),ct=ct.baseClass;return _t},xc=(ct,_t)=>(_t=q2(ct,_t),Ti[_t]),X0=(ct,_t)=>{(!_t.ptrType||!_t.ptr)&&qn("makeClassHandle requires ptr and ptrType");var kt=!!_t.smartPtrType,Yt=!!_t.smartPtr;return kt!==Yt&&qn("Both smartPtrType and smartPtr must be specified"),_t.count={value:1},K0(Object.create(ct,{$$:{value:_t,writable:!0}}))};function lc(ct){var _t=this.getPointee(ct);if(!_t)return this.destructor(ct),null;var kt=xc(this.registeredClass,_t);if(kt!==void 0){if(kt.$$.count.value===0)return kt.$$.ptr=_t,kt.$$.smartPtr=ct,kt.clone();var Yt=kt.clone();return this.destructor(ct),Yt}function ri(){return this.isSmartPointer?X0(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:_t,smartPtrType:this,smartPtr:ct}):X0(this.registeredClass.instancePrototype,{ptrType:this,ptr:ct})}var $t=this.registeredClass.getActualType(_t),Mi=va[$t];if(!Mi)return ri.call(this);var ki;this.isConst?ki=Mi.constPointerType:ki=Mi.pointerType;var _s=c0(_t,this.registeredClass,ki.registeredClass);return _s===null?ri.call(this):this.isSmartPointer?X0(ki.registeredClass.instancePrototype,{ptrType:ki,ptr:_s,smartPtrType:this,smartPtr:ct}):X0(ki.registeredClass.instancePrototype,{ptrType:ki,ptr:_s})}var K0=ct=>typeof FinalizationRegistry>"u"?(K0=_t=>_t,ct):(h2=new FinalizationRegistry(_t=>{kn(_t.$$)}),K0=_t=>{var kt=_t.$$,Yt=!!kt.smartPtr;if(Yt){var ri={$$:kt};h2.register(_t,ri,_t)}return _t},Ri=_t=>h2.unregister(_t),K0(ct)),Ll=()=>{Object.assign(Gn.prototype,{isAliasOf(ct){if(!(this instanceof Gn)||!(ct instanceof Gn))return!1;var _t=this.$$.ptrType.registeredClass,kt=this.$$.ptr;ct.$$=ct.$$;for(var Yt=ct.$$.ptrType.registeredClass,ri=ct.$$.ptr;_t.baseClass;)kt=_t.upcast(kt),_t=_t.baseClass;for(;Yt.baseClass;)ri=Yt.upcast(ri),Yt=Yt.baseClass;return _t===Yt&&kt===ri},clone(){if(this.$$.ptr||Xo(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var ct=K0(Object.create(Object.getPrototypeOf(this),{$$:{value:vh(this.$$)}}));return ct.$$.count.value+=1,ct.$$.deleteScheduled=!1,ct},delete(){this.$$.ptr||Xo(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&xn("Object already scheduled for deletion"),Ri(this),kn(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||Xo(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&xn("Object already scheduled for deletion"),H0.push(this),H0.length===1&&Mr&&Mr(j2),this.$$.deleteScheduled=!0,this}})};function Gn(){}var ao=(ct,_t)=>Object.defineProperty(_t,"name",{value:ct}),kl=(ct,_t,kt)=>{if(ct[_t].overloadTable===void 0){var Yt=ct[_t];ct[_t]=function(...ri){return ct[_t].overloadTable.hasOwnProperty(ri.length)||xn("Function '"+kt+"' called with an invalid number of arguments ("+ri.length+") - expects one of ("+ct[_t].overloadTable+")!"),ct[_t].overloadTable[ri.length].apply(this,ri)},ct[_t].overloadTable=[],ct[_t].overloadTable[Yt.argCount]=Yt}},hc=(ct,_t,kt)=>{V.hasOwnProperty(ct)?((kt===void 0||V[ct].overloadTable!==void 0&&V[ct].overloadTable[kt]!==void 0)&&xn("Cannot register public name '"+ct+"' twice"),kl(V,ct,ct),V.hasOwnProperty(kt)&&xn("Cannot register multiple overloads of a function with the same number of arguments ("+kt+")!"),V[ct].overloadTable[kt]=_t):(V[ct]=_t,kt!==void 0&&(V[ct].numArguments=kt))},cc=48,Wa=57,$2=ct=>{if(ct===void 0)return"_unknown";ct=ct.replace(/[^a-zA-Z0-9_]/g,"$");var _t=ct.charCodeAt(0);return _t>=cc&&_t<=Wa?"_"+ct:ct};function Ul(ct,_t,kt,Yt,ri,$t,Mi,ki){this.name=ct,this.constructor=_t,this.instancePrototype=kt,this.rawDestructor=Yt,this.baseClass=ri,this.getActualType=$t,this.upcast=Mi,this.downcast=ki,this.pureVirtualFunctions=[]}var Ro=(ct,_t,kt)=>{for(;_t!==kt;)_t.upcast||xn("Expected null or instance of "+kt.name+", got an instance of "+_t.name),ct=_t.upcast(ct),_t=_t.baseClass;return ct};function uc(ct,_t){if(_t===null)return this.isReference&&xn("null is not a valid "+this.name),0;_t.$$||xn('Cannot pass "'+Wl(_t)+'" as a '+this.name),_t.$$.ptr||xn("Cannot pass deleted object as a pointer of type "+this.name);var kt=_t.$$.ptrType.registeredClass,Yt=Ro(_t.$$.ptr,kt,this.registeredClass);return Yt}function Mh(ct,_t){var kt;if(_t===null)return this.isReference&&xn("null is not a valid "+this.name),this.isSmartPointer?(kt=this.rawConstructor(),ct!==null&&ct.push(this.rawDestructor,kt),kt):0;(!_t||!_t.$$)&&xn('Cannot pass "'+Wl(_t)+'" as a '+this.name),_t.$$.ptr||xn("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&_t.$$.ptrType.isConst&&xn("Cannot convert argument of type "+(_t.$$.smartPtrType?_t.$$.smartPtrType.name:_t.$$.ptrType.name)+" to parameter type "+this.name);var Yt=_t.$$.ptrType.registeredClass;if(kt=Ro(_t.$$.ptr,Yt,this.registeredClass),this.isSmartPointer)switch(_t.$$.smartPtr===void 0&&xn("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:_t.$$.smartPtrType===this?kt=_t.$$.smartPtr:xn("Cannot convert argument of type "+(_t.$$.smartPtrType?_t.$$.smartPtrType.name:_t.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:kt=_t.$$.smartPtr;break;case 2:if(_t.$$.smartPtrType===this)kt=_t.$$.smartPtr;else{var ri=_t.clone();kt=this.rawShare(kt,xl.toHandle(()=>ri.delete())),ct!==null&&ct.push(this.rawDestructor,kt)}break;default:xn("Unsupporting sharing policy")}return kt}function c2(ct,_t){if(_t===null)return this.isReference&&xn("null is not a valid "+this.name),0;_t.$$||xn('Cannot pass "'+Wl(_t)+'" as a '+this.name),_t.$$.ptr||xn("Cannot pass deleted object as a pointer of type "+this.name),_t.$$.ptrType.isConst&&xn("Cannot convert argument of type "+_t.$$.ptrType.name+" to parameter type "+this.name);var kt=_t.$$.ptrType.registeredClass,Yt=Ro(_t.$$.ptr,kt,this.registeredClass);return Yt}var Mo=()=>{Object.assign(xx.prototype,{getPointee(ct){return this.rawGetPointee&&(ct=this.rawGetPointee(ct)),ct},destructor(ct){var _t;(_t=this.rawDestructor)==null||_t.call(this,ct)},argPackAdvance:h0,readValueFromPointer:Rr,fromWireType:lc})};function xx(ct,_t,kt,Yt,ri,$t,Mi,ki,_s,ns,Ts){this.name=ct,this.registeredClass=_t,this.isReference=kt,this.isConst=Yt,this.isSmartPointer=ri,this.pointeeType=$t,this.sharingPolicy=Mi,this.rawGetPointee=ki,this.rawConstructor=_s,this.rawShare=ns,this.rawDestructor=Ts,!ri&&_t.baseClass===void 0?Yt?(this.toWireType=uc,this.destructorFunction=null):(this.toWireType=c2,this.destructorFunction=null):this.toWireType=Mh}var ji=(ct,_t,kt)=>{V.hasOwnProperty(ct)||qn("Replacing nonexistent public symbol"),V[ct].overloadTable!==void 0&&kt!==void 0?V[ct].overloadTable[kt]=_t:(V[ct]=_t,V[ct].argCount=kt)},_a=(ct,_t,kt)=>{var Yt=V["dynCall_"+ct];return Yt(_t,...kt)},u2=[],lx,Gl=ct=>{var _t=u2[ct];return _t||(ct>=u2.length&&(u2.length=ct+1),u2[ct]=_t=lx.get(ct)),_t},$a=(ct,_t,kt=[])=>{if(ct.includes("j"))return _a(ct,_t,kt);var Yt=Gl(_t)(...kt);return Yt},pc=(ct,_t)=>(...kt)=>$a(ct,_t,kt),u0=(ct,_t)=>{ct=Kr(ct);function kt(){return ct.includes("j")?pc(ct,_t):Gl(_t)}var Yt=kt();return typeof Yt!="function"&&xn("unknown function pointer with signature "+ct+": "+_t),Yt},hx=(ct,_t)=>{var kt=ao(_t,function(Yt){this.name=_t,this.message=Yt;var ri=new Error(Yt).stack;ri!==void 0&&(this.stack=this.toString()+`
`+ri.replace(/^Error(:[^\n]*)?\n/,""))});return kt.prototype=Object.create(ct.prototype),kt.prototype.constructor=kt,kt.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},kt},Gx,zl=ct=>{var _t=Mt(ct),kt=Kr(_t);return k0(_t),kt},aa=(ct,_t)=>{var kt=[],Yt={};function ri($t){if(!Yt[$t]&&!Tn[$t]){if(Mn[$t]){Mn[$t].forEach(ri);return}kt.push($t),Yt[$t]=!0}}throw _t.forEach(ri),new Gx(ct+": "+kt.map(zl).join([", "]))},Ko=(ct,_t,kt,Yt,ri,$t,Mi,ki,_s,ns,Ts,$r,nn)=>{Ts=Kr(Ts),$t=u0(ri,$t),ki&&(ki=u0(Mi,ki)),ns&&(ns=u0(_s,ns)),nn=u0($r,nn);var vn=$2(Ts);hc(vn,function(){aa("Cannot construct "+Ts+" due to unbound types",[Yt])}),$n([ct,_t,kt],Yt?[Yt]:[],Rn=>{var xr;Rn=Rn[0];var at,Lr;Yt?(at=Rn.registeredClass,Lr=at.instancePrototype):Lr=Gn.prototype;var us=ao(Ts,function(...Kl){if(Object.getPrototypeOf(this)!==jt)throw new px("Use 'new' to construct "+Ts);if(Ls.constructor_body===void 0)throw new px(Ts+" has no accessible constructor");var nu=Ls.constructor_body[Kl.length];if(nu===void 0)throw new px("Tried to invoke ctor of "+Ts+" with invalid number of parameters ("+Kl.length+") - expected ("+Object.keys(Ls.constructor_body).toString()+") parameters instead!");return nu.apply(this,Kl)}),jt=Object.create(Lr,{constructor:{value:us}});us.prototype=jt;var Ls=new Ul(Ts,us,jt,nn,at,$t,ki,ns);Ls.baseClass&&((xr=Ls.baseClass).__derivedClasses!=null||(xr.__derivedClasses=[]),Ls.baseClass.__derivedClasses.push(Ls));var ui=new xx(Ts,Ls,!0,!1,!1),co=new xx(Ts+"*",Ls,!1,!1,!1),wo=new xx(Ts+" const*",Ls,!1,!0,!1);return va[ct]={pointerType:co,constPointerType:wo},ji(vn,us),[ui,co,wo]})},xo=(ct,_t)=>{for(var kt=[],Yt=0;Yt<ct;Yt++)kt.push(Ye[_t+Yt*4>>2]);return kt};function wh(ct){for(var _t=1;_t<ct.length;++_t)if(ct[_t]!==null&&ct[_t].destructorFunction===void 0)return!0;return!1}function zx(ct,_t,kt,Yt,ri,$t){var Mi=_t.length;Mi<2&&xn("argTypes array size mismatch! Must at least get return value and 'this' types!");var ki=_t[1]!==null&&kt!==null,_s=wh(_t),ns=_t[0].name!=="void",Ts=Mi-2,$r=new Array(Ts),nn=[],vn=[],Rn=function(...xr){xr.length!==Ts&&xn("function "+ct+" called with "+xr.length+" arguments, expected "+Ts),vn.length=0;var at;nn.length=ki?2:1,nn[0]=ri,ki&&(at=_t[1].toWireType(vn,this),nn[1]=at);for(var Lr=0;Lr<Ts;++Lr)$r[Lr]=_t[Lr+2].toWireType(vn,xr[Lr]),nn.push($r[Lr]);var us=Yt(...nn);function jt(Ls){if(_s)rn(vn);else for(var ui=ki?1:2;ui<_t.length;ui++){var co=ui===1?at:$r[ui-2];_t[ui].destructorFunction!==null&&_t[ui].destructorFunction(co)}if(ns)return _t[0].fromWireType(Ls)}return jt(us)};return ao(ct,Rn)}var _c=(ct,_t,kt,Yt,ri,$t)=>{var Mi=xo(_t,kt);ri=u0(Yt,ri),$n([],[ct],ki=>{ki=ki[0];var _s="constructor "+ki.name;if(ki.registeredClass.constructor_body===void 0&&(ki.registeredClass.constructor_body=[]),ki.registeredClass.constructor_body[_t-1]!==void 0)throw new px("Cannot register multiple constructors with identical number of parameters ("+(_t-1)+") for class '"+ki.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return ki.registeredClass.constructor_body[_t-1]=()=>{aa("Cannot construct "+ki.name+" due to unbound types",Mi)},$n([],Mi,ns=>(ns.splice(1,0,null),ki.registeredClass.constructor_body[_t-1]=zx(_s,ns,null,ri,$t),[])),[]})},sr=ct=>{ct=ct.trim();const _t=ct.indexOf("(");return _t!==-1?ct.substr(0,_t):ct},Tc=(ct,_t,kt,Yt,ri,$t,Mi,ki,_s)=>{var ns=xo(kt,Yt);_t=Kr(_t),_t=sr(_t),$t=u0(ri,$t),$n([],[ct],Ts=>{Ts=Ts[0];var $r=Ts.name+"."+_t;_t.startsWith("@@")&&(_t=Symbol[_t.substring(2)]),ki&&Ts.registeredClass.pureVirtualFunctions.push(_t);function nn(){aa("Cannot call "+$r+" due to unbound types",ns)}var vn=Ts.registeredClass.instancePrototype,Rn=vn[_t];return Rn===void 0||Rn.overloadTable===void 0&&Rn.className!==Ts.name&&Rn.argCount===kt-2?(nn.argCount=kt-2,nn.className=Ts.name,vn[_t]=nn):(kl(vn,_t,$r),vn[_t].overloadTable[kt-2]=nn),$n([],ns,xr=>{var at=zx($r,xr,Ts,$t,Mi);return vn[_t].overloadTable===void 0?(at.argCount=kt-2,vn[_t]=at):vn[_t].overloadTable[kt-2]=at,[]}),[]})},rl=(ct,_t,kt)=>(ct instanceof Object||xn(kt+' with invalid "this": '+ct),ct instanceof _t.registeredClass.constructor||xn(kt+' incompatible with "this" of type '+ct.constructor.name),ct.$$.ptr||xn("cannot call emscripten binding method "+kt+" on deleted object"),Ro(ct.$$.ptr,ct.$$.ptrType.registeredClass,_t.registeredClass)),_0=(ct,_t,kt,Yt,ri,$t,Mi,ki,_s,ns)=>{_t=Kr(_t),ri=u0(Yt,ri),$n([],[ct],Ts=>{Ts=Ts[0];var $r=Ts.name+"."+_t,nn={get(){aa("Cannot access "+$r+" due to unbound types",[kt,Mi])},enumerable:!0,configurable:!0};return _s?nn.set=()=>aa("Cannot access "+$r+" due to unbound types",[kt,Mi]):nn.set=vn=>xn($r+" is a read-only property"),Object.defineProperty(Ts.registeredClass.instancePrototype,_t,nn),$n([],_s?[kt,Mi]:[kt],vn=>{var Rn=vn[0],xr={get(){var Lr=rl(this,Ts,$r+" getter");return Rn.fromWireType(ri($t,Lr))},enumerable:!0};if(_s){_s=u0(ki,_s);var at=vn[1];xr.set=function(Lr){var us=rl(this,Ts,$r+" setter"),jt=[];_s(ns,us,at.toWireType(jt,Lr)),rn(jt)}}return Object.defineProperty(Ts.registeredClass.instancePrototype,_t,xr),[]}),[]})},nl=[],ci=[],al=ct=>{ct>9&&--ci[ct+1]===0&&(ci[ct]=void 0,nl.push(ct))},wx=()=>ci.length/2-5-nl.length,jo=()=>{ci.push(0,1,void 0,1,null,1,!0,1,!1,1),V.count_emval_handles=wx},xl={toValue:ct=>(ct||xn("Cannot use deleted val. handle = "+ct),ci[ct]),toHandle:ct=>{switch(ct){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const _t=nl.pop()||ci.length;return ci[_t]=ct,ci[_t+1]=1,_t}}}},Ua={name:"emscripten::val",fromWireType:ct=>{var _t=xl.toValue(ct);return al(ct),_t},toWireType:(ct,_t)=>xl.toHandle(_t),argPackAdvance:h0,readValueFromPointer:Rr,destructorFunction:null},T0=ct=>l0(ct,Ua),Wl=ct=>{if(ct===null)return"null";var _t=typeof ct;return _t==="object"||_t==="array"||_t==="function"?ct.toString():""+ct},qo=(ct,_t)=>{switch(_t){case 4:return function(kt){return this.fromWireType(je[kt>>2])};case 8:return function(kt){return this.fromWireType(Ke[kt>>3])};default:throw new TypeError("invalid float width ("+_t+"): "+ct)}},Wx=(ct,_t,kt)=>{_t=Kr(_t),l0(ct,{name:_t,fromWireType:Yt=>Yt,toWireType:(Yt,ri)=>ri,argPackAdvance:h0,readValueFromPointer:qo(_t,kt),destructorFunction:null})},Hx=(ct,_t,kt)=>{switch(_t){case 1:return kt?Yt=>ke[Yt]:Yt=>Ue[Yt];case 2:return kt?Yt=>Ge[Yt>>1]:Yt=>We[Yt>>1];case 4:return kt?Yt=>Xe[Yt>>2]:Yt=>Ye[Yt>>2];default:throw new TypeError("invalid integer width ("+_t+"): "+ct)}},vc=(ct,_t,kt,Yt,ri)=>{_t=Kr(_t);var $t=Ts=>Ts;if(Yt===0){var Mi=32-8*kt;$t=Ts=>Ts<<Mi>>>Mi}var ki=_t.includes("unsigned"),_s=(Ts,$r)=>{},ns;ki?ns=function(Ts,$r){return _s($r,this.name),$r>>>0}:ns=function(Ts,$r){return _s($r,this.name),$r},l0(ct,{name:_t,fromWireType:$t,toWireType:ns,argPackAdvance:h0,readValueFromPointer:Hx(_t,kt,Yt!==0),destructorFunction:null})},Rc=(ct,_t,kt)=>{var Yt=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],ri=Yt[_t];function $t(Mi){var ki=Ye[Mi>>2],_s=Ye[Mi+4>>2];return new ri(ke.buffer,_s,ki)}kt=Kr(kt),l0(ct,{name:kt,fromWireType:$t,argPackAdvance:h0,readValueFromPointer:$t},{ignoreDuplicateRegistrations:!0})},Lh=(ct,_t,kt,Yt)=>{if(!(Yt>0))return 0;for(var ri=kt,$t=kt+Yt-1,Mi=0;Mi<ct.length;++Mi){var ki=ct.charCodeAt(Mi);if(ki>=55296&&ki<=57343){var _s=ct.charCodeAt(++Mi);ki=65536+((ki&1023)<<10)|_s&1023}if(ki<=127){if(kt>=$t)break;_t[kt++]=ki}else if(ki<=2047){if(kt+1>=$t)break;_t[kt++]=192|ki>>6,_t[kt++]=128|ki&63}else if(ki<=65535){if(kt+2>=$t)break;_t[kt++]=224|ki>>12,_t[kt++]=128|ki>>6&63,_t[kt++]=128|ki&63}else{if(kt+3>=$t)break;_t[kt++]=240|ki>>18,_t[kt++]=128|ki>>12&63,_t[kt++]=128|ki>>6&63,_t[kt++]=128|ki&63}}return _t[kt]=0,kt-ri},ll=(ct,_t,kt)=>Lh(ct,Ue,_t,kt),hl=ct=>{for(var _t=0,kt=0;kt<ct.length;++kt){var Yt=ct.charCodeAt(kt);Yt<=127?_t++:Yt<=2047?_t+=2:Yt>=55296&&Yt<=57343?(_t+=4,++kt):_t+=3}return _t},_x=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Mc=(ct,_t,kt)=>{for(var Yt=_t+kt,ri=_t;ct[ri]&&!(ri>=Yt);)++ri;if(ri-_t>16&&ct.buffer&&_x)return _x.decode(ct.subarray(_t,ri));for(var $t="";_t<ri;){var Mi=ct[_t++];if(!(Mi&128)){$t+=String.fromCharCode(Mi);continue}var ki=ct[_t++]&63;if((Mi&224)==192){$t+=String.fromCharCode((Mi&31)<<6|ki);continue}var _s=ct[_t++]&63;if((Mi&240)==224?Mi=(Mi&15)<<12|ki<<6|_s:Mi=(Mi&7)<<18|ki<<12|_s<<6|ct[_t++]&63,Mi<65536)$t+=String.fromCharCode(Mi);else{var ns=Mi-65536;$t+=String.fromCharCode(55296|ns>>10,56320|ns&1023)}}return $t},kh=(ct,_t)=>ct?Mc(Ue,ct,_t):"",cl=(ct,_t)=>{_t=Kr(_t);var kt=_t==="std::string";l0(ct,{name:_t,fromWireType(Yt){var ri=Ye[Yt>>2],$t=Yt+4,Mi;if(kt)for(var ki=$t,_s=0;_s<=ri;++_s){var ns=$t+_s;if(_s==ri||Ue[ns]==0){var Ts=ns-ki,$r=kh(ki,Ts);Mi===void 0?Mi=$r:(Mi+=String.fromCharCode(0),Mi+=$r),ki=ns+1}}else{for(var nn=new Array(ri),_s=0;_s<ri;++_s)nn[_s]=String.fromCharCode(Ue[$t+_s]);Mi=nn.join("")}return k0(Yt),Mi},toWireType(Yt,ri){ri instanceof ArrayBuffer&&(ri=new Uint8Array(ri));var $t,Mi=typeof ri=="string";Mi||ri instanceof Uint8Array||ri instanceof Uint8ClampedArray||ri instanceof Int8Array||xn("Cannot pass non-string to std::string"),kt&&Mi?$t=hl(ri):$t=ri.length;var ki=Y0(4+$t+1),_s=ki+4;if(Ye[ki>>2]=$t,kt&&Mi)ll(ri,_s,$t+1);else if(Mi)for(var ns=0;ns<$t;++ns){var Ts=ri.charCodeAt(ns);Ts>255&&(k0(_s),xn("String has UTF-16 code units that do not fit in 8 bits")),Ue[_s+ns]=Ts}else for(var ns=0;ns<$t;++ns)Ue[_s+ns]=ri[ns];return Yt!==null&&Yt.push(k0,ki),ki},argPackAdvance:h0,readValueFromPointer:Rr,destructorFunction(Yt){k0(Yt)}})},L0=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,_2=(ct,_t)=>{for(var kt=ct,Yt=kt>>1,ri=Yt+_t/2;!(Yt>=ri)&&We[Yt];)++Yt;if(kt=Yt<<1,kt-ct>32&&L0)return L0.decode(Ue.subarray(ct,kt));for(var $t="",Mi=0;!(Mi>=_t/2);++Mi){var ki=Ge[ct+Mi*2>>1];if(ki==0)break;$t+=String.fromCharCode(ki)}return $t},T2=(ct,_t,kt)=>{if(kt!=null||(kt=2147483647),kt<2)return 0;kt-=2;for(var Yt=_t,ri=kt<ct.length*2?kt/2:ct.length,$t=0;$t<ri;++$t){var Mi=ct.charCodeAt($t);Ge[_t>>1]=Mi,_t+=2}return Ge[_t>>1]=0,_t-Yt},Hl=ct=>ct.length*2,Ra=(ct,_t)=>{for(var kt=0,Yt="";!(kt>=_t/4);){var ri=Xe[ct+kt*4>>2];if(ri==0)break;if(++kt,ri>=65536){var $t=ri-65536;Yt+=String.fromCharCode(55296|$t>>10,56320|$t&1023)}else Yt+=String.fromCharCode(ri)}return Yt},Uh=(ct,_t,kt)=>{if(kt!=null||(kt=2147483647),kt<4)return 0;for(var Yt=_t,ri=Yt+kt-4,$t=0;$t<ct.length;++$t){var Mi=ct.charCodeAt($t);if(Mi>=55296&&Mi<=57343){var ki=ct.charCodeAt(++$t);Mi=65536+((Mi&1023)<<10)|ki&1023}if(Xe[_t>>2]=Mi,_t+=4,_t+4>ri)break}return Xe[_t>>2]=0,_t-Yt},Xl=ct=>{for(var _t=0,kt=0;kt<ct.length;++kt){var Yt=ct.charCodeAt(kt);Yt>=55296&&Yt<=57343&&++kt,_t+=4}return _t},ul=(ct,_t,kt)=>{kt=Kr(kt);var Yt,ri,$t,Mi;_t===2?(Yt=_2,ri=T2,Mi=Hl,$t=ki=>We[ki>>1]):_t===4&&(Yt=Ra,ri=Uh,Mi=Xl,$t=ki=>Ye[ki>>2]),l0(ct,{name:kt,fromWireType:ki=>{for(var _s=Ye[ki>>2],ns,Ts=ki+4,$r=0;$r<=_s;++$r){var nn=ki+4+$r*_t;if($r==_s||$t(nn)==0){var vn=nn-Ts,Rn=Yt(Ts,vn);ns===void 0?ns=Rn:(ns+=String.fromCharCode(0),ns+=Rn),Ts=nn+_t}}return k0(ki),ns},toWireType:(ki,_s)=>{typeof _s!="string"&&xn("Cannot pass non-string to C++ string type "+kt);var ns=Mi(_s),Ts=Y0(4+ns+_t);return Ye[Ts>>2]=ns/_t,ri(_s,Ts+4,ns+_t),ki!==null&&ki.push(k0,Ts),Ts},argPackAdvance:h0,readValueFromPointer:Rr,destructorFunction(ki){k0(ki)}})},v2=(ct,_t,kt,Yt,ri,$t)=>{hr[ct]={name:Kr(_t),rawConstructor:u0(kt,Yt),rawDestructor:u0(ri,$t),elements:[]}},lo=(ct,_t,kt,Yt,ri,$t,Mi,ki,_s)=>{hr[ct].elements.push({getterReturnType:_t,getter:u0(kt,Yt),getterContext:ri,setterArgumentType:$t,setter:u0(Mi,ki),setterContext:_s})},Yl=(ct,_t,kt,Yt,ri,$t)=>{a0[ct]={name:Kr(_t),rawConstructor:u0(kt,Yt),rawDestructor:u0(ri,$t),fields:[]}},Gh=(ct,_t,kt,Yt,ri,$t,Mi,ki,_s,ns)=>{a0[ct].fields.push({fieldName:Kr(_t),getterReturnType:kt,getter:u0(Yt,ri),getterContext:$t,setterArgumentType:Mi,setter:u0(ki,_s),setterContext:ns})},R2=(ct,_t)=>{_t=Kr(_t),l0(ct,{isVoid:!0,name:_t,argPackAdvance:0,fromWireType:()=>{},toWireType:(kt,Yt)=>{}})},wc=(ct,_t)=>{var kt=Tn[ct];return kt===void 0&&xn(_t+" has unknown type "+zl(ct)),kt},M2=(ct,_t)=>{ct=wc(ct,"_emval_take_value");var kt=ct.readValueFromPointer(_t);return xl.toHandle(kt)},zh=()=>{rs("")},Lc=(ct,_t,kt)=>Ue.copyWithin(ct,_t,_t+kt),j0=()=>2147483648,ho=ct=>{var _t=Re.buffer,kt=(ct-_t.byteLength+65535)/65536;try{return Re.grow(kt),qe(),1}catch{}},pl=ct=>{var _t=Ue.length;ct>>>=0;var kt=j0();if(ct>kt)return!1;for(var Yt=(_s,ns)=>_s+(ns-_s%ns)%ns,ri=1;ri<=4;ri*=2){var $t=_t*(1+.2/ri);$t=Math.min($t,ct+100663296);var Mi=Math.min(kt,Yt(Math.max(ct,$t),65536)),ki=ho(Mi);if(ki)return!0}return!1};Un=V.InternalError=class extends Error{constructor(ct){super(ct),this.name="InternalError"}},ka(),px=V.BindingError=class extends Error{constructor(ct){super(ct),this.name="BindingError"}},Ll(),ur(),Mo(),Gx=V.UnboundTypeError=hx(Error,"UnboundTypeError"),jo();var Gs={b:$s,h:cs,x:ux,q:Yx,v:wl,l:Ko,g:_c,c:Tc,f:_0,u:T0,n:Wx,e:vc,a:Rc,m:cl,j:ul,i:v2,d:lo,o:Yl,k:Gh,w:R2,p:M2,r:zh,t:Lc,s:pl},r0=hs(),k0=ct=>(k0=r0.A)(ct),Y0=ct=>(Y0=r0.B)(ct),Mt=ct=>(Mt=r0.D)(ct),lt=ct=>(lt=r0.E)(ct),ni;Wi=function ct(){ni||wi(),ni||(Wi=ct)};function wi(){if(Yi>0||(wt(),Yi>0))return;function ct(){ni||(ni=!0,V.calledRun=!0,!we&&(Kt(),$(V),V.onRuntimeInitialized&&V.onRuntimeInitialized(),Ht()))}V.setStatus?(V.setStatus("Running..."),setTimeout(function(){setTimeout(function(){V.setStatus("")},1),ct()},1)):ct()}if(V.preInit)for(typeof V.preInit=="function"&&(V.preInit=[V.preInit]);V.preInit.length>0;)V.preInit.pop()();return wi(),A.ready}})();class Aq{constructor(){this.faceTracks=[],this.faceFilters=[],this.meshScore=.9,this.maskSize=256}async process(A,V){var $,ne,xe,le,ce;const ue=JY(()=>{const Ue=ip(iU(A,3),"float32"),Ge=OD(Ue,1/255);return B0(Ge,0)});let Te=[];this.faceTracks.length===0&&(Te=await(($=this.faceDetector)==null?void 0:$.process(ue,!0))||[],Te.forEach(Ue=>{if(!Ue.keypoints)return;const{box:Ge}=Ue,We=.5*.3*(Ue.box[1][1]-Ue.box[0][1]);this.faceTracks.push({box:[[Ge[0][0],Ge[0][1]-We],[Ge[1][0],Ge[1][1]+We]],symmetry:[Ue.keypoints[Ae.Mouth],Ue.keypoints[Ae.Nose]]}),this.faceFilters.push(new this.faceModule.FaceFilter({minCutOff:1,minCutOffD:2,beta:30},{minCutOff:1,minCutOffD:2,beta:30},1))}),(ne=this.bodySegmenter)==null||ne.reset());const Me=this.faceTracks.length>0?((xe=this.meshDetector)==null?void 0:xe.process(ue,this.faceTracks))||[]:[],Re=[],we=[],ke=[];for(let Ue=0;Ue<this.faceTracks.length;Ue++){const Ge=Me[Ue],{box:We}=Ge,Xe=[Ge.keypoints[((le=this.meshDetector)==null?void 0:le.symmetryPoints[0])||0],Ge.keypoints[((ce=this.meshDetector)==null?void 0:ce.symmetryPoints[1])||0]];if(VU(this.faceTracks[Ue].box,We)>.5&&Ge.score>this.meshScore){if(ke.push(Ge),Re.push({box:We,symmetry:[{x:Xe[0][0],y:Xe[0][1]},{x:Xe[1][0],y:Xe[1][1]}]}),V===void 0)continue;const[Ye,je]=[ue.shape[1],ue.shape[2]],[Ke,qe]=[We[1][0]-We[0][0],We[1][1]-We[0][1]],$e=(Ke+qe*je/Ye)*.5;this.faceFilters[Ue].smoothFilter(Ge,V,1/$e),Ge.keypoints=this.faceFilters[Ue].smoothPixel(),Ge.box=this.faceFilters[Ue].smoothBox();const{bodySegmenter:vt,maskExt:nt}=this;if(vt){const wt=vt.size(),Kt=je/Ye,Ht=wt.width/wt.height/Kt,pi=Ht<1?{width:Ht,height:1}:{width:1,height:1/Ht},hi=[.5*(We[0][0]+We[1][0]),.5*(We[0][1]+We[1][1])],ai=nt?[[We[0][0]-Ke*nt,We[0][1]-qe*nt],[We[1][0]+Ke*nt,We[1][1]+qe*nt]]:[[hi[0]-.5*pi.width,hi[1]-.5*pi.height],[hi[0]+.5*pi.width,hi[1]+.5*pi.height]];ai[0][0]<0&&(ai[1][0]-=ai[0][0],ai[0][0]=0),ai[0][1]<0&&(ai[1][1]-=ai[0][1],ai[0][1]=0),ai[1][0]>1&&(ai[0][0]-=ai[1][0]-1,ai[1][0]=1),ai[1][1]>1&&(ai[0][1]-=ai[1][1]-1,ai[1][1]=1),ai[0][0]<0&&(ai[0][0]*=.5,ai[1][0]-=ai[0][0]),ai[0][1]<0&&(ai[0][1]*=.5,ai[1][1]-=ai[0][1]),Ge.mask=vt.process(ue,ai)}we.push(this.faceFilters[Ue])}else this.faceFilters[Ue].delete()}return ue.dispose(),this.faceTracks=Re,this.faceFilters=we,ke}align(A){var V;const $=new this.faceModule.VectorFloat;return A.flat().forEach(ne=>$.push_back(ne)),(V=this.faceAligner)==null||V.align($),$.delete(),this.alignTransform()}alignTransform(){if(!this.faceAligner)return;const A=this.faceAligner.rotation,V=this.faceAligner.translation,$=this.faceAligner.scale,ne=this.faceAligner.shapeScale;return{rotation:[A[0],A[1],A[2],A[3]],translation:[V[0],V[1],V[2]],scale:$,shapeScale:[ne[0],ne[1],ne[2]]}}metricPoints(){if(!this.faceAligner)return;let A=[];const V=this.faceAligner.metricPoints();for(let $=0;$<V.size();$+=3)A.push([V.get($+0),V.get($+1),V.get($+2)]);return V.delete(),A}referencePoints(){if(!this.faceAligner)return;let A=[];const V=this.faceAligner.referencePoints();for(let $=0;$<V.size();$+=3)A.push([V.get($+0),V.get($+1),V.get($+2)]);return V.delete(),A}backprojPoints(){if(!this.faceAligner)return;let A=[];const V=this.faceAligner.backprojPoints();for(let $=0;$<V.size();$+=3)A.push([V.get($+0),V.get($+1),V.get($+2)]);return V.delete(),A}setCamera(A,V,$){var ne;if((ne=this.faceAligner)==null||ne.setCamera(A,V,$),this.bodySegmenter&&!this.maskExt){const xe=this.maskSize/16,[le,ce]=V>1?[xe,Math.round(xe/V)]:[Math.round(xe*V),xe];this.bodySegmenter.resize({width:le*16,height:ce*16})}}async init(A,V="./",$=!1,ne=!1,xe=!1,le,ce=256,ue="webgl"){const Te=await VM(A,V,$),Me=new Te.ParseLoader(V),[Re,we]=ne?["faceext.wasm","meshextmodel.def"]:["face.wasm","meshmodel.def"],ke=[Re,"faceutils.wasm"];if(xe&&ke.push("mask.wasm"),!$)for(const je of ke)await Me.remove(je);if(!await Me.loadDict(ke)||!await Me.load(Re)||!Me.parse())return;Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!0),JG(),await Jj(ue);const Ue={weightUrlConverter:async je=>je,fetchFunc:async je=>{const Ke=new Blob([Me.file(je)]);return fetch(URL.createObjectURL(Ke))}},Ge=await Ph("facemodel.def",Ue),We=await Ph(we,Ue),Xe=xe&&await Me.load("mask.wasm")&&Me.parse()&&await Ph("maskmodel.def",Ue);if(this.faceDetector=new Ao(Ge),this.meshDetector=new AQ(We),Xe&&(this.bodySegmenter=new AT(Xe,typeof xe=="object"&&xe.smooth),this.bodySegmenter.resize({width:ce,height:ce}),this.maskSize=this.bodySegmenter.size().width,this.maskExt=le),!await Me.load("faceutils.wasm"))return;const Ye=await Av({wasmBinary:Me.data()});Me.delete(),Ye.FaceFilter.prototype.smoothFilter=function(je,Ke){const qe=new Ye.VectorFloat,$e=new Ye.VectorFloat;je.keypoints.flat().forEach(vt=>qe.push_back(vt)),je.box.flat().forEach(vt=>$e.push_back(vt)),this.filter(qe,$e,je.score,Ke,1),qe.delete(),$e.delete()},Ye.FaceFilter.prototype.smoothPixel=function(){let je=[];const Ke=this.pixel();for(let qe=0;qe<Ke.size();qe+=3)je.push([Ke.get(qe+0),Ke.get(qe+1),Ke.get(qe+2)]);return Ke.delete(),je},Ye.FaceFilter.prototype.smoothBox=function(){const je=this.box(),Ke=[[je[0],je[1]],[je[2],je[3]]];return je.delete(),Ke},this.faceModule=Ye,this.faceAligner=new this.faceModule.FaceAligner}reset(){var A;this.faceFilters.forEach(V=>V.delete()),this.faceFilters=[],this.faceTracks=[],(A=this.bodySegmenter)==null||A.reset()}async prepare(){var A,V,$;Cd().set("ENGINE_COMPILE_ONLY",!0),await((A=this.faceDetector)==null?void 0:A.prepare()),await((V=this.meshDetector)==null?void 0:V.prepare()),await(($=this.bodySegmenter)==null?void 0:$.prepare());const ne=f1();ne instanceof ea&&(ne.checkCompileCompletion(),ne.getUniformLocations()),Cd().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var A,V,$,ne;this.reset(),(A=this.faceDetector)==null||A.dispose(),(V=this.meshDetector)==null||V.dispose(),($=this.bodySegmenter)==null||$.dispose(),(ne=this.faceAligner)==null||ne.delete()}}var Al=Object.defineProperty,Aa=Object.getOwnPropertySymbols,An=Object.prototype.hasOwnProperty,AL=Object.prototype.propertyIsEnumerable,AH=(W,A,V)=>A in W?Al(W,A,{enumerable:!0,configurable:!0,writable:!0,value:V}):W[A]=V,Ak=(W,A)=>{for(var V in A||(A={}))An.call(A,V)&&AH(W,V,A[V]);if(Aa)for(var V of Aa(A))AL.call(A,V)&&AH(W,V,A[V]);return W};class Az{constructor(A){this.model=A,this.handsMax=1,this.iouThresh=.3,this.scoreThresh=.45,this.model=A,this.modelSize=A.inputs[0].shape?{width:A.inputs[0].shape[2],height:A.inputs[0].shape[1]}:{width:192,height:192},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchorsX=SD(this.anchorsData.map(V=>V.x)),this.anchorsY=SD(this.anchorsData.map(V=>V.y))}async process(A){let V={x:0,y:0};const[$,ne]=JY(()=>{const Te={width:A.shape[2],height:A.shape[1]},Me=Te.width/Te.height;let Re=Ak({},Te),we={x:0,y:0};Me>this.modelRatio?(Re.height=A.shape[2]/this.modelRatio,we.y=Math.floor((Re.height-A.shape[1])*.5),V.y=we.y/Re.height):Me<this.modelRatio&&(Re.width=A.shape[1]*this.modelRatio,we.x=Math.floor((Re.width-A.shape[2])*.5),V.x=we.x/Re.width);const ke=BA(A,[[0,0],[we.y,we.y],[we.x,we.x],[0,0]],0),Ue=dQ.resizeBilinear(ke,[this.modelSize.height,this.modelSize.width]),Ge=this.model.execute(Ue,"palm"),We=SB(t0(Ge,[0,0,1],[1,-1,-1])),Xe=SB(t0(Ge,[0,0,0],[1,-1,1])),Ye=Oj(tC(Xe,-100,100));return[this.decodeBoxes(We,[this.anchorsX,this.anchorsY],this.modelSize),Ye]}),xe=await $.data(),le=await ne.data();let ce=[];for(let Te=0;Te<le.length;Te++){if(le[Te]<this.scoreThresh)continue;const Me=xe[Te*18+2]-xe[Te*18+0],Re=xe[Te*18+3]-xe[Te*18+1];Me<0||Re<0||ce.push({box:[[xe[Te*18+0],xe[Te*18+1]],[xe[Te*18+2],xe[Te*18+3]]],points:[[xe[Te*18+4],xe[Te*18+5]],[xe[Te*18+6],xe[Te*18+7]],[xe[Te*18+8],xe[Te*18+9]],[xe[Te*18+10],xe[Te*18+11]],[xe[Te*18+12],xe[Te*18+13]],[xe[Te*18+14],xe[Te*18+15]],[xe[Te*18+16],xe[Te*18+17]]],score:le[Te]})}if($.dispose(),ne.dispose(),ce.length<1)return[];if(ce.length>1){const Te=Sg(ce.map(Ue=>[Ue.box[0][1],Ue.box[0][0],Ue.box[1][1],Ue.box[1][0]])),Me=SD(ce.map(Ue=>Ue.score)),Re=await dQ.nonMaxSuppressionAsync(Te,Me,this.handsMax,this.iouThresh,this.scoreThresh),we=await Re.data();Re.dispose();const ke=[];for(let Ue=0;Ue<we.length;Ue++)ke.push(ce[we[Ue]]);ce=ke}if(ce.length<1)return[];const ue={width:1-2*V.x,height:1-2*V.y};return ce.map(Te=>({points:Te.points.map(Me=>[(Me[0]-V.x)/ue.width,(Me[1]-V.y)/ue.height]),box:Te.box.map(Me=>[(Me[0]-V.x)/ue.width,(Me[1]-V.y)/ue.height]),score:Te.score}))}decodeBoxes(A,V,$){let ne=SB(t0(A,[0,0],[-1,1])),xe=SB(t0(A,[0,1],[-1,1])),le=SB(t0(A,[0,2],[-1,1])),ce=SB(t0(A,[0,3],[-1,1]));ne=OS(OP(ne,$.width),V[0]),xe=OS(OP(xe,$.height),V[1]),le=OP(le,$.width*2),ce=OP(ce,$.height*2);const ue=Oz(BS(ne,le),[2016,1]),Te=Oz(BS(xe,ce),[2016,1]),Me=Oz(OS(ne,le),[2016,1]),Re=Oz(OS(xe,ce),[2016,1]);let we=tN([ue,Te,Me,Re],1);for(let ke=0;ke<7;ke++){let Ue=SB(t0(A,[0,4+ke*2],[-1,1])),Ge=SB(t0(A,[0,4+ke*2+1],[-1,1]));Ue=Oz(OS(OP(Ue,$.width),V[0]),[2016,1]),Ge=Oz(OS(OP(Ge,$.height),V[1]),[2016,1]),we=tN([we,Ue,Ge],1)}return we}buildAnchors(A){const V=[8,16,16,16],$=[];let ne=0;for(;ne<4;){let xe=0,le=ne;for(;le<V.length&&V[le]===V[ne];)xe+=2,le++;const ce=V[ne],ue=Math.ceil(A.height/ce),Te=Math.ceil(A.width/ce);for(let Me=0;Me<ue;++Me)for(let Re=0;Re<Te;++Re)for(let we=0;we<xe;++we)$.push({x:(Re+.5)/Te,y:(Me+.5)/ue});ne=le}return $}async prepare(){const{width:A,height:V}=this.modelSize,$=BQ([1,V,A,3]),ne=this.model.execute($,"palm");await ne.data(),$.dispose(),ne.dispose()}dispose(){this.model.dispose(),this.anchorsX.dispose(),this.anchorsY.dispose()}}var Ax;(W=>(W.add=(A,V)=>[A[0]+V[0],A[1]+V[1],A[2]+V[2]],W.sub=(A,V)=>[A[0]-V[0],A[1]-V[1],A[2]-V[2]],W.cross=(A,V)=>[A[1]*V[2]-A[2]*V[1],A[2]*V[0]-A[0]*V[2],A[0]*V[1]-A[1]*V[0]],W.lerp=(A,V,$)=>[A[0]+(V[0]-A[0])*$,A[1]+(V[1]-A[1])*$,A[2]+(V[2]-A[2])*$],W.scale=(A,V)=>[A[0]*V,A[1]*V,A[2]*V],W.negate=A=>[-A[0],-A[1],-A[2]],W.normalize=A=>(0,W.scale)(A,1/(0,W.length)(A)),W.normalizeToLen=(A,V)=>(0,W.scale)(A,V/(0,W.length)(A)),W.dot=(A,V)=>A[0]*V[0]+A[1]*V[1]+A[2]*V[2],W.lengthSqr=A=>A[0]**2+A[1]**2+A[2]**2,W.length=A=>Math.sqrt(A[0]**2+A[1]**2+A[2]**2)))(Ax||(Ax={}));class AU{constructor(A,V=!0){this.model=A,this.wrist=V,this.localMaxSize={width:256,height:256},this.circlePoints=[],this.colorWeights=[.5,1,.8],this.colorThresh=.05,this.edgeThresh=.003,this.edgeStop=.01,this.model=A,this.modelSize=A.inputs[0].shape?{width:A.inputs[0].shape[2],height:A.inputs[0].shape[1]}:{width:224,height:224},this.modelRatio=this.modelSize.width/this.modelSize.height,this.buildCircle(31)}process(A,V){const[$,ne]=[A.shape[1],A.shape[2]],{modelSize:xe,modelRatio:le,localMaxSize:ce}=this;return V.map(ue=>{const Te=[ue.start[0]*ne,ue.start[1]*$],Me=[ue.end[0]*ne,ue.end[1]*$];let[Re,we]=[Me[0]-Te[0],Te[1]-Me[1]];const ke=Math.sqrt(Re**2+we**2);Re/=ke,we/=ke;const Ue=Math.atan2(Re,we),Ge=[.5*(ue.box[0][0]+ue.box[1][0])*ne,.5*(ue.box[0][1]+ue.box[1][1])*$];let We=.5*(ue.box[1][0]-ue.box[0][0])*ne,Xe=.5*(ue.box[1][1]-ue.box[0][1])*$;const Ye=We/Xe/le;Ye>1?We*=Ye:Xe/=Ye;const je=[Ge[1]-Xe,Ge[0]-We,Ge[1]+Xe,Ge[0]+We],Ke=JY(()=>this.rotatedRect(A,je,Ue,!1,xe)),qe=["Identity_2:0","Identity_1:0","Identity:0","Identity_3:0"],[$e,vt,nt,wt]=this.model.execute(Ke,qe),Kt=$e.dataSync(),Ht=wt.dataSync(),pi=vt.dataSync()[0],hi=2*nt.dataSync()[0]-1;let ai=[];for(let li=0;li<21;li++)ai.push([Kt[3*li+0]/xe.width,Kt[3*li+1]/xe.height,Kt[3*li+2]/xe.width/.4]);const Yi=[ai[0][0],ai[0][1]];let Wi=Yi[0],ls=Yi[1];Wi=(Wi-.5)*2*We,ls=(ls-.5)*2*Xe,Yi[0]=Wi*we-ls*Re+Ge[0],Yi[1]=Wi*Re+ls*we+Ge[1];const Hi=[Yi[1]-Xe,Yi[0]-We,Yi[1]+Xe,Yi[0]+We],rs=this.wrist?JY(()=>this.rotatedRect(A,Hi,Ue,!0,ce)):void 0;let Us=[],Hs=[];const qi=rs?JY(()=>{const li=SB(rs,[0]),vi=iX(li,[[.299,-.14713,.615],[.587,-.28886,-.51499],[.114,.436,-.10001]]),Ui=[[[[-.25],[-.25],[-.25]],[[0],[0],[0]],[[.25],[.25],[.25]]],[[[-.5],[-.5],[-.5]],[[0],[0],[0]],[[.5],[.5],[.5]]],[[[-.25],[-.25],[-.25]],[[0],[0],[0]],[[.25],[.25],[.25]]]],hs=[[[[-.25],[-.25],[-.25]],[[-.5],[-.5],[-.5]],[[-.25],[-.25],[-.25]]],[[[0],[0],[0]],[[0],[0],[0]],[[0],[0],[0]]],[[[.25],[.25],[.25]],[[.5],[.5],[.5]],[[.25],[.25],[.25]]]],Xs=tg(vi,Ui,1,"same"),cr=tg(vi,hs,1,"same"),Ks=tG(tx(Xs),2,!0),$s=tG(tx(cr),2,!0),hr=tG(OD(Xs,cr),2,!0),rn=OS(Ks,$s),Rr=tk(OS(tx(BS(Ks,$s)),OD(tx(hr),4))),Yr=OD(OS(rn,Rr),.5);let Tn=tf([BS(Yr,$s),hr],2);Tn=OP(Tn,tj(Tn,2,!0));let Mn=Rr;if(this.backend&&this.localMaxProg){const xn=this.backend.compileAndRun(this.localMaxProg,[Mn,Tn]);Mn=Ju().makeTensorFromTensorInfo(xn)}const Un=OD(OU(vi,4,4,"valid"),this.colorWeights),qn=Un.shape,$n=[qn[0]/2,qn[1]/2],cs=Oz(Un,[qn[0],qn[1],1,3]),a0=Sf(Un,[$n[0]-3,$n[1]-4,0],[7,9,3]),ux=tl(tj(BS(cs,Oz(a0,[-1,3])),3,!1),2,!0),Yx=Sf(Un,[$n[0]-4,8,0],[2,8,3]),ka=Sf(Un,[$n[0]-4,qn[1]-16,0],[2,8,3]),cn=OM([Oz(Yx,[-1,3]),Oz(ka,[-1,3])],0),Kr=tl(tj(BS(cs,cn),3,!1),2,!0),px=BR(BP(Bf(ux,Kr),Bf(ux,[this.colorThresh])),9,"max","same");return{yuv:vi,rgb:li,edgeVal:Mn,edgeXY:Tn,fg:px}}):void 0,as=qi?JY(()=>{const li=BD(qi.edgeVal,4,4,"valid");let vi=OU(qi.edgeXY,4,4,"valid");vi=OP(vi,tj(vi,2,!0));const Ui=li.dataSync(),hs=vi.dataSync(),Xs=qi.fg.dataSync(),cr=this.circlePoints.map(Yr=>this.evaluateLine([64/2,64/2],Yr,Ui,hs,Xs));let Ks=0,$s=0,hr=-1;for(let Yr=0;Yr<cr.length;Yr++){const Tn=cr[Yr].strengthL;for(let Mn=Yr;Mn<Yr+12&&Mn<cr.length;Mn++){const Un=Tn+cr[Mn].strengthR;Un>=hr&&(hr=Un,Ks=Yr,$s=Mn)}}Us.push([...this.circlePoints[Math.round(.5*(Ks+$s))]]);const rn=cr[Ks].anchorsL.map(Yr=>[Yr[0],Yr[1]]),Rr=cr[$s].anchorsR.map(Yr=>[Yr[0],Yr[1]]);Us.push(...rn),Us.push(...Rr),Hs.push(this.fitLine(rn)),Hs.push(this.fitLine(Rr))}):void 0;return Ke.dispose(),$e.dispose(),wt.dispose(),vt.dispose(),nt.dispose(),rs?.dispose(),qi?.yuv.dispose(),qi?.rgb.dispose(),qi?.edgeVal.dispose(),qi?.edgeXY.dispose(),{points:ai,metricData:Ht,score:pi,handedness:hi,radiusX:We,radiusY:Xe,angle:Ue,anchors:Us,lines:Hs,center:Ge,wristCenter:Yi,wristDebug:as}}).map((ue,Te)=>{const{points:Me,metricData:Re,score:we,handedness:ke,radiusX:Ue,radiusY:Ge,angle:We,anchors:Xe,lines:Ye,center:je,wristCenter:Ke,wristDebug:qe}=ue,$e=Me.map((Ht,pi)=>({pixel:Ht,metric:[Re[3*pi+0],Re[3*pi+1],Re[3*pi+2]]}));$e.forEach(Ht=>{Ht.pixel[0]=(Ht.pixel[0]-.5)*2*Ue,Ht.pixel[1]=(Ht.pixel[1]-.5)*2*Ge,Ht.pixel[2]*=2*Ue});const vt=Math.sin(We),nt=Math.cos(We);$e.forEach(Ht=>{const pi=Ht.pixel[0],hi=Ht.pixel[1];Ht.pixel[0]=(pi*nt-hi*vt+je[0])/ne,Ht.pixel[1]=(pi*vt+hi*nt+je[1])/$,Ht.pixel[2]/=ne;const ai=Ht.metric[0],Yi=Ht.metric[1];Ht.metric[0]=ai*nt-Yi*vt,Ht.metric[1]=ai*vt+Yi*nt});const wt=this.circlePoints.map(Ht=>[Ht[0]/64,Ht[1]/64]);Xe.forEach(Ht=>{Ht[0]=(Ht[0]+.5)/64,Ht[1]=(Ht[1]+.5)/64}),Xe.forEach(Ht=>{const pi=(Ht[0]-.5)*2*Ue,hi=(Ht[1]-.5)*2*Ge;Ht[0]=(pi*nt-hi*vt+Ke[0])/ne,Ht[1]=(pi*vt+hi*nt+Ke[1])/$}),Ye.forEach(Ht=>{Ht.point[0]=(Ht.point[0]+.5)/64,Ht.point[1]=(Ht.point[1]+.5)/64});const Kt=this.normalizeLines(Ye[0],Ye[1],[.5,.5]);return Kt.forEach(Ht=>{const pi=(Ht.point[0]-.5)*2*Ue,hi=(Ht.point[1]-.5)*2*Ge;Ht.point[0]=(pi*nt-hi*vt+Ke[0])/ne,Ht.point[1]=(pi*vt+hi*nt+Ke[1])/$;const ai=Ht.vector[0],Yi=Ht.vector[1];Ht.vector[0]=ai*nt-Yi*vt,Ht.vector[1]=ai*vt+Yi*nt}),{keypoints:$e,score:we,handedness:ke,wrist:{lines:Kt},debug:{box:V[Te],anchors:Xe,circle:wt,tensors:qe}}})}evaluateLine(A,V,$,ne,xe){const le=[V[0]-A[0],V[1]-A[1]],ce=this.buildLine(le[0],le[1]).slice(0,24),ue=ce.map(je=>[je[1],-je[0]]),Te=Math.sqrt(le[0]**2+le[1]**2);le[0]/=Te,le[1]/=Te;const Me=[le[1],-le[0]];ce.forEach(je=>{je[0]+=A[0],je[1]+=A[1]});let Re=[],we=[];const ke=new Array(16).fill(0),Ue=new Array(16).fill(0);for(let je=6;je<ce.length;je++){const Ke=ce[je];let qe=2,$e=[0,0],vt=-1,nt=-1,wt=[0,0];for(qe=2;qe<16;qe++){$e=[Ke[0]+ue[qe][0],Ke[1]+ue[qe][1]];const Kt=$e[1]*64+$e[0];if(xe[Kt]<.5)break;if($[Kt]<this.edgeThresh)continue;const Ht=ne[2*Kt],pi=ne[2*Kt+1];if(!(Math.abs(Ht*Me[0]+pi*Me[1])<.95)){if($[Kt]>this.edgeStop){nt=qe,wt=$e,vt=$[Kt];break}$[Kt]>vt&&(nt=qe,wt=$e,vt=$[Kt])}}for(nt<16&&nt>3&&(Re.push([...wt,nt]),ke[nt]++),qe=2,vt=-1,nt=-1,wt=[0,0],qe=2;qe<16;qe++){$e=[Ke[0]-ue[qe][0],Ke[1]-ue[qe][1]];const Kt=$e[1]*64+$e[0];if(xe[Kt]<.5)break;if($[Kt]<this.edgeThresh)continue;const Ht=ne[2*Kt],pi=ne[2*Kt+1];if(!(Math.abs(Ht*Me[0]+pi*Me[1])<.95)){if($[Kt]>this.edgeStop){nt=qe,wt=$e,vt=$[Kt];break}$[Kt]>vt&&(nt=qe,wt=$e,vt=$[Kt])}}nt<16&&nt>3&&(we.push([...wt,nt]),Ue[nt]++)}let Ge=0,We=0,Xe=0,Ye=0;for(let je=1;je<16;je++){const Ke=.5*ke[je-1]+ke[je]+.5*ke[je+1],qe=.5*Ue[je-1]+Ue[je]+.5*Ue[je+1];Ke>Ge&&(Ge=Ke,Xe=je),qe>We&&(We=qe,Ye=je)}return Re=Re.filter(je=>Math.abs(je[2]-Xe)<=1),we=we.filter(je=>Math.abs(je[2]-Ye)<=1),{anchorsL:Re,anchorsR:we,strengthL:Ge,strengthR:We}}fitLine(A){const V=A.reduce((ce,ue)=>[ce[0]+ue[0],ce[1]+ue[1]],[0,0]);V[0]/=A.length,V[1]/=A.length;const $=A.reduce((ce,ue)=>{const Te=[ue[0]-V[0],ue[1]-V[1]];return[ce[0]+Te[0]**2-Te[1]**2,ce[1]+2*Te[0]*Te[1]]},[0,0]),ne=Math.sqrt($[0]**2+$[1]**2),xe=[Math.sqrt(.5*(ne+$[0])),Math.sqrt(.5*(ne-$[0]))],le=Math.sqrt(xe[0]**2+xe[1]**2);return xe[0]/=le,xe[1]/=le,$[1]<0&&(xe[0]=-xe[0]),{point:V,vector:xe}}normalizeLines(A,V,$){const ne=$e=>[$e[0]/$e[2],$e[1]/$e[2],1],xe=[...A.point,1],le=[...V.point,1],ce=[...A.vector,0],ue=[...V.vector,0],Te=Ax.lerp(ce,ue,.5),Me=[Te[1],-Te[0],0],Re=Ax.cross(xe,Ax.add(xe,ce)),we=Ax.cross(le,Ax.add(le,ue)),ke=Ax.cross(xe,Ax.add(xe,Me)),Ue=ne(Ax.cross(ke,we)),Ge=Ax.lerp(xe,Ue,.5),We=[...$,1],Xe=Ax.add(Ge,Ax.scale(Te,Ax.dot(Te,Ax.sub(We,Ge)))),Ye=Ax.add(Xe,Ax.scale(Te,.15)),je=Ax.cross(Ye,Ax.add(Ye,Me)),Ke=ne(Ax.cross(Re,je)),qe=ne(Ax.cross(we,je));return[{point:[Ke[0],Ke[1]],vector:A.vector},{point:[qe[0],qe[1]],vector:V.vector},{point:Ye,vector:Te}]}buildLine(A,V){let[$,ne]=[Math.abs(A),Math.abs(V)],xe=!1;$<ne&&([$,ne]=[ne,$],xe=!0);let le=[],ce=0,ue=0,Te=2*ne,Me=Te-$;for(;ce<$-2;ce++)le.push([ce,ue]),Me+=Te,Me>=0&&(ue++,Me-=2*$);return xe&&(le=le.map(Re=>[Re[1],Re[0]])),A<0&&le.forEach(Re=>{Re[0]*=-1}),V<0&&le.forEach(Re=>{Re[1]*=-1}),le}buildCircle(A){let V=A,$=0,ne=3-2*A;for(;$<V;)this.circlePoints.push([V,$]),$++,ne>0?(V--,ne=ne+4*($-V)+10):ne=ne+4*$+6;$--;for(let xe=$;xe>=0;xe--){const le=this.circlePoints[xe];this.circlePoints.push([le[1],le[0]])}for(let xe=2*$;xe>=0;xe--){const le=this.circlePoints[xe];this.circlePoints.push([-le[0],le[1]])}this.circlePoints.forEach(xe=>{xe[0]+=32,xe[1]+=32})}rotatedRect(A,V,$,ne,xe){const[le,ce]=[V[2]-V[0],V[3]-V[1]],[ue,Te]=[(V[2]+V[0])*.5,(V[3]+V[1])*.5],[Me,Re]=[le/xe.height,ce/xe.width],[we,ke]=[Math.cos($),Math.sin($)],Ue=[we*Re,-ke*Me,(-we*ce+ke*le)*.5+Te,ke*Re,we*Me,(-ke*ce-we*le)*.5+ue,0,0];return dQ.transform(A,[Ue],"bilinear",ne?"reflect":"constant",0,[xe.height,xe.width])}async prepare(){const{width:A,height:V}=this.modelSize,$=BQ([1,V,A,3]),ne=this.model.execute($);if(await Promise.all(ne.map(async xe=>{await xe.data(),xe.dispose()})),$.dispose(),Jr()==="webgl"){const{width:xe,height:le}=this.localMaxSize;this.backend=f1(),this.localMaxProg={variableNames:["val","dir"],outputShape:[le,xe,1],userCode:`
                    void main() {
                        ivec3 c = getOutputCoords();
                        float dx = getDir(c[0], c[1], 0);
                        float dy = getDir(c[0], c[1], 1);
                        vec2 d = vec2(dx, dy) / max(abs(dx), abs(dy));
                        vec2 cf = vec2(c[1], c[0]);
                        float v0 = getVal(round(cf.y - 2.0 * d.y),
                                          round(cf.x - 2.0 * d.x), 0);
                        float v1 = getVal(round(cf.y - d.y),
                                          round(cf.x - d.x), 0);
                        float v2 = getVal(round(cf.y), round(cf.x), 0);
                        float v3 = getVal(round(cf.x + d.y),
                                          round(cf.x + d.x), 0);
                        float v4 = getVal(round(cf.y + 2.0 * d.y),
                                          round(cf.x + 2.0 * d.x), 0);
                        float vmax = max(max(v0, v1), max(v3, v4));
                        setOutput(v2 >= vmax ? v2 : 0.0);
                    }
            `};const ce=BQ([le,xe,1]),ue=this.backend.compileAndRun(this.localMaxProg,[ce,ce]),Te=Ju().makeTensorFromTensorInfo(ue);ce.dispose(),Te.dispose()}}async dispose(){var A;(A=this.model)==null||A.dispose()}}class AG{constructor(){this.freq=30,this.pixelParams={minCutOff:2,minCutOffD:4,beta:50},this.metricParams={minCutOff:.1,minCutOffD:1,beta:20},this.scoreCutOff=1,this.visibilityCutOff=1,this.time=0}filter(A,V,$=1){if(this.time>=V)return A;if(this.time!==0&&(this.freq=1/(V-this.time)),this.time=V,!this.raw||!this.smooth||!this.der)return this.raw=this.clonePose(A),this.smooth=this.clonePose(A),this.der={keypoints:A.keypoints.map(()=>({pixel:[0,0,0],metric:[0,0,0]})),score:0,handedness:.5,wrist:{lines:A.wrist.lines.map(()=>({point:[0,0],vector:[0,0]}))}},this.clonePose(this.smooth);const ne=[...this.smooth.keypoints[0].pixel];this.filterKeypoints(A.keypoints,this.raw.keypoints,this.der.keypoints,this.smooth.keypoints,$);const xe=[...this.smooth.keypoints[0].pixel],{raw:le,smooth:ce,der:ue}=this;for(let Me=0;Me<A.wrist.lines.length;Me++){const Re=A.wrist.lines[Me],we=le.wrist.lines[Me],ke=ue.wrist.lines[Me],Ue=ce.wrist.lines[Me];if(isNaN(Ue.point[0])||isNaN(Ue.point[0])||isNaN(Ue.vector[0])||isNaN(Ue.vector[0])){Ue.point=[...Re.point],Ue.vector=[...Re.vector];continue}if(isNaN(Re.point[0])||isNaN(Re.point[0])||isNaN(Re.vector[0])||isNaN(Re.vector[0])){Ue.point[0]+=xe[0]-ne[0],Ue.point[1]+=xe[1]-ne[1];continue}this.filterCoord2D(Re.point,we.point,ke.point,Ue.point,$,{minCutOff:.5,minCutOffD:4,beta:75}),this.filterCoord2D(Re.vector,we.vector,ke.vector,Ue.vector,$,{minCutOff:.1,minCutOffD:.5,beta:10});const Ge=Math.sqrt(Ue.vector[0]**2+Ue.vector[1]**2);Ue.vector[0]/=Ge,Ue.vector[1]/=Ge}const Te=this.alpha(this.scoreCutOff);return this.smooth.score=this.smooth.score+Te*(A.score-this.smooth.score),this.smooth.debug=A.debug&&{box:{box:[[...A.debug.box.box[0]],[...A.debug.box.box[1]]],points:A.debug.box.points.map(Me=>[...Me]),start:[...A.debug.box.start],end:[...A.debug.box.end]},circle:A.debug.circle,anchors:A.debug.anchors,tensors:A.debug.tensors},this.clonePose(this.smooth)}filterKeypoints(A,V,$,ne,xe){for(let le=0;le<A.length;le++)this.filterCoord3D(A[le].pixel,V[le].pixel,$[le].pixel,ne[le].pixel,xe,this.pixelParams),this.filterCoord3D(A[le].metric,V[le].metric,$[le].metric,ne[le].metric,xe,this.metricParams)}filterCoord3D(A,V,$,ne,xe,le){const ce=[(A[0]-ne[0])*xe*this.freq,(A[1]-ne[1])*xe*this.freq,(A[2]-ne[2])*xe*this.freq],ue=this.alpha(le.minCutOffD);$[0]=$[0]+ue*(ce[0]-$[0]),$[1]=$[1]+ue*(ce[1]-$[1]),$[2]=$[2]+ue*(ce[2]-$[2]);const Te=[this.alpha(le.minCutOff+le.beta*Math.abs($[0])),this.alpha(le.minCutOff+le.beta*Math.abs($[1])),this.alpha(le.minCutOff+le.beta*Math.abs($[2]))];ne[0]=ne[0]+Te[0]*(A[0]-ne[0]),ne[1]=ne[1]+Te[1]*(A[1]-ne[1]),ne[2]=ne[2]+Te[2]*(A[2]-ne[2]),V[0]=A[0],V[1]=A[1],V[2]=A[2]}filterCoord2D(A,V,$,ne,xe,le){const ce=[(A[0]-ne[0])*xe*this.freq,(A[1]-ne[1])*xe*this.freq],ue=this.alpha(le.minCutOffD);$[0]=$[0]+ue*(ce[0]-$[0]),$[1]=$[1]+ue*(ce[1]-$[1]);const Te=[this.alpha(le.minCutOff+le.beta*Math.abs($[0])),this.alpha(le.minCutOff+le.beta*Math.abs($[1]))];ne[0]=ne[0]+Te[0]*(A[0]-ne[0]),ne[1]=ne[1]+Te[1]*(A[1]-ne[1]),V[0]=A[0],V[1]=A[1]}reset(){delete this.raw,delete this.smooth,delete this.der}alpha(A){return 1/(1+this.freq/(2*Math.PI*A))}clonePose(A){return{keypoints:A.keypoints.map(V=>({pixel:[...V.pixel],metric:[...V.metric]})),score:A.score,handedness:A.handedness,wrist:{lines:A.wrist.lines.map(V=>({point:[...V.point],vector:[...V.vector]}))},debug:A.debug&&{box:{box:[[...A.debug.box.box[0]],[...A.debug.box.box[1]]],points:A.debug.box.points.map(V=>[...V]),start:[...A.debug.box.start],end:[...A.debug.box.end]},circle:A.debug.circle.map(V=>[...V]),anchors:A.debug.anchors.map(V=>[...V]),tensors:A.debug.tensors}}}}class Au{constructor(){this.handTracks=[],this.handFilters=[],this.angle=.05555555555555555*Math.PI,this.ratio=1.7777777777777777,this.near=1,this.handScore=.55}async process(A,V){var $,ne;const xe=JY(()=>{const Ue=ip(iU(A,3),"float32"),Ge=OP(Ue,255);return B0(Ge,0)}),[le,ce]=[xe.shape[1],xe.shape[2]],ue=(Ue,Ge)=>{const We=[Ue[0]*ce,Ue[1]*le],Xe=[Ge[0]*ce,Ge[1]*le];let[Ye,je]=[Xe[0]-We[0],We[1]-Xe[1]];const Ke=Math.sqrt(Ye**2+je**2);return Ye/=Ke,je/=Ke,[Ye,je]},Te=(Ue,Ge,We,Xe,Ye,je)=>{const Ke=[.5*(Ue[0][0]+Ue[1][0])*ce,.5*(Ue[0][1]+Ue[1][1])*le],qe={width:(Ue[1][0]-Ue[0][0])*ce,height:(Ue[1][1]-Ue[0][1])*le},[$e,vt]=ue(Ge,We),nt=[Ye*qe.width,je*qe.height];Ke[0]+=nt[0]*vt-nt[1]*$e,Ke[1]+=nt[0]*$e+nt[1]*vt,Ke[0]/=ce,Ke[1]/=le;const wt=.5*Xe*Math.max(qe.width,qe.height);let Kt=wt/ce,Ht=wt/le;return[[Ke[0]-Kt,Ke[1]-Ht],[Ke[0]+Kt,Ke[1]+Ht]]};if(this.handTracks.length===0){const Ue=await(($=this.palmDetector)==null?void 0:$.process(xe))||[];this.handTracks=Ue.map(Ge=>({box:Te(Ge.box,Ge.points[0],Ge.points[2],2.6,0,-.5),points:Ge.points,start:Ge.points[0],end:Ge.points[2]})),this.handTracks.forEach(()=>this.handFilters.push(new AG))}const Me=this.handTracks.length>0?((ne=this.handDetector)==null?void 0:ne.process(xe,this.handTracks))||[]:[];Me.forEach((Ue,Ge)=>{if(V===void 0)return;const We=ce/le,Xe=this.handTracks[Ge].box[1][0]-this.handTracks[Ge].box[0][0],Ye=(this.handTracks[Ge].box[1][1]-this.handTracks[Ge].box[0][1])/We,je=Math.sqrt(Xe*Xe+Ye*Ye)*(1+We);Me[Ge]=this.handFilters[Ge].filter(Ue,V,1/je)}),xe.dispose();const Re=[],we=[],ke=[];for(let Ue=0;Ue<Me.length;Ue++){const Ge=Me[Ue],{keypoints:We,score:Xe}=Ge;if(Xe<this.handScore)continue;const Ye=[We[0].pixel[0],We[0].pixel[1]],je=[We[5].pixel[0],We[5].pixel[1]],Ke=[We[10].pixel[0],We[10].pixel[1]],qe=[We[14].pixel[0],We[14].pixel[1]],$e=[.25*je[0]+.5*Ke[0]+.25*qe[0],.25*je[1]+.5*Ke[1]+.25*qe[1]],[vt,nt]=ue(Ye,$e),[wt,Kt]=[-vt,nt],Ht=[...We.slice(0,4),...We.slice(5,7),...We.slice(9,11),...We.slice(13,15),...We.slice(17,19)].map(Us=>[Us.pixel[0],Us.pixel[1]]),pi=[[10,10],[-10,-10]];for(let Us=0;Us<Ht.length;Us++)pi[0][0]=Math.min(pi[0][0],Ht[Us][0]),pi[0][1]=Math.min(pi[0][1],Ht[Us][1]),pi[1][0]=Math.max(pi[1][0],Ht[Us][0]),pi[1][1]=Math.max(pi[1][1],Ht[Us][1]);const hi=[(pi[0][0]+pi[1][0])*.5,(pi[0][1]+pi[1][1])*.5],ai=[[10,10],[-10,-10]];for(let Us=0;Us<Ht.length;Us++){const Hs=[(Ht[Us][0]-hi[0])*ce,(Ht[Us][1]-hi[1])*le],qi=[Kt*Hs[0]-wt*Hs[1],wt*Hs[0]+Kt*Hs[1]];ai[0][0]=Math.min(ai[0][0],qi[0]),ai[0][1]=Math.min(ai[0][1],qi[1]),ai[1][0]=Math.max(ai[1][0],qi[0]),ai[1][1]=Math.max(ai[1][1],qi[1])}const Yi=[(ai[0][0]+ai[1][0])*.5,(ai[0][1]+ai[1][1])*.5],Wi=[(nt*Yi[0]-vt*Yi[1])/ce+hi[0],(vt*Yi[0]+nt*Yi[1])/le+hi[1]],ls=.5*(ai[1][0]-ai[0][0])/ce,Hi=.5*(ai[1][1]-ai[0][1])/le,rs=Te([[Wi[0]-ls,hi[1]-Hi],[Wi[0]+ls,hi[1]+Hi]],Ye,$e,2,0,-.1);VU(rs,this.handTracks[Ue].box)<.5||(this.align(Me[Ue].keypoints),Re.push({box:rs,start:Ye,end:$e,points:[]}),we.push(this.handFilters[Ue]),ke.push(Me[Ue]))}return this.handTracks=Re,this.handFilters=we,ke}align(A){const V=2*Math.tan(.5*this.angle),$=this.ratio*V,ne=A.map(Te=>{const Me=[(Te.pixel[0]-.5)*$,(Te.pixel[1]-.5)*V],Re=[...Te.metric];return{pixel:Me,world:Re}}),xe=[];ne.forEach(Te=>{xe.push([0,1,-Te.pixel[1],Te.world[1]-Te.pixel[1]*Te.world[2]],[-1,0,Te.pixel[0],Te.pixel[0]*Te.world[2]-Te.world[0]])});const{V:le}=AS.svd(xe),ce=le[3][3],ue=[le[0][3]/ce,le[1][3]/ce,le[2][3]/ce];A.forEach(Te=>{Te.metric[0]+=ue[0],Te.metric[1]+=ue[1],Te.metric[2]+=ue[2]}),A.forEach(Te=>{const Me=[(Te.pixel[0]-.5)*$,(Te.pixel[1]-.5)*V],Re=Te.metric;Re[0]=Me[0]*Re[2],Re[1]=Me[1]*Re[2],Te.metric[1]=-Te.metric[1],Te.metric[2]=-Te.metric[2]})}setCamera(A,V,$=1){this.angle=A,this.ratio=V,this.near=$}async init(A,V="./",$=!1,ne="webgl"){const xe=await VM(A,V,$),le=new xe.ParseLoader(V);if($||await le.remove("hand.wasm"),!await le.loadDict(["hand.wasm"])||!await le.load("hand.wasm")||!le.parse())return;Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!0),JG(),await Jj(ne);const ce={weightUrlConverter:async Me=>Me,fetchFunc:async Me=>{const Re=new Blob([le.file(Me)]);return fetch(URL.createObjectURL(Re))}},ue=await Ph("palmmodel.def",ce),Te=await Ph("handmodel.def",ce);this.palmDetector=new Az(ue),this.handDetector=new AU(Te)}reset(){this.handTracks=[],this.handFilters=[]}async prepare(){var A,V;Cd().set("ENGINE_COMPILE_ONLY",!0),await((A=this.palmDetector)==null?void 0:A.prepare()),await((V=this.handDetector)==null?void 0:V.prepare());const $=f1();$ instanceof ea&&($.checkCompileCompletion(),$.getUniformLocations()),Cd().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var A;this.reset(),(A=this.palmDetector)==null||A.dispose()}}class AY{async process(A,V){var $;const ne=JY(()=>{const le=ip(iU(A,3),"float32"),ce=OD(le,1/255);return B0(ce,0)}),xe=($=this.segmenter)==null?void 0:$.process(ne,[[0,0],[1,1]]);return ne.dispose(),xe?[xe]:[]}async init(A,V="./",$=!1,ne=!1,xe=!1,le="webgl"){const ce=await VM(A,V,$),ue=new ce.ParseLoader(V),[Te,Me]=xe?["masksm.wasm","maskmodelsm.def"]:["mask.wasm","maskmodel.def"];if($||await ue.remove(Te),!await ue.loadDict([Te])||!await ue.load(Te)||!ue.parse())return;Cd().set("WEBGL_USE_SHAPES_UNIFORMS",!0),JG(),await Jj(le);const Re=await Ph(Me,{weightUrlConverter:async we=>we,fetchFunc:async we=>{const ke=new Blob([ue.file(we)]);return fetch(URL.createObjectURL(ke))}});this.segmenter=new AT(Re,ne)}reset(){var A;(A=this.segmenter)==null||A.reset()}async prepare(){var A;Cd().set("ENGINE_COMPILE_ONLY",!0),await((A=this.segmenter)==null?void 0:A.prepare());const V=f1();V instanceof ea&&(V.checkCompileCompletion(),V.getUniformLocations()),Cd().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var A;(A=this.segmenter)==null||A.dispose(),delete this.segmenter}}const AM={lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyebrowUpper:[156,70,63,105,66,107,55],rightEyebrowLower:[124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyebrowUpper:[383,300,293,334,296,336,285],leftEyebrowLower:[353,276,283,282,295],leftEyeIris:[468,469,470,471,472]},Ah=[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255],Aj=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]],Ar=[[0,-.03406405,.05979506],[0,-.01126867,.07475604],[0,-.02089025,.06058267],[-.00463928,.00955356,.06633583],[0,-.00463172,.0758658],[0,.00365668,.0724287],[0,.02473254,.05788627],[-.04253081,.02577645,.03279702],[0,.04019041,.05284765],[0,.04885978,.05385259],[0,.08261777,.04481537],[0,-.03706812,.05864923],[0,-.03918302,.05569429],[0,-.03994437,.05219482],[0,-.04542401,.05404753],[0,-.04745578,.05529456],[0,-.05019568,.05601447],[0,-.05365124,.0553544],[0,-.06149625,.05071371],[0,-.01501096,.07112196],[-.00416106,-.0146645,.06447657],[-.0708796,.05434801,99621e-8],[-.02628638,.02035898,.03848121],[-.03198363,.01985814,.03796952],[-.03775151,.02039402,.03646194],[-.04465819,.02422949,.03155169],[-.02164288,.02189867,.03851822],[-.03208229,.03223925,.04115823],[-.02673803,.03205336,.04092203],[-.03745193,.03165285,.03972409],[-.04161018,.03059068,.03719554],[-.05062005,.01934418,.02776093],[-.02266659,-.07425769,.04389811],[-.04445859,.0266399,.03173422],[-.0721453,.02263009,7315e-7],[-.05799793,.02349546,.02204059],[-.02844939,-.00720869,.0443313],[-.00711452,-.03329356,.05877044],[-.00606033,-.03924563,.05444922],[-.01431615,-.03500954,.05496188],[-.0191491,-.03803147,.05028929],[-.01131043,-.03973938,.05189647],[-.01563548,-.04082763,.04842262],[-.02650112,-.05003649,.04188482],[-.00427049,-.01094135,.07360528],[-.00496396,-.0047566,.07440358],[-.05253307,.03881582,.0336316],[-.01718698,.00974608,.04558359],[-.01608635,-.00942517,.05814193],[-.01651267,-.00610869,.05581319],[-.04765501,-.00701555,.03534632],[-.00478306,.00295764,.07101013],[-.03734964,.04508229,.04550455],[-.04588603,.04302036,.04048485],[-.06279331,.06615427,.01425851],[-.01220941,.04142164,.05106035],[-.02193489,.03100317,.04000575],[-.03102642,-.04352985,.04095904],[-.06719682,-.04788644,-.01745402],[-.01193824,-.01306796,.05737746],[-.00729766,-.01593713,.05833207],[-.02456206,-.04342622,.04283883],[-.02204823,-.04304509,.04162498],[-.04985894,.0480246,.03751978],[-.01592294,-.0125771,.05456949],[-.02644548,.04524653,.0492156],[-.02760292,.0510097,.05015991],[-.03523964,.08005974,.03729165],[-.05599763,.05715469,.0272426],[-.03063932,.06566143,.04529982],[-.05720968,.04254583,.02830853],[-.06374393,.04785589,.01591692],[-.00672728,-.03688017,.05737803],[-.0126256,-.03787692,.05417778],[-.01732553,-.03952768,.05000578],[-.01043625,-.01464974,.05662455],[-.02321234,-.0432907,.04258155],[-.02056846,-.04477672,.04520882],[-.02153084,-.04276323,.04038092],[-.00946874,-.0103525,.06512274],[-.01469132,-.04036351,.04604907],[-.0102434,-.03989852,.04926693],[-.00533422,-.03993222,.05138201],[-.0076972,-.06095395,.04985882],[-.00699606,-.05291851,.05448303],[-.00669687,-.0494977,.05509611],[-.00630947,-.04695102,.0544937],[-.00583218,-.04517983,.05339869],[-.0153717,-.04423207,.04745469],[-.016156,-.04475943,.04813631],[-.01729053,-.0461868,.04854462],[-.01838624,-.04828747,.04823736],[-.0236825,-.03106238,.04868095],[-.07542244,-.01049282,-.02431321],[0,-.01724004,.0660139],[-.01826614,-.04399532,.0439902],[-.01929558,-.04411831,.04497051],[-.00597442,-.02013687,.05866456],[-.01405627,-.01714197,.05241086],[-.00662449,-.01819322,.05863759],[-.02342339,.00572221,.04294303],[-.03327324,.00104862,.0411386],[-.01726175,-.00919166,.05273354],[-.05133204,.07485601,.02660443],[-.04538641,.06319907,.03683425],[-.03986562,.05109486,.04466315],[-.02169681,-.05440434,.04455873],[-.01395634,.05011962,.05316032],[-.016195,.06599216,.04921107],[-.01891399,.08236376,.04274999],[-.04195832,.02235205,.03375099],[-.05733342,.01411738,.02431726],[-.01859888,.02355756,.03843182],[-.04988612,.03074653,.03083858],[-.01303263,.01416452,.04831091],[-.01305757,-.0067278,.06415959],[-.0646517,.00937119,.01689873],[-.05258659,.00945811,.02974312],[-.04432338,.00722095,.03522615],[-.03300681,.0086164,.03872784],[-.02430178,.01131491,.04039035],[-.01820731,.01467953,.04224124],[-.00563221,.02307693,.05566789],[-.06338145,-.00529279,.01881175],[-.05587698,.03208071,.0268784],[-.00242624,-.01462858,.07071491],[-.01611251,.00339325,.0489542],[-.07743095,.02364999,-.02005167],[-.01391142,.01851047,.04448999],[-.01785794,-.00978285,.0485047],[-.04670959,.0266446,.03084075],[-.0133397,-.00283762,.06097047],[-.07270896,-.02890916,-.02252455],[-.01856432,.02585245,.03757904],[-.00923388,73075e-8,.06671944],[-.05000589,-.06135128,.01892522],[-.05085276,-.0717859,.0071471],[-.07159291,-.0081182,-72044e-8],[-.05843051,-.05248023,.0092409],[-.06847258,.03662916,.00724696],[-.02412942,-.08258854,.04119211],[-.00179909,-.01689865,.06573301],[-.02103655,-.00163946,.04566119],[-.06407571,.02236021,.01560843],[-.03670075,.02360153,.0363523],[-.03177186,.02294264,.03775705],[-.02196121,-.04598323,.04479785],[-.06234883,-.0194443,.01663542],[-.01292924,-.09295921,.04094062],[-.03210651,-.08533278,.02802],[-.04068926,-.07993109,.01925118],[0,.06545389,.05027312],[0,-.09403378,.0426449],[-.02724032,.02315802,.03777151],[-.0228846,.0239889,.03697603],[-.01998311,.02496546,.03689148],[-.0613004,.03399261,.02038516],[-.0228846,.02886503,.03775031],[-.02724032,.02961809,.03871767],[-.03177186,.02964135,.03876973],[-.03670075,.02927713,.03724325],[-.04018389,.02857356,.03482983],[-.07555811,.04106811,-.00991916],[-.04018389,.02483694,.03440898],[0,-.02521946,.05932265],[-.01776217,-.02683947,.05213116],[-.01222237,-.01182445,.05952464],[-.00731493,-.02536684,.05815343],[0,.03271026,.05236015],[-.04135272,-.06996639,.02671969],[-.03311811,-.07660816,.03382962],[-.01313701,-.08639995,.04702454],[-.05940524,-.06223629,-.00631469],[-.01998311,.02743837,.0374403],[-.00901447,.01236991,.05754256],[0,-.08765243,.04891439],[-.02308977,-.08974197,.03609069],[-.06954154,-.02439843,-.00131163],[-.01098819,-.04458788,.05120726],[-.01181124,-.04579997,.05189563],[-.01255818,-.04787901,.0523705],[-.01325085,-.05106508,.05205009],[-.01546388,-.05819392,.04757892],[-.01953754,-.04183893,.04431712],[-.02117802,-.04137093,.04555095],[-.02285339,-.04051196,.04582437],[-.0285016,-.03665721,.04484993],[-.05278538,-.02238942,.02861224],[-.00946709,.01907627,.0519678],[-.01314173,.03104912,.04231405],[-.0178,.02859999,.03881555],[-.0184511,-.0409888,.04247263],[-.05436186,-.04030482,.02109851],[-.00766444,.0318213,.04861453],[-.01938616,-.06614411,.04521083],[0,.01059412,.06774605],[-.00516573,.01583571,.06148363],[0,.01728368,.0631675],[-.01246815,.00230296,.05681035],[0,-.07942194,.05181172],[0,-.069915,.05153477],[-.00997827,-.06930922,.04979575],[-.03288807,-.05382515,.03795751],[-.02311631,-.01566238,.04590084],[-.0268025,-.06111567,.04096151],[-.03832928,-.01537327,.04137731],[-.0296186,-.02274216,.04440943],[-.04386901,-.02683286,.03643886],[-.01217295,-.07834466,.04969285],[-.01542374,-.00136843,.05201008],[-.03878377,-.06041764,.03311078],[-.03084037,-.06809843,.03814194],[-.03747321,-.04503546,.03726452],[-.06094129,-.03205992,.01473481],[-.04588995,-.04728726,.0298322],[-.06583231,-.03941269,70267e-8],[-.0349258,-.03195821,.04130198],[-.01255543,.0080234,.05307551],[-.01126122,-.00933603,.06538785],[-.01443109,-.01142775,.05905127],[-.00923043,-.00529043,.07003423],[-.01755386,.03529116,.04327697],[-.02632589,.03713828,.0436463],[-.03388062,.03721975,.04309029],[-.04075766,.03675412,.04076063],[-.0462291,.0347469,.03646322],[-.05171755,.02535752,.02670867],[-.0729733,.00763172,-48769e-8],[-.04706828,.01651,.03109532],[-.04071712,.01476821,.03476944],[-.03269817,.01470658,.03731945],[-.02527572,.0161731,.03865444],[-.01970894,.01858504,.03961782],[-.01579543,.0209794,.04084997],[-.07664182,.00673132,-.02435867],[-.01397041,-.0134014,.05630378],[-.00884838,.00658739,.06233231],[-.00767097,-.00968036,.07077932],[-.00460213,-.01334107,.06787448],[-.00748618,-.01067995,.06798303],[-.01236408,-.01585569,.05480489],[-.00387306,-.01409991,.06957705],[-.00319925,-.01607932,.06508676],[-.01639633,.02556297,.03863737],[-.01255645,.02467143,.042038],[-.01031362,.02382662,.04615849],[-.04253081,.02772296,.03315305],[-.0453,.0291,.03339685],[.00463928,.00955356,.06633583],[.04253081,.02577645,.03279702],[.00416106,-.0146645,.06447657],[.0708796,.05434801,99621e-8],[.02628638,.02035898,.03848121],[.03198363,.01985814,.03796952],[.03775151,.02039402,.03646194],[.04465819,.02422949,.03155169],[.02164288,.02189867,.03851822],[.03208229,.03223925,.04115823],[.02673803,.03205336,.04092203],[.03745193,.03165285,.03972409],[.04161018,.03059068,.03719554],[.05062005,.01934418,.02776093],[.02266659,-.07425769,.04389811],[.04445859,.0266399,.03173422],[.0721453,.02263009,7315e-7],[.05799793,.02349546,.02204059],[.02844939,-.00720869,.0443313],[.00711452,-.03329356,.05877044],[.00606033,-.03924563,.05444922],[.01431615,-.03500954,.05496188],[.0191491,-.03803147,.05028929],[.01131043,-.03973938,.05189647],[.01563548,-.04082763,.04842262],[.02650112,-.05003649,.04188482],[.00427049,-.01094135,.07360528],[.00496396,-.0047566,.07440358],[.05253307,.03881582,.0336316],[.01718698,.00974608,.04558359],[.01608635,-.00942517,.05814193],[.01651267,-.00610869,.05581319],[.04765501,-.00701555,.03534632],[.00478306,.00295764,.07101013],[.03734964,.04508229,.04550455],[.04588603,.04302036,.04048485],[.06279331,.06615427,.01425851],[.01220941,.04142164,.05106035],[.02193489,.03100317,.04000575],[.03102642,-.04352985,.04095904],[.06719682,-.04788644,-.01745402],[.01193824,-.01306796,.05737746],[.00729766,-.01593713,.05833207],[.02456206,-.04342622,.04283883],[.02204823,-.04304509,.04162498],[.04985894,.0480246,.03751978],[.01592294,-.0125771,.05456949],[.02644548,.04524653,.0492156],[.02760292,.0510097,.05015991],[.03523964,.08005974,.03729165],[.05599763,.05715469,.0272426],[.03063932,.06566143,.04529982],[.05720968,.04254583,.02830853],[.06374393,.04785589,.01591692],[.00672728,-.03688017,.05737803],[.0126256,-.03787692,.05417778],[.01732553,-.03952768,.05000578],[.01043625,-.01464974,.05662455],[.02321234,-.0432907,.04258155],[.02056846,-.04477672,.04520882],[.02153084,-.04276323,.04038092],[.00946874,-.0103525,.06512274],[.01469132,-.04036351,.04604907],[.0102434,-.03989852,.04926693],[.00533422,-.03993222,.05138201],[.0076972,-.06095395,.04985882],[.00699606,-.05291851,.05448303],[.00669687,-.0494977,.05509611],[.00630947,-.04695102,.0544937],[.00583218,-.04517983,.05339869],[.0153717,-.04423207,.04745469],[.016156,-.04475943,.04813631],[.01729053,-.0461868,.04854462],[.01838624,-.04828747,.04823736],[.0236825,-.03106238,.04868095],[.07542244,-.01049282,-.02431321],[.01826614,-.04399532,.0439902],[.01929558,-.04411831,.04497051],[.00597442,-.02013687,.05866456],[.01405627,-.01714197,.05241086],[.00662449,-.01819322,.05863759],[.02342339,.00572221,.04294303],[.03327324,.00104862,.0411386],[.01726175,-.00919166,.05273354],[.05133204,.07485601,.02660443],[.04538641,.06319907,.03683425],[.03986562,.05109486,.04466315],[.02169681,-.05440434,.04455873],[.01395634,.05011962,.05316032],[.016195,.06599216,.04921107],[.01891399,.08236376,.04274999],[.04195832,.02235205,.03375099],[.05733342,.01411738,.02431726],[.01859888,.02355756,.03843182],[.04988612,.03074653,.03083858],[.01303263,.01416452,.04831091],[.01305757,-.0067278,.06415959],[.0646517,.00937119,.01689873],[.05258659,.00945811,.02974312],[.04432338,.00722095,.03522615],[.03300681,.0086164,.03872784],[.02430178,.01131491,.04039035],[.01820731,.01467953,.04224124],[.00563221,.02307693,.05566789],[.06338145,-.00529279,.01881175],[.05587698,.03208071,.0268784],[.00242624,-.01462858,.07071491],[.01611251,.00339325,.0489542],[.07743095,.02364999,-.02005167],[.01391142,.01851047,.04448999],[.01785794,-.00978285,.0485047],[.04670959,.0266446,.03084075],[.0133397,-.00283762,.06097047],[.07270896,-.02890916,-.02252455],[.01856432,.02585245,.03757904],[.00923388,73075e-8,.06671944],[.05000589,-.06135128,.01892522],[.05085276,-.0717859,.0071471],[.07159291,-.0081182,-72044e-8],[.05843051,-.05248023,.0092409],[.06847258,.03662916,.00724696],[.02412942,-.08258854,.04119211],[.00179909,-.01689865,.06573301],[.02103655,-.00163946,.04566119],[.06407571,.02236021,.01560843],[.03670075,.02360153,.0363523],[.03177186,.02294264,.03775705],[.02196121,-.04598323,.04479785],[.06234883,-.0194443,.01663542],[.01292924,-.09295921,.04094062],[.03210651,-.08533278,.02802],[.04068926,-.07993109,.01925118],[.02724032,.02315802,.03777151],[.0228846,.0239889,.03697603],[.01998311,.02496546,.03689148],[.0613004,.03399261,.02038516],[.0228846,.02886503,.03775031],[.02724032,.02961809,.03871767],[.03177186,.02964135,.03876973],[.03670075,.02927713,.03724325],[.04018389,.02857356,.03482983],[.07555811,.04106811,-.00991916],[.04018389,.02483694,.03440898],[.01776217,-.02683947,.05213116],[.01222237,-.01182445,.05952464],[.00731493,-.02536684,.05815343],[.04135272,-.06996639,.02671969],[.03311811,-.07660816,.03382962],[.01313701,-.08639995,.04702454],[.05940524,-.06223629,-.00631469],[.01998311,.02743837,.0374403],[.00901447,.01236991,.05754256],[.02308977,-.08974197,.03609069],[.06954154,-.02439843,-.00131163],[.01098819,-.04458788,.05120726],[.01181124,-.04579997,.05189563],[.01255818,-.04787901,.0523705],[.01325085,-.05106508,.05205009],[.01546388,-.05819392,.04757892],[.01953754,-.04183893,.04431712],[.02117802,-.04137093,.04555095],[.02285339,-.04051196,.04582437],[.0285016,-.03665721,.04484993],[.05278538,-.02238942,.02861224],[.00946709,.01907627,.0519678],[.01314173,.03104912,.04231405],[.0178,.02859999,.03881555],[.0184511,-.0409888,.04247263],[.05436186,-.04030482,.02109851],[.00766444,.0318213,.04861453],[.01938616,-.06614411,.04521083],[.00516573,.01583571,.06148363],[.01246815,.00230296,.05681035],[.00997827,-.06930922,.04979575],[.03288807,-.05382515,.03795751],[.02311631,-.01566238,.04590084],[.0268025,-.06111567,.04096151],[.03832928,-.01537327,.04137731],[.0296186,-.02274216,.04440943],[.04386901,-.02683286,.03643886],[.01217295,-.07834466,.04969285],[.01542374,-.00136843,.05201008],[.03878377,-.06041764,.03311078],[.03084037,-.06809843,.03814194],[.03747321,-.04503546,.03726452],[.06094129,-.03205992,.01473481],[.04588995,-.04728726,.0298322],[.06583231,-.03941269,70267e-8],[.0349258,-.03195821,.04130198],[.01255543,.0080234,.05307551],[.01126122,-.00933603,.06538785],[.01443109,-.01142775,.05905127],[.00923043,-.00529043,.07003423],[.01755386,.03529116,.04327697],[.02632589,.03713828,.0436463],[.03388062,.03721975,.04309029],[.04075766,.03675412,.04076063],[.0462291,.0347469,.03646322],[.05171755,.02535752,.02670867],[.0729733,.00763172,-48769e-8],[.04706828,.01651,.03109532],[.04071712,.01476821,.03476944],[.03269817,.01470658,.03731945],[.02527572,.0161731,.03865444],[.01970894,.01858504,.03961782],[.01579543,.0209794,.04084997],[.07664182,.00673132,-.02435867],[.01397041,-.0134014,.05630378],[.00884838,.00658739,.06233231],[.00767097,-.00968036,.07077932],[.00460213,-.01334107,.06787448],[.00748618,-.01067995,.06798303],[.01236408,-.01585569,.05480489],[.00387306,-.01409991,.06957705],[.00319925,-.01607932,.06508676],[.01639633,.02556297,.03863737],[.01255645,.02467143,.042038],[.01031362,.02382662,.04615849],[.04253081,.02772296,.03315305],[.0453,.0291,.03339685]];class p0{constructor(){this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.meancolor",this.canvas.hidden=!0,this.canvas.width=1,this.canvas.height=1,this.context=this.canvas.getContext("2d",{alpha:!1,desynchronized:!0})}mean(A){if(!this.context)return;this.context.drawImage(A,0,0,1,1);const V=this.context.getImageData(0,0,1,1);return[V.data[0],V.data[1],V.data[2]]}brightness(A){const V=this.mean(A);return V?(.2989*V[0]+.587*V[1]+.1141*V[2])/255:void 0}dispose(){this.context=null,this.canvas&&document.removeChild(this.canvas),delete this.canvas}}},924:(W,A,V)=>{"use strict";var $=V(210),ne=V(559),xe=ne($("String.prototype.indexOf"));W.exports=function(ce,ue){var Te=$(ce,!!ue);return typeof Te=="function"&&xe(ce,".prototype.")>-1?ne(Te):Te}},559:(W,A,V)=>{"use strict";var $=V(612),ne=V(210),xe=V(771),le=V(453),ce=ne("%Function.prototype.apply%"),ue=ne("%Function.prototype.call%"),Te=ne("%Reflect.apply%",!0)||$.call(ue,ce),Me=V(429),Re=ne("%Math.max%");W.exports=function(Ue){if(typeof Ue!="function")throw new le("a function is required");var Ge=Te($,ue,arguments);return xe(Ge,1+Re(0,Ue.length-(arguments.length-1)),!0)};var we=function(){return Te($,ce,arguments)};Me?Me(W.exports,"apply",{value:we}):W.exports.apply=we},296:(W,A,V)=>{"use strict";var $=V(429),ne=V(464),xe=V(453),le=V(275);W.exports=function(ue,Te,Me){if(!ue||typeof ue!="object"&&typeof ue!="function")throw new xe("`obj` must be an object or a function`");if(typeof Te!="string"&&typeof Te!="symbol")throw new xe("`property` must be a string or a symbol`");if(arguments.length>3&&typeof arguments[3]!="boolean"&&arguments[3]!==null)throw new xe("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&typeof arguments[4]!="boolean"&&arguments[4]!==null)throw new xe("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&typeof arguments[5]!="boolean"&&arguments[5]!==null)throw new xe("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&typeof arguments[6]!="boolean")throw new xe("`loose`, if provided, must be a boolean");var Re=arguments.length>3?arguments[3]:null,we=arguments.length>4?arguments[4]:null,ke=arguments.length>5?arguments[5]:null,Ue=arguments.length>6?arguments[6]:!1,Ge=!!le&&le(ue,Te);if($)$(ue,Te,{configurable:ke===null&&Ge?Ge.configurable:!ke,enumerable:Re===null&&Ge?Ge.enumerable:!Re,value:Me,writable:we===null&&Ge?Ge.writable:!we});else if(Ue||!Re&&!we&&!ke)ue[Te]=Me;else throw new ne("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")}},429:(W,A,V)=>{"use strict";var $=V(210),ne=$("%Object.defineProperty%",!0)||!1;if(ne)try{ne({},"a",{value:1})}catch{ne=!1}W.exports=ne},981:W=>{"use strict";W.exports=EvalError},648:W=>{"use strict";W.exports=Error},726:W=>{"use strict";W.exports=RangeError},712:W=>{"use strict";W.exports=ReferenceError},464:W=>{"use strict";W.exports=SyntaxError},453:W=>{"use strict";W.exports=TypeError},915:W=>{"use strict";W.exports=URIError},187:W=>{"use strict";var A=typeof Reflect=="object"?Reflect:null,V=A&&typeof A.apply=="function"?A.apply:function($e,vt,nt){return Function.prototype.apply.call($e,vt,nt)},$;A&&typeof A.ownKeys=="function"?$=A.ownKeys:Object.getOwnPropertySymbols?$=function($e){return Object.getOwnPropertyNames($e).concat(Object.getOwnPropertySymbols($e))}:$=function($e){return Object.getOwnPropertyNames($e)};function ne(qe){console&&console.warn&&console.warn(qe)}var xe=Number.isNaN||function($e){return $e!==$e};function le(){le.init.call(this)}W.exports=le,W.exports.once=Ye,le.EventEmitter=le,le.prototype._events=void 0,le.prototype._eventsCount=0,le.prototype._maxListeners=void 0;var ce=10;function ue(qe){if(typeof qe!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof qe)}Object.defineProperty(le,"defaultMaxListeners",{enumerable:!0,get:function(){return ce},set:function(qe){if(typeof qe!="number"||qe<0||xe(qe))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+qe+".");ce=qe}}),le.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},le.prototype.setMaxListeners=function($e){if(typeof $e!="number"||$e<0||xe($e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+$e+".");return this._maxListeners=$e,this};function Te(qe){return qe._maxListeners===void 0?le.defaultMaxListeners:qe._maxListeners}le.prototype.getMaxListeners=function(){return Te(this)},le.prototype.emit=function($e){for(var vt=[],nt=1;nt<arguments.length;nt++)vt.push(arguments[nt]);var wt=$e==="error",Kt=this._events;if(Kt!==void 0)wt=wt&&Kt.error===void 0;else if(!wt)return!1;if(wt){var Ht;if(vt.length>0&&(Ht=vt[0]),Ht instanceof Error)throw Ht;var pi=new Error("Unhandled error."+(Ht?" ("+Ht.message+")":""));throw pi.context=Ht,pi}var hi=Kt[$e];if(hi===void 0)return!1;if(typeof hi=="function")V(hi,this,vt);else for(var ai=hi.length,Yi=Ge(hi,ai),nt=0;nt<ai;++nt)V(Yi[nt],this,vt);return!0};function Me(qe,$e,vt,nt){var wt,Kt,Ht;if(ue(vt),Kt=qe._events,Kt===void 0?(Kt=qe._events=Object.create(null),qe._eventsCount=0):(Kt.newListener!==void 0&&(qe.emit("newListener",$e,vt.listener?vt.listener:vt),Kt=qe._events),Ht=Kt[$e]),Ht===void 0)Ht=Kt[$e]=vt,++qe._eventsCount;else if(typeof Ht=="function"?Ht=Kt[$e]=nt?[vt,Ht]:[Ht,vt]:nt?Ht.unshift(vt):Ht.push(vt),wt=Te(qe),wt>0&&Ht.length>wt&&!Ht.warned){Ht.warned=!0;var pi=new Error("Possible EventEmitter memory leak detected. "+Ht.length+" "+String($e)+" listeners added. Use emitter.setMaxListeners() to increase limit");pi.name="MaxListenersExceededWarning",pi.emitter=qe,pi.type=$e,pi.count=Ht.length,ne(pi)}return qe}le.prototype.addListener=function($e,vt){return Me(this,$e,vt,!1)},le.prototype.on=le.prototype.addListener,le.prototype.prependListener=function($e,vt){return Me(this,$e,vt,!0)};function Re(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function we(qe,$e,vt){var nt={fired:!1,wrapFn:void 0,target:qe,type:$e,listener:vt},wt=Re.bind(nt);return wt.listener=vt,nt.wrapFn=wt,wt}le.prototype.once=function($e,vt){return ue(vt),this.on($e,we(this,$e,vt)),this},le.prototype.prependOnceListener=function($e,vt){return ue(vt),this.prependListener($e,we(this,$e,vt)),this},le.prototype.removeListener=function($e,vt){var nt,wt,Kt,Ht,pi;if(ue(vt),wt=this._events,wt===void 0)return this;if(nt=wt[$e],nt===void 0)return this;if(nt===vt||nt.listener===vt)--this._eventsCount===0?this._events=Object.create(null):(delete wt[$e],wt.removeListener&&this.emit("removeListener",$e,nt.listener||vt));else if(typeof nt!="function"){for(Kt=-1,Ht=nt.length-1;Ht>=0;Ht--)if(nt[Ht]===vt||nt[Ht].listener===vt){pi=nt[Ht].listener,Kt=Ht;break}if(Kt<0)return this;Kt===0?nt.shift():We(nt,Kt),nt.length===1&&(wt[$e]=nt[0]),wt.removeListener!==void 0&&this.emit("removeListener",$e,pi||vt)}return this},le.prototype.off=le.prototype.removeListener,le.prototype.removeAllListeners=function($e){var vt,nt,wt;if(nt=this._events,nt===void 0)return this;if(nt.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):nt[$e]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete nt[$e]),this;if(arguments.length===0){var Kt=Object.keys(nt),Ht;for(wt=0;wt<Kt.length;++wt)Ht=Kt[wt],Ht!=="removeListener"&&this.removeAllListeners(Ht);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(vt=nt[$e],typeof vt=="function")this.removeListener($e,vt);else if(vt!==void 0)for(wt=vt.length-1;wt>=0;wt--)this.removeListener($e,vt[wt]);return this};function ke(qe,$e,vt){var nt=qe._events;if(nt===void 0)return[];var wt=nt[$e];return wt===void 0?[]:typeof wt=="function"?vt?[wt.listener||wt]:[wt]:vt?Xe(wt):Ge(wt,wt.length)}le.prototype.listeners=function($e){return ke(this,$e,!0)},le.prototype.rawListeners=function($e){return ke(this,$e,!1)},le.listenerCount=function(qe,$e){return typeof qe.listenerCount=="function"?qe.listenerCount($e):Ue.call(qe,$e)},le.prototype.listenerCount=Ue;function Ue(qe){var $e=this._events;if($e!==void 0){var vt=$e[qe];if(typeof vt=="function")return 1;if(vt!==void 0)return vt.length}return 0}le.prototype.eventNames=function(){return this._eventsCount>0?$(this._events):[]};function Ge(qe,$e){for(var vt=new Array($e),nt=0;nt<$e;++nt)vt[nt]=qe[nt];return vt}function We(qe,$e){for(;$e+1<qe.length;$e++)qe[$e]=qe[$e+1];qe.pop()}function Xe(qe){for(var $e=new Array(qe.length),vt=0;vt<$e.length;++vt)$e[vt]=qe[vt].listener||qe[vt];return $e}function Ye(qe,$e){return new Promise(function(vt,nt){function wt(Ht){qe.removeListener($e,Kt),nt(Ht)}function Kt(){typeof qe.removeListener=="function"&&qe.removeListener("error",wt),vt([].slice.call(arguments))}Ke(qe,$e,Kt,{once:!0}),$e!=="error"&&je(qe,wt,{once:!0})})}function je(qe,$e,vt){typeof qe.on=="function"&&Ke(qe,"error",$e,vt)}function Ke(qe,$e,vt,nt){if(typeof qe.on=="function")nt.once?qe.once($e,vt):qe.on($e,vt);else if(typeof qe.addEventListener=="function")qe.addEventListener($e,function wt(Kt){nt.once&&qe.removeEventListener($e,wt),vt(Kt)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof qe)}},29:(W,A,V)=>{"use strict";var $=V(320),ne=Object.prototype.toString,xe=Object.prototype.hasOwnProperty,le=function(Re,we,ke){for(var Ue=0,Ge=Re.length;Ue<Ge;Ue++)xe.call(Re,Ue)&&(ke==null?we(Re[Ue],Ue,Re):we.call(ke,Re[Ue],Ue,Re))},ce=function(Re,we,ke){for(var Ue=0,Ge=Re.length;Ue<Ge;Ue++)ke==null?we(Re.charAt(Ue),Ue,Re):we.call(ke,Re.charAt(Ue),Ue,Re)},ue=function(Re,we,ke){for(var Ue in Re)xe.call(Re,Ue)&&(ke==null?we(Re[Ue],Ue,Re):we.call(ke,Re[Ue],Ue,Re))},Te=function(Re,we,ke){if(!$(we))throw new TypeError("iterator must be a function");var Ue;arguments.length>=3&&(Ue=ke),ne.call(Re)==="[object Array]"?le(Re,we,Ue):typeof Re=="string"?ce(Re,we,Ue):ue(Re,we,Ue)};W.exports=Te},709:W=>{"use strict";var A="Function.prototype.bind called on incompatible ",V=Object.prototype.toString,$=Math.max,ne="[object Function]",xe=function(Te,Me){for(var Re=[],we=0;we<Te.length;we+=1)Re[we]=Te[we];for(var ke=0;ke<Me.length;ke+=1)Re[ke+Te.length]=Me[ke];return Re},le=function(Te,Me){for(var Re=[],we=Me||0,ke=0;we<Te.length;we+=1,ke+=1)Re[ke]=Te[we];return Re},ce=function(ue,Te){for(var Me="",Re=0;Re<ue.length;Re+=1)Me+=ue[Re],Re+1<ue.length&&(Me+=Te);return Me};W.exports=function(Te){var Me=this;if(typeof Me!="function"||V.apply(Me)!==ne)throw new TypeError(A+Me);for(var Re=le(arguments,1),we,ke=function(){if(this instanceof we){var Ye=Me.apply(this,xe(Re,arguments));return Object(Ye)===Ye?Ye:this}return Me.apply(Te,xe(Re,arguments))},Ue=$(0,Me.length-Re.length),Ge=[],We=0;We<Ue;We++)Ge[We]="$"+We;if(we=Function("binder","return function ("+ce(Ge,",")+"){ return binder.apply(this,arguments); }")(ke),Me.prototype){var Xe=function(){};Xe.prototype=Me.prototype,we.prototype=new Xe,Xe.prototype=null}return we}},612:(W,A,V)=>{"use strict";var $=V(709);W.exports=Function.prototype.bind||$},210:(W,A,V)=>{"use strict";var $,ne=V(648),xe=V(981),le=V(726),ce=V(712),ue=V(464),Te=V(453),Me=V(915),Re=Function,we=function(Us){try{return Re('"use strict"; return ('+Us+").constructor;")()}catch{}},ke=Object.getOwnPropertyDescriptor;if(ke)try{ke({},"")}catch{ke=null}var Ue=function(){throw new Te},Ge=ke?function(){try{return arguments.callee,Ue}catch{try{return ke(arguments,"callee").get}catch{return Ue}}}():Ue,We=V(405)(),Xe=V(185)(),Ye=Object.getPrototypeOf||(Xe?function(Us){return Us.__proto__}:null),je={},Ke=typeof Uint8Array>"u"||!Ye?$:Ye(Uint8Array),qe={__proto__:null,"%AggregateError%":typeof AggregateError>"u"?$:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?$:ArrayBuffer,"%ArrayIteratorPrototype%":We&&Ye?Ye([][Symbol.iterator]()):$,"%AsyncFromSyncIteratorPrototype%":$,"%AsyncFunction%":je,"%AsyncGenerator%":je,"%AsyncGeneratorFunction%":je,"%AsyncIteratorPrototype%":je,"%Atomics%":typeof Atomics>"u"?$:Atomics,"%BigInt%":typeof BigInt>"u"?$:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?$:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?$:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?$:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":ne,"%eval%":eval,"%EvalError%":xe,"%Float32Array%":typeof Float32Array>"u"?$:Float32Array,"%Float64Array%":typeof Float64Array>"u"?$:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?$:FinalizationRegistry,"%Function%":Re,"%GeneratorFunction%":je,"%Int8Array%":typeof Int8Array>"u"?$:Int8Array,"%Int16Array%":typeof Int16Array>"u"?$:Int16Array,"%Int32Array%":typeof Int32Array>"u"?$:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":We&&Ye?Ye(Ye([][Symbol.iterator]())):$,"%JSON%":typeof JSON=="object"?JSON:$,"%Map%":typeof Map>"u"?$:Map,"%MapIteratorPrototype%":typeof Map>"u"||!We||!Ye?$:Ye(new Map()[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?$:Promise,"%Proxy%":typeof Proxy>"u"?$:Proxy,"%RangeError%":le,"%ReferenceError%":ce,"%Reflect%":typeof Reflect>"u"?$:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?$:Set,"%SetIteratorPrototype%":typeof Set>"u"||!We||!Ye?$:Ye(new Set()[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?$:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":We&&Ye?Ye(""[Symbol.iterator]()):$,"%Symbol%":We?Symbol:$,"%SyntaxError%":ue,"%ThrowTypeError%":Ge,"%TypedArray%":Ke,"%TypeError%":Te,"%Uint8Array%":typeof Uint8Array>"u"?$:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?$:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?$:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?$:Uint32Array,"%URIError%":Me,"%WeakMap%":typeof WeakMap>"u"?$:WeakMap,"%WeakRef%":typeof WeakRef>"u"?$:WeakRef,"%WeakSet%":typeof WeakSet>"u"?$:WeakSet};if(Ye)try{null.error}catch(Us){var $e=Ye(Ye(Us));qe["%Error.prototype%"]=$e}var vt=function Us(Hs){var qi;if(Hs==="%AsyncFunction%")qi=we("async function () {}");else if(Hs==="%GeneratorFunction%")qi=we("function* () {}");else if(Hs==="%AsyncGeneratorFunction%")qi=we("async function* () {}");else if(Hs==="%AsyncGenerator%"){var as=Us("%AsyncGeneratorFunction%");as&&(qi=as.prototype)}else if(Hs==="%AsyncIteratorPrototype%"){var li=Us("%AsyncGenerator%");li&&Ye&&(qi=Ye(li.prototype))}return qe[Hs]=qi,qi},nt={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},wt=V(612),Kt=V(824),Ht=wt.call(Function.call,Array.prototype.concat),pi=wt.call(Function.apply,Array.prototype.splice),hi=wt.call(Function.call,String.prototype.replace),ai=wt.call(Function.call,String.prototype.slice),Yi=wt.call(Function.call,RegExp.prototype.exec),Wi=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,ls=/\\(\\)?/g,Hi=function(Hs){var qi=ai(Hs,0,1),as=ai(Hs,-1);if(qi==="%"&&as!=="%")throw new ue("invalid intrinsic syntax, expected closing `%`");if(as==="%"&&qi!=="%")throw new ue("invalid intrinsic syntax, expected opening `%`");var li=[];return hi(Hs,Wi,function(vi,Ui,hs,Xs){li[li.length]=hs?hi(Xs,ls,"$1"):Ui||vi}),li},rs=function(Hs,qi){var as=Hs,li;if(Kt(nt,as)&&(li=nt[as],as="%"+li[0]+"%"),Kt(qe,as)){var vi=qe[as];if(vi===je&&(vi=vt(as)),typeof vi>"u"&&!qi)throw new Te("intrinsic "+Hs+" exists, but is not available. Please file an issue!");return{alias:li,name:as,value:vi}}throw new ue("intrinsic "+Hs+" does not exist!")};W.exports=function(Hs,qi){if(typeof Hs!="string"||Hs.length===0)throw new Te("intrinsic name must be a non-empty string");if(arguments.length>1&&typeof qi!="boolean")throw new Te('"allowMissing" argument must be a boolean');if(Yi(/^%?[^%]*%?$/,Hs)===null)throw new ue("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var as=Hi(Hs),li=as.length>0?as[0]:"",vi=rs("%"+li+"%",qi),Ui=vi.name,hs=vi.value,Xs=!1,cr=vi.alias;cr&&(li=cr[0],pi(as,Ht([0,1],cr)));for(var Ks=1,$s=!0;Ks<as.length;Ks+=1){var hr=as[Ks],rn=ai(hr,0,1),Rr=ai(hr,-1);if((rn==='"'||rn==="'"||rn==="`"||Rr==='"'||Rr==="'"||Rr==="`")&&rn!==Rr)throw new ue("property names with quotes must have matching quotes");if((hr==="constructor"||!$s)&&(Xs=!0),li+="."+hr,Ui="%"+li+"%",Kt(qe,Ui))hs=qe[Ui];else if(hs!=null){if(!(hr in hs)){if(!qi)throw new Te("base intrinsic for "+Hs+" exists, but the property is not available.");return}if(ke&&Ks+1>=as.length){var Yr=ke(hs,hr);$s=!!Yr,$s&&"get"in Yr&&!("originalValue"in Yr.get)?hs=Yr.get:hs=hs[hr]}else $s=Kt(hs,hr),hs=hs[hr];$s&&!Xs&&(qe[Ui]=hs)}}return hs}},275:(W,A,V)=>{"use strict";var $=V(210),ne=$("%Object.getOwnPropertyDescriptor%",!0);if(ne)try{ne([],"length")}catch{ne=null}W.exports=ne},44:(W,A,V)=>{"use strict";var $=V(429),ne=function(){return!!$};ne.hasArrayLengthDefineBug=function(){if(!$)return null;try{return $([],"length",{value:1}).length!==1}catch{return!0}},W.exports=ne},185:W=>{"use strict";var A={foo:{}},V=Object;W.exports=function(){return{__proto__:A}.foo===A.foo&&!({__proto__:null}instanceof V)}},405:(W,A,V)=>{"use strict";var $=typeof Symbol<"u"&&Symbol,ne=V(419);W.exports=function(){return typeof $!="function"||typeof Symbol!="function"||typeof $("foo")!="symbol"||typeof Symbol("bar")!="symbol"?!1:ne()}},419:W=>{"use strict";W.exports=function(){if(typeof Symbol!="function"||typeof Object.getOwnPropertySymbols!="function")return!1;if(typeof Symbol.iterator=="symbol")return!0;var V={},$=Symbol("test"),ne=Object($);if(typeof $=="string"||Object.prototype.toString.call($)!=="[object Symbol]"||Object.prototype.toString.call(ne)!=="[object Symbol]")return!1;var xe=42;V[$]=xe;for($ in V)return!1;if(typeof Object.keys=="function"&&Object.keys(V).length!==0||typeof Object.getOwnPropertyNames=="function"&&Object.getOwnPropertyNames(V).length!==0)return!1;var le=Object.getOwnPropertySymbols(V);if(le.length!==1||le[0]!==$||!Object.prototype.propertyIsEnumerable.call(V,$))return!1;if(typeof Object.getOwnPropertyDescriptor=="function"){var ce=Object.getOwnPropertyDescriptor(V,$);if(ce.value!==xe||ce.enumerable!==!0)return!1}return!0}},410:(W,A,V)=>{"use strict";var $=V(419);W.exports=function(){return $()&&!!Symbol.toStringTag}},824:(W,A,V)=>{"use strict";var $=Function.prototype.call,ne=Object.prototype.hasOwnProperty,xe=V(612);W.exports=xe.call($,ne)},717:W=>{typeof Object.create=="function"?W.exports=function(V,$){$&&(V.super_=$,V.prototype=Object.create($.prototype,{constructor:{value:V,enumerable:!1,writable:!0,configurable:!0}}))}:W.exports=function(V,$){if($){V.super_=$;var ne=function(){};ne.prototype=$.prototype,V.prototype=new ne,V.prototype.constructor=V}}},584:(W,A,V)=>{"use strict";var $=V(410)(),ne=V(924),xe=ne("Object.prototype.toString"),le=function(Me){return $&&Me&&typeof Me=="object"&&Symbol.toStringTag in Me?!1:xe(Me)==="[object Arguments]"},ce=function(Me){return le(Me)?!0:Me!==null&&typeof Me=="object"&&typeof Me.length=="number"&&Me.length>=0&&xe(Me)!=="[object Array]"&&xe(Me.callee)==="[object Function]"},ue=function(){return le(arguments)}();le.isLegacyArguments=ce,W.exports=ue?le:ce},320:W=>{"use strict";var A=Function.prototype.toString,V=typeof Reflect=="object"&&Reflect!==null&&Reflect.apply,$,ne;if(typeof V=="function"&&typeof Object.defineProperty=="function")try{$=Object.defineProperty({},"length",{get:function(){throw ne}}),ne={},V(function(){throw 42},null,$)}catch(je){je!==ne&&(V=null)}else V=null;var xe=/^\s*class\b/,le=function(Ke){try{var qe=A.call(Ke);return xe.test(qe)}catch{return!1}},ce=function(Ke){try{return le(Ke)?!1:(A.call(Ke),!0)}catch{return!1}},ue=Object.prototype.toString,Te="[object Object]",Me="[object Function]",Re="[object GeneratorFunction]",we="[object HTMLAllCollection]",ke="[object HTML document.all class]",Ue="[object HTMLCollection]",Ge=typeof Symbol=="function"&&!!Symbol.toStringTag,We=!(0 in[,]),Xe=function(){return!1};if(typeof document=="object"){var Ye=document.all;ue.call(Ye)===ue.call(document.all)&&(Xe=function(Ke){if((We||!Ke)&&(typeof Ke>"u"||typeof Ke=="object"))try{var qe=ue.call(Ke);return(qe===we||qe===ke||qe===Ue||qe===Te)&&Ke("")==null}catch{}return!1})}W.exports=V?function(Ke){if(Xe(Ke))return!0;if(!Ke||typeof Ke!="function"&&typeof Ke!="object")return!1;try{V(Ke,null,$)}catch(qe){if(qe!==ne)return!1}return!le(Ke)&&ce(Ke)}:function(Ke){if(Xe(Ke))return!0;if(!Ke||typeof Ke!="function"&&typeof Ke!="object")return!1;if(Ge)return ce(Ke);if(le(Ke))return!1;var qe=ue.call(Ke);return qe!==Me&&qe!==Re&&!/^\[object HTML/.test(qe)?!1:ce(Ke)}},662:(W,A,V)=>{"use strict";var $=Object.prototype.toString,ne=Function.prototype.toString,xe=/^\s*(?:function)?\*/,le=V(410)(),ce=Object.getPrototypeOf,ue=function(){if(!le)return!1;try{return Function("return function*() {}")()}catch{}},Te;W.exports=function(Re){if(typeof Re!="function")return!1;if(xe.test(ne.call(Re)))return!0;if(!le){var we=$.call(Re);return we==="[object GeneratorFunction]"}if(!ce)return!1;if(typeof Te>"u"){var ke=ue();Te=ke?ce(ke):!1}return ce(Re)===Te}},692:(W,A,V)=>{"use strict";var $=V(430);W.exports=function(xe){return!!$(xe)}},300:(W,A,V)=>{"use strict";var $=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof V.g<"u")return V.g;throw new Error("unable to locate global object")},ne=$();W.exports=A=ne.fetch,ne.fetch&&(A.default=ne.fetch.bind(ne)),A.Headers=ne.Headers,A.Request=ne.Request,A.Response=ne.Response},908:W=>{"use strict";W.exports=["Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]},771:(W,A,V)=>{"use strict";var $=V(210),ne=V(296),xe=V(44)(),le=V(275),ce=V(453),ue=$("%Math.floor%");W.exports=function(Me,Re){if(typeof Me!="function")throw new ce("`fn` is not a function");if(typeof Re!="number"||Re<0||Re>4294967295||ue(Re)!==Re)throw new ce("`length` must be a positive 32-bit integer");var we=arguments.length>2&&!!arguments[2],ke=!0,Ue=!0;if("length"in Me&&le){var Ge=le(Me,"length");Ge&&!Ge.configurable&&(ke=!1),Ge&&!Ge.writable&&(Ue=!1)}return(ke||Ue||!we)&&(xe?ne(Me,"length",Re,!0,!0):ne(Me,"length",Re)),Me}},384:W=>{W.exports=function(V){return V&&typeof V=="object"&&typeof V.copy=="function"&&typeof V.fill=="function"&&typeof V.readUInt8=="function"}},955:(W,A,V)=>{"use strict";var $=V(584),ne=V(662),xe=V(430),le=V(692);function ce(cs){return cs.call.bind(cs)}var ue=typeof BigInt<"u",Te=typeof Symbol<"u",Me=ce(Object.prototype.toString),Re=ce(Number.prototype.valueOf),we=ce(String.prototype.valueOf),ke=ce(Boolean.prototype.valueOf);if(ue)var Ue=ce(BigInt.prototype.valueOf);if(Te)var Ge=ce(Symbol.prototype.valueOf);function We(cs,a0){if(typeof cs!="object")return!1;try{return a0(cs),!0}catch{return!1}}A.isArgumentsObject=$,A.isGeneratorFunction=ne,A.isTypedArray=le;function Xe(cs){return typeof Promise<"u"&&cs instanceof Promise||cs!==null&&typeof cs=="object"&&typeof cs.then=="function"&&typeof cs.catch=="function"}A.isPromise=Xe;function Ye(cs){return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?ArrayBuffer.isView(cs):le(cs)||vi(cs)}A.isArrayBufferView=Ye;function je(cs){return xe(cs)==="Uint8Array"}A.isUint8Array=je;function Ke(cs){return xe(cs)==="Uint8ClampedArray"}A.isUint8ClampedArray=Ke;function qe(cs){return xe(cs)==="Uint16Array"}A.isUint16Array=qe;function $e(cs){return xe(cs)==="Uint32Array"}A.isUint32Array=$e;function vt(cs){return xe(cs)==="Int8Array"}A.isInt8Array=vt;function nt(cs){return xe(cs)==="Int16Array"}A.isInt16Array=nt;function wt(cs){return xe(cs)==="Int32Array"}A.isInt32Array=wt;function Kt(cs){return xe(cs)==="Float32Array"}A.isFloat32Array=Kt;function Ht(cs){return xe(cs)==="Float64Array"}A.isFloat64Array=Ht;function pi(cs){return xe(cs)==="BigInt64Array"}A.isBigInt64Array=pi;function hi(cs){return xe(cs)==="BigUint64Array"}A.isBigUint64Array=hi;function ai(cs){return Me(cs)==="[object Map]"}ai.working=typeof Map<"u"&&ai(new Map);function Yi(cs){return typeof Map>"u"?!1:ai.working?ai(cs):cs instanceof Map}A.isMap=Yi;function Wi(cs){return Me(cs)==="[object Set]"}Wi.working=typeof Set<"u"&&Wi(new Set);function ls(cs){return typeof Set>"u"?!1:Wi.working?Wi(cs):cs instanceof Set}A.isSet=ls;function Hi(cs){return Me(cs)==="[object WeakMap]"}Hi.working=typeof WeakMap<"u"&&Hi(new WeakMap);function rs(cs){return typeof WeakMap>"u"?!1:Hi.working?Hi(cs):cs instanceof WeakMap}A.isWeakMap=rs;function Us(cs){return Me(cs)==="[object WeakSet]"}Us.working=typeof WeakSet<"u"&&Us(new WeakSet);function Hs(cs){return Us(cs)}A.isWeakSet=Hs;function qi(cs){return Me(cs)==="[object ArrayBuffer]"}qi.working=typeof ArrayBuffer<"u"&&qi(new ArrayBuffer);function as(cs){return typeof ArrayBuffer>"u"?!1:qi.working?qi(cs):cs instanceof ArrayBuffer}A.isArrayBuffer=as;function li(cs){return Me(cs)==="[object DataView]"}li.working=typeof ArrayBuffer<"u"&&typeof DataView<"u"&&li(new DataView(new ArrayBuffer(1),0,1));function vi(cs){return typeof DataView>"u"?!1:li.working?li(cs):cs instanceof DataView}A.isDataView=vi;var Ui=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:void 0;function hs(cs){return Me(cs)==="[object SharedArrayBuffer]"}function Xs(cs){return typeof Ui>"u"?!1:(typeof hs.working>"u"&&(hs.working=hs(new Ui)),hs.working?hs(cs):cs instanceof Ui)}A.isSharedArrayBuffer=Xs;function cr(cs){return Me(cs)==="[object AsyncFunction]"}A.isAsyncFunction=cr;function Ks(cs){return Me(cs)==="[object Map Iterator]"}A.isMapIterator=Ks;function $s(cs){return Me(cs)==="[object Set Iterator]"}A.isSetIterator=$s;function hr(cs){return Me(cs)==="[object Generator]"}A.isGeneratorObject=hr;function rn(cs){return Me(cs)==="[object WebAssembly.Module]"}A.isWebAssemblyCompiledModule=rn;function Rr(cs){return We(cs,Re)}A.isNumberObject=Rr;function Yr(cs){return We(cs,we)}A.isStringObject=Yr;function Tn(cs){return We(cs,ke)}A.isBooleanObject=Tn;function Mn(cs){return ue&&We(cs,Ue)}A.isBigIntObject=Mn;function Un(cs){return Te&&We(cs,Ge)}A.isSymbolObject=Un;function qn(cs){return Rr(cs)||Yr(cs)||Tn(cs)||Mn(cs)||Un(cs)}A.isBoxedPrimitive=qn;function $n(cs){return typeof Uint8Array<"u"&&(as(cs)||Xs(cs))}A.isAnyArrayBuffer=$n,["isProxy","isExternal","isModuleNamespaceObject"].forEach(function(cs){Object.defineProperty(A,cs,{enumerable:!1,value:function(){throw new Error(cs+" is not supported in userland")}})})},539:(W,A,V)=>{var $=Object.getOwnPropertyDescriptors||function(vi){for(var Ui=Object.keys(vi),hs={},Xs=0;Xs<Ui.length;Xs++)hs[Ui[Xs]]=Object.getOwnPropertyDescriptor(vi,Ui[Xs]);return hs},ne=/%[sdj%]/g;A.format=function(li){if(!vt(li)){for(var vi=[],Ui=0;Ui<arguments.length;Ui++)vi.push(ue(arguments[Ui]));return vi.join(" ")}for(var Ui=1,hs=arguments,Xs=hs.length,cr=String(li).replace(ne,function($s){if($s==="%%")return"%";if(Ui>=Xs)return $s;switch($s){case"%s":return String(hs[Ui++]);case"%d":return Number(hs[Ui++]);case"%j":try{return JSON.stringify(hs[Ui++])}catch{return"[Circular]"}default:return $s}}),Ks=hs[Ui];Ui<Xs;Ks=hs[++Ui])Ke(Ks)||!Ht(Ks)?cr+=" "+Ks:cr+=" "+ue(Ks);return cr},A.deprecate=function(li,vi){if(typeof process<"u"&&process.noDeprecation===!0)return li;if(typeof process>"u")return function(){return A.deprecate(li,vi).apply(this,arguments)};var Ui=!1;function hs(){if(!Ui){if(process.throwDeprecation)throw new Error(vi);process.traceDeprecation?console.trace(vi):console.error(vi),Ui=!0}return li.apply(this,arguments)}return hs};var xe={},le=/^$/;if("MISSING_ENV_VAR".NODE_DEBUG){var ce="MISSING_ENV_VAR".NODE_DEBUG;ce=ce.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),le=new RegExp("^"+ce+"$","i")}A.debuglog=function(li){if(li=li.toUpperCase(),!xe[li])if(le.test(li)){var vi=process.pid;xe[li]=function(){var Ui=A.format.apply(A,arguments);console.error("%s %d: %s",li,vi,Ui)}}else xe[li]=function(){};return xe[li]};function ue(li,vi){var Ui={seen:[],stylize:Me};return arguments.length>=3&&(Ui.depth=arguments[2]),arguments.length>=4&&(Ui.colors=arguments[3]),je(vi)?Ui.showHidden=vi:vi&&A._extend(Ui,vi),wt(Ui.showHidden)&&(Ui.showHidden=!1),wt(Ui.depth)&&(Ui.depth=2),wt(Ui.colors)&&(Ui.colors=!1),wt(Ui.customInspect)&&(Ui.customInspect=!0),Ui.colors&&(Ui.stylize=Te),we(Ui,li,Ui.depth)}A.inspect=ue,ue.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},ue.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};function Te(li,vi){var Ui=ue.styles[vi];return Ui?"\x1B["+ue.colors[Ui][0]+"m"+li+"\x1B["+ue.colors[Ui][1]+"m":li}function Me(li,vi){return li}function Re(li){var vi={};return li.forEach(function(Ui,hs){vi[Ui]=!0}),vi}function we(li,vi,Ui){if(li.customInspect&&vi&&ai(vi.inspect)&&vi.inspect!==A.inspect&&!(vi.constructor&&vi.constructor.prototype===vi)){var hs=vi.inspect(Ui,li);return vt(hs)||(hs=we(li,hs,Ui)),hs}var Xs=ke(li,vi);if(Xs)return Xs;var cr=Object.keys(vi),Ks=Re(cr);if(li.showHidden&&(cr=Object.getOwnPropertyNames(vi)),hi(vi)&&(cr.indexOf("message")>=0||cr.indexOf("description")>=0))return Ue(vi);if(cr.length===0){if(ai(vi)){var $s=vi.name?": "+vi.name:"";return li.stylize("[Function"+$s+"]","special")}if(Kt(vi))return li.stylize(RegExp.prototype.toString.call(vi),"regexp");if(pi(vi))return li.stylize(Date.prototype.toString.call(vi),"date");if(hi(vi))return Ue(vi)}var hr="",rn=!1,Rr=["{","}"];if(Ye(vi)&&(rn=!0,Rr=["[","]"]),ai(vi)){var Yr=vi.name?": "+vi.name:"";hr=" [Function"+Yr+"]"}if(Kt(vi)&&(hr=" "+RegExp.prototype.toString.call(vi)),pi(vi)&&(hr=" "+Date.prototype.toUTCString.call(vi)),hi(vi)&&(hr=" "+Ue(vi)),cr.length===0&&(!rn||vi.length==0))return Rr[0]+hr+Rr[1];if(Ui<0)return Kt(vi)?li.stylize(RegExp.prototype.toString.call(vi),"regexp"):li.stylize("[Object]","special");li.seen.push(vi);var Tn;return rn?Tn=Ge(li,vi,Ui,Ks,cr):Tn=cr.map(function(Mn){return We(li,vi,Ui,Ks,Mn,rn)}),li.seen.pop(),Xe(Tn,hr,Rr)}function ke(li,vi){if(wt(vi))return li.stylize("undefined","undefined");if(vt(vi)){var Ui="'"+JSON.stringify(vi).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return li.stylize(Ui,"string")}if($e(vi))return li.stylize(""+vi,"number");if(je(vi))return li.stylize(""+vi,"boolean");if(Ke(vi))return li.stylize("null","null")}function Ue(li){return"["+Error.prototype.toString.call(li)+"]"}function Ge(li,vi,Ui,hs,Xs){for(var cr=[],Ks=0,$s=vi.length;Ks<$s;++Ks)Us(vi,String(Ks))?cr.push(We(li,vi,Ui,hs,String(Ks),!0)):cr.push("");return Xs.forEach(function(hr){hr.match(/^\d+$/)||cr.push(We(li,vi,Ui,hs,hr,!0))}),cr}function We(li,vi,Ui,hs,Xs,cr){var Ks,$s,hr;if(hr=Object.getOwnPropertyDescriptor(vi,Xs)||{value:vi[Xs]},hr.get?hr.set?$s=li.stylize("[Getter/Setter]","special"):$s=li.stylize("[Getter]","special"):hr.set&&($s=li.stylize("[Setter]","special")),Us(hs,Xs)||(Ks="["+Xs+"]"),$s||(li.seen.indexOf(hr.value)<0?(Ke(Ui)?$s=we(li,hr.value,null):$s=we(li,hr.value,Ui-1),$s.indexOf(`
`)>-1&&(cr?$s=$s.split(`
`).map(function(rn){return"  "+rn}).join(`
`).slice(2):$s=`
`+$s.split(`
`).map(function(rn){return"   "+rn}).join(`
`))):$s=li.stylize("[Circular]","special")),wt(Ks)){if(cr&&Xs.match(/^\d+$/))return $s;Ks=JSON.stringify(""+Xs),Ks.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(Ks=Ks.slice(1,-1),Ks=li.stylize(Ks,"name")):(Ks=Ks.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),Ks=li.stylize(Ks,"string"))}return Ks+": "+$s}function Xe(li,vi,Ui){var hs=0,Xs=li.reduce(function(cr,Ks){return hs++,Ks.indexOf(`
`)>=0&&hs++,cr+Ks.replace(/\u001b\[\d\d?m/g,"").length+1},0);return Xs>60?Ui[0]+(vi===""?"":vi+`
 `)+" "+li.join(`,
  `)+" "+Ui[1]:Ui[0]+vi+" "+li.join(", ")+" "+Ui[1]}A.types=V(955);function Ye(li){return Array.isArray(li)}A.isArray=Ye;function je(li){return typeof li=="boolean"}A.isBoolean=je;function Ke(li){return li===null}A.isNull=Ke;function qe(li){return li==null}A.isNullOrUndefined=qe;function $e(li){return typeof li=="number"}A.isNumber=$e;function vt(li){return typeof li=="string"}A.isString=vt;function nt(li){return typeof li=="symbol"}A.isSymbol=nt;function wt(li){return li===void 0}A.isUndefined=wt;function Kt(li){return Ht(li)&&Wi(li)==="[object RegExp]"}A.isRegExp=Kt,A.types.isRegExp=Kt;function Ht(li){return typeof li=="object"&&li!==null}A.isObject=Ht;function pi(li){return Ht(li)&&Wi(li)==="[object Date]"}A.isDate=pi,A.types.isDate=pi;function hi(li){return Ht(li)&&(Wi(li)==="[object Error]"||li instanceof Error)}A.isError=hi,A.types.isNativeError=hi;function ai(li){return typeof li=="function"}A.isFunction=ai;function Yi(li){return li===null||typeof li=="boolean"||typeof li=="number"||typeof li=="string"||typeof li=="symbol"||typeof li>"u"}A.isPrimitive=Yi,A.isBuffer=V(384);function Wi(li){return Object.prototype.toString.call(li)}function ls(li){return li<10?"0"+li.toString(10):li.toString(10)}var Hi=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function rs(){var li=new Date,vi=[ls(li.getHours()),ls(li.getMinutes()),ls(li.getSeconds())].join(":");return[li.getDate(),Hi[li.getMonth()],vi].join(" ")}A.log=function(){console.log("%s - %s",rs(),A.format.apply(A,arguments))},A.inherits=V(717),A._extend=function(li,vi){if(!vi||!Ht(vi))return li;for(var Ui=Object.keys(vi),hs=Ui.length;hs--;)li[Ui[hs]]=vi[Ui[hs]];return li};function Us(li,vi){return Object.prototype.hasOwnProperty.call(li,vi)}var Hs=typeof Symbol<"u"?Symbol("util.promisify.custom"):void 0;A.promisify=function(vi){if(typeof vi!="function")throw new TypeError('The "original" argument must be of type Function');if(Hs&&vi[Hs]){var Ui=vi[Hs];if(typeof Ui!="function")throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(Ui,Hs,{value:Ui,enumerable:!1,writable:!1,configurable:!0}),Ui}function Ui(){for(var hs,Xs,cr=new Promise(function(hr,rn){hs=hr,Xs=rn}),Ks=[],$s=0;$s<arguments.length;$s++)Ks.push(arguments[$s]);Ks.push(function(hr,rn){hr?Xs(hr):hs(rn)});try{vi.apply(this,Ks)}catch(hr){Xs(hr)}return cr}return Object.setPrototypeOf(Ui,Object.getPrototypeOf(vi)),Hs&&Object.defineProperty(Ui,Hs,{value:Ui,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(Ui,$(vi))},A.promisify.custom=Hs;function qi(li,vi){if(!li){var Ui=new Error("Promise was rejected with a falsy value");Ui.reason=li,li=Ui}return vi(li)}function as(li){if(typeof li!="function")throw new TypeError('The "original" argument must be of type Function');function vi(){for(var Ui=[],hs=0;hs<arguments.length;hs++)Ui.push(arguments[hs]);var Xs=Ui.pop();if(typeof Xs!="function")throw new TypeError("The last argument must be of type Function");var cr=this,Ks=function(){return Xs.apply(cr,arguments)};li.apply(this,Ui).then(function($s){process.nextTick(Ks.bind(null,null,$s))},function($s){process.nextTick(qi.bind(null,$s,Ks))})}return Object.setPrototypeOf(vi,Object.getPrototypeOf(li)),Object.defineProperties(vi,$(li)),vi}A.callbackify=as},430:(W,A,V)=>{"use strict";var $=V(29),ne=V(83),xe=V(559),le=V(924),ce=V(275),ue=le("Object.prototype.toString"),Te=V(410)(),Me=typeof globalThis>"u"?V.g:globalThis,Re=ne(),we=le("String.prototype.slice"),ke=Object.getPrototypeOf,Ue=le("Array.prototype.indexOf",!0)||function(je,Ke){for(var qe=0;qe<je.length;qe+=1)if(je[qe]===Ke)return qe;return-1},Ge={__proto__:null};Te&&ce&&ke?$(Re,function(Ye){var je=new Me[Ye];if(Symbol.toStringTag in je){var Ke=ke(je),qe=ce(Ke,Symbol.toStringTag);if(!qe){var $e=ke(Ke);qe=ce($e,Symbol.toStringTag)}Ge["$"+Ye]=xe(qe.get)}}):$(Re,function(Ye){var je=new Me[Ye],Ke=je.slice||je.set;Ke&&(Ge["$"+Ye]=xe(Ke))});var We=function(je){var Ke=!1;return $(Ge,function(qe,$e){if(!Ke)try{"$"+qe(je)===$e&&(Ke=we($e,1))}catch{}}),Ke},Xe=function(je){var Ke=!1;return $(Ge,function(qe,$e){if(!Ke)try{qe(je),Ke=we($e,1)}catch{}}),Ke};W.exports=function(je){if(!je||typeof je!="object")return!1;if(!Te){var Ke=we(ue(je),8,-1);return Ue(Re,Ke)>-1?Ke:Ke!=="Object"?!1:Xe(je)}return ce?We(je):null}},653:()=>{},83:(W,A,V)=>{"use strict";var $=V(908),ne=typeof globalThis>"u"?V.g:globalThis;W.exports=function(){for(var le=[],ce=0;ce<$.length;ce++)typeof ne[$[ce]]=="function"&&(le[le.length]=$[ce]);return le}}},__webpack_module_cache__={};function __webpack_require__(W){var A=__webpack_module_cache__[W];if(A!==void 0)return A.exports;var V=__webpack_module_cache__[W]={exports:{}};return __webpack_modules__[W](V,V.exports,__webpack_require__),V.exports}__webpack_require__.d=(W,A)=>{for(var V in A)__webpack_require__.o(A,V)&&!__webpack_require__.o(W,V)&&Object.defineProperty(W,V,{enumerable:!0,get:A[V]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(W,A)=>Object.prototype.hasOwnProperty.call(W,A);var __webpack_exports__={};(()=>{"use strict";var W=__webpack_require__(862),A=__webpack_require__(187);class V extends A.EventEmitter{}var $=Object.defineProperty,ne=Object.getOwnPropertySymbols,xe=Object.prototype.hasOwnProperty,le=Object.prototype.propertyIsEnumerable,ce=(pe,p,_)=>p in pe?$(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,ue=(pe,p)=>{for(var _ in p||(p={}))xe.call(p,_)&&ce(pe,_,p[_]);if(ne)for(var _ of ne(p))le.call(p,_)&&ce(pe,_,p[_]);return pe};class Te{constructor(p="canvas"){this.size={width:0,height:0},this.transpose=!1,this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.capture."+p,this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}capture(p){const{context:_,clipPix:E,transpose:I}=this;if(!_)return!1;let{width:Z,height:re}=this.size;return I&&([Z,re]=[re,Z]),I&&_.setTransform(0,1,1,0,0,0),E?_.drawImage(p,E.left,E.top,E.width,E.height,0,0,Z,re):_.drawImage(p,0,0,Z,re),I&&_.resetTransform(),!0}fill(){const{context:p}=this;if(!p)return;let{width:_,height:E}=this.size;p.fillStyle="rgba(255, 255, 255, 1)",p.fillRect(0,0,_,E)}data(){const{context:p}=this;if(!p)return;const{width:_,height:E}=this.size;return p.getImageData(0,0,_,E)}setSize(p){let{width:_,height:E}=p;this.transpose&&([_,E]=[E,_]),this.size={width:_,height:E},this.canvas.width=_,this.canvas.height=E,this.setClip(this.clip)}setClip(p){let{width:_,height:E}=this.size;this.transpose&&([_,E]=[E,_]),this.clip=p,this.clipPix=p&&{left:p.left*_,top:p.top*E,width:p.width*_,height:p.height*E}}setTranspose(p){if(p==this.transpose)return;let{width:_,height:E}=this.size;this.transpose&&([_,E]=[E,_]),this.transpose=p,this.setSize({width:_,height:E})}dispose(){this.context=null,this.canvas.remove()}}class Me extends V{constructor(){super(),this.buffer=new Te("capture"),this.captureTime=0}async setup(p){const _=p&&(E=>typeof E!="string"&&"size"in E)(p)&&p.size||{width:1920,height:1080};return this.updateSize(_),this.buffer.fill(),!0}dispose(){this.reset(),this.buffer.dispose()}async start(){this.captureTime=0,this.timer=Date.now()}pause(){}reset(){this.pause(),delete this.timer}capture(){return this.timer===void 0?!1:(this.captureTime=(Date.now()-this.timer)*1e3,!0)}size(){return ue({},this.buffer.size)}ratio(){const p=this.buffer.size;return p.width/p.height}updateSize(p){let{width:_,height:E}=p;const{sizeMax:I,clipRect:Z,transpose:re}=this;if(I&&(_>I||E>I)){const ae=_/E;ae>1?(_=I,E=I/ae):(E=I,_=ae*I),p={width:_,height:E}}this.buffer.setSize(p),this.buffer.setClip(Z),this.buffer.setTranspose(!!re),this.emit("resize",this.buffer.size)}}class Re extends Me{constructor(){super(),this.timeShift=0,this.videoRef=document.createElement("video"),this.videoRef.id="engeenee.capture.source",this.videoRef.muted=!0,this.videoRef.loop=!0,this.videoRef.playsInline=!0}async setup(p){const _=he=>typeof he=="string"||"url"in he&&typeof he.url=="string",E=he=>_(he)||"getVideoTracks"in he,I=he=>_(he)&&typeof he!="string"?(this.sizeMax=he.sizeMax,he.url):he,Z=he=>{var _e,ve;return he?(Le=>"video"in Le)(he)?he:(this.clipRect=he.clip,this.transpose=he.transpose,{video:{facingMode:he.rear?"environment":"user",width:(_e=he.size)==null?void 0:_e.width,height:(ve=he.size)==null?void 0:ve.height,frameRate:he.fps},audio:!1}):{video:!0,audio:!1}};delete this.sizeMax,delete this.clipRect,delete this.transpose;const re=p!==void 0&&E(p)?I(p):await navigator.mediaDevices.getUserMedia(Z(p)).catch(()=>{});if(!re)return!1;const{videoRef:ae}=this;return new Promise(he=>{ae.onloadedmetadata=()=>{this.updateSize({width:ae.videoWidth,height:ae.videoHeight}),ae.onresize=()=>{this.updateSize({width:ae.videoWidth,height:ae.videoHeight})},ae.onseeked=()=>{this.timeShift=this.captureTime,this.captureTime=0},he(!0)},typeof re=="string"?ae.src=re:ae.srcObject=re})}dispose(){super.dispose(),this.videoRef.remove()}async start(){this.captureTime=0,this.timeShift=0,(this.videoRef.srcObject||this.videoRef.src)&&await this.videoRef.play()}pause(){this.videoRef.pause()}reset(){this.pause(),this.videoRef.srcObject&&(this.videoRef.srcObject.getTracks().forEach(p=>p.stop()),this.videoRef.srcObject=null)}capture(){const{videoRef:p,buffer:_}=this,E=p.currentTime+this.timeShift;return E<=this.captureTime?!1:(this.captureTime=E,_.capture(p))}}class we extends V{constructor(p,_,E=Re){super(),this.engineParams=_,this.renderers=[],this.videoRatio=1920/1080,this.streamSize={width:1920,height:1080},this.processSize={width:1920,height:1080},this.resizeEnabled=!1,this.loopState=!1,this.init=async I=>{const Z=await this.setupProcessor(I);return this.emit("init",Z),Z},this.setup=async I=>{this.pause();const Z=await this.setupVideo(I);return this.emit("setup",Z),Z},this.start=async()=>{await this.video.start(),this.loopState=!0,this.emit("start"),this.enqueue()},this.pause=()=>{this.loopState=!1,this.loopId&&(window.cancelAnimationFrame(this.loopId),delete this.loopId),this.video.pause(),this.emit("pause")},this.reset=()=>{this.pause(),this.video.reset(),delete this.streamCanvas,delete this.processCanvas,this.processor.reset()},this.iterate=async()=>{var I;const{video:Z,streamCanvas:re,processCanvas:ae}=this;if(!Z.capture()||!re||!ae)return this.enqueue();this.resizeEnabled&&((I=this.resizeBuffer)==null||I.capture(Z.buffer.canvas));const he=await this.processor.process(ae,Z.captureTime);he&&await Promise.all(this.renderers.map(_e=>_e.update(he,re))),this.enqueue()},this.processor=typeof p=="function"?new p:p,this.video=typeof E=="function"?new E:E,this.video.on("resize",this.resizeVideo.bind(this))}async addRenderer(p){this.renderers.push(p),await p.load(),p.setupVideo(this.video.size(),this.video.ratio()),p.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle)}removeRenderer(p){const{renderers:_}=this,E=_.indexOf(p);E<0||(_[E].dispose(),_.splice(E,1))}enqueue(){this.loopId=this.loopState?window.requestAnimationFrame(this.iterate):void 0}async setupProcessor(p){var _;const E=this.resizeEnabled&&((_=this.resizeBuffer)==null?void 0:_.size)||this.video.size();return this.processor.init(p,E,this.video.ratio())}async setupVideo(p){return this.video.reset(),await this.video.setup(p)?(this.setupSize(this.video.size()),!0):!1}async setupSize(p){var _,E;const{width:I,height:Z}=p;this.videoRatio=I/Z;const re=Math.max(I,Z),ae=((_=this.engineParams)==null?void 0:_.max)||this.processor.optimalSize;if(this.resizeEnabled=!1,ae<re){this.resizeEnabled=!0;const he=re/ae;this.resizeBuffer||(this.resizeBuffer=new Te("resize")),this.resizeBuffer.setSize({width:I/he,height:Z/he})}this.resizeEnabled&&this.resizeBuffer?(this.processCanvas=this.resizeBuffer.canvas,this.processSize=this.resizeBuffer.size):(this.processCanvas=this.video.buffer.canvas,this.processSize=this.video.size()),((E=this.engineParams)==null?void 0:E.orig)!==!1?(this.streamCanvas=this.video.buffer.canvas,this.streamSize=this.video.size()):(this.streamCanvas=this.processCanvas,this.streamSize=this.streamSize)}resizeVideo(p){this.setupSize(p),this.processor.setupVideo(this.processSize,this.videoRatio),this.renderers.forEach(_=>_.setupVideo(this.streamSize,this.videoRatio)),this.renderers.forEach(_=>_.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle))}}var ke=Object.defineProperty,Ue=Object.getOwnPropertySymbols,Ge=Object.prototype.hasOwnProperty,We=Object.prototype.propertyIsEnumerable,Xe=(pe,p,_)=>p in pe?ke(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,Ye=(pe,p)=>{for(var _ in p||(p={}))Ge.call(p,_)&&Xe(pe,_,p[_]);if(Ue)for(var _ of Ue(p))We.call(p,_)&&Xe(pe,_,p[_]);return pe};class je extends V{constructor(){super(),this.params={},this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.optimalSize=1024,this.cameraRatio=this.videoRatio,this.cameraAngle=60/180*Math.PI}async process(p,_){return{}}async init(p,_,E){return this.params=p,!E&&_&&(E=_.width/_.height),this.setupVideo(_||this.videoSize,E||this.videoRatio),this.emit("init",!0),!0}reset(){this.emit("reset")}dispose(){}setupVideo(p,_){_=_||p.width/p.height,this.videoSize=Ye({},p),this.videoRatio=_,this.cameraRatio=_}}class Ke extends V{constructor(p,_="crop",E=1,I=!1,Z=1){super(),this.container=p,this.mode=_,this.layerCount=E,this.mirror=I,this.aspectRatio=Z,this.layers=[],this.padsSize=[1,1],this.setAspectRatio=re=>{this.aspectRatio=re,this.updateSizes(this.container.clientWidth/this.container.clientHeight)},this.setMirror=re=>{this.mirror=re,this.layers.forEach(ae=>{ae.style.transform=re?"scaleX(-1)":""})},this.setMode=re=>{if(this.mode=re,this.mode==="pad"&&!this.pads){this.pads=[document.createElement("canvas"),document.createElement("canvas")];const ae=-10*(this.layerCount+1)+"";for(let he=0;he<2;he++)this.pads[he].id="engeenee.canvas.pad"+he,this.pads[he].style.position="absolute",this.pads[he].style.zIndex=ae,this.container.appendChild(this.pads[he])}this.mode!=="pad"&&this.pads&&(this.pads.forEach(ae=>ae.remove()),delete this.pads),this.setAspectRatio(this.aspectRatio)},this.dispose=()=>{var re,ae;(re=this.observer)==null||re.disconnect(),delete this.observer,(ae=this.pads)==null||ae.forEach(he=>he.remove()),delete this.pads,this.layers.forEach(he=>he.remove()),this.layers=[]},this.updateSizes=re=>{let ae=1,he=1;re>this.aspectRatio?this.mode==="crop"?he=re/this.aspectRatio:ae=this.aspectRatio/re:this.mode==="crop"?ae=this.aspectRatio/re:he=re/this.aspectRatio;const _e=(1-ae)/2,ve=(1-he)/2,Le=ae*100+"%",ze=he*100+"%",He=_e*100+"%",xt=ve*100+"%";for(const rt of this.layers)rt.style.width=Le,rt.style.height=ze,rt.style.left=He,rt.style.top=xt;if(this.pads){this.padsSize=_e>0?[_e,1]:[1,ve];const rt=10,{clientWidth:Tt,clientHeight:Lt}=this.container,Nt=[2*rt/Tt,2*rt/Lt],qt=(this.padsSize[0]+2*Nt[0])*100+"%",Xt=(this.padsSize[1]+2*Nt[1])*100+"%";this.pads[0].style.width=qt,this.pads[0].style.height=Xt,this.pads[1].style.width=qt,this.pads[1].style.height=Xt;const zt=-Nt[0]*100+"%",Gt=-Nt[1]*100+"%";this.pads[0].style.top=Gt,this.pads[1].style.bottom=Gt,this.pads[0].style.left="unset",this.pads[0].style.right="unset",this.pads[1].style.left="unset",this.pads[1].style.right="unset",this.pads[this.mirror?1:0].style.left=zt,this.pads[this.mirror?0:1].style.right=zt;const xi=_e>0?this.mirror?"":"scaleX(-1)":"scaleY(-1) "+(this.mirror?"scaleX(-1)":"");this.pads[0].style.transform=xi,this.pads[1].style.transform=xi;const Gi="blur("+rt+"px)";this.pads[0].style.filter=Gi,this.pads[1].style.filter=Gi}this.emit("resize")},this.handleResize=re=>{if(re.length<1)return;const ae=re[0].contentRect;this.updateSizes(ae.width/ae.height)};for(let re=0;re<E;re++){const ae=document.createElement("canvas");ae.id="engeenee.canvas.layer"+re,ae.style.position="absolute",ae.style.zIndex=-10*(E-re)+"",this.mirror&&(ae.style.transform="scaleX(-1)"),this.container.appendChild(ae),this.layers.push(ae)}this.setMode(_),this.observer=new ResizeObserver(this.handleResize),this.observer.observe(this.container),this.container.style.overflow="hidden"}}var qe=Object.defineProperty,$e=Object.getOwnPropertySymbols,vt=Object.prototype.hasOwnProperty,nt=Object.prototype.propertyIsEnumerable,wt=(pe,p,_)=>p in pe?qe(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,Kt=(pe,p)=>{for(var _ in p||(p={}))vt.call(p,_)&&wt(pe,_,p[_]);if($e)for(var _ of $e(p))nt.call(p,_)&&wt(pe,_,p[_]);return pe};class Ht extends V{constructor(){super(),this.loaded=!1,this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.cameraRatio=this.videoRatio,this.cameraAngle=10/180*Math.PI}async load(){this.loaded||(this.loaded=!0,this.emit("load"))}unload(){this.loaded&&(this.loaded=!1)}async update(p,_){this.loaded&&(this.updateVideo(_),this.updateScene(),this.emit("render"))}updateVideo(p){}updateScene(){}dispose(){this.unload()}setupVideo(p,_){this.videoSize=Kt({},p),this.videoRatio=_||p.width/p.height,this.emit("resize",this.videoSize,this.videoRatio)}setupCamera(p,_){this.cameraRatio=p,this.cameraAngle=_}}class pi extends Ht{constructor(){super(...arguments),this.plugins=[]}async load(){if(!this.loaded)return await Promise.all(this.plugins.map(p=>p.load(this))),super.load()}unload(){this.plugins.forEach(p=>p.unload()),super.unload()}async update(p,_){if(this.loaded)return await this.updatePlugins(p,_),super.update(p,_)}async updatePlugins(p,_){for(let E of this.plugins)E.loaded&&await E.update(p,_)}dispose(){this.plugins.forEach(p=>p.dispose()),this.plugins=[],super.dispose()}async addPlugin(p){const{plugins:_}=this;this.loaded&&!p.loaded&&await p.load(this),_.push(p),_.sort((E,I)=>E.ordinal-I.ordinal)}removePlugin(p){const{plugins:_}=this,E=_.indexOf(p);E<0||(_[E].dispose(),_.splice(E,1))}removeAllPlugins(){this.plugins.forEach(p=>p.dispose()),this.plugins=[]}setupVideo(p,_){super.setupVideo(p,_),this.plugins.forEach(E=>E.setupVideo(p))}setupCamera(p,_){super.setupCamera(p,_),this.plugins.forEach(E=>E.setupCamera(p,_))}}class hi extends pi{constructor(p){super(),this.padCtx=[null,null],this.setupPadding=()=>{if(!this.canvas.pads)return;const{width:_,height:E}=this.videoSize,{padsSize:I}=this.canvas,Z=_*I[0]/(I[0]<.5?1-2*I[0]:1),re=E*I[1]/(I[1]<.5?1-2*I[1]:1);this.canvas.pads[0].width=Z,this.canvas.pads[0].height=re,this.canvas.pads[1].width=Z,this.canvas.pads[1].height=re},this.canvas=new Ke(p.container,p.mode,p.layerCount,p.mirror,p.aspectRatio),this.canvas.pads&&(this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")]),this.canvas.addListener("resize",this.setupPadding)}updateVideo(p){super.updateVideo(p),this.updatePads(p)}dispose(){this.padCtx=[null,null],this.canvas.dispose(),super.dispose()}setupVideo(p,_){super.setupVideo(p,_),this.canvas.setAspectRatio(this.videoRatio)}setMirror(p){this.canvas.setMirror(p)}setMode(p){this.canvas.setMode(p),this.canvas.pads?this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")]:this.padCtx=[null,null]}updatePads(p){if(!this.padCtx[0]||!this.padCtx[1]||!this.canvas.pads)return;const{videoSize:{width:_,height:E}}=this,{width:I,height:Z}=this.canvas.pads[0];this.padCtx[0].clearRect(0,0,I,Z),this.padCtx[0].drawImage(p,0,0,I,Z,0,0,I,Z),this.padCtx[1].clearRect(0,0,I,Z),this.padCtx[1].drawImage(p,_-I,E-Z,I,Z,0,0,I,Z)}}class ai extends null{constructor(p){super(p),this.videoCtx=null;const _=this.canvas.layers[0];this.videoCtx=_.getContext("2d")}updateVideo(p){const{videoCtx:_}=this;if(!_)return;const{width:E,height:I}=this.videoSize;_.clearRect(0,0,E,I),_.drawImage(p,0,0),super.updateVideo(p)}setupVideo(p,_){super.setupVideo(p,_);const{width:E,height:I}=this.videoSize;this.canvas.layers[0].width=E,this.canvas.layers[0].height=I}}class Yi{constructor(p,_={width:1920,height:1080},E=!1,I=!1){this.gl=p,this.size=_,this.grayscale=E,this.linear=I,this.buffer=null,this.resize(_)}update(p){const{gl:_,size:{width:E,height:I}}=this,Z=_.getParameter(_.TEXTURE_BINDING_2D),re=_.getParameter(_.UNPACK_FLIP_Y_WEBGL);return _.bindTexture(_.TEXTURE_2D,this.buffer),_.pixelStorei(_.UNPACK_FLIP_Y_WEBGL,!1),p instanceof Float32Array?_.texSubImage2D(_.TEXTURE_2D,0,0,0,E,I,this.grayscale?_.RED:_.RGBA,_.FLOAT,p):p instanceof Uint8Array?_.texSubImage2D(_.TEXTURE_2D,0,0,0,E,I,this.grayscale?_.RED:_.RGBA,_.UNSIGNED_BYTE,p):_.texSubImage2D(_.TEXTURE_2D,0,0,0,E,I,this.grayscale?_.RED:_.RGBA,_.UNSIGNED_BYTE,p),_.bindTexture(_.TEXTURE_2D,Z),_.pixelStorei(_.UNPACK_FLIP_Y_WEBGL,re),this.buffer}resize(p){const{width:_,height:E}=p;if(_===this.size.width&&E===this.size.height&&this.buffer)return!0;const{gl:I}=this;if(I.deleteTexture(this.buffer),this.buffer=null,(_>0||E>0)&&(this.buffer=I.createTexture()),!this.buffer)return!1;const Z=this.linear?I.LINEAR:I.NEAREST,re=I.getParameter(I.TEXTURE_BINDING_2D),ae=I.getParameter(I.UNPACK_FLIP_Y_WEBGL);return I.bindTexture(I.TEXTURE_2D,this.buffer),I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL,!1),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_WRAP_R,I.CLAMP_TO_EDGE),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_WRAP_S,I.CLAMP_TO_EDGE),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_WRAP_T,I.CLAMP_TO_EDGE),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_MIN_FILTER,Z),I.texParameteri(I.TEXTURE_2D,I.TEXTURE_MAG_FILTER,Z),this.size={width:_,height:E},I.texStorage2D(I.TEXTURE_2D,4,this.grayscale?I.R8:I.RGBA8,_,E),I.bindTexture(I.TEXTURE_2D,re),I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL,ae),!0}dispose(){this.gl.deleteTexture(this.buffer),this.buffer=null}texture(){return this.buffer}valid(){return!!this.buffer}}var Wi=Object.defineProperty,ls=Object.getOwnPropertySymbols,Hi=Object.prototype.hasOwnProperty,rs=Object.prototype.propertyIsEnumerable,Us=(pe,p,_)=>p in pe?Wi(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,Hs=(pe,p)=>{for(var _ in p||(p={}))Hi.call(p,_)&&Us(pe,_,p[_]);if(ls)for(var _ of ls(p))rs.call(p,_)&&Us(pe,_,p[_]);return pe};class qi{constructor(p,_={width:1920,height:1080},E=["image"],I={},Z=li,re=as,ae=!1,he=!1){this.gl=p,this.size=_,this.inputs=E,this.uniforms=I,this.vertShader=null,this.fragShader=null,this.shaderProgram=null,this.vertBuffer=null,this.vertAttrs=null,this.uniformsLoc={},this.frameBuffer=null,Z.includes("uniform vec2 wh;")&&!I.wh&&(I.wh="2f"),re.includes("uniform float flip;")&&!I.flip&&(I.flip="1f"),this.outputTexture=new Yi(p,_,ae,he),this.compile(Z,re),this.resize(_)}process(p,_={}){const{gl:E,outputTexture:I}=this;if(!E||!I||p.length!==this.inputs.length)return null;const Z=I.texture();if(!Z)return null;const re=this.save(E);return E.bindFramebuffer(E.FRAMEBUFFER,this.frameBuffer),E.framebufferTexture2D(E.FRAMEBUFFER,E.COLOR_ATTACHMENT0,E.TEXTURE_2D,Z,0),_=Hs({flip:[-1]},_),this.prepare(E,p,_),E.drawArrays(E.TRIANGLES,0,6),this.restore(E,re),Z}render(p,_={}){const{gl:E,outputTexture:I}=this;if(!E||!I||p.length!==this.inputs.length)return;const Z=this.save(E);E.bindFramebuffer(E.FRAMEBUFFER,null),_=Hs({flip:[1]},_),this.prepare(E,p,_),E.drawArrays(E.TRIANGLES,0,6),this.restore(E,Z)}output(){var p;return((p=this.outputTexture)==null?void 0:p.texture())||null}program(){return this.shaderProgram}resize(p){var _;const{gl:E}=this;this.size=Hs({},p),(_=this.outputTexture)==null||_.resize(p);const I=E.getParameter(E.CURRENT_PROGRAM);E.useProgram(this.shaderProgram),this.uniformsLoc.wh&&E.uniform2f(this.uniformsLoc.wh,p.width,p.height),E.useProgram(I)}setUniform(p,_){const{gl:E}=this,I=E.getParameter(E.CURRENT_PROGRAM);E.useProgram(this.shaderProgram),this.setUniformUnsafe(p,_),E.useProgram(I)}dispose(){var p;const{gl:_}=this;_.deleteBuffer(this.vertBuffer),this.vertBuffer=null,_.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,_.deleteShader(this.vertShader),this.vertShader=null,_.deleteShader(this.fragShader),this.fragShader=null,_.deleteProgram(this.shaderProgram),this.shaderProgram=null,(p=this.outputTexture)==null||p.dispose(),delete this.outputTexture}compile(p,_){const{gl:E}=this,I=this.save(E);if(this.vertBuffer=E.createBuffer(),this.vertAttrs=E.createVertexArray(),this.frameBuffer=E.createFramebuffer(),!this.vertBuffer||!this.frameBuffer||!this.vertAttrs){E.deleteBuffer(this.vertBuffer),this.vertBuffer=null,E.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,E.deleteVertexArray(this.vertAttrs),this.vertAttrs=null;return}if(this.vertShader=E.createShader(E.VERTEX_SHADER),this.fragShader=E.createShader(E.FRAGMENT_SHADER),this.shaderProgram=E.createProgram(),!this.vertShader||!this.fragShader||!this.shaderProgram){E.deleteBuffer(this.vertBuffer),this.vertBuffer=null,E.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,E.deleteShader(this.vertShader),this.vertShader=null,E.deleteShader(this.fragShader),this.fragShader=null,E.deleteProgram(this.shaderProgram),this.shaderProgram=null;return}E.shaderSource(this.vertShader,_),E.shaderSource(this.fragShader,p),E.compileShader(this.vertShader),E.compileShader(this.fragShader),E.attachShader(this.shaderProgram,this.vertShader),E.attachShader(this.shaderProgram,this.fragShader),E.linkProgram(this.shaderProgram),E.useProgram(this.shaderProgram),E.bindBuffer(E.ARRAY_BUFFER,this.vertBuffer),E.bufferData(E.ARRAY_BUFFER,new Float32Array([-1,-1,1,1,-1,1,-1,-1,1,-1,1,1]),E.STATIC_DRAW),E.bindVertexArray(this.vertAttrs);const Z=E.getAttribLocation(this.shaderProgram,"pos");E.vertexAttribPointer(Z,2,E.FLOAT,!1,0,0),E.enableVertexAttribArray(Z),this.uniformsLoc={};for(let re in this.uniforms)this.uniformsLoc[re]=E.getUniformLocation(this.shaderProgram,re);for(let re=0;re<this.inputs.length;re++)E.uniform1i(E.getUniformLocation(this.shaderProgram,this.inputs[re]),re);this.restore(E,I)}prepare(p,_,E={}){const{size:{width:I,height:Z}}=this;for(let re=0;re<_.length;re++)p.activeTexture(p.TEXTURE0+re),p.bindTexture(p.TEXTURE_2D,_[re]);p.useProgram(this.shaderProgram),p.bindVertexArray(this.vertAttrs);for(let re in E)this.setUniformUnsafe(re,E[re]);p.disable(p.CULL_FACE),p.colorMask(!0,!0,!0,!0),p.viewport(0,0,I,Z),p.scissor(0,0,I,Z),p.clear(p.COLOR_BUFFER_BIT)}save(p){return{program:p.getParameter(p.CURRENT_PROGRAM),arrayBuffer:p.getParameter(p.ARRAY_BUFFER_BINDING),framebuffer:p.getParameter(p.FRAMEBUFFER_BINDING),vertexArray:p.getParameter(p.VERTEX_ARRAY_BINDING),viewport:p.getParameter(p.VIEWPORT),scissor:p.getParameter(p.SCISSOR_BOX),colorMask:p.getParameter(p.COLOR_WRITEMASK),cullFace:p.getParameter(p.CULL_FACE),activeTexture:p.getParameter(p.ACTIVE_TEXTURE),textures:this.inputs.map((_,E)=>(p.activeTexture(p.TEXTURE0+E),p.getParameter(p.TEXTURE_BINDING_2D)))}}restore(p,_){p.useProgram(_.program),p.bindBuffer(p.ARRAY_BUFFER,_.arrayBuffer),p.bindFramebuffer(p.FRAMEBUFFER,_.framebuffer),p.bindVertexArray(_.vertexArray),p.viewport(_.viewport[0],_.viewport[1],_.viewport[2],_.viewport[3]),p.scissor(_.scissor[0],_.scissor[1],_.scissor[2],_.scissor[3]),p.colorMask(_.colorMask[0],_.colorMask[1],_.colorMask[2],_.colorMask[3]);for(let E=0;E<_.textures.length;E++)p.activeTexture(p.TEXTURE0+E),p.bindTexture(p.TEXTURE_2D,_.textures[E]);p.activeTexture(_.activeTexture),_.cullFace?p.enable(p.CULL_FACE):p.disable(p.CULL_FACE)}setUniformUnsafe(p,_){const E=this.uniformsLoc[p];if(!E)return;const{gl:I}=this;switch(this.uniforms[p]){case"1f":_.length===1&&I.uniform1f(E,_[0]);break;case"2f":_.length===2&&I.uniform2f(E,_[0],_[1]);break;case"3f":_.length===3&&I.uniform3f(E,_[0],_[1],_[2]);break;case"4f":_.length===4&&I.uniform4f(E,_[0],_[1],_[2],_[3]);break;case"1fv":I.uniform1fv(E,_);break;case"2fv":I.uniform2fv(E,_);break;case"3fv":I.uniform3fv(E,_);break;case"4fv":I.uniform4fv(E,_);break}}}const as=`
    attribute vec2 pos;
    uniform float flip;
    varying vec2 xy;
    void main() {
        xy = (vec2(pos.x, -pos.y) + 1.0) * 0.5;
        gl_Position = vec4(pos.x, pos.y * flip, 0, 1.0);
    }
`,li=`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform sampler2D image;
    void main() {
        gl_FragColor = texture2D(image, xy);
    }
`;class vi extends hi{constructor(p){super(p),this.shaderCtx=null,this.current=null;const _=this.canvas.layers[0];this.shaderCtx=_.getContext("webgl2",{alpha:!0,preserveDrawingBuffer:!0})}async load(){if(this.loaded)return;const{shaderCtx:p,videoSize:_}=this;if(p)return this.shader=new qi(p,_),this.input=new Yi(p,_),super.load()}unload(){var p,_;(p=this.input)==null||p.dispose(),delete this.input,(_=this.shader)==null||_.dispose(),delete this.shader,super.unload()}async update(p,_){if(!this.loaded)return;const{input:E}=this,I=E?.texture();if(!(!E||!I))return E.update(_),this.current=I,super.update(p,_)}updateVideo(p){this.shader&&(this.shader.render([this.current]),super.updateVideo(p))}setupVideo(p,_){var E,I;super.setupVideo(p,_);const{width:Z,height:re}=this.videoSize;this.canvas.layers[0].width=Z,this.canvas.layers[0].height=re,(E=this.input)==null||E.resize({width:Z,height:re}),(I=this.shader)==null||I.resize({width:Z,height:re})}}class Ui extends vi{dispose(){delete this.scene,super.dispose()}}class hs{constructor(){this.loaded=!1,this.ordinal=800}async load(p){this.loaded||(this.renderer=p,this.loaded=!0)}unload(){this.loaded&&(this.loaded=!1)}async update(p,_){this.loaded}dispose(){this.unload()}setupVideo(p){}setupCamera(p,_){}}var Xs=(pe=>(pe[pe.PreProcess=100]="PreProcess",pe[pe.Process=200]="Process",pe[pe.PostProcess=300]="PostProcess",pe[pe.PreRender=700]="PreRender",pe[pe.Render=800]="Render",pe[pe.PostRender=900]="PostRender",pe))(Xs||{});class cr extends null{constructor(){super(),this.ordinal=Xs.PreRender}async load(p){if(!(this.loaded||!(p instanceof ai)||!p.videoCtx))return this.videoCtx=p.videoCtx,super.load(p)}unload(){this.loaded&&(delete this.videoCtx,super.unload())}}var Ks=Object.defineProperty,$s=Object.getOwnPropertySymbols,hr=Object.prototype.hasOwnProperty,rn=Object.prototype.propertyIsEnumerable,Rr=(pe,p,_)=>p in pe?Ks(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,Yr=(pe,p)=>{for(var _ in p||(p={}))hr.call(p,_)&&Rr(pe,_,p[_]);if($s)for(var _ of $s(p))rn.call(p,_)&&Rr(pe,_,p[_]);return pe};class Tn extends null{constructor(p,_,E,I){super(),this.inputs=p,this.uniforms=_,this.fragSrc=E,this.vertSrc=I,this.size={width:0,height:0},this.ordinal=Xs.PreRender}async load(p){if(!(this.loaded||!(p instanceof vi)||!p.shaderCtx))return this.shaderCtx=p.shaderCtx,this.shader=new qi(this.shaderCtx,this.size,this.inputs,this.uniforms,this.fragSrc,this.vertSrc),super.load(p)}unload(){var p;this.loaded&&((p=this.shader)==null||p.dispose(),delete this.shader,delete this.shaderCtx,super.unload())}async update(p,_){var E;const{renderer:I}=this;if(!this.loaded||!(I instanceof vi)||!I.current)return;const Z=await this.process(p,I.current)&&((E=this.shader)==null?void 0:E.output());Z&&(I.current=Z)}async process(p,_){var E;return(E=this.shader)==null||E.process([_]),!0}setupVideo(p){var _;this.size=Yr({},p),(_=this.shader)==null||_.resize(p)}}class Mn extends hs{constructor(){super(),this.ordinal=Xs.Render}async load(p){if(!(this.loaded||!(p instanceof Ui)||!p.scene))return this.scene=p.scene,super.load(p)}unload(){this.loaded&&(delete this.scene,super.unload())}}class Un{constructor(p,_=!1,E="video",I){this.renderer=p,this.mirror=_,this.sizeMode=E,this.sizeMax=I}async snapshot(){return new Promise(p=>{this.renderer.once("render",()=>{const{renderer:_}=this,{layers:E}=_.canvas;let{width:I,height:Z}=_.canvas.layers[0];this.sizeMode==="max"?(I=Math.max(...E.map(_e=>_e.width)),Z=Math.max(...E.map(_e=>_e.height))):this.sizeMode==="min"&&(I=Math.min(...E.map(_e=>_e.width)),Z=Math.min(...E.map(_e=>_e.height)));const re=document.createElement("canvas");re.id="engeenee.snapshot",re.hidden=!0,re.width=I,re.height=Z;const ae=re.getContext("2d",{alpha:!0});if(!ae)return;this.mirror&&(ae.translate(I,0),ae.scale(-1,1)),E.forEach(_e=>ae.drawImage(_e,0,0,I,Z));const he=ae.getImageData(0,0,I,Z);re.remove(),p(he)})})}async snapshotLayers(){return new Promise(p=>{this.renderer.once("render",()=>{const _=document.createElement("canvas");_.id="engeenee.snapshot",_.hidden=!0;const E=_.getContext("2d",{alpha:!0});if(!E)return;const I=this.renderer.canvas.layers.map(Z=>{const{width:re,height:ae}=Z;return _.width=re,_.height=ae,E.resetTransform(),this.mirror&&(E.translate(re,0),E.scale(-1,1)),E.drawImage(Z,0,0),E.getImageData(0,0,re,ae)});_.remove(),p(I)})})}}class qn{constructor(p,_="video/webm",E=!1,I="video",Z,re){this.renderer=p,this.type=_,this.mirror=E,this.sizeMode=I,this.sizeMax=Z,this.bitRate=re,this.context=null,this.records=[],this.frame=()=>{var ae;const{renderer:he,context:_e,stream:ve}=this,{width:Le,height:ze}=this.canvas;!ve||!_e||(he.canvas.layers.map(He=>_e.drawImage(He,0,0,Le,ze)),(ae=ve.getVideoTracks()[0])==null||ae.requestFrame())},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:p,context:_,renderer:E}=this;if(!p||!_)return!1;const{layers:I}=E.canvas;let{width:Z,height:re}=I[0];this.sizeMode==="max"?(Z=Math.max(...I.map(he=>he.width)),re=Math.max(...I.map(he=>he.height))):this.sizeMode==="min"&&(Z=Math.min(...I.map(he=>he.width)),re=Math.min(...I.map(he=>he.height)));const ae=Math.max(Z,re);if(this.sizeMax&&ae>this.sizeMax){const he=this.sizeMax/ae;Z*=he,re*=he}return p.width=Z,p.height=re,_.resetTransform(),this.mirror&&(_.translate(Z,0),_.scale(-1,1)),E.on("render",this.frame),this.records=[],this.stream=p.captureStream(0),this.recorder=new MediaRecorder(this.stream,{mimeType:this.type,videoBitsPerSecond:this.bitRate}),this.recorder.ondataavailable=he=>this.records.push(he.data),this.recorder.start(),!0}async stop(){const{recorder:p}=this;if(!(!p||p.state!="recording"))return new Promise(_=>{p.onstop=()=>{var E;_(new Blob(this.records,{type:this.type})),this.records=[],(E=this.stream)==null||E.getVideoTracks().forEach(I=>I.stop()),this.renderer.removeListener("render",this.frame),delete this.stream,delete this.recorder},p.stop()})}dispose(){this.canvas.remove()}}class $n{constructor(p,_=0,E="video/webm",I){this.renderer=p,this.layer=_,this.type=E,this.bitRate=I,this.records=[]}start(){const{renderer:p}=this,_=p.canvas.layers[this.layer];return this.records=[],this.stream=_.captureStream(),this.recorder=new MediaRecorder(this.stream,{mimeType:this.type,videoBitsPerSecond:this.bitRate}),this.recorder.ondataavailable=E=>this.records.push(E.data),this.recorder.start(),!0}async stop(){const{recorder:p}=this;if(!(!p||p.state!="recording"))return new Promise(_=>{p.onstop=()=>{var E;_(new Blob(this.records,{type:this.type})),this.records=[],(E=this.stream)==null||E.getVideoTracks().forEach(I=>I.stop()),delete this.stream,delete this.recorder},p.stop()})}}class cs{constructor(p,_=!1,E="video",I){this.renderer=p,this.mirror=_,this.sizeMode=E,this.sizeMax=I,this.context=null,this.render=()=>{const{canvas:Z,context:re}=this;!Z||!re||this.renderer.canvas.layers.map(ae=>re.drawImage(ae,0,0,Z.width,Z.height))},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.mirror&&(this.canvas.style.transform="scaleX(-1)"),this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:p,context:_,renderer:E}=this;if(!p||!_)return!1;const{layers:I}=E.canvas;let{width:Z,height:re}=I[0];this.sizeMode==="max"?(Z=Math.max(...I.map(he=>he.width)),re=Math.max(...I.map(he=>he.height))):this.sizeMode==="min"&&(Z=Math.min(...I.map(he=>he.width)),re=Math.min(...I.map(he=>he.height)));const ae=Math.max(Z,re);if(this.sizeMax&&ae>this.sizeMax){const he=this.sizeMax/ae;Z*=he,re*=he}return p.width=Z,p.height=re,_.resetTransform(),this.mirror&&(_.translate(Z,0),_.scale(-1,1)),this.renderer.on("render",this.render),this.stream=p.captureStream(),!0}pause(){this.renderer.removeListener("render",this.render)}mediaStream(){return this.stream}}class a0 extends null{constructor(){super(...arguments),this.faceTracker=new g,this.cameraAngleBase=10/180*Math.PI}async init(p,_,E){return await this.faceTracker.init(p.token,p.root,p.cache,p.highP,p.mask,p.maskExt,p.maskSize),await this.faceTracker.prepare(),super.init(p,_,E)}reset(){this.faceTracker.reset(),super.reset()}dispose(){this.faceTracker.dispose()}async process(p,_){return{faces:(await this.faceTracker.process(p,_)).map(E=>{const{keypoints:I,mask:Z,score:re}=E,ae=E&&this.params.transform?this.faceTracker.align(E.keypoints):void 0,he=ae&&this.params.metric?this.faceTracker.metricPoints():void 0,_e=ae&&this.params.backproj?this.faceTracker.backprojPoints():void 0;return{pixel:I,metric:he,backproj:_e,transform:ae,mask:Z,score:re}})}}setupVideo(p,_){super.setupVideo(p,_),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.faceTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.faceTracker.reset()}}class ux extends null{constructor(p,_=s){super(a0,p,_)}}class Yx extends null{constructor(){super(),this.poseTracker=new o,this.cameraAngleBase=15/180*Math.PI;const p=/iPhone|iPad|iPod/i.test(navigator.userAgent);this.optimalSize=p?512:1024}async init(p,_,E){return await this.poseTracker.init(p.token,p.root,p.cache,p.mask),await this.poseTracker.prepare(),super.init(p,_,E)}reset(){return this.poseTracker.reset(),super.reset()}dispose(){this.poseTracker.dispose()}async process(p,_){return{poses:(await this.poseTracker.process(p,_)).map(E=>({points:xn(I=>E.keypoints[Kx[I]]),score:E.score,mask:E.mask,timestamp:_,debug:E.debug}))}}setupVideo(p,_){super.setupVideo(p,_),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.poseTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.poseTracker.reset()}}class ka extends null{constructor(p,_=s){super(Yx,p,_)}}const cn=["nose","eyeInnerL","eyeL","eyeOutterL","eyeInnerR","eyeR","eyeOutterR","earL","earR","mouthL","mouthR","shoulderL","shoulderR","elbowL","elbowR","wristL","wristR","pinkyL","pinkyR","indexL","indexR","thumbL","thumbR","hipL","hipR","kneeL","kneeR","ankleL","ankleR","heelL","heelR","footIndexL","footIndexR"];function Kr(pe,p){return Object.fromEntries(p.map(_=>[_,pe(_)]))}const px=(pe,p)=>Kr(pe,p),xn=pe=>Kr(pe,cn),Kx=xn(pe=>cn.indexOf(pe));class l0 extends je{constructor(){super(...arguments),this.handTracker=new W.F$,this.cameraAngleBase=10/180*Math.PI}async init(p,_,E){return await this.handTracker.init(p.token,p.root,p.cache),await this.handTracker.prepare(),super.init(p,_,E)}reset(){this.handTracker.reset(),super.reset()}dispose(){this.handTracker.dispose()}async process(p,_){return{hands:(await this.handTracker.process(p,_)).map(E=>({points:E.keypoints,score:E.score,handedness:E.handedness,wrist:E.wrist}))}}setupVideo(p,_){super.setupVideo(p,_),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.handTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.handTracker.reset()}}class h0 extends we{constructor(p,_=Re){super(l0,p,_)}}class wl extends null{constructor(){super(...arguments),this.maskTracker=new Q}async init(p,_,E){return await this.maskTracker.init(p.token,p.root,p.cache,p.smooth,p.masksm),await this.maskTracker.prepare(),super.init(p,_,E)}reset(){this.maskTracker.reset(),super.reset()}dispose(){this.maskTracker.dispose()}async process(p,_){return{masks:(await this.maskTracker.process(p,_)).map(E=>({mask:E}))}}}class vh extends null{constructor(p,_=s){super(wl,p,_)}}class Xo{constructor(p,_=!1,E,I){this.initialize(p,_,E,I)}initialize(p,_=!1,E,I){return this.mask=p,this.skipNextObservers=_,this.target=E,this.currentTarget=I,this}}class h2{constructor(p,_,E=null){this.callback=p,this.mask=_,this.scope=E,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(){this._remove&&this._remove()}}class Ri{static FromPromise(p,_){const E=new Ri;return p.then(I=>{E.notifyObservers(I)}).catch(I=>{if(_)_.notifyObservers(I);else throw I}),E}get observers(){return this._observers}constructor(p,_=!1){this.notifyIfTriggered=_,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new Xo(0),p&&(this._onObserverAdded=p)}add(p,_=-1,E=!1,I=null,Z=!1){if(!p)return null;const re=new h2(p,_,I);return re.unregisterOnNextCall=Z,E?this._observers.unshift(re):this._observers.push(re),this._onObserverAdded&&this._onObserverAdded(re),this._hasNotified&&this.notifyIfTriggered&&this._lastNotifiedValue!==void 0&&this.notifyObserver(re,this._lastNotifiedValue),re._remove=()=>{this.remove(re)},re}addOnce(p){return this.add(p,void 0,void 0,void 0,!0)}remove(p){return p?(p._remove=null,this._observers.indexOf(p)!==-1?(this._deferUnregister(p),!0):!1):!1}removeCallback(p,_){for(let E=0;E<this._observers.length;E++){const I=this._observers[E];if(!I._willBeUnregistered&&I.callback===p&&(!_||_===I.scope))return this._deferUnregister(I),!0}return!1}_deferUnregister(p){p._willBeUnregistered||(this._numObserversMarkedAsDeleted++,p.unregisterOnNextCall=!1,p._willBeUnregistered=!0,setTimeout(()=>{this._remove(p)},0))}_remove(p,_=!0){if(!p)return!1;const E=this._observers.indexOf(p);return E!==-1?(_&&this._numObserversMarkedAsDeleted--,this._observers.splice(E,1),!0):!1}makeObserverTopPriority(p){this._remove(p,!1),this._observers.unshift(p)}makeObserverBottomPriority(p){this._remove(p,!1),this._observers.push(p)}notifyObservers(p,_=-1,E,I,Z){if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=p),!this._observers.length)return!0;const re=this._eventState;re.mask=_,re.target=E,re.currentTarget=I,re.skipNextObservers=!1,re.lastReturnValue=p,re.userInfo=Z;for(const ae of this._observers)if(!ae._willBeUnregistered&&(ae.mask&_&&(ae.unregisterOnNextCall&&this._deferUnregister(ae),ae.scope?re.lastReturnValue=ae.callback.apply(ae.scope,[p,re]):re.lastReturnValue=ae.callback(p,re)),re.skipNextObservers))return!1;return!0}notifyObserver(p,_,E=-1){if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=_),p._willBeUnregistered)return;const I=this._eventState;I.mask=E,I.skipNextObservers=!1,p.unregisterOnNextCall&&this._deferUnregister(p),p.callback(_,I)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const p=this._observers.pop();p&&(p._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const p=new Ri;return p._observers=this._observers.slice(0),p}hasSpecificMask(p=-1){for(const _ of this._observers)if(_.mask&p||_.mask===p)return!0;return!1}}class Rh{get wrapU(){return this._cachedWrapU}set wrapU(p){this._cachedWrapU=p}get wrapV(){return this._cachedWrapV}set wrapV(p){this._cachedWrapV=p}get wrapR(){return this._cachedWrapR}set wrapR(p){this._cachedWrapR=p}get anisotropicFilteringLevel(){return this._cachedAnisotropicFilteringLevel}set anisotropicFilteringLevel(p){this._cachedAnisotropicFilteringLevel=p}get comparisonFunction(){return this._comparisonFunction}set comparisonFunction(p){this._comparisonFunction=p}get useMipMaps(){return this._useMipMaps}set useMipMaps(p){this._useMipMaps=p}constructor(){this.samplingMode=-1,this._useMipMaps=!0,this._cachedWrapU=null,this._cachedWrapV=null,this._cachedWrapR=null,this._cachedAnisotropicFilteringLevel=null,this._comparisonFunction=0}setParameters(p=1,_=1,E=1,I=1,Z=2,re=0){return this._cachedWrapU=p,this._cachedWrapV=_,this._cachedWrapR=E,this._cachedAnisotropicFilteringLevel=I,this.samplingMode=Z,this._comparisonFunction=re,this}compareSampler(p){return this._cachedWrapU===p._cachedWrapU&&this._cachedWrapV===p._cachedWrapV&&this._cachedWrapR===p._cachedWrapR&&this._cachedAnisotropicFilteringLevel===p._cachedAnisotropicFilteringLevel&&this.samplingMode===p.samplingMode&&this._comparisonFunction===p._comparisonFunction&&this._useMipMaps===p._useMipMaps}}var kn;(function(pe){pe[pe.Unknown=0]="Unknown",pe[pe.Url=1]="Url",pe[pe.Temp=2]="Temp",pe[pe.Raw=3]="Raw",pe[pe.Dynamic=4]="Dynamic",pe[pe.RenderTarget=5]="RenderTarget",pe[pe.MultiRenderTarget=6]="MultiRenderTarget",pe[pe.Cube=7]="Cube",pe[pe.CubeRaw=8]="CubeRaw",pe[pe.CubePrefiltered=9]="CubePrefiltered",pe[pe.Raw3D=10]="Raw3D",pe[pe.Raw2DArray=11]="Raw2DArray",pe[pe.DepthStencil=12]="DepthStencil",pe[pe.CubeRawRGBD=13]="CubeRawRGBD",pe[pe.Depth=14]="Depth"})(kn||(kn={}));class c0 extends Rh{get useMipMaps(){return this.generateMipMaps}set useMipMaps(p){this.generateMipMaps=p}get uniqueId(){return this._uniqueId}_setUniqueId(p){this._uniqueId=p}getEngine(){return this._engine}get source(){return this._source}constructor(p,_,E=!1){super(),this.isReady=!1,this.isCube=!1,this.is3D=!1,this.is2DArray=!1,this.isMultiview=!1,this.url="",this.generateMipMaps=!1,this.samples=0,this.type=-1,this.format=-1,this.onLoadedObservable=new Ri,this.onErrorObservable=new Ri,this.onRebuildCallback=null,this.width=0,this.height=0,this.depth=0,this.baseWidth=0,this.baseHeight=0,this.baseDepth=0,this.invertY=!1,this._invertVScale=!1,this._associatedChannel=-1,this._source=kn.Unknown,this._buffer=null,this._bufferView=null,this._bufferViewArray=null,this._bufferViewArrayArray=null,this._size=0,this._extension="",this._files=null,this._workingCanvas=null,this._workingContext=null,this._cachedCoordinatesMode=null,this._isDisabled=!1,this._compression=null,this._sphericalPolynomial=null,this._sphericalPolynomialPromise=null,this._sphericalPolynomialComputed=!1,this._lodGenerationScale=0,this._lodGenerationOffset=0,this._useSRGBBuffer=!1,this._creationFlags=0,this._lodTextureHigh=null,this._lodTextureMid=null,this._lodTextureLow=null,this._isRGBD=!1,this._linearSpecularLOD=!1,this._irradianceTexture=null,this._hardwareTexture=null,this._maxLodLevel=null,this._references=1,this._gammaSpace=null,this._premulAlpha=!1,this._dynamicTextureSource=null,this._engine=p,this._source=_,this._uniqueId=c0._Counter++,E||(this._hardwareTexture=p._createHardwareTexture())}incrementReferences(){this._references++}updateSize(p,_,E=1){this._engine.updateTextureDimensions(this,p,_,E),this.width=p,this.height=_,this.depth=E,this.baseWidth=p,this.baseHeight=_,this.baseDepth=E,this._size=p*_*E}_rebuild(){if(this.isReady=!1,this._cachedCoordinatesMode=null,this._cachedWrapU=null,this._cachedWrapV=null,this._cachedWrapR=null,this._cachedAnisotropicFilteringLevel=null,this.onRebuildCallback){const _=this.onRebuildCallback(this),E=I=>{I._swapAndDie(this,!1),this.isReady=_.isReady};_.isAsync?_.proxy.then(E):E(_.proxy);return}let p;switch(this.source){case kn.Temp:break;case kn.Url:p=this._engine.createTexture(this._originalUrl??this.url,!this.generateMipMaps,this.invertY,null,this.samplingMode,_=>{_._swapAndDie(this,!1),this.isReady=!0},null,this._buffer,void 0,this.format,this._extension,void 0,void 0,void 0,this._useSRGBBuffer);return;case kn.Raw:p=this._engine.createRawTexture(this._bufferView,this.baseWidth,this.baseHeight,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type,this._creationFlags,this._useSRGBBuffer),p._swapAndDie(this,!1),this.isReady=!0;break;case kn.Raw3D:p=this._engine.createRawTexture3D(this._bufferView,this.baseWidth,this.baseHeight,this.baseDepth,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type),p._swapAndDie(this,!1),this.isReady=!0;break;case kn.Raw2DArray:p=this._engine.createRawTexture2DArray(this._bufferView,this.baseWidth,this.baseHeight,this.baseDepth,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type),p._swapAndDie(this,!1),this.isReady=!0;break;case kn.Dynamic:p=this._engine.createDynamicTexture(this.baseWidth,this.baseHeight,this.generateMipMaps,this.samplingMode),p._swapAndDie(this,!1),this._dynamicTextureSource&&this._engine.updateDynamicTexture(this,this._dynamicTextureSource,this.invertY,this._premulAlpha,this.format,!0);break;case kn.Cube:p=this._engine.createCubeTexture(this.url,null,this._files,!this.generateMipMaps,()=>{p._swapAndDie(this,!1),this.isReady=!0},null,this.format,this._extension,!1,0,0,null,void 0,this._useSRGBBuffer);return;case kn.CubeRaw:p=this._engine.createRawCubeTexture(this._bufferViewArray,this.width,this._originalFormat??this.format,this.type,this.generateMipMaps,this.invertY,this.samplingMode,this._compression),p._swapAndDie(this,!1),this.isReady=!0;break;case kn.CubeRawRGBD:return;case kn.CubePrefiltered:p=this._engine.createPrefilteredCubeTexture(this.url,null,this._lodGenerationScale,this._lodGenerationOffset,_=>{_&&_._swapAndDie(this,!1),this.isReady=!0},null,this.format,this._extension),p._sphericalPolynomial=this._sphericalPolynomial;return;case kn.DepthStencil:case kn.Depth:break}}_swapAndDie(p,_=!0){this._hardwareTexture?.setUsage(p._source,this.generateMipMaps,this.is2DArray,this.isCube,this.is3D,this.width,this.height,this.depth),p._hardwareTexture=this._hardwareTexture,_&&(p._isRGBD=this._isRGBD),this._lodTextureHigh&&(p._lodTextureHigh&&p._lodTextureHigh.dispose(),p._lodTextureHigh=this._lodTextureHigh),this._lodTextureMid&&(p._lodTextureMid&&p._lodTextureMid.dispose(),p._lodTextureMid=this._lodTextureMid),this._lodTextureLow&&(p._lodTextureLow&&p._lodTextureLow.dispose(),p._lodTextureLow=this._lodTextureLow),this._irradianceTexture&&(p._irradianceTexture&&p._irradianceTexture.dispose(),p._irradianceTexture=this._irradianceTexture);const E=this._engine.getLoadedTexturesCache();let I=E.indexOf(this);I!==-1&&E.splice(I,1),I=E.indexOf(p),I===-1&&E.push(p)}dispose(){this._references--,this.onLoadedObservable.clear(),this.onErrorObservable.clear(),this._references===0&&(this._engine._releaseTexture(this),this._hardwareTexture=null,this._dynamicTextureSource=null)}}c0._Counter=0;function va(){return typeof window<"u"}function Ux(){return typeof navigator<"u"}function no(){return typeof document<"u"}function H0(pe){let p="",_=pe.firstChild;for(;_;)_.nodeType===3&&(p+=_.textContent),_=_.nextSibling;return p}const j2={IsWindowObjectExist:va,IsNavigatorAvailable:Ux,IsDocumentAvailable:no,GetDOMTextContent:H0};class Mr{static get LastCreatedEngine(){return this.Instances.length===0?null:this.Instances[this.Instances.length-1]}static get LastCreatedScene(){return this._LastCreatedScene}}Mr.Instances=[],Mr.OnEnginesDisposedObservable=new Ri,Mr._LastCreatedScene=null,Mr.UseFallbackTexture=!0,Mr.FallbackTexture="";const Yo={};function ur(pe,p=!1){if(!(p&&Yo[pe]))return Yo[pe]=!0,`${pe} needs to be imported before as it contains a side-effect required by your code.`}class Ti{static _CheckLimit(p,_){let E=Ti._LogLimitOutputs[p];return E?E.current++:(E={limit:_,current:1},Ti._LogLimitOutputs[p]=E),E.current<=E.limit}static _GenerateLimitMessage(p,_=1){const E=Ti._LogLimitOutputs[p];if(!E||!Ti.MessageLimitReached)return;const I=this._Levels[_];E.current===E.limit&&Ti[I.name](Ti.MessageLimitReached.replace(/%LIMIT%/g,""+E.limit).replace(/%TYPE%/g,I.name??""))}static _AddLogEntry(p){Ti._LogCache=p+Ti._LogCache,Ti.OnNewCacheEntry&&Ti.OnNewCacheEntry(p)}static _FormatMessage(p){const _=I=>I<10?"0"+I:""+I,E=new Date;return"["+_(E.getHours())+":"+_(E.getMinutes())+":"+_(E.getSeconds())+"]: "+p}static _LogDisabled(p,_){}static _LogEnabled(p=1,_,E){const I=Array.isArray(_)?_[0]:_;if(E!==void 0&&!Ti._CheckLimit(I,E))return;const Z=Ti._FormatMessage(I),re=this._Levels[p],ae=Array.isArray(_)?_.slice(1):[];re.logFunc&&re.logFunc("BJS - "+Z,...ae);const he=`<div style='color:${re.color}'>${Z}</div><br>`;Ti._AddLogEntry(he),Ti._GenerateLimitMessage(I,p)}static get LogCache(){return Ti._LogCache}static ClearLogCache(){Ti._LogCache="",Ti._LogLimitOutputs={},Ti.errorsCount=0}static set LogLevels(p){Ti.Log=Ti._LogDisabled,Ti.Warn=Ti._LogDisabled,Ti.Error=Ti._LogDisabled,[Ti.MessageLogLevel,Ti.WarningLogLevel,Ti.ErrorLogLevel].forEach(_=>{if((p&_)===_){const E=this._Levels[_];Ti[E.name]=Ti._LogEnabled.bind(Ti,_)}})}}Ti.NoneLogLevel=0,Ti.MessageLogLevel=1,Ti.WarningLogLevel=2,Ti.ErrorLogLevel=4,Ti.AllLogLevel=7,Ti.MessageLimitReached="Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.",Ti._LogCache="",Ti._LogLimitOutputs={},Ti._Levels=[{},{color:"white",logFunc:console.log,name:"Log"},{color:"orange",logFunc:console.warn,name:"Warn"},{},{color:"red",logFunc:console.error,name:"Error"}],Ti.errorsCount=0,Ti.Log=Ti._LogEnabled.bind(Ti,Ti.MessageLogLevel),Ti.Warn=Ti._LogEnabled.bind(Ti,Ti.WarningLogLevel),Ti.Error=Ti._LogEnabled.bind(Ti,Ti.ErrorLogLevel);const q2="attribute",xc="varying";class X0{constructor(){this.children=[]}isValid(p){return!0}process(p,_){let E="";if(this.line){let I=this.line;const Z=_.processor;if(Z){Z.lineProcessor&&(I=Z.lineProcessor(I,_.isFragment,_.processingContext));const re=_.processor?.attributeKeywordName??q2,ae=_.isFragment&&_.processor?.varyingFragmentKeywordName?_.processor?.varyingFragmentKeywordName:!_.isFragment&&_.processor?.varyingVertexKeywordName?_.processor?.varyingVertexKeywordName:xc;!_.isFragment&&Z.attributeProcessor&&this.line.startsWith(re)?I=Z.attributeProcessor(this.line,p,_.processingContext):Z.varyingProcessor&&(Z.varyingCheck?.(this.line,_.isFragment)||!Z.varyingCheck&&this.line.startsWith(ae))?I=Z.varyingProcessor(this.line,_.isFragment,p,_.processingContext):Z.uniformProcessor&&Z.uniformRegexp&&Z.uniformRegexp.test(this.line)?_.lookForClosingBracketForUniformBuffer||(I=Z.uniformProcessor(this.line,_.isFragment,p,_.processingContext)):Z.uniformBufferProcessor&&Z.uniformBufferRegexp&&Z.uniformBufferRegexp.test(this.line)?_.lookForClosingBracketForUniformBuffer||(I=Z.uniformBufferProcessor(this.line,_.isFragment,_.processingContext),_.lookForClosingBracketForUniformBuffer=!0):Z.textureProcessor&&Z.textureRegexp&&Z.textureRegexp.test(this.line)?I=Z.textureProcessor(this.line,_.isFragment,p,_.processingContext):(Z.uniformProcessor||Z.uniformBufferProcessor)&&this.line.startsWith("uniform")&&!_.lookForClosingBracketForUniformBuffer&&(/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line)?Z.uniformProcessor&&(I=Z.uniformProcessor(this.line,_.isFragment,p,_.processingContext)):Z.uniformBufferProcessor&&(I=Z.uniformBufferProcessor(this.line,_.isFragment,_.processingContext),_.lookForClosingBracketForUniformBuffer=!0)),_.lookForClosingBracketForUniformBuffer&&this.line.indexOf("}")!==-1&&(_.lookForClosingBracketForUniformBuffer=!1,Z.endOfUniformBufferProcessor&&(I=Z.endOfUniformBufferProcessor(this.line,_.isFragment,_.processingContext)))}E+=I+`
`}return this.children.forEach(I=>{E+=I.process(p,_)}),this.additionalDefineKey&&(p[this.additionalDefineKey]=this.additionalDefineValue||"true"),E}}class lc{constructor(){this._lines=[]}get currentLine(){return this._lines[this.lineIndex]}get canRead(){return this.lineIndex<this._lines.length-1}set lines(p){this._lines.length=0;for(const _ of p){if(!_||_==="\r")continue;if(_[0]==="#"){this._lines.push(_);continue}const E=_.trim();if(!E)continue;if(E.startsWith("//")){this._lines.push(_);continue}const I=E.indexOf(";");if(I===-1)this._lines.push(E);else if(I===E.length-1)E.length>1&&this._lines.push(E);else{const Z=_.split(";");for(let re=0;re<Z.length;re++){let ae=Z[re];ae&&(ae=ae.trim(),ae&&this._lines.push(ae+(re!==Z.length-1?";":"")))}}}}}class K0 extends X0{process(p,_){for(let E=0;E<this.children.length;E++){const I=this.children[E];if(I.isValid(p))return I.process(p,_)}return""}}class Ll extends X0{isValid(p){return this.testExpression.isTrue(p)}}class Gn{isTrue(p){return!0}static postfixToInfix(p){const _=[];for(const E of p)if(Gn._OperatorPriority[E]===void 0)_.push(E);else{const I=_[_.length-1],Z=_[_.length-2];_.length-=2,_.push(`(${Z}${E}${I})`)}return _[_.length-1]}static infixToPostfix(p){const _=Gn._InfixToPostfixCache.get(p);if(_)return _.accessTime=Date.now(),_.result;if(!p.includes("&&")&&!p.includes("||")&&!p.includes(")")&&!p.includes("("))return[p];const E=[];let I=-1;const Z=()=>{ve=ve.trim(),ve!==""&&(E.push(ve),ve="")},re=Le=>{I<Gn._Stack.length-1&&(Gn._Stack[++I]=Le)},ae=()=>Gn._Stack[I],he=()=>I===-1?"!!INVALID EXPRESSION!!":Gn._Stack[I--];let _e=0,ve="";for(;_e<p.length;){const Le=p.charAt(_e),ze=_e<p.length-1?p.substr(_e,2):"";if(Le==="(")ve="",re(Le);else if(Le===")"){for(Z();I!==-1&&ae()!=="(";)E.push(he());he()}else if(Gn._OperatorPriority[ze]>1){for(Z();I!==-1&&Gn._OperatorPriority[ae()]>=Gn._OperatorPriority[ze];)E.push(he());re(ze),_e++}else ve+=Le;_e++}for(Z();I!==-1;)ae()==="("?he():E.push(he());return Gn._InfixToPostfixCache.size>=Gn.InfixToPostfixCacheLimitSize&&Gn.ClearCache(),Gn._InfixToPostfixCache.set(p,{result:E,accessTime:Date.now()}),E}static ClearCache(){const p=Array.from(Gn._InfixToPostfixCache.entries()).sort((_,E)=>_[1].accessTime-E[1].accessTime);for(let _=0;_<Gn.InfixToPostfixCacheCleanupSize;_++)Gn._InfixToPostfixCache.delete(p[_][0])}}Gn.InfixToPostfixCacheLimitSize=5e4,Gn.InfixToPostfixCacheCleanupSize=25e3,Gn._InfixToPostfixCache=new Map,Gn._OperatorPriority={")":0,"(":1,"||":2,"&&":3},Gn._Stack=["","","","","","","","","","","","","","","","","","","",""];class ao extends Gn{constructor(p,_=!1){super(),this.define=p,this.not=_}isTrue(p){let _=p[this.define]!==void 0;return this.not&&(_=!_),_}}class kl extends Gn{isTrue(p){return this.leftOperand.isTrue(p)||this.rightOperand.isTrue(p)}}class hc extends Gn{isTrue(p){return this.leftOperand.isTrue(p)&&this.rightOperand.isTrue(p)}}class cc extends Gn{constructor(p,_,E){super(),this.define=p,this.operand=_,this.testValue=E}isTrue(p){let _=p[this.define];_===void 0&&(_=this.define);let E=!1;const I=parseInt(_),Z=parseInt(this.testValue);switch(this.operand){case">":E=I>Z;break;case"<":E=I<Z;break;case"<=":E=I<=Z;break;case">=":E=I>=Z;break;case"==":E=I===Z;break;case"!=":E=I!==Z;break}return E}}var Wa;(function(pe){pe[pe.GLSL=0]="GLSL",pe[pe.WGSL=1]="WGSL"})(Wa||(Wa={}));const $2=/defined\s*?\((.+?)\)/g,Ul=/defined\s*?\[(.+?)\]/g,Ro=/#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,uc=/__decl__/,Mh=/light\{X\}.(\w*)/g,c2=/\{X\}/g,Mo=[];class xx{static Initialize(p){p.processor&&p.processor.initializeShaders&&p.processor.initializeShaders(p.processingContext)}static Process(p,_,E,I){_.processor?.preProcessShaderCode&&(p=_.processor.preProcessShaderCode(p,_.isFragment)),this._ProcessIncludes(p,_,Z=>{_.processCodeAfterIncludes&&(Z=_.processCodeAfterIncludes(_.isFragment?"fragment":"vertex",Z));const re=this._ProcessShaderConversion(Z,_,I);E(re,Z)})}static PreProcess(p,_,E,I){_.processor?.preProcessShaderCode&&(p=_.processor.preProcessShaderCode(p,_.isFragment)),this._ProcessIncludes(p,_,Z=>{_.processCodeAfterIncludes&&(Z=_.processCodeAfterIncludes(_.isFragment?"fragment":"vertex",Z));const re=this._ApplyPreProcessing(Z,_,I);E(re,Z)})}static Finalize(p,_,E){return!E.processor||!E.processor.finalizeShaders?{vertexCode:p,fragmentCode:_}:E.processor.finalizeShaders(p,_,E.processingContext)}static _ProcessPrecision(p,_){if(_.processor?.noPrecision)return p;const E=_.shouldUseHighPrecisionShader;return p.indexOf("precision highp float")===-1?E?p=`precision highp float;
`+p:p=`precision mediump float;
`+p:E||(p=p.replace("precision highp float","precision mediump float")),p}static _ExtractOperation(p){const E=/defined\((.+)\)/.exec(p);if(E&&E.length)return new ao(E[1].trim(),p[0]==="!");const I=["==","!=",">=","<=","<",">"];let Z="",re=0;for(Z of I)if(re=p.indexOf(Z),re>-1)break;if(re===-1)return new ao(p);const ae=p.substring(0,re).trim(),he=p.substring(re+Z.length).trim();return new cc(ae,Z,he)}static _BuildSubExpression(p){p=p.replace($2,"defined[$1]");const _=Gn.infixToPostfix(p),E=[];for(const Z of _)if(Z!=="||"&&Z!=="&&")E.push(Z);else if(E.length>=2){let re=E[E.length-1],ae=E[E.length-2];E.length-=2;const he=Z=="&&"?new hc:new kl;typeof re=="string"&&(re=re.replace(Ul,"defined($1)")),typeof ae=="string"&&(ae=ae.replace(Ul,"defined($1)")),he.leftOperand=typeof ae=="string"?this._ExtractOperation(ae):ae,he.rightOperand=typeof re=="string"?this._ExtractOperation(re):re,E.push(he)}let I=E[E.length-1];return typeof I=="string"&&(I=I.replace(Ul,"defined($1)")),typeof I=="string"?this._ExtractOperation(I):I}static _BuildExpression(p,_){const E=new Ll,I=p.substring(0,_);let Z=p.substring(_);return Z=Z.substring(0,(Z.indexOf("//")+1||Z.length+1)-1).trim(),I==="#ifdef"?E.testExpression=new ao(Z):I==="#ifndef"?E.testExpression=new ao(Z,!0):E.testExpression=this._BuildSubExpression(Z),E}static _MoveCursorWithinIf(p,_,E){let I=p.currentLine;for(;this._MoveCursor(p,E);){I=p.currentLine;const Z=I.substring(0,5).toLowerCase();if(Z==="#else"){const re=new X0;_.children.push(re),this._MoveCursor(p,re);return}else if(Z==="#elif"){const re=this._BuildExpression(I,5);_.children.push(re),E=re}}}static _MoveCursor(p,_){for(;p.canRead;){p.lineIndex++;const E=p.currentLine;if(E.indexOf("#")>=0){const Z=xx._MoveCursorRegex.exec(E);if(Z&&Z.length){switch(Z[0]){case"#ifdef":{const ae=new K0;_.children.push(ae);const he=this._BuildExpression(E,6);ae.children.push(he),this._MoveCursorWithinIf(p,ae,he);break}case"#else":case"#elif":return!0;case"#endif":return!1;case"#ifndef":{const ae=new K0;_.children.push(ae);const he=this._BuildExpression(E,7);ae.children.push(he),this._MoveCursorWithinIf(p,ae,he);break}case"#if":{const ae=new K0,he=this._BuildExpression(E,3);_.children.push(ae),ae.children.push(he),this._MoveCursorWithinIf(p,ae,he);break}}continue}}const I=new X0;if(I.line=E,_.children.push(I),E[0]==="#"&&E[1]==="d"){const Z=E.replace(";","").split(" ");I.additionalDefineKey=Z[1],Z.length===3&&(I.additionalDefineValue=Z[2])}}return!1}static _EvaluatePreProcessors(p,_,E){const I=new X0,Z=new lc;return Z.lineIndex=-1,Z.lines=p.split(`
`),this._MoveCursor(Z,I),I.process(_,E)}static _PreparePreProcessors(p,_){const E=p.defines,I={};for(const Z of E){const ae=Z.replace("#define","").replace(";","").trim().split(" ");I[ae[0]]=ae.length>1?ae[1]:""}return p.processor?.shaderLanguage===Wa.GLSL&&(I.GL_ES="true"),I.__VERSION__=p.version,I[p.platformName]="true",_._getGlobalDefines(I),I}static _ProcessShaderConversion(p,_,E){let I=this._ProcessPrecision(p,_);if(!_.processor||_.processor.shaderLanguage===Wa.GLSL&&I.indexOf("#version 3")!==-1&&(I=I.replace("#version 300 es",""),!_.processor.parseGLES3))return I;const Z=_.defines,re=this._PreparePreProcessors(_,E);return _.processor.preProcessor&&(I=_.processor.preProcessor(I,Z,_.isFragment,_.processingContext)),I=this._EvaluatePreProcessors(I,re,_),_.processor.postProcessor&&(I=_.processor.postProcessor(I,Z,_.isFragment,_.processingContext,E)),E._features.needShaderCodeInlining&&(I=E.inlineShaderCode(I)),I}static _ApplyPreProcessing(p,_,E){let I=p;const Z=_.defines,re=this._PreparePreProcessors(_,E);return _.processor?.preProcessor&&(I=_.processor.preProcessor(I,Z,_.isFragment,_.processingContext)),I=this._EvaluatePreProcessors(I,re,_),_.processor?.postProcessor&&(I=_.processor.postProcessor(I,Z,_.isFragment,_.processingContext,E)),E._features.needShaderCodeInlining&&(I=E.inlineShaderCode(I)),I}static _ProcessIncludes(p,_,E){Mo.length=0;let I;for(;(I=Ro.exec(p))!==null;)Mo.push(I);let Z=String(p),re=[p],ae=!1;for(const he of Mo){let _e=he[1];if(_e.indexOf("__decl__")!==-1&&(_e=_e.replace(uc,""),_.supportsUniformBuffers&&(_e=_e.replace("Vertex","Ubo").replace("Fragment","Ubo")),_e=_e+"Declaration"),_.includesShadersStore[_e]){let ve=_.includesShadersStore[_e];if(he[2]){const ze=he[3].split(",");for(let He=0;He<ze.length;He+=2){const xt=new RegExp(ze[He],"g"),rt=ze[He+1];ve=ve.replace(xt,rt)}}if(he[4]){const ze=he[5];if(ze.indexOf("..")!==-1){const He=ze.split(".."),xt=parseInt(He[0]);let rt=parseInt(He[1]),Tt=ve.slice(0);ve="",isNaN(rt)&&(rt=_.indexParameters[He[1]]);for(let Lt=xt;Lt<rt;Lt++)_.supportsUniformBuffers||(Tt=Tt.replace(Mh,(Nt,qt)=>qt+"{X}")),ve+=Tt.replace(c2,Lt.toString())+`
`}else _.supportsUniformBuffers||(ve=ve.replace(Mh,(He,xt)=>xt+"{X}")),ve=ve.replace(c2,ze)}const Le=[];for(const ze of re){const He=ze.split(he[0]);for(let xt=0;xt<He.length-1;xt++)Le.push(He[xt]),Le.push(ve);Le.push(He[He.length-1])}re=Le,ae=ae||ve.indexOf("#include<")>=0||ve.indexOf("#include <")>=0}else{const ve=_.shadersRepository+"ShadersInclude/"+_e+".fx";xx._FileToolsLoadFile(ve,Le=>{_.includesShadersStore[_e]=Le,this._ProcessIncludes(re.join(""),_,E)});return}}Mo.length=0,Z=re.join(""),ae?this._ProcessIncludes(Z.toString(),_,E):E(Z)}static _FileToolsLoadFile(p,_,E,I,Z,re){throw ur("FileTools")}}xx._MoveCursorRegex=/(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;class ji{static GetShadersRepository(p=Wa.GLSL){return p===Wa.GLSL?ji.ShadersRepository:ji.ShadersRepositoryWGSL}static GetShadersStore(p=Wa.GLSL){return p===Wa.GLSL?ji.ShadersStore:ji.ShadersStoreWGSL}static GetIncludesShadersStore(p=Wa.GLSL){return p===Wa.GLSL?ji.IncludesShadersStore:ji.IncludesShadersStoreWGSL}}ji.ShadersRepository="src/Shaders/",ji.ShadersStore={},ji.IncludesShadersStore={},ji.ShadersRepositoryWGSL="src/ShadersWGSL/",ji.ShadersStoreWGSL={},ji.IncludesShadersStoreWGSL={};class _a{static get ShadersRepository(){return ji.ShadersRepository}static set ShadersRepository(p){ji.ShadersRepository=p}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new Ri),this._onBindObservable}get shaderLanguage(){return this._shaderLanguage}constructor(p,_,E,I=null,Z,re=null,ae=null,he=null,_e=null,ve,Le="",ze=Wa.GLSL){if(this.name=null,this.defines="",this.onCompiled=null,this.onError=null,this.onBind=null,this.uniqueId=0,this.onCompileObservable=new Ri,this.onErrorObservable=new Ri,this._onBindObservable=null,this._isDisposed=!1,this._bonesComputationForcedToCPU=!1,this._uniformBuffersNames={},this._multiTarget=!1,this._samplers={},this._isReady=!1,this._compilationError="",this._allFallbacksProcessed=!1,this._uniforms={},this._key="",this._fallbacks=null,this._vertexSourceCodeOverride="",this._fragmentSourceCodeOverride="",this._transformFeedbackVaryings=null,this._pipelineContext=null,this._vertexSourceCode="",this._fragmentSourceCode="",this._vertexSourceCodeBeforeMigration="",this._fragmentSourceCodeBeforeMigration="",this._rawVertexSourceCode="",this._rawFragmentSourceCode="",this._processCodeAfterIncludes=void 0,this._processFinalCode=null,this.name=p,this._key=Le,_.attributes){const He=_;if(this._engine=E,this._attributesNames=He.attributes,this._uniformsNames=He.uniformsNames.concat(He.samplers),this._samplerList=He.samplers.slice(),this.defines=He.defines,this.onError=He.onError,this.onCompiled=He.onCompiled,this._fallbacks=He.fallbacks,this._indexParameters=He.indexParameters,this._transformFeedbackVaryings=He.transformFeedbackVaryings||null,this._multiTarget=!!He.multiTarget,this._shaderLanguage=He.shaderLanguage??Wa.GLSL,He.uniformBuffersNames){this._uniformBuffersNamesList=He.uniformBuffersNames.slice();for(let xt=0;xt<He.uniformBuffersNames.length;xt++)this._uniformBuffersNames[He.uniformBuffersNames[xt]]=xt}this._processFinalCode=He.processFinalCode??null,this._processCodeAfterIncludes=He.processCodeAfterIncludes??void 0}else this._engine=Z,this.defines=re??"",this._uniformsNames=E.concat(I),this._samplerList=I?I.slice():[],this._attributesNames=_,this._uniformBuffersNamesList=[],this._shaderLanguage=ze,this.onError=_e,this.onCompiled=he,this._indexParameters=ve,this._fallbacks=ae;this._attributeLocationByName={},this.uniqueId=_a._UniqueIdSeed++,this._processShaderCode()}_processShaderCode(p=null,_=!1){let E,I;const Z=this.name,re=va()?this._engine.getHostDocument():null;Z.vertexSource?E="source:"+Z.vertexSource:Z.vertexElement?(E=re?re.getElementById(Z.vertexElement):null,E||(E=Z.vertexElement)):E=Z.vertex||Z,Z.fragmentSource?I="source:"+Z.fragmentSource:Z.fragmentElement?(I=re?re.getElementById(Z.fragmentElement):null,I||(I=Z.fragmentElement)):I=Z.fragment||Z,this._processingContext=this._engine._getShaderProcessingContext(this._shaderLanguage);let ae={defines:this.defines.split(`
`),indexParameters:this._indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:p??this._engine._getShaderProcessor(this._shaderLanguage),supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:ji.GetShadersRepository(this._shaderLanguage),includesShadersStore:ji.GetIncludesShadersStore(this._shaderLanguage),version:(this._engine.version*100).toString(),platformName:this._engine.shaderPlatformName,processingContext:this._processingContext,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:this._processCodeAfterIncludes};const he=[void 0,void 0],_e=()=>{if(he[0]&&he[1]){ae.isFragment=!0;const[ve,Le]=he;xx.Process(Le,ae,(ze,He)=>{this._fragmentSourceCodeBeforeMigration=He,this._processFinalCode&&(ze=this._processFinalCode("fragment",ze));const xt=xx.Finalize(ve,ze,ae);ae=null,this._useFinalCode(xt.vertexCode,xt.fragmentCode,Z,_)},this._engine)}};this._loadShader(E,"Vertex","",ve=>{xx.Initialize(ae),xx.Process(ve,ae,(Le,ze)=>{this._rawVertexSourceCode=ve,this._vertexSourceCodeBeforeMigration=ze,this._processFinalCode&&(Le=this._processFinalCode("vertex",Le)),he[0]=Le,_e()},this._engine)}),this._loadShader(I,"Fragment","Pixel",ve=>{this._rawFragmentSourceCode=ve,he[1]=ve,_e()})}_useFinalCode(p,_,E,I=!1){if(E){const Z=E.vertexElement||E.vertex||E.spectorName||E,re=E.fragmentElement||E.fragment||E.spectorName||E;this._vertexSourceCode=(this._shaderLanguage===Wa.WGSL?"//":"")+"#define SHADER_NAME vertex:"+Z+`
`+p,this._fragmentSourceCode=(this._shaderLanguage===Wa.WGSL?"//":"")+"#define SHADER_NAME fragment:"+re+`
`+_}else this._vertexSourceCode=p,this._fragmentSourceCode=_;this._prepareEffect(I)}get key(){return this._key}isReady(){try{return this._isReadyInternal()}catch{return!1}}_isReadyInternal(){return this._isReady?!0:this._pipelineContext?this._pipelineContext.isReady:!1}getEngine(){return this._engine}getPipelineContext(){return this._pipelineContext}getAttributesNames(){return this._attributesNames}getAttributeLocation(p){return this._attributes[p]}getAttributeLocationByName(p){return this._attributeLocationByName[p]}getAttributesCount(){return this._attributes.length}getUniformIndex(p){return this._uniformsNames.indexOf(p)}getUniform(p){return this._uniforms[p]}getSamplers(){return this._samplerList}getUniformNames(){return this._uniformsNames}getUniformBuffersNames(){return this._uniformBuffersNamesList}getIndexParameters(){return this._indexParameters}getCompilationError(){return this._compilationError}allFallbacksProcessed(){return this._allFallbacksProcessed}executeWhenCompiled(p){if(this.isReady()){p(this);return}this.onCompileObservable.add(_=>{p(_)}),(!this._pipelineContext||this._pipelineContext.isAsync)&&setTimeout(()=>{this._checkIsReady(null)},16)}_checkIsReady(p){try{if(this._isReadyInternal())return}catch(_){this._processCompilationErrors(_,p);return}this._isDisposed||setTimeout(()=>{this._checkIsReady(p)},16)}_loadShader(p,_,E,I){if(typeof HTMLElement<"u"&&p instanceof HTMLElement){const ae=H0(p);I(ae);return}if(p.substr(0,7)==="source:"){I(p.substr(7));return}if(p.substr(0,7)==="base64:"){const ae=window.atob(p.substr(7));I(ae);return}const Z=ji.GetShadersStore(this._shaderLanguage);if(Z[p+_+"Shader"]){I(Z[p+_+"Shader"]);return}if(E&&Z[p+E+"Shader"]){I(Z[p+E+"Shader"]);return}let re;p[0]==="."||p[0]==="/"||p.indexOf("http")>-1?re=p:re=ji.GetShadersRepository(this._shaderLanguage)+p,this._engine._loadFile(re+"."+_.toLowerCase()+".fx",I)}get vertexSourceCode(){return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._vertexSourceCodeOverride:this._pipelineContext?._getVertexShaderCode()??this._vertexSourceCode}get fragmentSourceCode(){return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._fragmentSourceCodeOverride:this._pipelineContext?._getFragmentShaderCode()??this._fragmentSourceCode}get vertexSourceCodeBeforeMigration(){return this._vertexSourceCodeBeforeMigration}get fragmentSourceCodeBeforeMigration(){return this._fragmentSourceCodeBeforeMigration}get rawVertexSourceCode(){return this._rawVertexSourceCode}get rawFragmentSourceCode(){return this._rawFragmentSourceCode}_rebuildProgram(p,_,E,I){this._isReady=!1,this._vertexSourceCodeOverride=p,this._fragmentSourceCodeOverride=_,this.onError=(Z,re)=>{I&&I(re)},this.onCompiled=()=>{const Z=this.getEngine().scenes;if(Z)for(let re=0;re<Z.length;re++)Z[re].markAllMaterialsAsDirty(63);this._pipelineContext._handlesSpectorRebuildCallback?.(E)},this._fallbacks=null,this._prepareEffect()}_prepareEffect(p=!1){const _=this._attributesNames,E=this.defines,I=this._pipelineContext;this._isReady=!1;try{const Z=this._engine;this._pipelineContext=(p?I:void 0)??Z.createPipelineContext(this._processingContext),this._pipelineContext._name=this._key.replace(/\r/g,"").replace(/\n/g,"|");const re=(ae,he,_e,ve)=>this._rebuildProgram(ae,he,_e,ve);this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?Z._preparePipelineContext(this._pipelineContext,this._vertexSourceCodeOverride,this._fragmentSourceCodeOverride,!0,this._rawVertexSourceCode,this._rawFragmentSourceCode,re,null,this._transformFeedbackVaryings,this._key):Z._preparePipelineContext(this._pipelineContext,this._vertexSourceCode,this._fragmentSourceCode,!1,this._rawVertexSourceCode,this._rawFragmentSourceCode,re,E,this._transformFeedbackVaryings,this._key),Z._executeWhenRenderingStateIsCompiled(this._pipelineContext,()=>{if(this._attributes=[],this._pipelineContext._fillEffectInformation(this,this._uniformBuffersNames,this._uniformsNames,this._uniforms,this._samplerList,this._samplers,_,this._attributes),_)for(let ae=0;ae<_.length;ae++){const he=_[ae];this._attributeLocationByName[he]=this._attributes[ae]}Z.bindSamplers(this),this._compilationError="",this._isReady=!0,this.onCompiled&&this.onCompiled(this),this.onCompileObservable.notifyObservers(this),this.onCompileObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh(),I&&!p&&this.getEngine()._deletePipelineContext(I)}),this._pipelineContext.isAsync&&this._checkIsReady(I)}catch(Z){this._processCompilationErrors(Z,I)}}_getShaderCodeAndErrorLine(p,_,E){const I=E?/FRAGMENT SHADER ERROR: 0:(\d+?):/:/VERTEX SHADER ERROR: 0:(\d+?):/;let Z=null;if(_&&p){const re=_.match(I);if(re&&re.length===2){const ae=parseInt(re[1]),he=p.split(`
`,-1);he.length>=ae&&(Z=`Offending line [${ae}] in ${E?"fragment":"vertex"} code: ${he[ae-1]}`)}}return[p,Z]}_processCompilationErrors(p,_=null){this._compilationError=p.message;const E=this._attributesNames,I=this._fallbacks;if(Ti.Error("Unable to compile effect:"),Ti.Error("Uniforms: "+this._uniformsNames.map(function(re){return" "+re})),Ti.Error("Attributes: "+E.map(function(re){return" "+re})),Ti.Error(`Defines:
`+this.defines),_a.LogShaderCodeOnCompilationError){let re=null,ae=null,he=null;this._pipelineContext?._getVertexShaderCode()&&([he,re]=this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(),this._compilationError,!1),he&&(Ti.Error("Vertex code:"),Ti.Error(he))),this._pipelineContext?._getFragmentShaderCode()&&([he,ae]=this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(),this._compilationError,!0),he&&(Ti.Error("Fragment code:"),Ti.Error(he))),re&&Ti.Error(re),ae&&Ti.Error(ae)}Ti.Error("Error: "+this._compilationError);const Z=()=>{this.onError&&this.onError(this,this._compilationError),this.onErrorObservable.notifyObservers(this)};_&&(this._pipelineContext=_,this._isReady=!0,Z()),I?(this._pipelineContext=null,I.hasMoreFallbacks?(this._allFallbacksProcessed=!1,Ti.Error("Trying next fallback."),this.defines=I.reduce(this.defines,this),this._prepareEffect()):(this._allFallbacksProcessed=!0,Z(),this.onErrorObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh())):(this._allFallbacksProcessed=!0,_||Z())}get isSupported(){return this._compilationError===""}_bindTexture(p,_){this._engine._bindTexture(this._samplers[p],_,p)}setTexture(p,_){this._engine.setTexture(this._samplers[p],this._uniforms[p],_,p)}setDepthStencilTexture(p,_){this._engine.setDepthStencilTexture(this._samplers[p],this._uniforms[p],_,p)}setTextureArray(p,_){const E=p+"Ex";if(this._samplerList.indexOf(E+"0")===-1){const I=this._samplerList.indexOf(p);for(let re=1;re<_.length;re++){const ae=E+(re-1).toString();this._samplerList.splice(I+re,0,ae)}let Z=0;for(const re of this._samplerList)this._samplers[re]=Z,Z+=1}this._engine.setTextureArray(this._samplers[p],this._uniforms[p],_,p)}setTextureFromPostProcess(p,_){this._engine.setTextureFromPostProcess(this._samplers[p],_,p)}setTextureFromPostProcessOutput(p,_){this._engine.setTextureFromPostProcessOutput(this._samplers[p],_,p)}bindUniformBuffer(p,_){const E=this._uniformBuffersNames[_];E===void 0||_a._BaseCache[E]===p&&this._engine._features.useUBOBindingCache||(_a._BaseCache[E]=p,this._engine.bindUniformBufferBase(p,E,_))}bindUniformBlock(p,_){this._engine.bindUniformBlock(this._pipelineContext,p,_)}setInt(p,_){return this._pipelineContext.setInt(p,_),this}setInt2(p,_,E){return this._pipelineContext.setInt2(p,_,E),this}setInt3(p,_,E,I){return this._pipelineContext.setInt3(p,_,E,I),this}setInt4(p,_,E,I,Z){return this._pipelineContext.setInt4(p,_,E,I,Z),this}setIntArray(p,_){return this._pipelineContext.setIntArray(p,_),this}setIntArray2(p,_){return this._pipelineContext.setIntArray2(p,_),this}setIntArray3(p,_){return this._pipelineContext.setIntArray3(p,_),this}setIntArray4(p,_){return this._pipelineContext.setIntArray4(p,_),this}setUInt(p,_){return this._pipelineContext.setUInt(p,_),this}setUInt2(p,_,E){return this._pipelineContext.setUInt2(p,_,E),this}setUInt3(p,_,E,I){return this._pipelineContext.setUInt3(p,_,E,I),this}setUInt4(p,_,E,I,Z){return this._pipelineContext.setUInt4(p,_,E,I,Z),this}setUIntArray(p,_){return this._pipelineContext.setUIntArray(p,_),this}setUIntArray2(p,_){return this._pipelineContext.setUIntArray2(p,_),this}setUIntArray3(p,_){return this._pipelineContext.setUIntArray3(p,_),this}setUIntArray4(p,_){return this._pipelineContext.setUIntArray4(p,_),this}setFloatArray(p,_){return this._pipelineContext.setArray(p,_),this}setFloatArray2(p,_){return this._pipelineContext.setArray2(p,_),this}setFloatArray3(p,_){return this._pipelineContext.setArray3(p,_),this}setFloatArray4(p,_){return this._pipelineContext.setArray4(p,_),this}setArray(p,_){return this._pipelineContext.setArray(p,_),this}setArray2(p,_){return this._pipelineContext.setArray2(p,_),this}setArray3(p,_){return this._pipelineContext.setArray3(p,_),this}setArray4(p,_){return this._pipelineContext.setArray4(p,_),this}setMatrices(p,_){return this._pipelineContext.setMatrices(p,_),this}setMatrix(p,_){return this._pipelineContext.setMatrix(p,_),this}setMatrix3x3(p,_){return this._pipelineContext.setMatrix3x3(p,_),this}setMatrix2x2(p,_){return this._pipelineContext.setMatrix2x2(p,_),this}setFloat(p,_){return this._pipelineContext.setFloat(p,_),this}setBool(p,_){return this._pipelineContext.setInt(p,_?1:0),this}setVector2(p,_){return this._pipelineContext.setVector2(p,_),this}setFloat2(p,_,E){return this._pipelineContext.setFloat2(p,_,E),this}setVector3(p,_){return this._pipelineContext.setVector3(p,_),this}setFloat3(p,_,E,I){return this._pipelineContext.setFloat3(p,_,E,I),this}setVector4(p,_){return this._pipelineContext.setVector4(p,_),this}setQuaternion(p,_){return this._pipelineContext.setQuaternion(p,_),this}setFloat4(p,_,E,I,Z){return this._pipelineContext.setFloat4(p,_,E,I,Z),this}setColor3(p,_){return this._pipelineContext.setColor3(p,_),this}setColor4(p,_,E){return this._pipelineContext.setColor4(p,_,E),this}setDirectColor4(p,_){return this._pipelineContext.setDirectColor4(p,_),this}dispose(){this._pipelineContext&&this._pipelineContext.dispose(),this._engine._releaseEffect(this),this._isDisposed=!0}static RegisterShader(p,_,E,I=Wa.GLSL){_&&(ji.GetShadersStore(I)[`${p}PixelShader`]=_),E&&(ji.GetShadersStore(I)[`${p}VertexShader`]=E)}static ResetCache(){_a._BaseCache={}}}_a.LogShaderCodeOnCompilationError=!0,_a._UniqueIdSeed=0,_a._BaseCache={},_a.ShadersStore=ji.ShadersStore,_a.IncludesShadersStore=ji.IncludesShadersStore;class u2{constructor(p=!0){this._isDepthTestDirty=!1,this._isDepthMaskDirty=!1,this._isDepthFuncDirty=!1,this._isCullFaceDirty=!1,this._isCullDirty=!1,this._isZOffsetDirty=!1,this._isFrontFaceDirty=!1,p&&this.reset()}get isDirty(){return this._isDepthFuncDirty||this._isDepthTestDirty||this._isDepthMaskDirty||this._isCullFaceDirty||this._isCullDirty||this._isZOffsetDirty||this._isFrontFaceDirty}get zOffset(){return this._zOffset}set zOffset(p){this._zOffset!==p&&(this._zOffset=p,this._isZOffsetDirty=!0)}get zOffsetUnits(){return this._zOffsetUnits}set zOffsetUnits(p){this._zOffsetUnits!==p&&(this._zOffsetUnits=p,this._isZOffsetDirty=!0)}get cullFace(){return this._cullFace}set cullFace(p){this._cullFace!==p&&(this._cullFace=p,this._isCullFaceDirty=!0)}get cull(){return this._cull}set cull(p){this._cull!==p&&(this._cull=p,this._isCullDirty=!0)}get depthFunc(){return this._depthFunc}set depthFunc(p){this._depthFunc!==p&&(this._depthFunc=p,this._isDepthFuncDirty=!0)}get depthMask(){return this._depthMask}set depthMask(p){this._depthMask!==p&&(this._depthMask=p,this._isDepthMaskDirty=!0)}get depthTest(){return this._depthTest}set depthTest(p){this._depthTest!==p&&(this._depthTest=p,this._isDepthTestDirty=!0)}get frontFace(){return this._frontFace}set frontFace(p){this._frontFace!==p&&(this._frontFace=p,this._isFrontFaceDirty=!0)}reset(){this._depthMask=!0,this._depthTest=!0,this._depthFunc=null,this._cullFace=null,this._cull=null,this._zOffset=0,this._zOffsetUnits=0,this._frontFace=null,this._isDepthTestDirty=!0,this._isDepthMaskDirty=!0,this._isDepthFuncDirty=!1,this._isCullFaceDirty=!1,this._isCullDirty=!1,this._isZOffsetDirty=!0,this._isFrontFaceDirty=!1}apply(p){this.isDirty&&(this._isCullDirty&&(this.cull?p.enable(p.CULL_FACE):p.disable(p.CULL_FACE),this._isCullDirty=!1),this._isCullFaceDirty&&(p.cullFace(this.cullFace),this._isCullFaceDirty=!1),this._isDepthMaskDirty&&(p.depthMask(this.depthMask),this._isDepthMaskDirty=!1),this._isDepthTestDirty&&(this.depthTest?p.enable(p.DEPTH_TEST):p.disable(p.DEPTH_TEST),this._isDepthTestDirty=!1),this._isDepthFuncDirty&&(p.depthFunc(this.depthFunc),this._isDepthFuncDirty=!1),this._isZOffsetDirty&&(this.zOffset||this.zOffsetUnits?(p.enable(p.POLYGON_OFFSET_FILL),p.polygonOffset(this.zOffset,this.zOffsetUnits)):p.disable(p.POLYGON_OFFSET_FILL),this._isZOffsetDirty=!1),this._isFrontFaceDirty&&(p.frontFace(this.frontFace),this._isFrontFaceDirty=!1))}}class lx{constructor(){this.reset()}reset(){this.enabled=!1,this.mask=255,this.func=lx.ALWAYS,this.funcRef=1,this.funcMask=255,this.opStencilFail=lx.KEEP,this.opDepthFail=lx.KEEP,this.opStencilDepthPass=lx.REPLACE}get stencilFunc(){return this.func}set stencilFunc(p){this.func=p}get stencilFuncRef(){return this.funcRef}set stencilFuncRef(p){this.funcRef=p}get stencilFuncMask(){return this.funcMask}set stencilFuncMask(p){this.funcMask=p}get stencilOpStencilFail(){return this.opStencilFail}set stencilOpStencilFail(p){this.opStencilFail=p}get stencilOpDepthFail(){return this.opDepthFail}set stencilOpDepthFail(p){this.opDepthFail=p}get stencilOpStencilDepthPass(){return this.opStencilDepthPass}set stencilOpStencilDepthPass(p){this.opStencilDepthPass=p}get stencilMask(){return this.mask}set stencilMask(p){this.mask=p}get stencilTest(){return this.enabled}set stencilTest(p){this.enabled=p}}lx.ALWAYS=519,lx.KEEP=7680,lx.REPLACE=7681;class Gl{constructor(){this._blendFunctionParameters=new Array(4),this._blendEquationParameters=new Array(2),this._blendConstants=new Array(4),this._isBlendConstantsDirty=!1,this._alphaBlend=!1,this._isAlphaBlendDirty=!1,this._isBlendFunctionParametersDirty=!1,this._isBlendEquationParametersDirty=!1,this.reset()}get isDirty(){return this._isAlphaBlendDirty||this._isBlendFunctionParametersDirty||this._isBlendEquationParametersDirty}get alphaBlend(){return this._alphaBlend}set alphaBlend(p){this._alphaBlend!==p&&(this._alphaBlend=p,this._isAlphaBlendDirty=!0)}setAlphaBlendConstants(p,_,E,I){this._blendConstants[0]===p&&this._blendConstants[1]===_&&this._blendConstants[2]===E&&this._blendConstants[3]===I||(this._blendConstants[0]=p,this._blendConstants[1]=_,this._blendConstants[2]=E,this._blendConstants[3]=I,this._isBlendConstantsDirty=!0)}setAlphaBlendFunctionParameters(p,_,E,I){this._blendFunctionParameters[0]===p&&this._blendFunctionParameters[1]===_&&this._blendFunctionParameters[2]===E&&this._blendFunctionParameters[3]===I||(this._blendFunctionParameters[0]=p,this._blendFunctionParameters[1]=_,this._blendFunctionParameters[2]=E,this._blendFunctionParameters[3]=I,this._isBlendFunctionParametersDirty=!0)}setAlphaEquationParameters(p,_){this._blendEquationParameters[0]===p&&this._blendEquationParameters[1]===_||(this._blendEquationParameters[0]=p,this._blendEquationParameters[1]=_,this._isBlendEquationParametersDirty=!0)}reset(){this._alphaBlend=!1,this._blendFunctionParameters[0]=null,this._blendFunctionParameters[1]=null,this._blendFunctionParameters[2]=null,this._blendFunctionParameters[3]=null,this._blendEquationParameters[0]=null,this._blendEquationParameters[1]=null,this._blendConstants[0]=null,this._blendConstants[1]=null,this._blendConstants[2]=null,this._blendConstants[3]=null,this._isAlphaBlendDirty=!0,this._isBlendFunctionParametersDirty=!1,this._isBlendEquationParametersDirty=!1,this._isBlendConstantsDirty=!1}apply(p){this.isDirty&&(this._isAlphaBlendDirty&&(this._alphaBlend?p.enable(p.BLEND):p.disable(p.BLEND),this._isAlphaBlendDirty=!1),this._isBlendFunctionParametersDirty&&(p.blendFuncSeparate(this._blendFunctionParameters[0],this._blendFunctionParameters[1],this._blendFunctionParameters[2],this._blendFunctionParameters[3]),this._isBlendFunctionParametersDirty=!1),this._isBlendEquationParametersDirty&&(p.blendEquationSeparate(this._blendEquationParameters[0],this._blendEquationParameters[1]),this._isBlendEquationParametersDirty=!1),this._isBlendConstantsDirty&&(p.blendColor(this._blendConstants[0],this._blendConstants[1],this._blendConstants[2],this._blendConstants[3]),this._isBlendConstantsDirty=!1))}}class $a{constructor(){this.shaderLanguage=Wa.GLSL}postProcessor(p,_,E,I,Z){if(!Z.getCaps().drawBuffersExtension){const re=/#extension.+GL_EXT_draw_buffers.+(enable|require)/g;p=p.replace(re,"")}return p}}const pc=/(flat\s)?\s*varying\s*.*/;class u0{constructor(){this.shaderLanguage=Wa.GLSL}attributeProcessor(p){return p.replace("attribute","in")}varyingCheck(p,_){return pc.test(p)}varyingProcessor(p,_){return p.replace("varying",_?"in":"out")}postProcessor(p,_,E){const I=p.search(/#extension.+GL_EXT_draw_buffers.+require/)!==-1,Z=/#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;if(p=p.replace(Z,""),p=p.replace(/texture2D\s*\(/g,"texture("),E){const re=p.search(/layout *\(location *= *0\) *out/g)!==-1;p=p.replace(/texture2DLodEXT\s*\(/g,"textureLod("),p=p.replace(/textureCubeLodEXT\s*\(/g,"textureLod("),p=p.replace(/textureCube\s*\(/g,"texture("),p=p.replace(/gl_FragDepthEXT/g,"gl_FragDepth"),p=p.replace(/gl_FragColor/g,"glFragColor"),p=p.replace(/gl_FragData/g,"glFragData"),p=p.replace(/void\s+?main\s*\(/g,(I||re?"":`layout(location = 0) out vec4 glFragColor;
`)+"void main(")}else if(_.indexOf("#define MULTIVIEW")!==-1)return`#extension GL_OVR_multiview2 : require
layout (num_views = 2) in;
`+p;return p}}class hx{get underlyingResource(){return null}constructor(){this.references=0,this.capacity=0,this.is32Bits=!1,this.uniqueId=hx._Counter++}}hx._Counter=0;class Gx extends hx{constructor(p){super(),this._buffer=p}get underlyingResource(){return this._buffer}}class zl{constructor(){this._valueCache={},this.vertexCompilationError=null,this.fragmentCompilationError=null,this.programLinkError=null,this.programValidationError=null,this._isDisposed=!1}get isAsync(){return this.isParallelCompiled}get isReady(){return this.program?this.isParallelCompiled?this.engine._isRenderingStateCompiled(this):!0:!1}_handlesSpectorRebuildCallback(p){p&&this.program&&p(this.program)}_fillEffectInformation(p,_,E,I,Z,re,ae,he){const _e=this.engine;if(_e.supportsUniformBuffers)for(const ze in _)p.bindUniformBlock(ze,_[ze]);this.engine.getUniforms(this,E).forEach((ze,He)=>{I[E[He]]=ze}),this._uniforms=I;let Le;for(Le=0;Le<Z.length;Le++)p.getUniform(Z[Le])==null&&(Z.splice(Le,1),Le--);Z.forEach((ze,He)=>{re[ze]=He});for(const ze of _e.getAttributes(this,ae))he.push(ze)}dispose(){this._uniforms={},this._isDisposed=!0}_cacheMatrix(p,_){const E=this._valueCache[p],I=_.updateFlag;return E!==void 0&&E===I?!1:(this._valueCache[p]=I,!0)}_cacheFloat2(p,_,E){let I=this._valueCache[p];if(!I||I.length!==2)return I=[_,E],this._valueCache[p]=I,!0;let Z=!1;return I[0]!==_&&(I[0]=_,Z=!0),I[1]!==E&&(I[1]=E,Z=!0),Z}_cacheFloat3(p,_,E,I){let Z=this._valueCache[p];if(!Z||Z.length!==3)return Z=[_,E,I],this._valueCache[p]=Z,!0;let re=!1;return Z[0]!==_&&(Z[0]=_,re=!0),Z[1]!==E&&(Z[1]=E,re=!0),Z[2]!==I&&(Z[2]=I,re=!0),re}_cacheFloat4(p,_,E,I,Z){let re=this._valueCache[p];if(!re||re.length!==4)return re=[_,E,I,Z],this._valueCache[p]=re,!0;let ae=!1;return re[0]!==_&&(re[0]=_,ae=!0),re[1]!==E&&(re[1]=E,ae=!0),re[2]!==I&&(re[2]=I,ae=!0),re[3]!==Z&&(re[3]=Z,ae=!0),ae}setInt(p,_){const E=this._valueCache[p];E!==void 0&&E===_||this.engine.setInt(this._uniforms[p],_)&&(this._valueCache[p]=_)}setInt2(p,_,E){this._cacheFloat2(p,_,E)&&(this.engine.setInt2(this._uniforms[p],_,E)||(this._valueCache[p]=null))}setInt3(p,_,E,I){this._cacheFloat3(p,_,E,I)&&(this.engine.setInt3(this._uniforms[p],_,E,I)||(this._valueCache[p]=null))}setInt4(p,_,E,I,Z){this._cacheFloat4(p,_,E,I,Z)&&(this.engine.setInt4(this._uniforms[p],_,E,I,Z)||(this._valueCache[p]=null))}setIntArray(p,_){this._valueCache[p]=null,this.engine.setIntArray(this._uniforms[p],_)}setIntArray2(p,_){this._valueCache[p]=null,this.engine.setIntArray2(this._uniforms[p],_)}setIntArray3(p,_){this._valueCache[p]=null,this.engine.setIntArray3(this._uniforms[p],_)}setIntArray4(p,_){this._valueCache[p]=null,this.engine.setIntArray4(this._uniforms[p],_)}setUInt(p,_){const E=this._valueCache[p];E!==void 0&&E===_||this.engine.setUInt(this._uniforms[p],_)&&(this._valueCache[p]=_)}setUInt2(p,_,E){this._cacheFloat2(p,_,E)&&(this.engine.setUInt2(this._uniforms[p],_,E)||(this._valueCache[p]=null))}setUInt3(p,_,E,I){this._cacheFloat3(p,_,E,I)&&(this.engine.setUInt3(this._uniforms[p],_,E,I)||(this._valueCache[p]=null))}setUInt4(p,_,E,I,Z){this._cacheFloat4(p,_,E,I,Z)&&(this.engine.setUInt4(this._uniforms[p],_,E,I,Z)||(this._valueCache[p]=null))}setUIntArray(p,_){this._valueCache[p]=null,this.engine.setUIntArray(this._uniforms[p],_)}setUIntArray2(p,_){this._valueCache[p]=null,this.engine.setUIntArray2(this._uniforms[p],_)}setUIntArray3(p,_){this._valueCache[p]=null,this.engine.setUIntArray3(this._uniforms[p],_)}setUIntArray4(p,_){this._valueCache[p]=null,this.engine.setUIntArray4(this._uniforms[p],_)}setArray(p,_){this._valueCache[p]=null,this.engine.setArray(this._uniforms[p],_)}setArray2(p,_){this._valueCache[p]=null,this.engine.setArray2(this._uniforms[p],_)}setArray3(p,_){this._valueCache[p]=null,this.engine.setArray3(this._uniforms[p],_)}setArray4(p,_){this._valueCache[p]=null,this.engine.setArray4(this._uniforms[p],_)}setMatrices(p,_){_&&(this._valueCache[p]=null,this.engine.setMatrices(this._uniforms[p],_))}setMatrix(p,_){this._cacheMatrix(p,_)&&(this.engine.setMatrices(this._uniforms[p],_.toArray())||(this._valueCache[p]=null))}setMatrix3x3(p,_){this._valueCache[p]=null,this.engine.setMatrix3x3(this._uniforms[p],_)}setMatrix2x2(p,_){this._valueCache[p]=null,this.engine.setMatrix2x2(this._uniforms[p],_)}setFloat(p,_){const E=this._valueCache[p];E!==void 0&&E===_||this.engine.setFloat(this._uniforms[p],_)&&(this._valueCache[p]=_)}setVector2(p,_){this._cacheFloat2(p,_.x,_.y)&&(this.engine.setFloat2(this._uniforms[p],_.x,_.y)||(this._valueCache[p]=null))}setFloat2(p,_,E){this._cacheFloat2(p,_,E)&&(this.engine.setFloat2(this._uniforms[p],_,E)||(this._valueCache[p]=null))}setVector3(p,_){this._cacheFloat3(p,_.x,_.y,_.z)&&(this.engine.setFloat3(this._uniforms[p],_.x,_.y,_.z)||(this._valueCache[p]=null))}setFloat3(p,_,E,I){this._cacheFloat3(p,_,E,I)&&(this.engine.setFloat3(this._uniforms[p],_,E,I)||(this._valueCache[p]=null))}setVector4(p,_){this._cacheFloat4(p,_.x,_.y,_.z,_.w)&&(this.engine.setFloat4(this._uniforms[p],_.x,_.y,_.z,_.w)||(this._valueCache[p]=null))}setQuaternion(p,_){this._cacheFloat4(p,_.x,_.y,_.z,_.w)&&(this.engine.setFloat4(this._uniforms[p],_.x,_.y,_.z,_.w)||(this._valueCache[p]=null))}setFloat4(p,_,E,I,Z){this._cacheFloat4(p,_,E,I,Z)&&(this.engine.setFloat4(this._uniforms[p],_,E,I,Z)||(this._valueCache[p]=null))}setColor3(p,_){this._cacheFloat3(p,_.r,_.g,_.b)&&(this.engine.setFloat3(this._uniforms[p],_.r,_.g,_.b)||(this._valueCache[p]=null))}setColor4(p,_,E){this._cacheFloat4(p,_.r,_.g,_.b,E)&&(this.engine.setFloat4(this._uniforms[p],_.r,_.g,_.b,E)||(this._valueCache[p]=null))}setDirectColor4(p,_){this._cacheFloat4(p,_.r,_.g,_.b,_.a)&&(this.engine.setFloat4(this._uniforms[p],_.r,_.g,_.b,_.a)||(this._valueCache[p]=null))}_getVertexShaderCode(){return this.vertexShader?this.engine._getShaderSource(this.vertexShader):null}_getFragmentShaderCode(){return this.fragmentShader?this.engine._getShaderSource(this.fragmentShader):null}}class aa{static SetMatrixPrecision(p){if(aa.MatrixTrackPrecisionChange=!1,p&&!aa.MatrixUse64Bits&&aa.MatrixTrackedMatrices)for(let _=0;_<aa.MatrixTrackedMatrices.length;++_){const E=aa.MatrixTrackedMatrices[_],I=E._m;E._m=new Array(16);for(let Z=0;Z<16;++Z)E._m[Z]=I[Z]}aa.MatrixUse64Bits=p,aa.MatrixCurrentType=aa.MatrixUse64Bits?Array:Float32Array,aa.MatrixTrackedMatrices=null}}aa.MatrixUse64Bits=!1,aa.MatrixTrackPrecisionChange=!0,aa.MatrixCurrentType=Float32Array,aa.MatrixTrackedMatrices=[];class Ko{get underlyingResource(){return this._webGLTexture}constructor(p=null,_){if(this._MSAARenderBuffers=null,this._context=_,!p&&(p=_.createTexture(),!p))throw new Error("Unable to create webGL texture");this.set(p)}setUsage(){}set(p){this._webGLTexture=p}reset(){this._webGLTexture=null,this._MSAARenderBuffers=null}addMSAARenderBuffer(p){this._MSAARenderBuffers||(this._MSAARenderBuffers=[]),this._MSAARenderBuffers.push(p)}releaseMSAARenderBuffers(){if(this._MSAARenderBuffers){for(const p of this._MSAARenderBuffers)this._context.deleteRenderbuffer(p);this._MSAARenderBuffers=null}}getMSAARenderBuffer(p=0){return this._MSAARenderBuffers?.[p]??null}release(){this.releaseMSAARenderBuffers(),this._webGLTexture&&this._context.deleteTexture(this._webGLTexture),this.reset()}}class xo{static IsWrapper(p){return p.getPipelineContext===void 0}static GetEffect(p){return p.getPipelineContext===void 0?p.effect:p}constructor(p,_=!0){this._wasPreviouslyReady=!1,this._forceRebindOnNextCall=!0,this._wasPreviouslyUsingInstances=null,this.effect=null,this.defines=null,this.drawContext=p.createDrawContext(),_&&(this.materialContext=p.createMaterialContext())}setEffect(p,_,E=!0){this.effect=p,_!==void 0&&(this.defines=_),E&&this.drawContext?.reset()}dispose(){this.drawContext?.dispose()}}class wh{get isDirty(){return this._isStencilTestDirty||this._isStencilMaskDirty||this._isStencilFuncDirty||this._isStencilOpDirty}get func(){return this._func}set func(p){this._func!==p&&(this._func=p,this._isStencilFuncDirty=!0)}get funcRef(){return this._funcRef}set funcRef(p){this._funcRef!==p&&(this._funcRef=p,this._isStencilFuncDirty=!0)}get funcMask(){return this._funcMask}set funcMask(p){this._funcMask!==p&&(this._funcMask=p,this._isStencilFuncDirty=!0)}get opStencilFail(){return this._opStencilFail}set opStencilFail(p){this._opStencilFail!==p&&(this._opStencilFail=p,this._isStencilOpDirty=!0)}get opDepthFail(){return this._opDepthFail}set opDepthFail(p){this._opDepthFail!==p&&(this._opDepthFail=p,this._isStencilOpDirty=!0)}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(p){this._opStencilDepthPass!==p&&(this._opStencilDepthPass=p,this._isStencilOpDirty=!0)}get mask(){return this._mask}set mask(p){this._mask!==p&&(this._mask=p,this._isStencilMaskDirty=!0)}get enabled(){return this._enabled}set enabled(p){this._enabled!==p&&(this._enabled=p,this._isStencilTestDirty=!0)}constructor(p=!0){this._isStencilTestDirty=!1,this._isStencilMaskDirty=!1,this._isStencilFuncDirty=!1,this._isStencilOpDirty=!1,this.useStencilGlobalOnly=!1,p&&this.reset()}reset(){this.stencilMaterial=void 0,this.stencilGlobal?.reset(),this._isStencilTestDirty=!0,this._isStencilMaskDirty=!0,this._isStencilFuncDirty=!0,this._isStencilOpDirty=!0}apply(p){if(!p)return;const _=!this.useStencilGlobalOnly&&!!this.stencilMaterial?.enabled;this.enabled=_?this.stencilMaterial.enabled:this.stencilGlobal.enabled,this.func=_?this.stencilMaterial.func:this.stencilGlobal.func,this.funcRef=_?this.stencilMaterial.funcRef:this.stencilGlobal.funcRef,this.funcMask=_?this.stencilMaterial.funcMask:this.stencilGlobal.funcMask,this.opStencilFail=_?this.stencilMaterial.opStencilFail:this.stencilGlobal.opStencilFail,this.opDepthFail=_?this.stencilMaterial.opDepthFail:this.stencilGlobal.opDepthFail,this.opStencilDepthPass=_?this.stencilMaterial.opStencilDepthPass:this.stencilGlobal.opStencilDepthPass,this.mask=_?this.stencilMaterial.mask:this.stencilGlobal.mask,this.isDirty&&(this._isStencilTestDirty&&(this.enabled?p.enable(p.STENCIL_TEST):p.disable(p.STENCIL_TEST),this._isStencilTestDirty=!1),this._isStencilMaskDirty&&(p.stencilMask(this.mask),this._isStencilMaskDirty=!1),this._isStencilFuncDirty&&(p.stencilFunc(this.func,this.funcRef,this.funcMask),this._isStencilFuncDirty=!1),this._isStencilOpDirty&&(p.stencilOp(this.opStencilFail,this.opDepthFail,this.opStencilDepthPass),this._isStencilOpDirty=!1))}}class zx{static get Now(){return va()&&window.performance&&window.performance.now?window.performance.now():Date.now()}}class _c{}class sr{static get NpmPackage(){return"babylonjs@6.41.2"}static get Version(){return"6.41.2"}get description(){let p=this.name+this.webGLVersion;return this._caps.parallelShaderCompile&&(p+=" - Parallel shader compilation"),p}get name(){return this._name}set name(p){this._name=p}get version(){return this._webGLVersion}get isDisposed(){return this._isDisposed}static get ShadersRepository(){return _a.ShadersRepository}static set ShadersRepository(p){_a.ShadersRepository=p}_getShaderProcessor(p){return this._shaderProcessor}get useReverseDepthBuffer(){return this._useReverseDepthBuffer}set useReverseDepthBuffer(p){p!==this._useReverseDepthBuffer&&(this._useReverseDepthBuffer=p,p?this._depthCullingState.depthFunc=518:this._depthCullingState.depthFunc=515)}get frameId(){return this._frameId}get supportsUniformBuffers(){return this.webGLVersion>1&&!this.disableUniformBuffers}getCreationOptions(){return this._creationOptions}get _shouldUseHighPrecisionShader(){return!!(this._caps.highPrecisionShaderSupported&&this._highPrecisionShadersAllowed)}get needPOTTextures(){return this._webGLVersion<2||this.forcePOTTextures}get activeRenderLoops(){return this._activeRenderLoops}get doNotHandleContextLost(){return this._doNotHandleContextLost}set doNotHandleContextLost(p){this._doNotHandleContextLost=p}get _supportsHardwareTextureRescaling(){return!1}set framebufferDimensionsObject(p){this._framebufferDimensionsObject=p}get currentViewport(){return this._cachedViewport}get emptyTexture(){return this._emptyTexture||(this._emptyTexture=this.createRawTexture(new Uint8Array(4),1,1,5,!1,!1,1)),this._emptyTexture}get emptyTexture3D(){return this._emptyTexture3D||(this._emptyTexture3D=this.createRawTexture3D(new Uint8Array(4),1,1,1,5,!1,!1,1)),this._emptyTexture3D}get emptyTexture2DArray(){return this._emptyTexture2DArray||(this._emptyTexture2DArray=this.createRawTexture2DArray(new Uint8Array(4),1,1,1,5,!1,!1,1)),this._emptyTexture2DArray}get emptyCubeTexture(){if(!this._emptyCubeTexture){const p=new Uint8Array(4),_=[p,p,p,p,p,p];this._emptyCubeTexture=this.createRawCubeTexture(_,1,5,0,!1,!1,1)}return this._emptyCubeTexture}get isWebGPU(){return this._isWebGPU}get shaderPlatformName(){return this._shaderPlatformName}get snapshotRendering(){return!1}set snapshotRendering(p){}get snapshotRenderingMode(){return this._snapshotRenderingMode}set snapshotRenderingMode(p){this._snapshotRenderingMode=p}snapshotRenderingReset(){this.snapshotRendering=!1}static _CreateCanvas(p,_){if(typeof document>"u")return new OffscreenCanvas(p,_);const E=document.createElement("canvas");return E.width=p,E.height=_,E}createCanvas(p,_){return sr._CreateCanvas(p,_)}createCanvasImage(){return document.createElement("img")}constructor(p,_,E,I){this._name="WebGL",this._isDisposed=!1,this.forcePOTTextures=!1,this.isFullscreen=!1,this.cullBackFaces=null,this.renderEvenInBackground=!0,this.preventCacheWipeBetweenFrames=!1,this.validateShaderPrograms=!1,this._useReverseDepthBuffer=!1,this.isNDCHalfZRange=!1,this.hasOriginBottomLeft=!0,this.disableUniformBuffers=!1,this.onDisposeObservable=new Ri,this._frameId=0,this._uniformBuffers=new Array,this._storageBuffers=new Array,this._webGLVersion=1,this._windowIsBackground=!1,this._highPrecisionShadersAllowed=!0,this._badOS=!1,this._badDesktopOS=!1,this._renderingQueueLaunched=!1,this._activeRenderLoops=new Array,this.onContextLostObservable=new Ri,this.onContextRestoredObservable=new Ri,this._contextWasLost=!1,this._doNotHandleContextLost=!1,this.disableVertexArrayObjects=!1,this._colorWrite=!0,this._colorWriteChanged=!0,this._depthCullingState=new u2,this._stencilStateComposer=new wh,this._stencilState=new lx,this._alphaState=new Gl,this._alphaMode=1,this._alphaEquation=0,this._internalTexturesCache=new Array,this._renderTargetWrapperCache=new Array,this._activeChannel=0,this._currentTextureChannel=-1,this._boundTexturesCache={},this._compiledEffects={},this._vertexAttribArraysEnabled=[],this._currentRenderTarget=null,this._uintIndicesCurrentlySet=!1,this._currentBoundBuffer=new Array,this._currentFramebuffer=null,this._dummyFramebuffer=null,this._currentBufferPointers=new Array,this._currentInstanceLocations=new Array,this._currentInstanceBuffers=new Array,this._vaoRecordInProgress=!1,this._mustWipeVertexAttributes=!1,this._nextFreeTextureSlots=new Array,this._maxSimultaneousTextures=0,this._maxMSAASamplesOverride=null,this._activeRequests=new Array,this.adaptToDeviceRatio=!1,this._lastDevicePixelRatio=1,this._transformTextureUrl=null,this.hostInformation={isMobile:!1},this.premultipliedAlpha=!0,this.onBeforeTextureInitObservable=new Ri,this._isWebGPU=!1,this._snapshotRenderingMode=0,this._viewportCached={x:0,y:0,z:0,w:0},this._unpackFlipYCached=null,this.enableUnpackFlipYCached=!0,this._boundUniforms={},this.startTime=zx.Now;let Z=null;E=E||{},this._creationOptions=E,this.adaptToDeviceRatio=I??!1,this._stencilStateComposer.stencilGlobal=this._stencilState,aa.SetMatrixPrecision(!!E.useHighPrecisionMatrix),E.antialias=_??E.antialias,E.deterministicLockstep=E.deterministicLockstep??!1,E.lockstepMaxSteps=E.lockstepMaxSteps??4,E.timeStep=E.timeStep??1/60,E.audioEngine=E.audioEngine??!0,E.stencil=E.stencil??!0,this._audioContext=E.audioEngineOptions?.audioContext??null,this._audioDestination=E.audioEngineOptions?.audioDestination??null,this.premultipliedAlpha=E.premultipliedAlpha??!0,this.useExactSrgbConversions=E.useExactSrgbConversions??!1,this._doNotHandleContextLost=!!E.doNotHandleContextLost,this._isStencilEnable=!!E.stencil,I=I||E.adaptToDeviceRatio||!1;const re=va()&&window.devicePixelRatio||1,ae=E.limitDeviceRatio||re;if(this._hardwareScalingLevel=I?1/Math.min(ae,re):1,this._lastDevicePixelRatio=re,!p)return;if(p.getContext){if(Z=p,this._renderingCanvas=Z,E.preserveDrawingBuffer===void 0&&(E.preserveDrawingBuffer=!1),E.xrCompatible===void 0&&(E.xrCompatible=!0),navigator&&navigator.userAgent){this._setupMobileChecks();const _e=navigator.userAgent;for(const ve of sr.ExceptionList){const Le=ve.key,ze=ve.targets;if(new RegExp(Le).test(_e)){if(ve.capture&&ve.captureConstraint){const xt=ve.capture,rt=ve.captureConstraint,Lt=new RegExp(xt).exec(_e);if(Lt&&Lt.length>0&&parseInt(Lt[Lt.length-1])>=rt)continue}for(const xt of ze)switch(xt){case"uniformBuffer":this.disableUniformBuffers=!0;break;case"vao":this.disableVertexArrayObjects=!0;break;case"antialias":E.antialias=!1;break;case"maxMSAASamples":this._maxMSAASamplesOverride=1;break}}}}if(this._doNotHandleContextLost||(this._onContextLost=_e=>{_e.preventDefault(),this._contextWasLost=!0,Ti.Warn("WebGL context lost."),this.onContextLostObservable.notifyObservers(this)},this._onContextRestored=()=>{this._restoreEngineAfterContextLost(()=>this._initGLContext())},Z.addEventListener("webglcontextlost",this._onContextLost,!1),Z.addEventListener("webglcontextrestored",this._onContextRestored,!1),E.powerPreference=E.powerPreference||"high-performance"),this._badDesktopOS=/^((?!chrome|android).)*safari/i.test(navigator.userAgent),this._badDesktopOS&&(E.xrCompatible=!1),!E.disableWebGL2Support)try{this._gl=Z.getContext("webgl2",E)||Z.getContext("experimental-webgl2",E),this._gl&&(this._webGLVersion=2,this._shaderPlatformName="WEBGL2",this._gl.deleteQuery||(this._webGLVersion=1,this._shaderPlatformName="WEBGL1"))}catch{}if(!this._gl){if(!Z)throw new Error("The provided canvas is null or undefined.");try{this._gl=Z.getContext("webgl",E)||Z.getContext("experimental-webgl",E)}catch{throw new Error("WebGL not supported")}}if(!this._gl)throw new Error("WebGL not supported")}else{this._gl=p,this._renderingCanvas=this._gl.canvas,this._gl.renderbufferStorageMultisample?(this._webGLVersion=2,this._shaderPlatformName="WEBGL2"):this._shaderPlatformName="WEBGL1";const _e=this._gl.getContextAttributes();_e&&(E.stencil=_e.stencil)}this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,this._gl.NONE),E.useHighPrecisionFloats!==void 0&&(this._highPrecisionShadersAllowed=E.useHighPrecisionFloats),this.resize(),this._initGLContext(),this._initFeatures();for(let _e=0;_e<this._caps.maxVertexAttribs;_e++)this._currentBufferPointers[_e]=new _c;this._shaderProcessor=this.webGLVersion>1?new u0:new $a,this._badOS=/iPad/i.test(navigator.userAgent)||/iPhone/i.test(navigator.userAgent);const he=`Babylon.js v${sr.Version}`;Ti.Log(he+` - ${this.description}`),this._renderingCanvas&&this._renderingCanvas.setAttribute&&this._renderingCanvas.setAttribute("data-engine",he)}_setupMobileChecks(){navigator&&navigator.userAgent&&(this._checkForMobile=()=>{const p=navigator.userAgent;this.hostInformation.isMobile=p.indexOf("Mobile")!==-1||p.indexOf("Mac")!==-1&&no()&&"ontouchend"in document},this._checkForMobile(),va()&&window.addEventListener("resize",this._checkForMobile))}_restoreEngineAfterContextLost(p){setTimeout(async()=>{this._dummyFramebuffer=null,this._emptyTexture=null,this._emptyCubeTexture=null,this._emptyTexture3D=null,this._emptyTexture2DArray=null;const _=this._depthCullingState.depthTest,E=this._depthCullingState.depthFunc,I=this._depthCullingState.depthMask,Z=this._stencilState.stencilTest;await p(),this.wipeCaches(!0),this._rebuildEffects(),this._rebuildComputeEffects?.(),this._rebuildBuffers(),this._rebuildInternalTextures(),this._rebuildTextures(),this._rebuildRenderTargetWrappers(),this.wipeCaches(!0),this._depthCullingState.depthTest=_,this._depthCullingState.depthFunc=E,this._depthCullingState.depthMask=I,this._stencilState.stencilTest=Z,Ti.Warn(this.name+" context successfully restored."),this.onContextRestoredObservable.notifyObservers(this),this._contextWasLost=!1},0)}_sharedInit(p){this._renderingCanvas=p}_getShaderProcessingContext(p){return null}_rebuildInternalTextures(){const p=this._internalTexturesCache.slice();for(const _ of p)_._rebuild()}_rebuildRenderTargetWrappers(){const p=this._renderTargetWrapperCache.slice();for(const _ of p)_._rebuild()}_rebuildEffects(){for(const p in this._compiledEffects){const _=this._compiledEffects[p];_._pipelineContext=null,_._prepareEffect()}_a.ResetCache()}areAllEffectsReady(){for(const p in this._compiledEffects)if(!this._compiledEffects[p].isReady())return!1;return!0}_rebuildBuffers(){for(const p of this._uniformBuffers)p._rebuildAfterContextLost()}_rebuildTextures(){}_initGLContext(){this._caps={maxTexturesImageUnits:this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),maxCombinedTexturesImageUnits:this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),maxVertexTextureImageUnits:this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),maxTextureSize:this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),maxSamples:this._webGLVersion>1?this._gl.getParameter(this._gl.MAX_SAMPLES):1,maxCubemapTextureSize:this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),maxRenderTextureSize:this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),maxVertexAttribs:this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),maxVaryingVectors:this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),maxFragmentUniformVectors:this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),maxVertexUniformVectors:this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),parallelShaderCompile:this._gl.getExtension("KHR_parallel_shader_compile")||void 0,standardDerivatives:this._webGLVersion>1||this._gl.getExtension("OES_standard_derivatives")!==null,maxAnisotropy:1,astc:this._gl.getExtension("WEBGL_compressed_texture_astc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),bptc:this._gl.getExtension("EXT_texture_compression_bptc")||this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),s3tc:this._gl.getExtension("WEBGL_compressed_texture_s3tc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),s3tc_srgb:this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),pvrtc:this._gl.getExtension("WEBGL_compressed_texture_pvrtc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),etc1:this._gl.getExtension("WEBGL_compressed_texture_etc1")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),etc2:this._gl.getExtension("WEBGL_compressed_texture_etc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc")||this._gl.getExtension("WEBGL_compressed_texture_es3_0"),textureAnisotropicFilterExtension:this._gl.getExtension("EXT_texture_filter_anisotropic")||this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic")||this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),uintIndices:this._webGLVersion>1||this._gl.getExtension("OES_element_index_uint")!==null,fragmentDepthSupported:this._webGLVersion>1||this._gl.getExtension("EXT_frag_depth")!==null,highPrecisionShaderSupported:!1,timerQuery:this._gl.getExtension("EXT_disjoint_timer_query_webgl2")||this._gl.getExtension("EXT_disjoint_timer_query"),supportOcclusionQuery:this._webGLVersion>1,canUseTimestampForTimerQuery:!1,drawBuffersExtension:!1,maxMSAASamples:1,colorBufferFloat:!!(this._webGLVersion>1&&this._gl.getExtension("EXT_color_buffer_float")),supportFloatTexturesResolve:!1,rg11b10ufColorRenderable:!1,colorBufferHalfFloat:!!(this._webGLVersion>1&&this._gl.getExtension("EXT_color_buffer_half_float")),textureFloat:!!(this._webGLVersion>1||this._gl.getExtension("OES_texture_float")),textureHalfFloat:!!(this._webGLVersion>1||this._gl.getExtension("OES_texture_half_float")),textureHalfFloatRender:!1,textureFloatLinearFiltering:!1,textureFloatRender:!1,textureHalfFloatLinearFiltering:!1,vertexArrayObject:!1,instancedArrays:!1,textureLOD:!!(this._webGLVersion>1||this._gl.getExtension("EXT_shader_texture_lod")),texelFetch:this._webGLVersion!==1,blendMinMax:!1,multiview:this._gl.getExtension("OVR_multiview2"),oculusMultiview:this._gl.getExtension("OCULUS_multiview"),depthTextureExtension:!1,canUseGLInstanceID:this._webGLVersion>1,canUseGLVertexID:this._webGLVersion>1,supportComputeShaders:!1,supportSRGBBuffers:!1,supportTransformFeedbacks:this._webGLVersion>1,textureMaxLevel:this._webGLVersion>1,texture2DArrayMaxLayerCount:this._webGLVersion>1?this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS):128,disableMorphTargetTexture:!1},this._caps.supportFloatTexturesResolve=this._caps.colorBufferFloat,this._caps.rg11b10ufColorRenderable=this._caps.colorBufferFloat,this._glVersion=this._gl.getParameter(this._gl.VERSION);const p=this._gl.getExtension("WEBGL_debug_renderer_info");if(p!=null&&(this._glRenderer=this._gl.getParameter(p.UNMASKED_RENDERER_WEBGL),this._glVendor=this._gl.getParameter(p.UNMASKED_VENDOR_WEBGL)),this._glVendor||(this._glVendor=this._gl.getParameter(this._gl.VENDOR)||"Unknown vendor"),this._glRenderer||(this._glRenderer=this._gl.getParameter(this._gl.RENDERER)||"Unknown renderer"),this._gl.HALF_FLOAT_OES!==36193&&(this._gl.HALF_FLOAT_OES=36193),this._gl.RGBA16F!==34842&&(this._gl.RGBA16F=34842),this._gl.RGBA32F!==34836&&(this._gl.RGBA32F=34836),this._gl.DEPTH24_STENCIL8!==35056&&(this._gl.DEPTH24_STENCIL8=35056),this._caps.timerQuery&&(this._webGLVersion===1&&(this._gl.getQuery=this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)),this._caps.canUseTimestampForTimerQuery=(this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT,this._caps.timerQuery.QUERY_COUNTER_BITS_EXT)??0)>0),this._caps.maxAnisotropy=this._caps.textureAnisotropicFilterExtension?this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,this._caps.textureFloatLinearFiltering=!!(this._caps.textureFloat&&this._gl.getExtension("OES_texture_float_linear")),this._caps.textureFloatRender=!!(this._caps.textureFloat&&this._canRenderToFloatFramebuffer()),this._caps.textureHalfFloatLinearFiltering=!!(this._webGLVersion>1||this._caps.textureHalfFloat&&this._gl.getExtension("OES_texture_half_float_linear")),this._caps.astc&&(this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR),this._caps.bptc&&(this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT=this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT),this._caps.s3tc_srgb&&(this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT,this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT),this._caps.etc2&&(this._gl.COMPRESSED_SRGB8_ETC2=this._caps.etc2.COMPRESSED_SRGB8_ETC2,this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC),this._webGLVersion>1&&this._gl.HALF_FLOAT_OES!==5131&&(this._gl.HALF_FLOAT_OES=5131),this._caps.textureHalfFloatRender=this._caps.textureHalfFloat&&this._canRenderToHalfFloatFramebuffer(),this._webGLVersion>1)this._caps.drawBuffersExtension=!0,this._caps.maxMSAASamples=this._maxMSAASamplesOverride!==null?this._maxMSAASamplesOverride:this._gl.getParameter(this._gl.MAX_SAMPLES);else{const _=this._gl.getExtension("WEBGL_draw_buffers");if(_!==null){this._caps.drawBuffersExtension=!0,this._gl.drawBuffers=_.drawBuffersWEBGL.bind(_),this._gl.DRAW_FRAMEBUFFER=this._gl.FRAMEBUFFER;for(let E=0;E<16;E++)this._gl["COLOR_ATTACHMENT"+E+"_WEBGL"]=_["COLOR_ATTACHMENT"+E+"_WEBGL"]}}if(this._webGLVersion>1)this._caps.depthTextureExtension=!0;else{const _=this._gl.getExtension("WEBGL_depth_texture");_!=null&&(this._caps.depthTextureExtension=!0,this._gl.UNSIGNED_INT_24_8=_.UNSIGNED_INT_24_8_WEBGL)}if(this.disableVertexArrayObjects)this._caps.vertexArrayObject=!1;else if(this._webGLVersion>1)this._caps.vertexArrayObject=!0;else{const _=this._gl.getExtension("OES_vertex_array_object");_!=null&&(this._caps.vertexArrayObject=!0,this._gl.createVertexArray=_.createVertexArrayOES.bind(_),this._gl.bindVertexArray=_.bindVertexArrayOES.bind(_),this._gl.deleteVertexArray=_.deleteVertexArrayOES.bind(_))}if(this._webGLVersion>1)this._caps.instancedArrays=!0;else{const _=this._gl.getExtension("ANGLE_instanced_arrays");_!=null?(this._caps.instancedArrays=!0,this._gl.drawArraysInstanced=_.drawArraysInstancedANGLE.bind(_),this._gl.drawElementsInstanced=_.drawElementsInstancedANGLE.bind(_),this._gl.vertexAttribDivisor=_.vertexAttribDivisorANGLE.bind(_)):this._caps.instancedArrays=!1}if(this._gl.getShaderPrecisionFormat){const _=this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER,this._gl.HIGH_FLOAT),E=this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER,this._gl.HIGH_FLOAT);_&&E&&(this._caps.highPrecisionShaderSupported=_.precision!==0&&E.precision!==0)}if(this._webGLVersion>1)this._caps.blendMinMax=!0;else{const _=this._gl.getExtension("EXT_blend_minmax");_!=null&&(this._caps.blendMinMax=!0,this._gl.MAX=_.MAX_EXT,this._gl.MIN=_.MIN_EXT)}if(!this._caps.supportSRGBBuffers){if(this._webGLVersion>1)this._caps.supportSRGBBuffers=!0,this._glSRGBExtensionValues={SRGB:WebGL2RenderingContext.SRGB,SRGB8:WebGL2RenderingContext.SRGB8,SRGB8_ALPHA8:WebGL2RenderingContext.SRGB8_ALPHA8};else{const _=this._gl.getExtension("EXT_sRGB");_!=null&&(this._caps.supportSRGBBuffers=!0,this._glSRGBExtensionValues={SRGB:_.SRGB_EXT,SRGB8:_.SRGB_ALPHA_EXT,SRGB8_ALPHA8:_.SRGB_ALPHA_EXT})}this._caps.supportSRGBBuffers=this._caps.supportSRGBBuffers&&!!(this._creationOptions&&this._creationOptions.forceSRGBBufferSupportState)}this._depthCullingState.depthTest=!0,this._depthCullingState.depthFunc=this._gl.LEQUAL,this._depthCullingState.depthMask=!0,this._maxSimultaneousTextures=this._caps.maxCombinedTexturesImageUnits;for(let _=0;_<this._maxSimultaneousTextures;_++)this._nextFreeTextureSlots.push(_);this._glRenderer==="Mali-G72"&&(this._caps.disableMorphTargetTexture=!0)}_initFeatures(){this._features={forceBitmapOverHTMLImageElement:typeof HTMLImageElement>"u",supportRenderAndCopyToLodForFloatTextures:this._webGLVersion!==1,supportDepthStencilTexture:this._webGLVersion!==1,supportShadowSamplers:this._webGLVersion!==1,uniformBufferHardCheckMatrix:!1,allowTexturePrefiltering:this._webGLVersion!==1,trackUbosInFrame:!1,checkUbosContentBeforeUpload:!1,supportCSM:this._webGLVersion!==1,basisNeedsPOT:this._webGLVersion===1,support3DTextures:this._webGLVersion!==1,needTypeSuffixInShaderConstants:this._webGLVersion!==1,supportMSAA:this._webGLVersion!==1,supportSSAO2:this._webGLVersion!==1,supportExtendedTextureFormats:this._webGLVersion!==1,supportSwitchCaseInShader:this._webGLVersion!==1,supportSyncTextureRead:!0,needsInvertingBitmap:!0,useUBOBindingCache:!0,needShaderCodeInlining:!1,needToAlwaysBindUniformBuffers:!1,supportRenderPasses:!1,supportSpriteInstancing:!0,forceVertexBufferStrideMultiple4Bytes:!1,_collectUbosUpdatedInFrame:!1}}get webGLVersion(){return this._webGLVersion}getClassName(){return"ThinEngine"}get isStencilEnable(){return this._isStencilEnable}_prepareWorkingCanvas(){if(this._workingCanvas)return;this._workingCanvas=this.createCanvas(1,1);const p=this._workingCanvas.getContext("2d");p&&(this._workingContext=p)}resetTextureCache(){for(const p in this._boundTexturesCache)Object.prototype.hasOwnProperty.call(this._boundTexturesCache,p)&&(this._boundTexturesCache[p]=null);this._currentTextureChannel=-1}getInfo(){return this.getGlInfo()}getGlInfo(){return{vendor:this._glVendor,renderer:this._glRenderer,version:this._glVersion}}setHardwareScalingLevel(p){this._hardwareScalingLevel=p,this.resize()}getHardwareScalingLevel(){return this._hardwareScalingLevel}getLoadedTexturesCache(){return this._internalTexturesCache}getCaps(){return this._caps}stopRenderLoop(p){if(!p){this._activeRenderLoops.length=0,this._cancelFrame();return}const _=this._activeRenderLoops.indexOf(p);_>=0&&(this._activeRenderLoops.splice(_,1),this._activeRenderLoops.length==0&&this._cancelFrame())}_cancelFrame(){if(this._renderingQueueLaunched&&this._frameHandler){if(this._renderingQueueLaunched=!1,va()){const{cancelAnimationFrame:p}=this.getHostWindow()||window;if(typeof p=="function")return p(this._frameHandler)}else if(typeof cancelAnimationFrame=="function")return cancelAnimationFrame(this._frameHandler);return clearTimeout(this._frameHandler)}}_renderLoop(){if(!this._contextWasLost){let p=!0;if((this._isDisposed||!this.renderEvenInBackground&&this._windowIsBackground)&&(p=!1),p){this.beginFrame();for(let _=0;_<this._activeRenderLoops.length;_++){const E=this._activeRenderLoops[_];E()}this.endFrame()}}this._activeRenderLoops.length>0?this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow()):this._renderingQueueLaunched=!1}getRenderingCanvas(){return this._renderingCanvas}getAudioContext(){return this._audioContext}getAudioDestination(){return this._audioDestination}getHostWindow(){return va()?this._renderingCanvas&&this._renderingCanvas.ownerDocument&&this._renderingCanvas.ownerDocument.defaultView?this._renderingCanvas.ownerDocument.defaultView:window:null}getRenderWidth(p=!1){return!p&&this._currentRenderTarget?this._currentRenderTarget.width:this._framebufferDimensionsObject?this._framebufferDimensionsObject.framebufferWidth:this._gl.drawingBufferWidth}getRenderHeight(p=!1){return!p&&this._currentRenderTarget?this._currentRenderTarget.height:this._framebufferDimensionsObject?this._framebufferDimensionsObject.framebufferHeight:this._gl.drawingBufferHeight}_queueNewFrame(p,_){return sr.QueueNewFrame(p,_)}runRenderLoop(p){this._activeRenderLoops.indexOf(p)===-1&&(this._activeRenderLoops.push(p),this._renderingQueueLaunched||(this._renderingQueueLaunched=!0,this._boundRenderFunction=()=>this._renderLoop(),this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow())))}clear(p,_,E,I=!1){const Z=this.stencilStateComposer.useStencilGlobalOnly;this.stencilStateComposer.useStencilGlobalOnly=!0,this.applyStates(),this.stencilStateComposer.useStencilGlobalOnly=Z;let re=0;if(_&&p){let ae=!0;if(this._currentRenderTarget){const he=this._currentRenderTarget.texture?.format;if(he===8||he===9||he===10||he===11){const _e=this._currentRenderTarget.texture?.type;_e===7||_e===5?(sr._TempClearColorUint32[0]=p.r*255,sr._TempClearColorUint32[1]=p.g*255,sr._TempClearColorUint32[2]=p.b*255,sr._TempClearColorUint32[3]=p.a*255,this._gl.clearBufferuiv(this._gl.COLOR,0,sr._TempClearColorUint32),ae=!1):(sr._TempClearColorInt32[0]=p.r*255,sr._TempClearColorInt32[1]=p.g*255,sr._TempClearColorInt32[2]=p.b*255,sr._TempClearColorInt32[3]=p.a*255,this._gl.clearBufferiv(this._gl.COLOR,0,sr._TempClearColorInt32),ae=!1)}}ae&&(this._gl.clearColor(p.r,p.g,p.b,p.a!==void 0?p.a:1),re|=this._gl.COLOR_BUFFER_BIT)}E&&(this.useReverseDepthBuffer?(this._depthCullingState.depthFunc=this._gl.GEQUAL,this._gl.clearDepth(0)):this._gl.clearDepth(1),re|=this._gl.DEPTH_BUFFER_BIT),I&&(this._gl.clearStencil(0),re|=this._gl.STENCIL_BUFFER_BIT),this._gl.clear(re)}_viewport(p,_,E,I){(p!==this._viewportCached.x||_!==this._viewportCached.y||E!==this._viewportCached.z||I!==this._viewportCached.w)&&(this._viewportCached.x=p,this._viewportCached.y=_,this._viewportCached.z=E,this._viewportCached.w=I,this._gl.viewport(p,_,E,I))}setViewport(p,_,E){const I=_||this.getRenderWidth(),Z=E||this.getRenderHeight(),re=p.x||0,ae=p.y||0;this._cachedViewport=p,this._viewport(re*I,ae*Z,I*p.width,Z*p.height)}beginFrame(){}endFrame(){this._badOS&&this.flushFramebuffer(),this._frameId++}resize(p=!1){let _,E;if(this.adaptToDeviceRatio){const I=va()&&window.devicePixelRatio||1,Z=this._lastDevicePixelRatio/I;this._lastDevicePixelRatio=I,this._hardwareScalingLevel*=Z}if(va()&&no())if(this._renderingCanvas){const I=this._renderingCanvas.getBoundingClientRect?this._renderingCanvas.getBoundingClientRect():{width:this._renderingCanvas.width*this._hardwareScalingLevel,height:this._renderingCanvas.height*this._hardwareScalingLevel};_=this._renderingCanvas.clientWidth||I.width||this._renderingCanvas.width||100,E=this._renderingCanvas.clientHeight||I.height||this._renderingCanvas.height||100}else _=window.innerWidth,E=window.innerHeight;else _=this._renderingCanvas?this._renderingCanvas.width:100,E=this._renderingCanvas?this._renderingCanvas.height:100;this.setSize(_/this._hardwareScalingLevel,E/this._hardwareScalingLevel,p)}setSize(p,_,E=!1){return!this._renderingCanvas||(p=p|0,_=_|0,!E&&this._renderingCanvas.width===p&&this._renderingCanvas.height===_)?!1:(this._renderingCanvas.width=p,this._renderingCanvas.height=_,!0)}bindFramebuffer(p,_=0,E,I,Z,re=0,ae=0){const he=p;this._currentRenderTarget&&this.unBindFramebuffer(this._currentRenderTarget),this._currentRenderTarget=p,this._bindUnboundFramebuffer(he._MSAAFramebuffer?he._MSAAFramebuffer:he._framebuffer);const _e=this._gl;p.isMulti||(p.is2DArray?_e.framebufferTextureLayer(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,p.texture._hardwareTexture?.underlyingResource,re,ae):p.isCube?_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_CUBE_MAP_POSITIVE_X+_,p.texture._hardwareTexture?.underlyingResource,re):he._currentLOD!==re&&(_e.framebufferTexture2D(_e.FRAMEBUFFER,_e.COLOR_ATTACHMENT0,_e.TEXTURE_2D,p.texture._hardwareTexture?.underlyingResource,re),he._currentLOD=re));const ve=p._depthStencilTexture;if(ve){const Le=p._depthStencilTextureWithStencil?_e.DEPTH_STENCIL_ATTACHMENT:_e.DEPTH_ATTACHMENT;p.is2DArray?_e.framebufferTextureLayer(_e.FRAMEBUFFER,Le,ve._hardwareTexture?.underlyingResource,re,ae):p.isCube?_e.framebufferTexture2D(_e.FRAMEBUFFER,Le,_e.TEXTURE_CUBE_MAP_POSITIVE_X+_,ve._hardwareTexture?.underlyingResource,re):_e.framebufferTexture2D(_e.FRAMEBUFFER,Le,_e.TEXTURE_2D,ve._hardwareTexture?.underlyingResource,re)}this._cachedViewport&&!Z?this.setViewport(this._cachedViewport,E,I):(E||(E=p.width,re&&(E=E/Math.pow(2,re))),I||(I=p.height,re&&(I=I/Math.pow(2,re))),this._viewport(0,0,E,I)),this.wipeCaches()}setState(p,_=0,E,I=!1,Z,re,ae=0){(this._depthCullingState.cull!==p||E)&&(this._depthCullingState.cull=p);const he=this.cullBackFaces??Z??!0?this._gl.BACK:this._gl.FRONT;(this._depthCullingState.cullFace!==he||E)&&(this._depthCullingState.cullFace=he),this.setZOffset(_),this.setZOffsetUnits(ae);const _e=I?this._gl.CW:this._gl.CCW;(this._depthCullingState.frontFace!==_e||E)&&(this._depthCullingState.frontFace=_e),this._stencilStateComposer.stencilMaterial=re}getDepthBuffer(){return this._depthCullingState.depthTest}setDepthBuffer(p){this._depthCullingState.depthTest=p}setZOffset(p){this._depthCullingState.zOffset=this.useReverseDepthBuffer?-p:p}getZOffset(){const p=this._depthCullingState.zOffset;return this.useReverseDepthBuffer?-p:p}setZOffsetUnits(p){this._depthCullingState.zOffsetUnits=this.useReverseDepthBuffer?-p:p}getZOffsetUnits(){const p=this._depthCullingState.zOffsetUnits;return this.useReverseDepthBuffer?-p:p}_bindUnboundFramebuffer(p){this._currentFramebuffer!==p&&(this._gl.bindFramebuffer(this._gl.FRAMEBUFFER,p),this._currentFramebuffer=p)}_currentFrameBufferIsDefaultFrameBuffer(){return this._currentFramebuffer===null}generateMipmaps(p){this._bindTextureDirectly(this._gl.TEXTURE_2D,p,!0),this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null)}unBindFramebuffer(p,_=!1,E){const I=p;this._currentRenderTarget=null;const Z=this._gl;if(I._MSAAFramebuffer){if(p.isMulti){this.unBindMultiColorAttachmentFramebuffer(p,_,E);return}Z.bindFramebuffer(Z.READ_FRAMEBUFFER,I._MSAAFramebuffer),Z.bindFramebuffer(Z.DRAW_FRAMEBUFFER,I._framebuffer),Z.blitFramebuffer(0,0,p.width,p.height,0,0,p.width,p.height,Z.COLOR_BUFFER_BIT,Z.NEAREST)}p.texture?.generateMipMaps&&!_&&!p.isCube&&this.generateMipmaps(p.texture),E&&(I._MSAAFramebuffer&&this._bindUnboundFramebuffer(I._framebuffer),E()),this._bindUnboundFramebuffer(null)}flushFramebuffer(){this._gl.flush()}restoreDefaultFramebuffer(){this._currentRenderTarget?this.unBindFramebuffer(this._currentRenderTarget):this._bindUnboundFramebuffer(null),this._cachedViewport&&this.setViewport(this._cachedViewport),this.wipeCaches()}_resetVertexBufferBinding(){this.bindArrayBuffer(null),this._cachedVertexBuffers=null}createVertexBuffer(p,_,E){return this._createVertexBuffer(p,this._gl.STATIC_DRAW)}_createVertexBuffer(p,_){const E=this._gl.createBuffer();if(!E)throw new Error("Unable to create vertex buffer");const I=new Gx(E);return this.bindArrayBuffer(I),typeof p!="number"?p instanceof Array?(this._gl.bufferData(this._gl.ARRAY_BUFFER,new Float32Array(p),_),I.capacity=p.length*4):(this._gl.bufferData(this._gl.ARRAY_BUFFER,p,_),I.capacity=p.byteLength):(this._gl.bufferData(this._gl.ARRAY_BUFFER,new Uint8Array(p),_),I.capacity=p),this._resetVertexBufferBinding(),I.references=1,I}createDynamicVertexBuffer(p,_){return this._createVertexBuffer(p,this._gl.DYNAMIC_DRAW)}_resetIndexBufferBinding(){this.bindIndexBuffer(null),this._cachedIndexBuffer=null}createIndexBuffer(p,_,E){const I=this._gl.createBuffer(),Z=new Gx(I);if(!I)throw new Error("Unable to create index buffer");this.bindIndexBuffer(Z);const re=this._normalizeIndexData(p);return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER,re,_?this._gl.DYNAMIC_DRAW:this._gl.STATIC_DRAW),this._resetIndexBufferBinding(),Z.references=1,Z.is32Bits=re.BYTES_PER_ELEMENT===4,Z}_normalizeIndexData(p){if(p.BYTES_PER_ELEMENT===2)return p;if(this._caps.uintIndices){if(p instanceof Uint32Array)return p;for(let E=0;E<p.length;E++)if(p[E]>=65535)return new Uint32Array(p);return new Uint16Array(p)}return new Uint16Array(p)}bindArrayBuffer(p){this._vaoRecordInProgress||this._unbindVertexArrayObject(),this._bindBuffer(p,this._gl.ARRAY_BUFFER)}bindUniformBlock(p,_,E){const I=p.program,Z=this._gl.getUniformBlockIndex(I,_);this._gl.uniformBlockBinding(I,Z,E)}bindIndexBuffer(p){this._vaoRecordInProgress||this._unbindVertexArrayObject(),this._bindBuffer(p,this._gl.ELEMENT_ARRAY_BUFFER)}_bindBuffer(p,_){(this._vaoRecordInProgress||this._currentBoundBuffer[_]!==p)&&(this._gl.bindBuffer(_,p?p.underlyingResource:null),this._currentBoundBuffer[_]=p)}updateArrayBuffer(p){this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,p)}_vertexAttribPointer(p,_,E,I,Z,re,ae){const he=this._currentBufferPointers[_];if(!he)return;let _e=!1;he.active?(he.buffer!==p&&(he.buffer=p,_e=!0),he.size!==E&&(he.size=E,_e=!0),he.type!==I&&(he.type=I,_e=!0),he.normalized!==Z&&(he.normalized=Z,_e=!0),he.stride!==re&&(he.stride=re,_e=!0),he.offset!==ae&&(he.offset=ae,_e=!0)):(_e=!0,he.active=!0,he.index=_,he.size=E,he.type=I,he.normalized=Z,he.stride=re,he.offset=ae,he.buffer=p),(_e||this._vaoRecordInProgress)&&(this.bindArrayBuffer(p),I===this._gl.UNSIGNED_INT||I===this._gl.INT?this._gl.vertexAttribIPointer(_,E,I,re,ae):this._gl.vertexAttribPointer(_,E,I,Z,re,ae))}_bindIndexBufferWithCache(p){p!=null&&this._cachedIndexBuffer!==p&&(this._cachedIndexBuffer=p,this.bindIndexBuffer(p),this._uintIndicesCurrentlySet=p.is32Bits)}_bindVertexBuffersAttributes(p,_,E){const I=_.getAttributesNames();this._vaoRecordInProgress||this._unbindVertexArrayObject(),this.unbindAllAttributes();for(let Z=0;Z<I.length;Z++){const re=_.getAttributeLocation(Z);if(re>=0){const ae=I[Z];let he=null;if(E&&(he=E[ae]),he||(he=p[ae]),!he)continue;this._gl.enableVertexAttribArray(re),this._vaoRecordInProgress||(this._vertexAttribArraysEnabled[re]=!0);const _e=he.getBuffer();_e&&(this._vertexAttribPointer(_e,re,he.getSize(),he.type,he.normalized,he.byteStride,he.byteOffset),he.getIsInstanced()&&(this._gl.vertexAttribDivisor(re,he.getInstanceDivisor()),this._vaoRecordInProgress||(this._currentInstanceLocations.push(re),this._currentInstanceBuffers.push(_e))))}}}recordVertexArrayObject(p,_,E,I){const Z=this._gl.createVertexArray();if(!Z)throw new Error("Unable to create VAO");return this._vaoRecordInProgress=!0,this._gl.bindVertexArray(Z),this._mustWipeVertexAttributes=!0,this._bindVertexBuffersAttributes(p,E,I),this.bindIndexBuffer(_),this._vaoRecordInProgress=!1,this._gl.bindVertexArray(null),Z}bindVertexArrayObject(p,_){this._cachedVertexArrayObject!==p&&(this._cachedVertexArrayObject=p,this._gl.bindVertexArray(p),this._cachedVertexBuffers=null,this._cachedIndexBuffer=null,this._uintIndicesCurrentlySet=_!=null&&_.is32Bits,this._mustWipeVertexAttributes=!0)}bindBuffersDirectly(p,_,E,I,Z){if(this._cachedVertexBuffers!==p||this._cachedEffectForVertexBuffers!==Z){this._cachedVertexBuffers=p,this._cachedEffectForVertexBuffers=Z;const re=Z.getAttributesCount();this._unbindVertexArrayObject(),this.unbindAllAttributes();let ae=0;for(let he=0;he<re;he++)if(he<E.length){const _e=Z.getAttributeLocation(he);_e>=0&&(this._gl.enableVertexAttribArray(_e),this._vertexAttribArraysEnabled[_e]=!0,this._vertexAttribPointer(p,_e,E[he],this._gl.FLOAT,!1,I,ae)),ae+=E[he]*4}}this._bindIndexBufferWithCache(_)}_unbindVertexArrayObject(){this._cachedVertexArrayObject&&(this._cachedVertexArrayObject=null,this._gl.bindVertexArray(null))}bindBuffers(p,_,E,I){(this._cachedVertexBuffers!==p||this._cachedEffectForVertexBuffers!==E)&&(this._cachedVertexBuffers=p,this._cachedEffectForVertexBuffers=E,this._bindVertexBuffersAttributes(p,E,I)),this._bindIndexBufferWithCache(_)}unbindInstanceAttributes(){let p;for(let _=0,E=this._currentInstanceLocations.length;_<E;_++){const I=this._currentInstanceBuffers[_];p!=I&&I.references&&(p=I,this.bindArrayBuffer(I));const Z=this._currentInstanceLocations[_];this._gl.vertexAttribDivisor(Z,0)}this._currentInstanceBuffers.length=0,this._currentInstanceLocations.length=0}releaseVertexArrayObject(p){this._gl.deleteVertexArray(p)}_releaseBuffer(p){return p.references--,p.references===0?(this._deleteBuffer(p),!0):!1}_deleteBuffer(p){this._gl.deleteBuffer(p.underlyingResource)}updateAndBindInstancesBuffer(p,_,E){if(this.bindArrayBuffer(p),_&&this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,_),E[0].index!==void 0)this.bindInstancesBuffer(p,E,!0);else for(let I=0;I<4;I++){const Z=E[I];this._vertexAttribArraysEnabled[Z]||(this._gl.enableVertexAttribArray(Z),this._vertexAttribArraysEnabled[Z]=!0),this._vertexAttribPointer(p,Z,4,this._gl.FLOAT,!1,64,I*16),this._gl.vertexAttribDivisor(Z,1),this._currentInstanceLocations.push(Z),this._currentInstanceBuffers.push(p)}}bindInstancesBuffer(p,_,E=!0){this.bindArrayBuffer(p);let I=0;if(E)for(let Z=0;Z<_.length;Z++){const re=_[Z];I+=re.attributeSize*4}for(let Z=0;Z<_.length;Z++){const re=_[Z];re.index===void 0&&(re.index=this._currentEffect.getAttributeLocationByName(re.attributeName)),!(re.index<0)&&(this._vertexAttribArraysEnabled[re.index]||(this._gl.enableVertexAttribArray(re.index),this._vertexAttribArraysEnabled[re.index]=!0),this._vertexAttribPointer(p,re.index,re.attributeSize,re.attributeType||this._gl.FLOAT,re.normalized||!1,I,re.offset),this._gl.vertexAttribDivisor(re.index,re.divisor===void 0?1:re.divisor),this._currentInstanceLocations.push(re.index),this._currentInstanceBuffers.push(p))}}disableInstanceAttributeByName(p){if(!this._currentEffect)return;const _=this._currentEffect.getAttributeLocationByName(p);this.disableInstanceAttribute(_)}disableInstanceAttribute(p){let _=!1,E;for(;(E=this._currentInstanceLocations.indexOf(p))!==-1;)this._currentInstanceLocations.splice(E,1),this._currentInstanceBuffers.splice(E,1),_=!0,E=this._currentInstanceLocations.indexOf(p);_&&(this._gl.vertexAttribDivisor(p,0),this.disableAttributeByIndex(p))}disableAttributeByIndex(p){this._gl.disableVertexAttribArray(p),this._vertexAttribArraysEnabled[p]=!1,this._currentBufferPointers[p].active=!1}draw(p,_,E,I){this.drawElementsType(p?0:1,_,E,I)}drawPointClouds(p,_,E){this.drawArraysType(2,p,_,E)}drawUnIndexed(p,_,E,I){this.drawArraysType(p?0:1,_,E,I)}drawElementsType(p,_,E,I){this.applyStates(),this._reportDrawCall();const Z=this._drawMode(p),re=this._uintIndicesCurrentlySet?this._gl.UNSIGNED_INT:this._gl.UNSIGNED_SHORT,ae=this._uintIndicesCurrentlySet?4:2;I?this._gl.drawElementsInstanced(Z,E,re,_*ae,I):this._gl.drawElements(Z,E,re,_*ae)}drawArraysType(p,_,E,I){this.applyStates(),this._reportDrawCall();const Z=this._drawMode(p);I?this._gl.drawArraysInstanced(Z,_,E,I):this._gl.drawArrays(Z,_,E)}_drawMode(p){switch(p){case 0:return this._gl.TRIANGLES;case 2:return this._gl.POINTS;case 1:return this._gl.LINES;case 3:return this._gl.POINTS;case 4:return this._gl.LINES;case 5:return this._gl.LINE_LOOP;case 6:return this._gl.LINE_STRIP;case 7:return this._gl.TRIANGLE_STRIP;case 8:return this._gl.TRIANGLE_FAN;default:return this._gl.TRIANGLES}}_reportDrawCall(){}_releaseEffect(p){this._compiledEffects[p._key]&&delete this._compiledEffects[p._key];const _=p.getPipelineContext();_&&this._deletePipelineContext(_)}_deletePipelineContext(p){const _=p;_&&_.program&&(_.program.__SPECTOR_rebuildProgram=null,this._gl.deleteProgram(_.program))}_getGlobalDefines(p){if(p){this.isNDCHalfZRange?p.IS_NDC_HALF_ZRANGE="":delete p.IS_NDC_HALF_ZRANGE,this.useReverseDepthBuffer?p.USE_REVERSE_DEPTHBUFFER="":delete p.USE_REVERSE_DEPTHBUFFER,this.useExactSrgbConversions?p.USE_EXACT_SRGB_CONVERSIONS="":delete p.USE_EXACT_SRGB_CONVERSIONS;return}else{let _="";return this.isNDCHalfZRange&&(_+="#define IS_NDC_HALF_ZRANGE"),this.useReverseDepthBuffer&&(_&&(_+=`
`),_+="#define USE_REVERSE_DEPTHBUFFER"),this.useExactSrgbConversions&&(_&&(_+=`
`),_+="#define USE_EXACT_SRGB_CONVERSIONS"),_}}createEffect(p,_,E,I,Z,re,ae,he,_e,ve=Wa.GLSL){const Le=p.vertexElement||p.vertex||p.vertexToken||p.vertexSource||p,ze=p.fragmentElement||p.fragment||p.fragmentToken||p.fragmentSource||p,He=this._getGlobalDefines();let xt=Z??_.defines??"";He&&(xt+=He);const rt=Le+"+"+ze+"@"+xt;if(this._compiledEffects[rt]){const Lt=this._compiledEffects[rt];return ae&&Lt.isReady()&&ae(Lt),Lt}const Tt=new _a(p,_,E,I,this,Z,re,ae,he,_e,rt,ve);return this._compiledEffects[rt]=Tt,Tt}static _ConcatenateShader(p,_,E=""){return E+(_?_+`
`:"")+p}_compileShader(p,_,E,I){return this._compileRawShader(sr._ConcatenateShader(p,E,I),_)}_compileRawShader(p,_){const E=this._gl,I=E.createShader(_==="vertex"?E.VERTEX_SHADER:E.FRAGMENT_SHADER);if(!I){let Z=E.NO_ERROR,re=E.NO_ERROR;for(;(re=E.getError())!==E.NO_ERROR;)Z=re;throw new Error(`Something went wrong while creating a gl ${_} shader object. gl error=${Z}, gl isContextLost=${E.isContextLost()}, _contextWasLost=${this._contextWasLost}`)}return E.shaderSource(I,p),E.compileShader(I),I}_getShaderSource(p){return this._gl.getShaderSource(p)}createRawShaderProgram(p,_,E,I,Z=null){I=I||this._gl;const re=this._compileRawShader(_,"vertex"),ae=this._compileRawShader(E,"fragment");return this._createShaderProgram(p,re,ae,I,Z)}createShaderProgram(p,_,E,I,Z,re=null){Z=Z||this._gl;const ae=this._webGLVersion>1?`#version 300 es
#define WEBGL2 
`:"",he=this._compileShader(_,"vertex",I,ae),_e=this._compileShader(E,"fragment",I,ae);return this._createShaderProgram(p,he,_e,Z,re)}inlineShaderCode(p){return p}createPipelineContext(p){const _=new zl;return _.engine=this,this._caps.parallelShaderCompile&&(_.isParallelCompiled=!0),_}createMaterialContext(){}createDrawContext(){}_createShaderProgram(p,_,E,I,Z=null){const re=I.createProgram();if(p.program=re,!re)throw new Error("Unable to create program");return I.attachShader(re,_),I.attachShader(re,E),I.linkProgram(re),p.context=I,p.vertexShader=_,p.fragmentShader=E,p.isParallelCompiled||this._finalizePipelineContext(p),re}_finalizePipelineContext(p){const _=p.context,E=p.vertexShader,I=p.fragmentShader,Z=p.program;if(!_.getProgramParameter(Z,_.LINK_STATUS)){if(!this._gl.getShaderParameter(E,this._gl.COMPILE_STATUS)){const he=this._gl.getShaderInfoLog(E);if(he)throw p.vertexCompilationError=he,new Error("VERTEX SHADER "+he)}if(!this._gl.getShaderParameter(I,this._gl.COMPILE_STATUS)){const he=this._gl.getShaderInfoLog(I);if(he)throw p.fragmentCompilationError=he,new Error("FRAGMENT SHADER "+he)}const ae=_.getProgramInfoLog(Z);if(ae)throw p.programLinkError=ae,new Error(ae)}if(this.validateShaderPrograms&&(_.validateProgram(Z),!_.getProgramParameter(Z,_.VALIDATE_STATUS))){const he=_.getProgramInfoLog(Z);if(he)throw p.programValidationError=he,new Error(he)}_.deleteShader(E),_.deleteShader(I),p.vertexShader=void 0,p.fragmentShader=void 0,p.onCompiled&&(p.onCompiled(),p.onCompiled=void 0)}_preparePipelineContext(p,_,E,I,Z,re,ae,he,_e,ve){const Le=p;I?Le.program=this.createRawShaderProgram(Le,_,E,void 0,_e):Le.program=this.createShaderProgram(Le,_,E,he,void 0,_e),Le.program.__SPECTOR_rebuildProgram=ae}_isRenderingStateCompiled(p){const _=p;return this._isDisposed||_._isDisposed?!1:this._gl.getProgramParameter(_.program,this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)?(this._finalizePipelineContext(_),!0):!1}_executeWhenRenderingStateIsCompiled(p,_){const E=p;if(!E.isParallelCompiled){_();return}const I=E.onCompiled;I?E.onCompiled=()=>{I(),_()}:E.onCompiled=_}getUniforms(p,_){const E=new Array,I=p;for(let Z=0;Z<_.length;Z++)E.push(this._gl.getUniformLocation(I.program,_[Z]));return E}getAttributes(p,_){const E=[],I=p;for(let Z=0;Z<_.length;Z++)try{E.push(this._gl.getAttribLocation(I.program,_[Z]))}catch{E.push(-1)}return E}enableEffect(p){p=p!==null&&xo.IsWrapper(p)?p.effect:p,!(!p||p===this._currentEffect)&&(this._stencilStateComposer.stencilMaterial=void 0,p=p,this.bindSamplers(p),this._currentEffect=p,p.onBind&&p.onBind(p),p._onBindObservable&&p._onBindObservable.notifyObservers(p))}setInt(p,_){return p?(this._gl.uniform1i(p,_),!0):!1}setInt2(p,_,E){return p?(this._gl.uniform2i(p,_,E),!0):!1}setInt3(p,_,E,I){return p?(this._gl.uniform3i(p,_,E,I),!0):!1}setInt4(p,_,E,I,Z){return p?(this._gl.uniform4i(p,_,E,I,Z),!0):!1}setIntArray(p,_){return p?(this._gl.uniform1iv(p,_),!0):!1}setIntArray2(p,_){return!p||_.length%2!==0?!1:(this._gl.uniform2iv(p,_),!0)}setIntArray3(p,_){return!p||_.length%3!==0?!1:(this._gl.uniform3iv(p,_),!0)}setIntArray4(p,_){return!p||_.length%4!==0?!1:(this._gl.uniform4iv(p,_),!0)}setUInt(p,_){return p?(this._gl.uniform1ui(p,_),!0):!1}setUInt2(p,_,E){return p?(this._gl.uniform2ui(p,_,E),!0):!1}setUInt3(p,_,E,I){return p?(this._gl.uniform3ui(p,_,E,I),!0):!1}setUInt4(p,_,E,I,Z){return p?(this._gl.uniform4ui(p,_,E,I,Z),!0):!1}setUIntArray(p,_){return p?(this._gl.uniform1uiv(p,_),!0):!1}setUIntArray2(p,_){return!p||_.length%2!==0?!1:(this._gl.uniform2uiv(p,_),!0)}setUIntArray3(p,_){return!p||_.length%3!==0?!1:(this._gl.uniform3uiv(p,_),!0)}setUIntArray4(p,_){return!p||_.length%4!==0?!1:(this._gl.uniform4uiv(p,_),!0)}setArray(p,_){return!p||_.length<1?!1:(this._gl.uniform1fv(p,_),!0)}setArray2(p,_){return!p||_.length%2!==0?!1:(this._gl.uniform2fv(p,_),!0)}setArray3(p,_){return!p||_.length%3!==0?!1:(this._gl.uniform3fv(p,_),!0)}setArray4(p,_){return!p||_.length%4!==0?!1:(this._gl.uniform4fv(p,_),!0)}setMatrices(p,_){return p?(this._gl.uniformMatrix4fv(p,!1,_),!0):!1}setMatrix3x3(p,_){return p?(this._gl.uniformMatrix3fv(p,!1,_),!0):!1}setMatrix2x2(p,_){return p?(this._gl.uniformMatrix2fv(p,!1,_),!0):!1}setFloat(p,_){return p?(this._gl.uniform1f(p,_),!0):!1}setFloat2(p,_,E){return p?(this._gl.uniform2f(p,_,E),!0):!1}setFloat3(p,_,E,I){return p?(this._gl.uniform3f(p,_,E,I),!0):!1}setFloat4(p,_,E,I,Z){return p?(this._gl.uniform4f(p,_,E,I,Z),!0):!1}applyStates(){if(this._depthCullingState.apply(this._gl),this._stencilStateComposer.apply(this._gl),this._alphaState.apply(this._gl),this._colorWriteChanged){this._colorWriteChanged=!1;const p=this._colorWrite;this._gl.colorMask(p,p,p,p)}}setColorWrite(p){p!==this._colorWrite&&(this._colorWriteChanged=!0,this._colorWrite=p)}getColorWrite(){return this._colorWrite}get depthCullingState(){return this._depthCullingState}get alphaState(){return this._alphaState}get stencilState(){return this._stencilState}get stencilStateComposer(){return this._stencilStateComposer}clearInternalTexturesCache(){this._internalTexturesCache.length=0}wipeCaches(p){this.preventCacheWipeBetweenFrames&&!p||(this._currentEffect=null,this._viewportCached.x=0,this._viewportCached.y=0,this._viewportCached.z=0,this._viewportCached.w=0,this._unbindVertexArrayObject(),p&&(this._currentProgram=null,this.resetTextureCache(),this._stencilStateComposer.reset(),this._depthCullingState.reset(),this._depthCullingState.depthFunc=this._gl.LEQUAL,this._alphaState.reset(),this._alphaMode=1,this._alphaEquation=0,this._colorWrite=!0,this._colorWriteChanged=!0,this._unpackFlipYCached=null,this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,this._gl.NONE),this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,0),this._mustWipeVertexAttributes=!0,this.unbindAllAttributes()),this._resetVertexBufferBinding(),this._cachedIndexBuffer=null,this._cachedEffectForVertexBuffers=null,this.bindIndexBuffer(null))}_getSamplingParameters(p,_){const E=this._gl;let I=E.NEAREST,Z=E.NEAREST;switch(p){case 11:I=E.LINEAR,_?Z=E.LINEAR_MIPMAP_NEAREST:Z=E.LINEAR;break;case 3:I=E.LINEAR,_?Z=E.LINEAR_MIPMAP_LINEAR:Z=E.LINEAR;break;case 8:I=E.NEAREST,_?Z=E.NEAREST_MIPMAP_LINEAR:Z=E.NEAREST;break;case 4:I=E.NEAREST,_?Z=E.NEAREST_MIPMAP_NEAREST:Z=E.NEAREST;break;case 5:I=E.NEAREST,_?Z=E.LINEAR_MIPMAP_NEAREST:Z=E.LINEAR;break;case 6:I=E.NEAREST,_?Z=E.LINEAR_MIPMAP_LINEAR:Z=E.LINEAR;break;case 7:I=E.NEAREST,Z=E.LINEAR;break;case 1:I=E.NEAREST,Z=E.NEAREST;break;case 9:I=E.LINEAR,_?Z=E.NEAREST_MIPMAP_NEAREST:Z=E.NEAREST;break;case 10:I=E.LINEAR,_?Z=E.NEAREST_MIPMAP_LINEAR:Z=E.NEAREST;break;case 2:I=E.LINEAR,Z=E.LINEAR;break;case 12:I=E.LINEAR,Z=E.NEAREST;break}return{min:Z,mag:I}}_createTexture(){const p=this._gl.createTexture();if(!p)throw new Error("Unable to create texture");return p}_createHardwareTexture(){return new Ko(this._createTexture(),this._gl)}_createInternalTexture(p,_,E=!0,I=kn.Unknown){let Z=!1,re=0,ae=3,he=5,_e=!1,ve=1,Le;_!==void 0&&typeof _=="object"?(Z=!!_.generateMipMaps,re=_.type===void 0?0:_.type,ae=_.samplingMode===void 0?3:_.samplingMode,he=_.format===void 0?5:_.format,_e=_.useSRGBBuffer===void 0?!1:_.useSRGBBuffer,ve=_.samples??1,Le=_.label):Z=!!_,_e&&(_e=this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU)),(re===1&&!this._caps.textureFloatLinearFiltering||re===2&&!this._caps.textureHalfFloatLinearFiltering)&&(ae=1),re===1&&!this._caps.textureFloat&&(re=0,Ti.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));const ze=this._gl,He=new c0(this,I),xt=p.width||p,rt=p.height||p,Tt=p.layers||0,Lt=this._getSamplingParameters(ae,Z),Nt=Tt!==0?ze.TEXTURE_2D_ARRAY:ze.TEXTURE_2D,qt=this._getRGBABufferInternalSizedFormat(re,he,_e),Xt=this._getInternalFormat(he),zt=this._getWebGLTextureType(re);return this._bindTextureDirectly(Nt,He),Tt!==0?(He.is2DArray=!0,ze.texImage3D(Nt,0,qt,xt,rt,Tt,0,Xt,zt,null)):ze.texImage2D(Nt,0,qt,xt,rt,0,Xt,zt,null),ze.texParameteri(Nt,ze.TEXTURE_MAG_FILTER,Lt.mag),ze.texParameteri(Nt,ze.TEXTURE_MIN_FILTER,Lt.min),ze.texParameteri(Nt,ze.TEXTURE_WRAP_S,ze.CLAMP_TO_EDGE),ze.texParameteri(Nt,ze.TEXTURE_WRAP_T,ze.CLAMP_TO_EDGE),Z&&this._gl.generateMipmap(Nt),this._bindTextureDirectly(Nt,null),He._useSRGBBuffer=_e,He.baseWidth=xt,He.baseHeight=rt,He.width=xt,He.height=rt,He.depth=Tt,He.isReady=!0,He.samples=ve,He.generateMipMaps=Z,He.samplingMode=ae,He.type=re,He.format=he,He.label=Le,this._internalTexturesCache.push(He),He}_getUseSRGBBuffer(p,_){return p&&this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU||_)}_createTextureBase(p,_,E,I,Z=3,re=null,ae=null,he,_e,ve=null,Le=null,ze=null,He=null,xt,rt,Tt){p=p||"";const Lt=p.substr(0,5)==="data:",Nt=p.substr(0,5)==="blob:",qt=Lt&&p.indexOf(";base64,")!==-1,Xt=Le||new c0(this,kn.Url);Xt!==Le&&(Xt.label=p.substring(0,60));const zt=p;this._transformTextureUrl&&!qt&&!Le&&!ve&&(p=this._transformTextureUrl(p)),zt!==p&&(Xt._originalUrl=zt);const Gt=p.lastIndexOf(".");let xi=He||(Gt>-1?p.substring(Gt).toLowerCase():""),Gi=null;xi.indexOf("?")>-1&&(xi=xi.split("?")[0]);for(const hn of sr._TextureLoaders)if(hn.canLoad(xi,xt)){Gi=hn;break}I&&I.addPendingData(Xt),Xt.url=p,Xt.generateMipMaps=!_,Xt.samplingMode=Z,Xt.invertY=E,Xt._useSRGBBuffer=this._getUseSRGBBuffer(!!Tt,_),this._doNotHandleContextLost||(Xt._buffer=ve);let ks=null;re&&!Le&&(ks=Xt.onLoadedObservable.add(re)),Le||this._internalTexturesCache.push(Xt);const Ur=(hn,pn)=>{I&&I.removePendingData(Xt),p===zt?(ks&&Xt.onLoadedObservable.remove(ks),Mr.UseFallbackTexture&&p!==Mr.FallbackTexture&&this._createTextureBase(Mr.FallbackTexture,_,Xt.invertY,I,Z,null,ae,he,_e,ve,Xt),hn=(hn||"Unknown error")+(Mr.UseFallbackTexture?" - Fallback texture was used":""),Xt.onErrorObservable.notifyObservers({message:hn,exception:pn}),ae&&ae(hn,pn)):(Ti.Warn(`Failed to load ${p}, falling back to ${zt}`),this._createTextureBase(zt,_,Xt.invertY,I,Z,re,ae,he,_e,ve,Xt,ze,He,xt,rt,Tt))};if(Gi){const hn=pn=>{Gi.loadData(pn,Xt,(_n,x0,Ta,n0,z0,W0)=>{W0?Ur("TextureLoader failed to load data"):he(Xt,xi,I,{width:_n,height:x0},Xt.invertY,!Ta,n0,()=>(z0(),!1),Z)},rt)};ve?ve instanceof ArrayBuffer?hn(new Uint8Array(ve)):ArrayBuffer.isView(ve)?hn(ve):ae&&ae("Unable to load: only ArrayBuffer or ArrayBufferView is supported",null):this._loadFile(p,pn=>hn(new Uint8Array(pn)),void 0,I?I.offlineProvider:void 0,!0,(pn,_n)=>{Ur("Unable to load "+(pn&&pn.responseURL,_n))})}else{const hn=pn=>{Nt&&!this._doNotHandleContextLost&&(Xt._buffer=pn),he(Xt,xi,I,pn,Xt.invertY,_,!1,_e,Z)};!Lt||qt?ve&&(typeof ve.decoding=="string"||ve.close)?hn(ve):sr._FileToolsLoadImage(p,hn,Ur,I?I.offlineProvider:null,xt,Xt.invertY&&this._features.needsInvertingBitmap?{imageOrientation:"flipY"}:void 0):typeof ve=="string"||ve instanceof ArrayBuffer||ArrayBuffer.isView(ve)||ve instanceof Blob?sr._FileToolsLoadImage(ve,hn,Ur,I?I.offlineProvider:null,xt,Xt.invertY&&this._features.needsInvertingBitmap?{imageOrientation:"flipY"}:void 0):ve&&hn(ve)}return Xt}createTexture(p,_,E,I,Z=3,re=null,ae=null,he=null,_e=null,ve=null,Le=null,ze,He,xt,rt){return this._createTextureBase(p,_,E,I,Z,re,ae,this._prepareWebGLTexture.bind(this),(Tt,Lt,Nt,qt,Xt,zt)=>{const Gt=this._gl,xi=Nt.width===Tt&&Nt.height===Lt;Xt._creationFlags=xt??0;const Gi=this._getTexImageParametersForCreateTexture(ve,qt,Xt._useSRGBBuffer);if(xi)return Gt.texImage2D(Gt.TEXTURE_2D,0,Gi.internalFormat,Gi.format,Gi.type,Nt),!1;const vs=this._caps.maxTextureSize;if(Nt.width>vs||Nt.height>vs||!this._supportsHardwareTextureRescaling)return this._prepareWorkingCanvas(),!this._workingCanvas||!this._workingContext||(this._workingCanvas.width=Tt,this._workingCanvas.height=Lt,this._workingContext.drawImage(Nt,0,0,Nt.width,Nt.height,0,0,Tt,Lt),Gt.texImage2D(Gt.TEXTURE_2D,0,Gi.internalFormat,Gi.format,Gi.type,this._workingCanvas),Xt.width=Tt,Xt.height=Lt),!1;{const ks=new c0(this,kn.Temp);this._bindTextureDirectly(Gt.TEXTURE_2D,ks,!0),Gt.texImage2D(Gt.TEXTURE_2D,0,Gi.internalFormat,Gi.format,Gi.type,Nt),this._rescaleTexture(ks,Xt,I,Gi.format,()=>{this._releaseTexture(ks),this._bindTextureDirectly(Gt.TEXTURE_2D,Xt,!0),zt()})}return!0},he,_e,ve,Le,ze,He,rt)}_getTexImageParametersForCreateTexture(p,_,E){p==null&&(p=_===".jpg"&&!E?4:5);let I,Z;return this.webGLVersion===1?(I=this._getInternalFormat(p,E),Z=I):(I=this._getInternalFormat(p,!1),Z=this._getRGBABufferInternalSizedFormat(0,p,E)),{internalFormat:Z,format:I,type:this._gl.UNSIGNED_BYTE}}static _FileToolsLoadImage(p,_,E,I,Z,re){throw ur("FileTools")}_rescaleTexture(p,_,E,I,Z){}createRawTexture(p,_,E,I,Z,re,ae,he=null,_e=0,ve=0,Le=!1){throw ur("Engine.RawTexture")}createRawCubeTexture(p,_,E,I,Z,re,ae,he=null){throw ur("Engine.RawTexture")}createRawTexture3D(p,_,E,I,Z,re,ae,he,_e=null,ve=0){throw ur("Engine.RawTexture")}createRawTexture2DArray(p,_,E,I,Z,re,ae,he,_e=null,ve=0){throw ur("Engine.RawTexture")}_unpackFlipY(p){this._unpackFlipYCached!==p&&(this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL,p?1:0),this.enableUnpackFlipYCached&&(this._unpackFlipYCached=p))}_getUnpackAlignement(){return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT)}_getTextureTarget(p){return p.isCube?this._gl.TEXTURE_CUBE_MAP:p.is3D?this._gl.TEXTURE_3D:p.is2DArray||p.isMultiview?this._gl.TEXTURE_2D_ARRAY:this._gl.TEXTURE_2D}updateTextureSamplingMode(p,_,E=!1){const I=this._getTextureTarget(_),Z=this._getSamplingParameters(p,_.useMipMaps||E);this._setTextureParameterInteger(I,this._gl.TEXTURE_MAG_FILTER,Z.mag,_),this._setTextureParameterInteger(I,this._gl.TEXTURE_MIN_FILTER,Z.min),E&&(_.generateMipMaps=!0,this._gl.generateMipmap(I)),this._bindTextureDirectly(I,null),_.samplingMode=p}updateTextureDimensions(p,_,E,I=1){}updateTextureWrappingMode(p,_,E=null,I=null){const Z=this._getTextureTarget(p);_!==null&&(this._setTextureParameterInteger(Z,this._gl.TEXTURE_WRAP_S,this._getTextureWrapMode(_),p),p._cachedWrapU=_),E!==null&&(this._setTextureParameterInteger(Z,this._gl.TEXTURE_WRAP_T,this._getTextureWrapMode(E),p),p._cachedWrapV=E),(p.is2DArray||p.is3D)&&I!==null&&(this._setTextureParameterInteger(Z,this._gl.TEXTURE_WRAP_R,this._getTextureWrapMode(I),p),p._cachedWrapR=I),this._bindTextureDirectly(Z,null)}_setupDepthStencilTexture(p,_,E,I,Z,re=1){const ae=_.width||_,he=_.height||_,_e=_.layers||0;p.baseWidth=ae,p.baseHeight=he,p.width=ae,p.height=he,p.is2DArray=_e>0,p.depth=_e,p.isReady=!0,p.samples=re,p.generateMipMaps=!1,p.samplingMode=I?2:1,p.type=0,p._comparisonFunction=Z;const ve=this._gl,Le=this._getTextureTarget(p),ze=this._getSamplingParameters(p.samplingMode,!1);ve.texParameteri(Le,ve.TEXTURE_MAG_FILTER,ze.mag),ve.texParameteri(Le,ve.TEXTURE_MIN_FILTER,ze.min),ve.texParameteri(Le,ve.TEXTURE_WRAP_S,ve.CLAMP_TO_EDGE),ve.texParameteri(Le,ve.TEXTURE_WRAP_T,ve.CLAMP_TO_EDGE),this.webGLVersion>1&&(Z===0?(ve.texParameteri(Le,ve.TEXTURE_COMPARE_FUNC,515),ve.texParameteri(Le,ve.TEXTURE_COMPARE_MODE,ve.NONE)):(ve.texParameteri(Le,ve.TEXTURE_COMPARE_FUNC,Z),ve.texParameteri(Le,ve.TEXTURE_COMPARE_MODE,ve.COMPARE_REF_TO_TEXTURE)))}_uploadCompressedDataToTextureDirectly(p,_,E,I,Z,re=0,ae=0){const he=this._gl;let _e=he.TEXTURE_2D;if(p.isCube&&(_e=he.TEXTURE_CUBE_MAP_POSITIVE_X+re),p._useSRGBBuffer)switch(_){case 37492:case 36196:this._caps.etc2?_=he.COMPRESSED_SRGB8_ETC2:p._useSRGBBuffer=!1;break;case 37496:this._caps.etc2?_=he.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:p._useSRGBBuffer=!1;break;case 36492:_=he.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;break;case 37808:_=he.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;break;case 33776:this._caps.s3tc_srgb?_=he.COMPRESSED_SRGB_S3TC_DXT1_EXT:p._useSRGBBuffer=!1;break;case 33777:this._caps.s3tc_srgb?_=he.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:p._useSRGBBuffer=!1;break;case 33779:this._caps.s3tc_srgb?_=he.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:p._useSRGBBuffer=!1;break;default:p._useSRGBBuffer=!1;break}this._gl.compressedTexImage2D(_e,ae,_,E,I,0,Z)}_uploadDataToTextureDirectly(p,_,E=0,I=0,Z,re=!1){const ae=this._gl,he=this._getWebGLTextureType(p.type),_e=this._getInternalFormat(p.format),ve=Z===void 0?this._getRGBABufferInternalSizedFormat(p.type,p.format,p._useSRGBBuffer):this._getInternalFormat(Z,p._useSRGBBuffer);this._unpackFlipY(p.invertY);let Le=ae.TEXTURE_2D;p.isCube&&(Le=ae.TEXTURE_CUBE_MAP_POSITIVE_X+E);const ze=Math.round(Math.log(p.width)*Math.LOG2E),He=Math.round(Math.log(p.height)*Math.LOG2E),xt=re?p.width:Math.pow(2,Math.max(ze-I,0)),rt=re?p.height:Math.pow(2,Math.max(He-I,0));ae.texImage2D(Le,I,ve,xt,rt,0,_e,he,_)}updateTextureData(p,_,E,I,Z,re,ae=0,he=0,_e=!1){const ve=this._gl,Le=this._getWebGLTextureType(p.type),ze=this._getInternalFormat(p.format);this._unpackFlipY(p.invertY);let He=ve.TEXTURE_2D,xt=ve.TEXTURE_2D;p.isCube&&(xt=ve.TEXTURE_CUBE_MAP_POSITIVE_X+ae,He=ve.TEXTURE_CUBE_MAP),this._bindTextureDirectly(He,p,!0),ve.texSubImage2D(xt,he,E,I,Z,re,ze,Le,_),_e&&this._gl.generateMipmap(xt),this._bindTextureDirectly(He,null)}_uploadArrayBufferViewToTexture(p,_,E=0,I=0){const Z=this._gl,re=p.isCube?Z.TEXTURE_CUBE_MAP:Z.TEXTURE_2D;this._bindTextureDirectly(re,p,!0),this._uploadDataToTextureDirectly(p,_,E,I),this._bindTextureDirectly(re,null,!0)}_prepareWebGLTextureContinuation(p,_,E,I,Z){const re=this._gl;if(!re)return;const ae=this._getSamplingParameters(Z,!E);re.texParameteri(re.TEXTURE_2D,re.TEXTURE_MAG_FILTER,ae.mag),re.texParameteri(re.TEXTURE_2D,re.TEXTURE_MIN_FILTER,ae.min),!E&&!I&&re.generateMipmap(re.TEXTURE_2D),this._bindTextureDirectly(re.TEXTURE_2D,null),_&&_.removePendingData(p),p.onLoadedObservable.notifyObservers(p),p.onLoadedObservable.clear()}_prepareWebGLTexture(p,_,E,I,Z,re,ae,he,_e=3){const ve=this.getCaps().maxTextureSize,Le=Math.min(ve,this.needPOTTextures?sr.GetExponentOfTwo(I.width,ve):I.width),ze=Math.min(ve,this.needPOTTextures?sr.GetExponentOfTwo(I.height,ve):I.height),He=this._gl;if(He){if(!p._hardwareTexture){E&&E.removePendingData(p);return}this._bindTextureDirectly(He.TEXTURE_2D,p,!0),this._unpackFlipY(Z===void 0?!0:!!Z),p.baseWidth=I.width,p.baseHeight=I.height,p.width=Le,p.height=ze,p.isReady=!0,p.type=p.type!==-1?p.type:0,p.format=p.format!==-1?p.format:_===".jpg"&&!p._useSRGBBuffer?4:5,!he(Le,ze,I,_,p,()=>{this._prepareWebGLTextureContinuation(p,E,re,ae,_e)})&&this._prepareWebGLTextureContinuation(p,E,re,ae,_e)}}_setupFramebufferDepthAttachments(p,_,E,I,Z=1){const re=this._gl;if(p&&_)return this._createRenderBuffer(E,I,Z,re.DEPTH_STENCIL,re.DEPTH24_STENCIL8,re.DEPTH_STENCIL_ATTACHMENT);if(_){let ae=re.DEPTH_COMPONENT16;return this._webGLVersion>1&&(ae=re.DEPTH_COMPONENT32F),this._createRenderBuffer(E,I,Z,ae,ae,re.DEPTH_ATTACHMENT)}return p?this._createRenderBuffer(E,I,Z,re.STENCIL_INDEX8,re.STENCIL_INDEX8,re.STENCIL_ATTACHMENT):null}_createRenderBuffer(p,_,E,I,Z,re,ae=!0){const _e=this._gl.createRenderbuffer();return this._updateRenderBuffer(_e,p,_,E,I,Z,re,ae)}_updateRenderBuffer(p,_,E,I,Z,re,ae,he=!0){const _e=this._gl;return _e.bindRenderbuffer(_e.RENDERBUFFER,p),I>1&&_e.renderbufferStorageMultisample?_e.renderbufferStorageMultisample(_e.RENDERBUFFER,I,re,_,E):_e.renderbufferStorage(_e.RENDERBUFFER,Z,_,E),_e.framebufferRenderbuffer(_e.FRAMEBUFFER,ae,_e.RENDERBUFFER,p),he&&_e.bindRenderbuffer(_e.RENDERBUFFER,null),p}_releaseTexture(p){this._deleteTexture(p._hardwareTexture?.underlyingResource),this.unbindAllTextures();const _=this._internalTexturesCache.indexOf(p);_!==-1&&this._internalTexturesCache.splice(_,1),p._lodTextureHigh&&p._lodTextureHigh.dispose(),p._lodTextureMid&&p._lodTextureMid.dispose(),p._lodTextureLow&&p._lodTextureLow.dispose(),p._irradianceTexture&&p._irradianceTexture.dispose()}_releaseRenderTargetWrapper(p){const _=this._renderTargetWrapperCache.indexOf(p);_!==-1&&this._renderTargetWrapperCache.splice(_,1)}_deleteTexture(p){p&&this._gl.deleteTexture(p)}_setProgram(p){this._currentProgram!==p&&(this._gl.useProgram(p),this._currentProgram=p)}bindSamplers(p){const _=p.getPipelineContext();this._setProgram(_.program);const E=p.getSamplers();for(let I=0;I<E.length;I++){const Z=p.getUniform(E[I]);Z&&(this._boundUniforms[I]=Z)}this._currentEffect=null}_activateCurrentTexture(){this._currentTextureChannel!==this._activeChannel&&(this._gl.activeTexture(this._gl.TEXTURE0+this._activeChannel),this._currentTextureChannel=this._activeChannel)}_bindTextureDirectly(p,_,E=!1,I=!1){let Z=!1;const re=_&&_._associatedChannel>-1;if(E&&re&&(this._activeChannel=_._associatedChannel),this._boundTexturesCache[this._activeChannel]!==_||I){if(this._activateCurrentTexture(),_&&_.isMultiview)throw Ti.Error(["_bindTextureDirectly called with a multiview texture!",p,_]),"_bindTextureDirectly called with a multiview texture!";this._gl.bindTexture(p,_?._hardwareTexture?.underlyingResource??null),this._boundTexturesCache[this._activeChannel]=_,_&&(_._associatedChannel=this._activeChannel)}else E&&(Z=!0,this._activateCurrentTexture());return re&&!E&&this._bindSamplerUniformToChannel(_._associatedChannel,this._activeChannel),Z}_bindTexture(p,_,E){if(p===void 0)return;_&&(_._associatedChannel=p),this._activeChannel=p;const I=_?this._getTextureTarget(_):this._gl.TEXTURE_2D;this._bindTextureDirectly(I,_)}unbindAllTextures(){for(let p=0;p<this._maxSimultaneousTextures;p++)this._activeChannel=p,this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),this.webGLVersion>1&&(this._bindTextureDirectly(this._gl.TEXTURE_3D,null),this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY,null))}setTexture(p,_,E,I){p!==void 0&&(_&&(this._boundUniforms[p]=_),this._setTexture(p,E))}_bindSamplerUniformToChannel(p,_){const E=this._boundUniforms[p];!E||E._currentState===_||(this._gl.uniform1i(E,_),E._currentState=_)}_getTextureWrapMode(p){switch(p){case 1:return this._gl.REPEAT;case 0:return this._gl.CLAMP_TO_EDGE;case 2:return this._gl.MIRRORED_REPEAT}return this._gl.REPEAT}_setTexture(p,_,E=!1,I=!1,Z=""){if(!_)return this._boundTexturesCache[p]!=null&&(this._activeChannel=p,this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),this.webGLVersion>1&&(this._bindTextureDirectly(this._gl.TEXTURE_3D,null),this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY,null))),!1;if(_.video){this._activeChannel=p;const _e=_.getInternalTexture();_e&&(_e._associatedChannel=p),_.update()}else if(_.delayLoadState===4)return _.delayLoad(),!1;let re;I?re=_.depthStencilTexture:_.isReady()?re=_.getInternalTexture():_.isCube?re=this.emptyCubeTexture:_.is3D?re=this.emptyTexture3D:_.is2DArray?re=this.emptyTexture2DArray:re=this.emptyTexture,!E&&re&&(re._associatedChannel=p);let ae=!0;this._boundTexturesCache[p]===re&&(E||this._bindSamplerUniformToChannel(re._associatedChannel,p),ae=!1),this._activeChannel=p;const he=this._getTextureTarget(re);if(ae&&this._bindTextureDirectly(he,re,E),re&&!re.isMultiview){if(re.isCube&&re._cachedCoordinatesMode!==_.coordinatesMode){re._cachedCoordinatesMode=_.coordinatesMode;const _e=_.coordinatesMode!==3&&_.coordinatesMode!==5?1:0;_.wrapU=_e,_.wrapV=_e}re._cachedWrapU!==_.wrapU&&(re._cachedWrapU=_.wrapU,this._setTextureParameterInteger(he,this._gl.TEXTURE_WRAP_S,this._getTextureWrapMode(_.wrapU),re)),re._cachedWrapV!==_.wrapV&&(re._cachedWrapV=_.wrapV,this._setTextureParameterInteger(he,this._gl.TEXTURE_WRAP_T,this._getTextureWrapMode(_.wrapV),re)),re.is3D&&re._cachedWrapR!==_.wrapR&&(re._cachedWrapR=_.wrapR,this._setTextureParameterInteger(he,this._gl.TEXTURE_WRAP_R,this._getTextureWrapMode(_.wrapR),re)),this._setAnisotropicLevel(he,re,_.anisotropicFilteringLevel)}return!0}setTextureArray(p,_,E,I){if(!(p===void 0||!_)){(!this._textureUnits||this._textureUnits.length!==E.length)&&(this._textureUnits=new Int32Array(E.length));for(let Z=0;Z<E.length;Z++){const re=E[Z].getInternalTexture();re?(this._textureUnits[Z]=p+Z,re._associatedChannel=p+Z):this._textureUnits[Z]=-1}this._gl.uniform1iv(_,this._textureUnits);for(let Z=0;Z<E.length;Z++)this._setTexture(this._textureUnits[Z],E[Z],!0)}}_setAnisotropicLevel(p,_,E){const I=this._caps.textureAnisotropicFilterExtension;_.samplingMode!==11&&_.samplingMode!==3&&_.samplingMode!==2&&(E=1),I&&_._cachedAnisotropicFilteringLevel!==E&&(this._setTextureParameterFloat(p,I.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(E,this._caps.maxAnisotropy),_),_._cachedAnisotropicFilteringLevel=E)}_setTextureParameterFloat(p,_,E,I){this._bindTextureDirectly(p,I,!0,!0),this._gl.texParameterf(p,_,E)}_setTextureParameterInteger(p,_,E,I){I&&this._bindTextureDirectly(p,I,!0,!0),this._gl.texParameteri(p,_,E)}unbindAllAttributes(){if(this._mustWipeVertexAttributes){this._mustWipeVertexAttributes=!1;for(let p=0;p<this._caps.maxVertexAttribs;p++)this.disableAttributeByIndex(p);return}for(let p=0,_=this._vertexAttribArraysEnabled.length;p<_;p++)p>=this._caps.maxVertexAttribs||!this._vertexAttribArraysEnabled[p]||this.disableAttributeByIndex(p)}releaseEffects(){for(const p in this._compiledEffects){const _=this._compiledEffects[p].getPipelineContext();this._deletePipelineContext(_)}this._compiledEffects={}}dispose(){this._isDisposed=!0,this.stopRenderLoop(),this.onBeforeTextureInitObservable&&this.onBeforeTextureInitObservable.clear(),this._emptyTexture&&(this._releaseTexture(this._emptyTexture),this._emptyTexture=null),this._emptyCubeTexture&&(this._releaseTexture(this._emptyCubeTexture),this._emptyCubeTexture=null),this._dummyFramebuffer&&this._gl.deleteFramebuffer(this._dummyFramebuffer),this.releaseEffects(),this.releaseComputeEffects?.(),this.unbindAllAttributes(),this._boundUniforms={},va()&&this._renderingCanvas&&(this._doNotHandleContextLost||(this._renderingCanvas.removeEventListener("webglcontextlost",this._onContextLost),this._renderingCanvas.removeEventListener("webglcontextrestored",this._onContextRestored)),window.removeEventListener("resize",this._checkForMobile)),this._workingCanvas=null,this._workingContext=null,this._currentBufferPointers.length=0,this._renderingCanvas=null,this._currentProgram=null,this._boundRenderFunction=null,_a.ResetCache();for(const p of this._activeRequests)p.abort();this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this._creationOptions.loseContextOnDispose&&this._gl.getExtension("WEBGL_lose_context")?.loseContext()}attachContextLostEvent(p){this._renderingCanvas&&this._renderingCanvas.addEventListener("webglcontextlost",p,!1)}attachContextRestoredEvent(p){this._renderingCanvas&&this._renderingCanvas.addEventListener("webglcontextrestored",p,!1)}getError(){return this._gl.getError()}_canRenderToFloatFramebuffer(){return this._webGLVersion>1?this._caps.colorBufferFloat:this._canRenderToFramebuffer(1)}_canRenderToHalfFloatFramebuffer(){return this._webGLVersion>1?this._caps.colorBufferFloat:this._canRenderToFramebuffer(2)}_canRenderToFramebuffer(p){const _=this._gl;for(;_.getError()!==_.NO_ERROR;);let E=!0;const I=_.createTexture();_.bindTexture(_.TEXTURE_2D,I),_.texImage2D(_.TEXTURE_2D,0,this._getRGBABufferInternalSizedFormat(p),1,1,0,_.RGBA,this._getWebGLTextureType(p),null),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_MIN_FILTER,_.NEAREST),_.texParameteri(_.TEXTURE_2D,_.TEXTURE_MAG_FILTER,_.NEAREST);const Z=_.createFramebuffer();_.bindFramebuffer(_.FRAMEBUFFER,Z),_.framebufferTexture2D(_.FRAMEBUFFER,_.COLOR_ATTACHMENT0,_.TEXTURE_2D,I,0);const re=_.checkFramebufferStatus(_.FRAMEBUFFER);if(E=E&&re===_.FRAMEBUFFER_COMPLETE,E=E&&_.getError()===_.NO_ERROR,E&&(_.clear(_.COLOR_BUFFER_BIT),E=E&&_.getError()===_.NO_ERROR),E){_.bindFramebuffer(_.FRAMEBUFFER,null);const ae=_.RGBA,he=_.UNSIGNED_BYTE,_e=new Uint8Array(4);_.readPixels(0,0,1,1,ae,he,_e),E=E&&_.getError()===_.NO_ERROR}for(_.deleteTexture(I),_.deleteFramebuffer(Z),_.bindFramebuffer(_.FRAMEBUFFER,null);!E&&_.getError()!==_.NO_ERROR;);return E}_getWebGLTextureType(p){if(this._webGLVersion===1){switch(p){case 1:return this._gl.FLOAT;case 2:return this._gl.HALF_FLOAT_OES;case 0:return this._gl.UNSIGNED_BYTE;case 8:return this._gl.UNSIGNED_SHORT_4_4_4_4;case 9:return this._gl.UNSIGNED_SHORT_5_5_5_1;case 10:return this._gl.UNSIGNED_SHORT_5_6_5}return this._gl.UNSIGNED_BYTE}switch(p){case 3:return this._gl.BYTE;case 0:return this._gl.UNSIGNED_BYTE;case 4:return this._gl.SHORT;case 5:return this._gl.UNSIGNED_SHORT;case 6:return this._gl.INT;case 7:return this._gl.UNSIGNED_INT;case 1:return this._gl.FLOAT;case 2:return this._gl.HALF_FLOAT;case 8:return this._gl.UNSIGNED_SHORT_4_4_4_4;case 9:return this._gl.UNSIGNED_SHORT_5_5_5_1;case 10:return this._gl.UNSIGNED_SHORT_5_6_5;case 11:return this._gl.UNSIGNED_INT_2_10_10_10_REV;case 12:return this._gl.UNSIGNED_INT_24_8;case 13:return this._gl.UNSIGNED_INT_10F_11F_11F_REV;case 14:return this._gl.UNSIGNED_INT_5_9_9_9_REV;case 15:return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV}return this._gl.UNSIGNED_BYTE}_getInternalFormat(p,_=!1){let E=_?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA;switch(p){case 0:E=this._gl.ALPHA;break;case 1:E=this._gl.LUMINANCE;break;case 2:E=this._gl.LUMINANCE_ALPHA;break;case 6:E=this._gl.RED;break;case 7:E=this._gl.RG;break;case 4:E=_?this._glSRGBExtensionValues.SRGB:this._gl.RGB;break;case 5:E=_?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA;break}if(this._webGLVersion>1)switch(p){case 8:E=this._gl.RED_INTEGER;break;case 9:E=this._gl.RG_INTEGER;break;case 10:E=this._gl.RGB_INTEGER;break;case 11:E=this._gl.RGBA_INTEGER;break}return E}_getRGBABufferInternalSizedFormat(p,_,E=!1){if(this._webGLVersion===1){if(_!==void 0)switch(_){case 0:return this._gl.ALPHA;case 1:return this._gl.LUMINANCE;case 2:return this._gl.LUMINANCE_ALPHA;case 4:return E?this._glSRGBExtensionValues.SRGB:this._gl.RGB}return this._gl.RGBA}switch(p){case 3:switch(_){case 6:return this._gl.R8_SNORM;case 7:return this._gl.RG8_SNORM;case 4:return this._gl.RGB8_SNORM;case 8:return this._gl.R8I;case 9:return this._gl.RG8I;case 10:return this._gl.RGB8I;case 11:return this._gl.RGBA8I;default:return this._gl.RGBA8_SNORM}case 0:switch(_){case 6:return this._gl.R8;case 7:return this._gl.RG8;case 4:return E?this._glSRGBExtensionValues.SRGB8:this._gl.RGB8;case 5:return E?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA8;case 8:return this._gl.R8UI;case 9:return this._gl.RG8UI;case 10:return this._gl.RGB8UI;case 11:return this._gl.RGBA8UI;case 0:return this._gl.ALPHA;case 1:return this._gl.LUMINANCE;case 2:return this._gl.LUMINANCE_ALPHA;default:return this._gl.RGBA8}case 4:switch(_){case 8:return this._gl.R16I;case 9:return this._gl.RG16I;case 10:return this._gl.RGB16I;case 11:return this._gl.RGBA16I;default:return this._gl.RGBA16I}case 5:switch(_){case 8:return this._gl.R16UI;case 9:return this._gl.RG16UI;case 10:return this._gl.RGB16UI;case 11:return this._gl.RGBA16UI;default:return this._gl.RGBA16UI}case 6:switch(_){case 8:return this._gl.R32I;case 9:return this._gl.RG32I;case 10:return this._gl.RGB32I;case 11:return this._gl.RGBA32I;default:return this._gl.RGBA32I}case 7:switch(_){case 8:return this._gl.R32UI;case 9:return this._gl.RG32UI;case 10:return this._gl.RGB32UI;case 11:return this._gl.RGBA32UI;default:return this._gl.RGBA32UI}case 1:switch(_){case 6:return this._gl.R32F;case 7:return this._gl.RG32F;case 4:return this._gl.RGB32F;case 5:return this._gl.RGBA32F;default:return this._gl.RGBA32F}case 2:switch(_){case 6:return this._gl.R16F;case 7:return this._gl.RG16F;case 4:return this._gl.RGB16F;case 5:return this._gl.RGBA16F;default:return this._gl.RGBA16F}case 10:return this._gl.RGB565;case 13:return this._gl.R11F_G11F_B10F;case 14:return this._gl.RGB9_E5;case 8:return this._gl.RGBA4;case 9:return this._gl.RGB5_A1;case 11:switch(_){case 5:return this._gl.RGB10_A2;case 11:return this._gl.RGB10_A2UI;default:return this._gl.RGB10_A2}}return E?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA8}_loadFile(p,_,E,I,Z,re){const ae=sr._FileToolsLoadFile(p,_,E,I,Z,re);return this._activeRequests.push(ae),ae.onCompleteObservable.add(he=>{this._activeRequests.splice(this._activeRequests.indexOf(he),1)}),ae}static _FileToolsLoadFile(p,_,E,I,Z,re){throw ur("FileTools")}readPixels(p,_,E,I,Z=!0,re=!0){const ae=Z?4:3,he=Z?this._gl.RGBA:this._gl.RGB,_e=new Uint8Array(I*E*ae);return re&&this.flushFramebuffer(),this._gl.readPixels(p,_,E,I,he,this._gl.UNSIGNED_BYTE,_e),Promise.resolve(_e)}static get IsSupportedAsync(){return Promise.resolve(this.isSupported())}static get IsSupported(){return this.isSupported()}static isSupported(){if(this._HasMajorPerformanceCaveat!==null)return!this._HasMajorPerformanceCaveat;if(this._IsSupported===null)try{const p=this._CreateCanvas(1,1),_=p.getContext("webgl")||p.getContext("experimental-webgl");this._IsSupported=_!=null&&!!window.WebGLRenderingContext}catch{this._IsSupported=!1}return this._IsSupported}static get HasMajorPerformanceCaveat(){if(this._HasMajorPerformanceCaveat===null)try{const p=this._CreateCanvas(1,1),_=p.getContext("webgl",{failIfMajorPerformanceCaveat:!0})||p.getContext("experimental-webgl",{failIfMajorPerformanceCaveat:!0});this._HasMajorPerformanceCaveat=!_}catch{this._HasMajorPerformanceCaveat=!1}return this._HasMajorPerformanceCaveat}static CeilingPOT(p){return p--,p|=p>>1,p|=p>>2,p|=p>>4,p|=p>>8,p|=p>>16,p++,p}static FloorPOT(p){return p=p|p>>1,p=p|p>>2,p=p|p>>4,p=p|p>>8,p=p|p>>16,p-(p>>1)}static NearestPOT(p){const _=sr.CeilingPOT(p),E=sr.FloorPOT(p);return _-p>p-E?E:_}static GetExponentOfTwo(p,_,E=2){let I;switch(E){case 1:I=sr.FloorPOT(p);break;case 2:I=sr.NearestPOT(p);break;case 3:default:I=sr.CeilingPOT(p);break}return Math.min(I,_)}static QueueNewFrame(p,_){if(va()){const{requestAnimationFrame:E}=_||window;if(typeof E=="function")return E(p)}else if(typeof requestAnimationFrame=="function")return requestAnimationFrame(p);return setTimeout(p,16)}getHostDocument(){return this._renderingCanvas&&this._renderingCanvas.ownerDocument?this._renderingCanvas.ownerDocument:no()?document:null}}sr._TempClearColorUint32=new Uint32Array(4),sr._TempClearColorInt32=new Int32Array(4),sr.ExceptionList=[{key:"Chrome/63.0",capture:"63\\.0\\.3239\\.(\\d+)",captureConstraint:108,targets:["uniformBuffer"]},{key:"Firefox/58",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Firefox/59",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Chrome/72.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Chrome/73.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Chrome/74.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome/71",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome/72",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Chrome/12\\d\\..+?Mobile",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:".*AppleWebKit.*(15.4).*Safari",capture:null,captureConstraint:null,targets:["antialias","maxMSAASamples"]},{key:".*(15.4).*AppleWebKit.*Safari",capture:null,captureConstraint:null,targets:["antialias","maxMSAASamples"]}],sr._TextureLoaders=[],sr.CollisionsEpsilon=.001,sr._IsSupported=null,sr._HasMajorPerformanceCaveat=null;class Tc{constructor(p=30){this._enabled=!0,this._rollingFrameTime=new rl(p)}sampleFrame(p=zx.Now){if(this._enabled){if(this._lastFrameTimeMs!=null){const _=p-this._lastFrameTimeMs;this._rollingFrameTime.add(_)}this._lastFrameTimeMs=p}}get averageFrameTime(){return this._rollingFrameTime.average}get averageFrameTimeVariance(){return this._rollingFrameTime.variance}get instantaneousFrameTime(){return this._rollingFrameTime.history(0)}get averageFPS(){return 1e3/this._rollingFrameTime.average}get instantaneousFPS(){const p=this._rollingFrameTime.history(0);return p===0?0:1e3/p}get isSaturated(){return this._rollingFrameTime.isSaturated()}enable(){this._enabled=!0}disable(){this._enabled=!1,this._lastFrameTimeMs=null}get isEnabled(){return this._enabled}reset(){this._lastFrameTimeMs=null,this._rollingFrameTime.reset()}}class rl{constructor(p){this._samples=new Array(p),this.reset()}add(p){let _;if(this.isSaturated()){const E=this._samples[this._pos];_=E-this.average,this.average-=_/(this._sampleCount-1),this._m2-=_*(E-this.average)}else this._sampleCount++;_=p-this.average,this.average+=_/this._sampleCount,this._m2+=_*(p-this.average),this.variance=this._m2/(this._sampleCount-1),this._samples[this._pos]=p,this._pos++,this._pos%=this._samples.length}history(p){if(p>=this._sampleCount||p>=this._samples.length)return 0;const _=this._wrapPosition(this._pos-1);return this._samples[this._wrapPosition(_-p)]}isSaturated(){return this._sampleCount>=this._samples.length}reset(){this.average=0,this.variance=0,this._sampleCount=0,this._pos=0,this._m2=0}_wrapPosition(p){const _=this._samples.length;return(p%_+_)%_}}class _0{get min(){return this._min}get max(){return this._max}get average(){return this._average}get lastSecAverage(){return this._lastSecAverage}get current(){return this._current}get total(){return this._totalAccumulated}get count(){return this._totalValueCount}constructor(){this._startMonitoringTime=0,this._min=0,this._max=0,this._average=0,this._lastSecAverage=0,this._current=0,this._totalValueCount=0,this._totalAccumulated=0,this._lastSecAccumulated=0,this._lastSecTime=0,this._lastSecValueCount=0}fetchNewFrame(){this._totalValueCount++,this._current=0,this._lastSecValueCount++}addCount(p,_){_0.Enabled&&(this._current+=p,_&&this._fetchResult())}beginMonitoring(){_0.Enabled&&(this._startMonitoringTime=zx.Now)}endMonitoring(p=!0){if(!_0.Enabled)return;p&&this.fetchNewFrame();const _=zx.Now;this._current=_-this._startMonitoringTime,p&&this._fetchResult()}endFrame(){this._fetchResult()}_fetchResult(){this._totalAccumulated+=this._current,this._lastSecAccumulated+=this._current,this._min=Math.min(this._min,this._current),this._max=Math.max(this._max,this._current),this._average=this._totalAccumulated/this._totalValueCount;const p=zx.Now;p-this._lastSecTime>1e3&&(this._lastSecAverage=this._lastSecAccumulated/this._lastSecValueCount,this._lastSecTime=p,this._lastSecAccumulated=0,this._lastSecValueCount=0)}}_0.Enabled=!0,sr.prototype.setAlphaConstants=function(pe,p,_,E){this._alphaState.setAlphaBlendConstants(pe,p,_,E)},sr.prototype.setAlphaMode=function(pe,p=!1){if(this._alphaMode===pe){if(!p){const _=pe===0;this.depthCullingState.depthMask!==_&&(this.depthCullingState.depthMask=_)}return}switch(pe){case 0:this._alphaState.alphaBlend=!1;break;case 7:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 8:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 2:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 6:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE,this._gl.ZERO,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 1:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE,this._gl.ZERO,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 3:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 4:this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR,this._gl.ZERO,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 5:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 9:this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR,this._gl.ONE_MINUS_CONSTANT_COLOR,this._gl.CONSTANT_ALPHA,this._gl.ONE_MINUS_CONSTANT_ALPHA),this._alphaState.alphaBlend=!0;break;case 10:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 11:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 12:this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA,this._gl.ONE,this._gl.ZERO,this._gl.ZERO),this._alphaState.alphaBlend=!0;break;case 13:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE_MINUS_DST_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 14:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 15:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE,this._gl.ONE,this._gl.ZERO),this._alphaState.alphaBlend=!0;break;case 16:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ZERO,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 17:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break}p||(this.depthCullingState.depthMask=pe===0),this._alphaMode=pe},sr.prototype.getAlphaMode=function(){return this._alphaMode},sr.prototype.setAlphaEquation=function(pe){if(this._alphaEquation!==pe){switch(pe){case 0:this._alphaState.setAlphaEquationParameters(32774,32774);break;case 1:this._alphaState.setAlphaEquationParameters(32778,32778);break;case 2:this._alphaState.setAlphaEquationParameters(32779,32779);break;case 3:this._alphaState.setAlphaEquationParameters(32776,32776);break;case 4:this._alphaState.setAlphaEquationParameters(32775,32775);break;case 5:this._alphaState.setAlphaEquationParameters(32775,32774);break}this._alphaEquation=pe}},sr.prototype.getAlphaEquation=function(){return this._alphaEquation};function nl(pe,p,_=!1,E){switch(pe){case 3:{const Z=p instanceof ArrayBuffer?new Int8Array(p):new Int8Array(p);return E&&Z.set(new Int8Array(E)),Z}case 0:{const Z=p instanceof ArrayBuffer?new Uint8Array(p):new Uint8Array(p);return E&&Z.set(new Uint8Array(E)),Z}case 4:{const Z=p instanceof ArrayBuffer?new Int16Array(p):new Int16Array(_?p/2:p);return E&&Z.set(new Int16Array(E)),Z}case 5:case 8:case 9:case 10:case 2:{const Z=p instanceof ArrayBuffer?new Uint16Array(p):new Uint16Array(_?p/2:p);return E&&Z.set(new Uint16Array(E)),Z}case 6:{const Z=p instanceof ArrayBuffer?new Int32Array(p):new Int32Array(_?p/4:p);return E&&Z.set(new Int32Array(E)),Z}case 7:case 11:case 12:case 13:case 14:case 15:{const Z=p instanceof ArrayBuffer?new Uint32Array(p):new Uint32Array(_?p/4:p);return E&&Z.set(new Uint32Array(E)),Z}case 1:{const Z=p instanceof ArrayBuffer?new Float32Array(p):new Float32Array(_?p/4:p);return E&&Z.set(new Float32Array(E)),Z}}const I=p instanceof ArrayBuffer?new Uint8Array(p):new Uint8Array(p);return E&&I.set(new Uint8Array(E)),I}sr.prototype._readTexturePixelsSync=function(pe,p,_,E=-1,I=0,Z=null,re=!0,ae=!1,he=0,_e=0){const ve=this._gl;if(!ve)throw new Error("Engine does not have gl rendering context.");if(!this._dummyFramebuffer){const ze=ve.createFramebuffer();if(!ze)throw new Error("Unable to create dummy framebuffer");this._dummyFramebuffer=ze}ve.bindFramebuffer(ve.FRAMEBUFFER,this._dummyFramebuffer),E>-1?ve.framebufferTexture2D(ve.FRAMEBUFFER,ve.COLOR_ATTACHMENT0,ve.TEXTURE_CUBE_MAP_POSITIVE_X+E,pe._hardwareTexture?.underlyingResource,I):ve.framebufferTexture2D(ve.FRAMEBUFFER,ve.COLOR_ATTACHMENT0,ve.TEXTURE_2D,pe._hardwareTexture?.underlyingResource,I);let Le=pe.type!==void 0?this._getWebGLTextureType(pe.type):ve.UNSIGNED_BYTE;if(ae)Z||(Z=nl(pe.type,4*p*_));else switch(Le){case ve.UNSIGNED_BYTE:Z||(Z=new Uint8Array(4*p*_)),Le=ve.UNSIGNED_BYTE;break;default:Z||(Z=new Float32Array(4*p*_)),Le=ve.FLOAT;break}return re&&this.flushFramebuffer(),ve.readPixels(he,_e,p,_,ve.RGBA,Le,Z),ve.bindFramebuffer(ve.FRAMEBUFFER,this._currentFramebuffer),Z},sr.prototype._readTexturePixels=function(pe,p,_,E=-1,I=0,Z=null,re=!0,ae=!1,he=0,_e=0){return Promise.resolve(this._readTexturePixelsSync(pe,p,_,E,I,Z,re,ae,he,_e))},sr.prototype.updateDynamicIndexBuffer=function(pe,p,_=0){this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER]=null,this.bindIndexBuffer(pe);let E;pe.is32Bits?E=p instanceof Uint32Array?p:new Uint32Array(p):E=p instanceof Uint16Array?p:new Uint16Array(p),this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER,E,this._gl.DYNAMIC_DRAW),this._resetIndexBufferBinding()},sr.prototype.updateDynamicVertexBuffer=function(pe,p,_,E){this.bindArrayBuffer(pe),_===void 0&&(_=0);const I=p.byteLength||p.length;E===void 0||E>=I&&_===0?p instanceof Array?this._gl.bufferSubData(this._gl.ARRAY_BUFFER,_,new Float32Array(p)):this._gl.bufferSubData(this._gl.ARRAY_BUFFER,_,p):p instanceof Array?this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,new Float32Array(p).subarray(_,_+E)):(p instanceof ArrayBuffer?p=new Uint8Array(p,_,E):p=new Uint8Array(p.buffer,p.byteOffset+_,E),this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,p)),this._resetVertexBufferBinding()};class ci extends sr{static get NpmPackage(){return sr.NpmPackage}static get Version(){return sr.Version}static get Instances(){return Mr.Instances}static get LastCreatedEngine(){return Mr.LastCreatedEngine}static get LastCreatedScene(){return Mr.LastCreatedScene}_createImageBitmapFromSource(p,_){return new Promise((I,Z)=>{const re=new Image;re.onload=()=>{re.decode().then(()=>{this.createImageBitmap(re,_).then(ae=>{I(ae)})})},re.onerror=()=>{Z(`Error loading image ${re.src}`)},re.src=p})}createImageBitmap(p,_){return createImageBitmap(p,_)}resizeImageBitmap(p,_,E){const Z=this.createCanvas(_,E).getContext("2d");if(!Z)throw new Error("Unable to get 2d context for resizeImageBitmap");return Z.drawImage(p,0,0),Z.getImageData(0,0,_,E).data}static MarkAllMaterialsAsDirty(p,_){for(let E=0;E<ci.Instances.length;E++){const I=ci.Instances[E];for(let Z=0;Z<I.scenes.length;Z++)I.scenes[Z].markAllMaterialsAsDirty(p,_)}}static DefaultLoadingScreenFactory(p){throw ur("LoadingScreen")}get _supportsHardwareTextureRescaling(){return!!ci._RescalePostProcessFactory}get performanceMonitor(){return this._performanceMonitor}get compatibilityMode(){return this._compatibilityMode}set compatibilityMode(p){this._compatibilityMode=!0}getInputElement(){return this._renderingCanvas}constructor(p,_,E,I=!1){if(super(p,_,E,I),this.enableOfflineSupport=!1,this.disableManifestCheck=!1,this.disableContextMenu=!0,this.scenes=[],this._virtualScenes=new Array,this.onNewSceneAddedObservable=new Ri,this.postProcesses=[],this.isPointerLock=!1,this.onResizeObservable=new Ri,this.onCanvasBlurObservable=new Ri,this.onCanvasFocusObservable=new Ri,this.onCanvasPointerOutObservable=new Ri,this.onBeginFrameObservable=new Ri,this.customAnimationFrameRequester=null,this.onEndFrameObservable=new Ri,this.onBeforeShaderCompilationObservable=new Ri,this.onAfterShaderCompilationObservable=new Ri,this._deterministicLockstep=!1,this._lockstepMaxSteps=4,this._timeStep=1/60,this._fps=60,this._deltaTime=0,this._drawCalls=new _0,this.canvasTabIndex=1,this.disablePerformanceMonitorInBackground=!1,this._performanceMonitor=new Tc,this._compatibilityMode=!0,this.currentRenderPassId=0,this._renderPassNames=["main"],ci.Instances.push(this),!!p&&(this._features.supportRenderPasses=!0,E=this._creationOptions,p.getContext)){const Z=p;this._sharedInit(Z)}}_initGLContext(){super._initGLContext(),this._rescalePostProcess=null}_sharedInit(p){super._sharedInit(p),this._onCanvasFocus=()=>{this.onCanvasFocusObservable.notifyObservers(this)},this._onCanvasBlur=()=>{this.onCanvasBlurObservable.notifyObservers(this)},this._onCanvasContextMenu=E=>{this.disableContextMenu&&E.preventDefault()},p.addEventListener("focus",this._onCanvasFocus),p.addEventListener("blur",this._onCanvasBlur),p.addEventListener("contextmenu",this._onCanvasContextMenu),this._onBlur=()=>{this.disablePerformanceMonitorInBackground&&this._performanceMonitor.disable(),this._windowIsBackground=!0},this._onFocus=()=>{this.disablePerformanceMonitorInBackground&&this._performanceMonitor.enable(),this._windowIsBackground=!1},this._onCanvasPointerOut=E=>{document.elementFromPoint(E.clientX,E.clientY)!==p&&this.onCanvasPointerOutObservable.notifyObservers(E)};const _=this.getHostWindow();_&&typeof _.addEventListener=="function"&&(_.addEventListener("blur",this._onBlur),_.addEventListener("focus",this._onFocus)),p.addEventListener("pointerout",this._onCanvasPointerOut),this._creationOptions.doNotHandleTouchAction||this._disableTouchAction(),!ci.audioEngine&&this._creationOptions.audioEngine&&ci.AudioEngineFactory&&(ci.audioEngine=ci.AudioEngineFactory(this.getRenderingCanvas(),this.getAudioContext(),this.getAudioDestination())),no()&&(this._onFullscreenChange=()=>{this.isFullscreen=!!document.fullscreenElement,this.isFullscreen&&this._pointerLockRequested&&p&&ci._RequestPointerlock(p)},document.addEventListener("fullscreenchange",this._onFullscreenChange,!1),document.addEventListener("webkitfullscreenchange",this._onFullscreenChange,!1),this._onPointerLockChange=()=>{this.isPointerLock=document.pointerLockElement===p},document.addEventListener("pointerlockchange",this._onPointerLockChange,!1),document.addEventListener("webkitpointerlockchange",this._onPointerLockChange,!1)),this.enableOfflineSupport=ci.OfflineProviderFactory!==void 0,this._deterministicLockstep=!!this._creationOptions.deterministicLockstep,this._lockstepMaxSteps=this._creationOptions.lockstepMaxSteps||0,this._timeStep=this._creationOptions.timeStep||1/60}_verifyPointerLock(){this._onPointerLockChange?.()}getAspectRatio(p,_=!1){const E=p.viewport;return this.getRenderWidth(_)*E.width/(this.getRenderHeight(_)*E.height)}getScreenAspectRatio(){return this.getRenderWidth(!0)/this.getRenderHeight(!0)}getRenderingCanvasClientRect(){return this._renderingCanvas?this._renderingCanvas.getBoundingClientRect():null}getInputElementClientRect(){return this._renderingCanvas?this.getInputElement().getBoundingClientRect():null}isDeterministicLockStep(){return this._deterministicLockstep}getLockstepMaxSteps(){return this._lockstepMaxSteps}getTimeStep(){return this._timeStep*1e3}generateMipMapsForCubemap(p,_=!0){if(p.generateMipMaps){const E=this._gl;this._bindTextureDirectly(E.TEXTURE_CUBE_MAP,p,!0),E.generateMipmap(E.TEXTURE_CUBE_MAP),_&&this._bindTextureDirectly(E.TEXTURE_CUBE_MAP,null)}}getDepthWrite(){return this._depthCullingState.depthMask}setDepthWrite(p){this._depthCullingState.depthMask=p}getStencilBuffer(){return this._stencilState.stencilTest}setStencilBuffer(p){this._stencilState.stencilTest=p}getStencilMask(){return this._stencilState.stencilMask}setStencilMask(p){this._stencilState.stencilMask=p}getStencilFunction(){return this._stencilState.stencilFunc}getStencilFunctionReference(){return this._stencilState.stencilFuncRef}getStencilFunctionMask(){return this._stencilState.stencilFuncMask}setStencilFunction(p){this._stencilState.stencilFunc=p}setStencilFunctionReference(p){this._stencilState.stencilFuncRef=p}setStencilFunctionMask(p){this._stencilState.stencilFuncMask=p}getStencilOperationFail(){return this._stencilState.stencilOpStencilFail}getStencilOperationDepthFail(){return this._stencilState.stencilOpDepthFail}getStencilOperationPass(){return this._stencilState.stencilOpStencilDepthPass}setStencilOperationFail(p){this._stencilState.stencilOpStencilFail=p}setStencilOperationDepthFail(p){this._stencilState.stencilOpDepthFail=p}setStencilOperationPass(p){this._stencilState.stencilOpStencilDepthPass=p}setDitheringState(p){p?this._gl.enable(this._gl.DITHER):this._gl.disable(this._gl.DITHER)}setRasterizerState(p){p?this._gl.disable(this._gl.RASTERIZER_DISCARD):this._gl.enable(this._gl.RASTERIZER_DISCARD)}getDepthFunction(){return this._depthCullingState.depthFunc}setDepthFunction(p){this._depthCullingState.depthFunc=p}setDepthFunctionToGreater(){this.setDepthFunction(516)}setDepthFunctionToGreaterOrEqual(){this.setDepthFunction(518)}setDepthFunctionToLess(){this.setDepthFunction(513)}setDepthFunctionToLessOrEqual(){this.setDepthFunction(515)}cacheStencilState(){this._cachedStencilBuffer=this.getStencilBuffer(),this._cachedStencilFunction=this.getStencilFunction(),this._cachedStencilMask=this.getStencilMask(),this._cachedStencilOperationPass=this.getStencilOperationPass(),this._cachedStencilOperationFail=this.getStencilOperationFail(),this._cachedStencilOperationDepthFail=this.getStencilOperationDepthFail(),this._cachedStencilReference=this.getStencilFunctionReference()}restoreStencilState(){this.setStencilFunction(this._cachedStencilFunction),this.setStencilMask(this._cachedStencilMask),this.setStencilBuffer(this._cachedStencilBuffer),this.setStencilOperationPass(this._cachedStencilOperationPass),this.setStencilOperationFail(this._cachedStencilOperationFail),this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail),this.setStencilFunctionReference(this._cachedStencilReference)}setDirectViewport(p,_,E,I){const Z=this._cachedViewport;return this._cachedViewport=null,this._viewport(p,_,E,I),Z}scissorClear(p,_,E,I,Z){this.enableScissor(p,_,E,I),this.clear(Z,!0,!0,!0),this.disableScissor()}enableScissor(p,_,E,I){const Z=this._gl;Z.enable(Z.SCISSOR_TEST),Z.scissor(p,_,E,I)}disableScissor(){const p=this._gl;p.disable(p.SCISSOR_TEST)}_reportDrawCall(p=1){this._drawCalls.addCount(p,!1)}_loadFileAsync(p,_,E){return new Promise((I,Z)=>{this._loadFile(p,re=>{I(re)},void 0,_,E,(re,ae)=>{Z(ae)})})}getVertexShaderSource(p){const _=this._gl.getAttachedShaders(p);return _?this._gl.getShaderSource(_[0]):null}getFragmentShaderSource(p){const _=this._gl.getAttachedShaders(p);return _?this._gl.getShaderSource(_[1]):null}setDepthStencilTexture(p,_,E,I){p!==void 0&&(_&&(this._boundUniforms[p]=_),!E||!E.depthStencilTexture?this._setTexture(p,null,void 0,void 0,I):this._setTexture(p,E,!1,!0,I))}setTextureFromPostProcess(p,_,E){let I=null;_&&(_._forcedOutputTexture?I=_._forcedOutputTexture:_._textures.data[_._currentRenderTextureInd]&&(I=_._textures.data[_._currentRenderTextureInd])),this._bindTexture(p,I?.texture??null,E)}setTextureFromPostProcessOutput(p,_,E){this._bindTexture(p,_?._outputTexture?.texture??null,E)}_rebuildBuffers(){for(const p of this.scenes)p.resetCachedMaterial(),p._rebuildGeometries();for(const p of this._virtualScenes)p.resetCachedMaterial(),p._rebuildGeometries();super._rebuildBuffers()}_rebuildTextures(){for(const p of this.scenes)p._rebuildTextures();for(const p of this._virtualScenes)p._rebuildTextures();super._rebuildTextures()}_renderFrame(){for(let p=0;p<this._activeRenderLoops.length;p++){const _=this._activeRenderLoops[p];_()}}_cancelFrame(){if(this._renderingQueueLaunched&&this.customAnimationFrameRequester){this._renderingQueueLaunched=!1;const{cancelAnimationFrame:p}=this.customAnimationFrameRequester;p&&p(this.customAnimationFrameRequester.requestID)}else super._cancelFrame()}_renderLoop(){if(!this._contextWasLost){let p=!0;(this.isDisposed||!this.renderEvenInBackground&&this._windowIsBackground)&&(p=!1),p&&(this.beginFrame(),this._renderViews()||this._renderFrame(),this.endFrame())}this._activeRenderLoops.length>0?this.customAnimationFrameRequester?(this.customAnimationFrameRequester.requestID=this._queueNewFrame(this.customAnimationFrameRequester.renderFunction||this._boundRenderFunction,this.customAnimationFrameRequester),this._frameHandler=this.customAnimationFrameRequester.requestID):this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow()):this._renderingQueueLaunched=!1}_renderViews(){return!1}switchFullscreen(p){this.isFullscreen?this.exitFullscreen():this.enterFullscreen(p)}enterFullscreen(p){this.isFullscreen||(this._pointerLockRequested=p,this._renderingCanvas&&ci._RequestFullscreen(this._renderingCanvas))}exitFullscreen(){this.isFullscreen&&ci._ExitFullscreen()}enterPointerlock(){this._renderingCanvas&&ci._RequestPointerlock(this._renderingCanvas)}exitPointerlock(){ci._ExitPointerlock()}beginFrame(){this._measureFps(),this.onBeginFrameObservable.notifyObservers(this),super.beginFrame()}endFrame(){super.endFrame(),this.onEndFrameObservable.notifyObservers(this)}setSize(p,_,E=!1){if(!this._renderingCanvas||!super.setSize(p,_,E))return!1;if(this.scenes){for(let I=0;I<this.scenes.length;I++){const Z=this.scenes[I];for(let re=0;re<Z.cameras.length;re++){const ae=Z.cameras[re];ae._currentRenderId=0}}this.onResizeObservable.hasObservers()&&this.onResizeObservable.notifyObservers(this)}return!0}_deletePipelineContext(p){const _=p;_&&_.program&&_.transformFeedback&&(this.deleteTransformFeedback(_.transformFeedback),_.transformFeedback=null),super._deletePipelineContext(p)}createShaderProgram(p,_,E,I,Z,re=null){Z=Z||this._gl,this.onBeforeShaderCompilationObservable.notifyObservers(this);const ae=super.createShaderProgram(p,_,E,I,Z,re);return this.onAfterShaderCompilationObservable.notifyObservers(this),ae}_createShaderProgram(p,_,E,I,Z=null){const re=I.createProgram();if(p.program=re,!re)throw new Error("Unable to create program");if(I.attachShader(re,_),I.attachShader(re,E),this.webGLVersion>1&&Z){const ae=this.createTransformFeedback();this.bindTransformFeedback(ae),this.setTranformFeedbackVaryings(re,Z),p.transformFeedback=ae}return I.linkProgram(re),this.webGLVersion>1&&Z&&this.bindTransformFeedback(null),p.context=I,p.vertexShader=_,p.fragmentShader=E,p.isParallelCompiled||this._finalizePipelineContext(p),re}_releaseTexture(p){super._releaseTexture(p)}_releaseRenderTargetWrapper(p){super._releaseRenderTargetWrapper(p),this.scenes.forEach(_=>{_.postProcesses.forEach(E=>{E._outputTexture===p&&(E._outputTexture=null)}),_.cameras.forEach(E=>{E._postProcesses.forEach(I=>{I&&I._outputTexture===p&&(I._outputTexture=null)})})})}getRenderPassNames(){return this._renderPassNames}getCurrentRenderPassName(){return this._renderPassNames[this.currentRenderPassId]}createRenderPassId(p){const _=++ci._RenderPassIdCounter;return this._renderPassNames[_]=p??"NONAME",_}releaseRenderPassId(p){this._renderPassNames[p]=void 0;for(let _=0;_<this.scenes.length;++_){const E=this.scenes[_];for(let I=0;I<E.meshes.length;++I){const Z=E.meshes[I];if(Z.subMeshes)for(let re=0;re<Z.subMeshes.length;++re)Z.subMeshes[re]._removeDrawWrapper(p)}}}_rescaleTexture(p,_,E,I,Z){this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MAG_FILTER,this._gl.LINEAR),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MIN_FILTER,this._gl.LINEAR),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_S,this._gl.CLAMP_TO_EDGE),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_T,this._gl.CLAMP_TO_EDGE);const re=this.createRenderTargetTexture({width:_.width,height:_.height},{generateMipMaps:!1,type:0,samplingMode:2,generateDepthBuffer:!1,generateStencilBuffer:!1});!this._rescalePostProcess&&ci._RescalePostProcessFactory&&(this._rescalePostProcess=ci._RescalePostProcessFactory(this)),this._rescalePostProcess&&(this._rescalePostProcess.externalTextureSamplerBinding=!0,this._rescalePostProcess.getEffect().executeWhenCompiled(()=>{this._rescalePostProcess.onApply=function(he){he._bindTexture("textureSampler",p)};let ae=E;ae||(ae=this.scenes[this.scenes.length-1]),ae.postProcessManager.directRender([this._rescalePostProcess],re,!0),this._bindTextureDirectly(this._gl.TEXTURE_2D,_,!0),this._gl.copyTexImage2D(this._gl.TEXTURE_2D,0,I,0,0,_.width,_.height,0),this.unBindFramebuffer(re),re.dispose(),Z&&Z()}))}getFps(){return this._fps}getDeltaTime(){return this._deltaTime}_measureFps(){this._performanceMonitor.sampleFrame(),this._fps=this._performanceMonitor.averageFPS,this._deltaTime=this._performanceMonitor.instantaneousFrameTime||0}wrapWebGLTexture(p,_=!1,E=3,I=0,Z=0){const re=new Ko(p,this._gl),ae=new c0(this,kn.Unknown,!0);return ae._hardwareTexture=re,ae.baseWidth=I,ae.baseHeight=Z,ae.width=I,ae.height=Z,ae.isReady=!0,ae.useMipMaps=_,this.updateTextureSamplingMode(E,ae),ae}_uploadImageToTexture(p,_,E=0,I=0){const Z=this._gl,re=this._getWebGLTextureType(p.type),ae=this._getInternalFormat(p.format),he=this._getRGBABufferInternalSizedFormat(p.type,ae),_e=p.isCube?Z.TEXTURE_CUBE_MAP:Z.TEXTURE_2D;this._bindTextureDirectly(_e,p,!0),this._unpackFlipY(p.invertY);let ve=Z.TEXTURE_2D;p.isCube&&(ve=Z.TEXTURE_CUBE_MAP_POSITIVE_X+E),Z.texImage2D(ve,I,he,ae,re,_),this._bindTextureDirectly(_e,null,!0)}updateTextureComparisonFunction(p,_){if(this.webGLVersion===1){Ti.Error("WebGL 1 does not support texture comparison.");return}const E=this._gl;p.isCube?(this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,p,!0),_===0?(E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_COMPARE_FUNC,515),E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_COMPARE_MODE,E.NONE)):(E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_COMPARE_FUNC,_),E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_COMPARE_MODE,E.COMPARE_REF_TO_TEXTURE)),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null)):(this._bindTextureDirectly(this._gl.TEXTURE_2D,p,!0),_===0?(E.texParameteri(E.TEXTURE_2D,E.TEXTURE_COMPARE_FUNC,515),E.texParameteri(E.TEXTURE_2D,E.TEXTURE_COMPARE_MODE,E.NONE)):(E.texParameteri(E.TEXTURE_2D,E.TEXTURE_COMPARE_FUNC,_),E.texParameteri(E.TEXTURE_2D,E.TEXTURE_COMPARE_MODE,E.COMPARE_REF_TO_TEXTURE)),this._bindTextureDirectly(this._gl.TEXTURE_2D,null)),p._comparisonFunction=_}createInstancesBuffer(p){const _=this._gl.createBuffer();if(!_)throw new Error("Unable to create instance buffer");const E=new Gx(_);return E.capacity=p,this.bindArrayBuffer(E),this._gl.bufferData(this._gl.ARRAY_BUFFER,p,this._gl.DYNAMIC_DRAW),E.references=1,E}deleteInstancesBuffer(p){this._gl.deleteBuffer(p)}_clientWaitAsync(p,_=0,E=10){const I=this._gl;return new Promise((Z,re)=>{const ae=()=>{const he=I.clientWaitSync(p,_,0);if(he==I.WAIT_FAILED){re();return}if(he==I.TIMEOUT_EXPIRED){setTimeout(ae,E);return}Z()};ae()})}_readPixelsAsync(p,_,E,I,Z,re,ae){if(this._webGLVersion<2)throw new Error("_readPixelsAsync only work on WebGL2+");const he=this._gl,_e=he.createBuffer();he.bindBuffer(he.PIXEL_PACK_BUFFER,_e),he.bufferData(he.PIXEL_PACK_BUFFER,ae.byteLength,he.STREAM_READ),he.readPixels(p,_,E,I,Z,re,0),he.bindBuffer(he.PIXEL_PACK_BUFFER,null);const ve=he.fenceSync(he.SYNC_GPU_COMMANDS_COMPLETE,0);return ve?(he.flush(),this._clientWaitAsync(ve,0,10).then(()=>(he.deleteSync(ve),he.bindBuffer(he.PIXEL_PACK_BUFFER,_e),he.getBufferSubData(he.PIXEL_PACK_BUFFER,0,ae),he.bindBuffer(he.PIXEL_PACK_BUFFER,null),he.deleteBuffer(_e),ae))):null}dispose(){for(this.hideLoadingUI(),this.onNewSceneAddedObservable.clear();this.postProcesses.length;)this.postProcesses[0].dispose();for(this._rescalePostProcess&&this._rescalePostProcess.dispose();this.scenes.length;)this.scenes[0].dispose();for(;this._virtualScenes.length;)this._virtualScenes[0].dispose();Mr.Instances.length===1&&ci.audioEngine&&(ci.audioEngine.dispose(),ci.audioEngine=null);const p=this.getHostWindow();p&&typeof p.removeEventListener=="function"&&(p.removeEventListener("blur",this._onBlur),p.removeEventListener("focus",this._onFocus)),this._renderingCanvas&&(this._renderingCanvas.removeEventListener("focus",this._onCanvasFocus),this._renderingCanvas.removeEventListener("blur",this._onCanvasBlur),this._renderingCanvas.removeEventListener("pointerout",this._onCanvasPointerOut),this._renderingCanvas.removeEventListener("contextmenu",this._onCanvasContextMenu)),no()&&(document.removeEventListener("fullscreenchange",this._onFullscreenChange),document.removeEventListener("mozfullscreenchange",this._onFullscreenChange),document.removeEventListener("webkitfullscreenchange",this._onFullscreenChange),document.removeEventListener("msfullscreenchange",this._onFullscreenChange),document.removeEventListener("pointerlockchange",this._onPointerLockChange),document.removeEventListener("mspointerlockchange",this._onPointerLockChange),document.removeEventListener("mozpointerlockchange",this._onPointerLockChange),document.removeEventListener("webkitpointerlockchange",this._onPointerLockChange)),super.dispose();const _=Mr.Instances.indexOf(this);_>=0&&Mr.Instances.splice(_,1),ci.Instances.length||Mr.OnEnginesDisposedObservable.notifyObservers(this),this.onResizeObservable.clear(),this.onCanvasBlurObservable.clear(),this.onCanvasFocusObservable.clear(),this.onCanvasPointerOutObservable.clear(),this.onBeginFrameObservable.clear(),this.onEndFrameObservable.clear()}_disableTouchAction(){!this._renderingCanvas||!this._renderingCanvas.setAttribute||(this._renderingCanvas.setAttribute("touch-action","none"),this._renderingCanvas.style.touchAction="none",this._renderingCanvas.style.webkitTapHighlightColor="transparent")}displayLoadingUI(){if(!va())return;const p=this.loadingScreen;p&&p.displayLoadingUI()}hideLoadingUI(){if(!va())return;const p=this._loadingScreen;p&&p.hideLoadingUI()}get loadingScreen(){return!this._loadingScreen&&this._renderingCanvas&&(this._loadingScreen=ci.DefaultLoadingScreenFactory(this._renderingCanvas)),this._loadingScreen}set loadingScreen(p){this._loadingScreen=p}set loadingUIText(p){this.loadingScreen.loadingUIText=p}set loadingUIBackgroundColor(p){this.loadingScreen.loadingUIBackgroundColor=p}createVideoElement(p){return document.createElement("video")}static _RequestPointerlock(p){if(p.requestPointerLock){const _=p.requestPointerLock();_ instanceof Promise?_.then(()=>{p.focus()}).catch(()=>{}):p.focus()}}static _ExitPointerlock(){document.exitPointerLock&&document.exitPointerLock()}static _RequestFullscreen(p){const _=p.requestFullscreen||p.webkitRequestFullscreen;_&&_.call(p)}static _ExitFullscreen(){const p=document;document.exitFullscreen?document.exitFullscreen():p.webkitCancelFullScreen&&p.webkitCancelFullScreen()}getFontOffset(p){const _=document.createElement("span");_.innerHTML="Hg",_.setAttribute("style",`font: ${p} !important`);const E=document.createElement("div");E.style.display="inline-block",E.style.width="1px",E.style.height="0px",E.style.verticalAlign="bottom";const I=document.createElement("div");I.style.whiteSpace="nowrap",I.appendChild(_),I.appendChild(E),document.body.appendChild(I);let Z=0,re=0;try{re=E.getBoundingClientRect().top-_.getBoundingClientRect().top,E.style.verticalAlign="baseline",Z=E.getBoundingClientRect().top-_.getBoundingClientRect().top}finally{document.body.removeChild(I)}return{ascent:Z,height:re,descent:re-Z}}}ci.ALPHA_DISABLE=0,ci.ALPHA_ADD=1,ci.ALPHA_COMBINE=2,ci.ALPHA_SUBTRACT=3,ci.ALPHA_MULTIPLY=4,ci.ALPHA_MAXIMIZED=5,ci.ALPHA_ONEONE=6,ci.ALPHA_PREMULTIPLIED=7,ci.ALPHA_PREMULTIPLIED_PORTERDUFF=8,ci.ALPHA_INTERPOLATE=9,ci.ALPHA_SCREENMODE=10,ci.DELAYLOADSTATE_NONE=0,ci.DELAYLOADSTATE_LOADED=1,ci.DELAYLOADSTATE_LOADING=2,ci.DELAYLOADSTATE_NOTLOADED=4,ci.NEVER=512,ci.ALWAYS=519,ci.LESS=513,ci.EQUAL=514,ci.LEQUAL=515,ci.GREATER=516,ci.GEQUAL=518,ci.NOTEQUAL=517,ci.KEEP=7680,ci.REPLACE=7681,ci.INCR=7682,ci.DECR=7683,ci.INVERT=5386,ci.INCR_WRAP=34055,ci.DECR_WRAP=34056,ci.TEXTURE_CLAMP_ADDRESSMODE=0,ci.TEXTURE_WRAP_ADDRESSMODE=1,ci.TEXTURE_MIRROR_ADDRESSMODE=2,ci.TEXTUREFORMAT_ALPHA=0,ci.TEXTUREFORMAT_LUMINANCE=1,ci.TEXTUREFORMAT_LUMINANCE_ALPHA=2,ci.TEXTUREFORMAT_RGB=4,ci.TEXTUREFORMAT_RGBA=5,ci.TEXTUREFORMAT_RED=6,ci.TEXTUREFORMAT_R=6,ci.TEXTUREFORMAT_RG=7,ci.TEXTUREFORMAT_RED_INTEGER=8,ci.TEXTUREFORMAT_R_INTEGER=8,ci.TEXTUREFORMAT_RG_INTEGER=9,ci.TEXTUREFORMAT_RGB_INTEGER=10,ci.TEXTUREFORMAT_RGBA_INTEGER=11,ci.TEXTURETYPE_UNSIGNED_BYTE=0,ci.TEXTURETYPE_UNSIGNED_INT=0,ci.TEXTURETYPE_FLOAT=1,ci.TEXTURETYPE_HALF_FLOAT=2,ci.TEXTURETYPE_BYTE=3,ci.TEXTURETYPE_SHORT=4,ci.TEXTURETYPE_UNSIGNED_SHORT=5,ci.TEXTURETYPE_INT=6,ci.TEXTURETYPE_UNSIGNED_INTEGER=7,ci.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4=8,ci.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1=9,ci.TEXTURETYPE_UNSIGNED_SHORT_5_6_5=10,ci.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV=11,ci.TEXTURETYPE_UNSIGNED_INT_24_8=12,ci.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV=13,ci.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV=14,ci.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV=15,ci.TEXTURE_NEAREST_SAMPLINGMODE=1,ci.TEXTURE_BILINEAR_SAMPLINGMODE=2,ci.TEXTURE_TRILINEAR_SAMPLINGMODE=3,ci.TEXTURE_NEAREST_NEAREST_MIPLINEAR=8,ci.TEXTURE_LINEAR_LINEAR_MIPNEAREST=11,ci.TEXTURE_LINEAR_LINEAR_MIPLINEAR=3,ci.TEXTURE_NEAREST_NEAREST_MIPNEAREST=4,ci.TEXTURE_NEAREST_LINEAR_MIPNEAREST=5,ci.TEXTURE_NEAREST_LINEAR_MIPLINEAR=6,ci.TEXTURE_NEAREST_LINEAR=7,ci.TEXTURE_NEAREST_NEAREST=1,ci.TEXTURE_LINEAR_NEAREST_MIPNEAREST=9,ci.TEXTURE_LINEAR_NEAREST_MIPLINEAR=10,ci.TEXTURE_LINEAR_LINEAR=2,ci.TEXTURE_LINEAR_NEAREST=12,ci.TEXTURE_EXPLICIT_MODE=0,ci.TEXTURE_SPHERICAL_MODE=1,ci.TEXTURE_PLANAR_MODE=2,ci.TEXTURE_CUBIC_MODE=3,ci.TEXTURE_PROJECTION_MODE=4,ci.TEXTURE_SKYBOX_MODE=5,ci.TEXTURE_INVCUBIC_MODE=6,ci.TEXTURE_EQUIRECTANGULAR_MODE=7,ci.TEXTURE_FIXED_EQUIRECTANGULAR_MODE=8,ci.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9,ci.SCALEMODE_FLOOR=1,ci.SCALEMODE_NEAREST=2,ci.SCALEMODE_CEILING=3,ci._RescalePostProcessFactory=null,ci._RenderPassIdCounter=0;const al=(pe,p,_)=>!pe||pe.getClassName&&pe.getClassName()==="Mesh"?null:pe.getClassName&&(pe.getClassName()==="SubMesh"||pe.getClassName()==="PhysicsBody")?pe.clone(p):pe.clone?pe.clone():Array.isArray(pe)?pe.slice():_&&typeof pe=="object"?{...pe}:null;function wx(pe){const p=[];do Object.getOwnPropertyNames(pe).forEach(function(_){p.indexOf(_)===-1&&p.push(_)});while(pe=Object.getPrototypeOf(pe));return p}class jo{static DeepCopy(p,_,E,I,Z=!1){const re=wx(p);for(const ae of re){if(ae[0]==="_"&&(!I||I.indexOf(ae)===-1)||ae.endsWith("Observable")||E&&E.indexOf(ae)!==-1)continue;const he=p[ae],_e=typeof he;if(_e!=="function")try{if(_e==="object")if(he instanceof Uint8Array)_[ae]=Uint8Array.from(he);else if(he instanceof Array){if(_[ae]=[],he.length>0)if(typeof he[0]=="object")for(let ve=0;ve<he.length;ve++){const Le=al(he[ve],_,Z);_[ae].indexOf(Le)===-1&&_[ae].push(Le)}else _[ae]=he.slice(0)}else _[ae]=al(he,_,Z);else _[ae]=he}catch(ve){Ti.Warn(ve.message)}}}}function xl(){return typeof _native<"u"&&_native.XMLHttpRequest?new _native.XMLHttpRequest:new XMLHttpRequest}class Ua{constructor(){this._xhr=xl(),this._requestURL=""}static get IsCustomRequestAvailable(){return Object.keys(Ua.CustomRequestHeaders).length>0||Ua.CustomRequestModifiers.length>0}_injectCustomRequestHeaders(){if(!this._shouldSkipRequestModifications(this._requestURL))for(const p in Ua.CustomRequestHeaders){const _=Ua.CustomRequestHeaders[p];_&&this._xhr.setRequestHeader(p,_)}}_shouldSkipRequestModifications(p){return Ua.SkipRequestModificationForBabylonCDN&&(p.includes("preview.babylonjs.com")||p.includes("cdn.babylonjs.com"))}get onprogress(){return this._xhr.onprogress}set onprogress(p){this._xhr.onprogress=p}get readyState(){return this._xhr.readyState}get status(){return this._xhr.status}get statusText(){return this._xhr.statusText}get response(){return this._xhr.response}get responseURL(){return this._xhr.responseURL}get responseText(){return this._xhr.responseText}get responseType(){return this._xhr.responseType}set responseType(p){this._xhr.responseType=p}get timeout(){return this._xhr.timeout}set timeout(p){this._xhr.timeout=p}addEventListener(p,_,E){this._xhr.addEventListener(p,_,E)}removeEventListener(p,_,E){this._xhr.removeEventListener(p,_,E)}abort(){this._xhr.abort()}send(p){Ua.CustomRequestHeaders&&this._injectCustomRequestHeaders(),this._xhr.send(p)}open(p,_){for(const E of Ua.CustomRequestModifiers){if(this._shouldSkipRequestModifications(_))return;E(this._xhr,_)}_=_.replace("file:http:","http:"),_=_.replace("file:https:","https:"),this._requestURL=_,this._xhr.open(p,_,!0)}setRequestHeader(p,_){this._xhr.setRequestHeader(p,_)}getResponseHeader(p){return this._xhr.getResponseHeader(p)}}Ua.CustomRequestHeaders={},Ua.CustomRequestModifiers=new Array,Ua.SkipRequestModificationForBabylonCDN=!0;class T0{}T0.FilesToLoad={};class Wl{static ExponentialBackoff(p=3,_=500){return(E,I,Z)=>I.status!==0||Z>=p||E.indexOf("file:")!==-1?-1:Math.pow(2,Z)*_}}class qo extends Error{}qo._setPrototypeOf=Object.setPrototypeOf||((pe,p)=>(pe.__proto__=p,pe));const Wx={MeshInvalidPositionsError:0,UnsupportedTextureError:1e3,GLTFLoaderUnexpectedMagicError:2e3,SceneLoaderError:3e3,LoadFileError:4e3,RequestFileError:4001,ReadFileError:4002};class Hx extends qo{constructor(p,_,E){super(p),this.errorCode=_,this.innerError=E,this.name="RuntimeError",qo._setPrototypeOf(this,Hx.prototype)}}const vc=(pe,p)=>pe.endsWith(p),Rc=(pe,p)=>pe?pe.startsWith(p):!1,Lh=pe=>{if(typeof TextDecoder<"u")return new TextDecoder().decode(pe);let p="";for(let _=0;_<pe.byteLength;_++)p+=String.fromCharCode(pe[_]);return p},ll=pe=>{const p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";let _="",E,I,Z,re,ae,he,_e,ve=0;const Le=ArrayBuffer.isView(pe)?new Uint8Array(pe.buffer,pe.byteOffset,pe.byteLength):new Uint8Array(pe);for(;ve<Le.length;)E=Le[ve++],I=ve<Le.length?Le[ve++]:Number.NaN,Z=ve<Le.length?Le[ve++]:Number.NaN,re=E>>2,ae=(E&3)<<4|I>>4,he=(I&15)<<2|Z>>6,_e=Z&63,isNaN(I)?he=_e=64:isNaN(Z)&&(_e=64),_+=p.charAt(re)+p.charAt(ae)+p.charAt(he)+p.charAt(_e);return _},hl=pe=>atob(pe),_x=pe=>{const p=hl(pe),_=p.length,E=new Uint8Array(new ArrayBuffer(_));for(let I=0;I<_;I++)E[I]=p.charCodeAt(I);return E.buffer},kh={EndsWith:vc,StartsWith:Rc,Decode:Lh,EncodeArrayBufferToBase64:ll,DecodeBase64ToString:hl,DecodeBase64ToBinary:_x,PadNumber:(pe,p)=>{let _=String(pe);for(;_.length<p;)_="0"+_;return _}};class cl{static SetImmediate(p){va()&&window.setImmediate?window.setImmediate(p):setTimeout(p,1)}}const L0=new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);class _2 extends Hx{constructor(p,_){super(p,Wx.LoadFileError),this.name="LoadFileError",qo._setPrototypeOf(this,_2.prototype),_ instanceof Ua?this.request=_:this.file=_}}class T2 extends Hx{constructor(p,_){super(p,Wx.RequestFileError),this.request=_,this.name="RequestFileError",qo._setPrototypeOf(this,T2.prototype)}}class Hl extends Hx{constructor(p,_){super(p,Wx.ReadFileError),this.file=_,this.name="ReadFileError",qo._setPrototypeOf(this,Hl.prototype)}}const Ra={DefaultRetryStrategy:Wl.ExponentialBackoff(),BaseUrl:"",CorsBehavior:"anonymous",PreprocessUrl:pe=>pe,ScriptBaseUrl:"",ScriptPreprocessUrl:pe=>pe},Uh=pe=>(pe=pe.replace(/#/gm,"%23"),pe),Xl=(pe,p)=>{if(!(pe&&pe.indexOf("data:")===0)&&Ra.CorsBehavior)if(typeof Ra.CorsBehavior=="string"||Ra.CorsBehavior instanceof String)p.crossOrigin=Ra.CorsBehavior;else{const _=Ra.CorsBehavior(pe);_&&(p.crossOrigin=_)}},ul=(pe,p,_,E,I="",Z)=>{const re=Mr.LastCreatedEngine;if(typeof HTMLImageElement>"u"&&!re?._features.forceBitmapOverHTMLImageElement)return _("LoadImage is only supported in web or BabylonNative environments."),null;let ae,he=!1;pe instanceof ArrayBuffer||ArrayBuffer.isView(pe)?typeof Blob<"u"&&typeof URL<"u"?(ae=URL.createObjectURL(new Blob([pe],{type:I})),he=!0):ae=`data:${I};base64,`+ll(pe):pe instanceof Blob?(ae=URL.createObjectURL(pe),he=!0):(ae=Uh(pe),ae=Ra.PreprocessUrl(pe));const _e=zt=>{if(_){const Gt=ae||pe.toString();_(`Error while trying to load image: ${Gt.indexOf("http")===0||Gt.length<=128?Gt:Gt.slice(0,128)+"..."}`,zt)}};if(re?._features.forceBitmapOverHTMLImageElement)return lo(ae,zt=>{re.createImageBitmap(new Blob([zt],{type:I}),{premultiplyAlpha:"none",...Z}).then(Gt=>{p(Gt),he&&URL.revokeObjectURL(ae)}).catch(Gt=>{_&&_("Error while trying to load image: "+pe,Gt)})},void 0,E||void 0,!0,(zt,Gt)=>{_e(Gt)}),null;const ve=new Image;Xl(ae,ve);const Le=[],ze=()=>{Le.forEach(zt=>{zt.target.addEventListener(zt.name,zt.handler)})},He=()=>{Le.forEach(zt=>{zt.target.removeEventListener(zt.name,zt.handler)}),Le.length=0},xt=()=>{He(),p(ve),he&&ve.src&&URL.revokeObjectURL(ve.src)},rt=zt=>{He(),_e(zt),he&&ve.src&&URL.revokeObjectURL(ve.src)},Tt=zt=>{if(zt.blockedURI!==ve.src)return;He();const Gt=new Error(`CSP violation of policy ${zt.effectiveDirective} ${zt.blockedURI}. Current policy is ${zt.originalPolicy}`);Mr.UseFallbackTexture=!1,_e(Gt),he&&ve.src&&URL.revokeObjectURL(ve.src),ve.src=""};Le.push({target:ve,name:"load",handler:xt}),Le.push({target:ve,name:"error",handler:rt}),Le.push({target:document,name:"securitypolicyviolation",handler:Tt}),ze();const Lt=ae.substring(0,5)==="blob:",Nt=ae.substring(0,5)==="data:",qt=()=>{Lt||Nt||!Ua.IsCustomRequestAvailable?ve.src=ae:lo(ae,(zt,Gt,xi)=>{const Gi=!I&&xi?xi:I,vs=new Blob([zt],{type:Gi}),ks=URL.createObjectURL(vs);he=!0,ve.src=ks},void 0,E||void 0,!0,(zt,Gt)=>{_e(Gt)})},Xt=()=>{E&&E.loadImage(ae,ve)};if(!Lt&&!Nt&&E&&E.enableTexturesOffline)E.open(Xt,qt);else{if(ae.indexOf("file:")!==-1){const zt=decodeURIComponent(ae.substring(5).toLowerCase());if(T0.FilesToLoad[zt]&&typeof URL<"u"){try{let Gt;try{Gt=URL.createObjectURL(T0.FilesToLoad[zt])}catch{Gt=URL.createObjectURL(T0.FilesToLoad[zt])}ve.src=Gt,he=!0}catch{ve.src=""}return ve}}qt()}return ve},v2=(pe,p,_,E,I)=>{const Z=new FileReader,re={onCompleteObservable:new Ri,abort:()=>Z.abort()};return Z.onloadend=()=>re.onCompleteObservable.notifyObservers(re),I&&(Z.onerror=()=>{I(new Hl(`Unable to read ${pe.name}`,pe))}),Z.onload=ae=>{p(ae.target.result)},_&&(Z.onprogress=_),E?Z.readAsArrayBuffer(pe):Z.readAsText(pe),re},lo=(pe,p,_,E,I,Z,re)=>{if(pe.name)return v2(pe,p,_,I,Z?ve=>{Z(void 0,ve)}:void 0);const ae=pe;if(ae.indexOf("file:")!==-1){let ve=decodeURIComponent(ae.substring(5).toLowerCase());ve.indexOf("./")===0&&(ve=ve.substring(2));const Le=T0.FilesToLoad[ve];if(Le)return v2(Le,p,_,I,Z?ze=>Z(void 0,new _2(ze.message,ze.file)):void 0)}const{match:he,type:_e}=wc(ae);if(he){const ve={onCompleteObservable:new Ri,abort:()=>()=>{}};try{const Le=I?M2(ae):zh(ae);p(Le,void 0,_e)}catch(Le){Z?Z(void 0,Le):Ti.Error(Le.message||"Failed to parse the Data URL")}return cl.SetImmediate(()=>{ve.onCompleteObservable.notifyObservers(ve)}),ve}return Yl(ae,(ve,Le)=>{p(ve,Le?.responseURL,Le?.getResponseHeader("content-type"))},_,E,I,Z?ve=>{Z(ve.request,new _2(ve.message,ve.request))}:void 0,re)},Yl=(pe,p,_,E,I,Z,re)=>{pe=Uh(pe),pe=Ra.PreprocessUrl(pe);const ae=Ra.BaseUrl+pe;let he=!1;const _e={onCompleteObservable:new Ri,abort:()=>he=!0},ve=()=>{let Le=new Ua,ze=null,He;const xt=()=>{Le&&(_&&Le.removeEventListener("progress",_),He&&Le.removeEventListener("readystatechange",He),Le.removeEventListener("loadend",rt))};let rt=()=>{xt(),_e.onCompleteObservable.notifyObservers(_e),_e.onCompleteObservable.clear(),_=void 0,He=null,rt=null,Z=void 0,re=void 0,p=void 0};_e.abort=()=>{he=!0,rt&&rt(),Le&&Le.readyState!==(XMLHttpRequest.DONE||4)&&Le.abort(),ze!==null&&(clearTimeout(ze),ze=null),Le=null};const Tt=Nt=>{const qt=Nt.message||"Unknown error";Z&&Le?Z(new T2(qt,Le)):Ti.Error(qt)},Lt=Nt=>{if(Le){if(Le.open("GET",ae),re)try{re(Le)}catch(qt){Tt(qt);return}I&&(Le.responseType="arraybuffer"),_&&Le.addEventListener("progress",_),rt&&Le.addEventListener("loadend",rt),He=()=>{if(!(he||!Le)&&Le.readyState===(XMLHttpRequest.DONE||4)){if(He&&Le.removeEventListener("readystatechange",He),Le.status>=200&&Le.status<300||Le.status===0&&(!va()||Gh())){try{p&&p(I?Le.response:Le.responseText,Le)}catch(zt){Tt(zt)}return}const qt=Ra.DefaultRetryStrategy;if(qt){const zt=qt(ae,Le,Nt);if(zt!==-1){xt(),Le=new Ua,ze=setTimeout(()=>Lt(Nt+1),zt);return}}const Xt=new T2("Error status: "+Le.status+" "+Le.statusText+" - Unable to load "+ae,Le);Z&&Z(Xt)}},Le.addEventListener("readystatechange",He),Le.send()}};Lt(0)};if(E&&E.enableSceneOffline){const Le=He=>{He&&He.status>400?Z&&Z(He):ve()},ze=()=>{E&&E.loadFile(Ra.BaseUrl+pe,He=>{!he&&p&&p(He),_e.onCompleteObservable.notifyObservers(_e)},_?He=>{!he&&_&&_(He)}:void 0,Le,I)};E.open(ze,Le)}else ve();return _e},Gh=()=>typeof location<"u"&&location.protocol==="file:",R2=pe=>L0.test(pe),wc=pe=>{const p=L0.exec(pe);return p===null||p.length===0?{match:!1,type:""}:{match:!0,type:p[0].replace("data:","").replace("base64,","")}};function M2(pe){return _x(pe.split(",")[1])}const zh=pe=>hl(pe.split(",")[1]);(()=>{sr._FileToolsLoadImage=ul,sr._FileToolsLoadFile=lo,xx._FileToolsLoadFile=lo})();let j0;((pe,p,_,E,I,Z,re,ae,he,_e)=>{j0={DecodeBase64UrlToBinary:pe,DecodeBase64UrlToString:p,DefaultRetryStrategy:_.DefaultRetryStrategy,BaseUrl:_.BaseUrl,CorsBehavior:_.CorsBehavior,PreprocessUrl:_.PreprocessUrl,IsBase64DataUrl:E,IsFileURL:I,LoadFile:Z,LoadImage:re,ReadFile:ae,RequestFile:he,SetCorsBehavior:_e},Object.defineProperty(j0,"DefaultRetryStrategy",{get:function(){return _.DefaultRetryStrategy},set:function(ve){_.DefaultRetryStrategy=ve}}),Object.defineProperty(j0,"BaseUrl",{get:function(){return _.BaseUrl},set:function(ve){_.BaseUrl=ve}}),Object.defineProperty(j0,"PreprocessUrl",{get:function(){return _.PreprocessUrl},set:function(ve){_.PreprocessUrl=ve}}),Object.defineProperty(j0,"CorsBehavior",{get:function(){return _.CorsBehavior},set:function(ve){_.CorsBehavior=ve}})})(M2,zh,Ra,R2,Gh,lo,ul,v2,Yl,Xl);const pl={};function Gs(pe,p){pl[pe]=p}function r0(pe){return pl[pe]}class k0{static Instantiate(p){if(this.RegisteredExternalClasses&&this.RegisteredExternalClasses[p])return this.RegisteredExternalClasses[p];const _=r0(p);if(_)return _;Ti.Warn(p+" not found, you may have missed an import.");const E=p.split(".");let I=window||this;for(let Z=0,re=E.length;Z<re;Z++)I=I[E[Z]];return typeof I!="function"?null:I}}k0.RegisteredExternalClasses={};function Y0(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,pe=>{const p=Math.random()*16|0;return(pe==="x"?p:p&3|8).toString(16)})}const Mt={RandomId:Y0};class lt{static get BaseUrl(){return Ra.BaseUrl}static set BaseUrl(p){Ra.BaseUrl=p}static IsAbsoluteUrl(p){return p.indexOf("//")===0?!0:p.indexOf("://")===-1||p.indexOf(".")===-1||p.indexOf("/")===-1||p.indexOf(":")>p.indexOf("/")?!1:p.indexOf("://")<p.indexOf(".")||p.indexOf("data:")===0||p.indexOf("blob:")===0}static set ScriptBaseUrl(p){Ra.ScriptBaseUrl=p}static get ScriptBaseUrl(){return Ra.ScriptBaseUrl}static set ScriptPreprocessUrl(p){Ra.ScriptPreprocessUrl=p}static get ScriptPreprocessUrl(){return Ra.ScriptPreprocessUrl}static get DefaultRetryStrategy(){return Ra.DefaultRetryStrategy}static set DefaultRetryStrategy(p){Ra.DefaultRetryStrategy=p}static get CorsBehavior(){return Ra.CorsBehavior}static set CorsBehavior(p){Ra.CorsBehavior=p}static get UseFallbackTexture(){return Mr.UseFallbackTexture}static set UseFallbackTexture(p){Mr.UseFallbackTexture=p}static get RegisteredExternalClasses(){return k0.RegisteredExternalClasses}static set RegisteredExternalClasses(p){k0.RegisteredExternalClasses=p}static get fallbackTexture(){return Mr.FallbackTexture}static set fallbackTexture(p){Mr.FallbackTexture=p}static FetchToRef(p,_,E,I,Z,re){const ae=Math.abs(p)*E%E|0,he=Math.abs(_)*I%I|0,_e=(ae+he*E)*4;re.r=Z[_e]/255,re.g=Z[_e+1]/255,re.b=Z[_e+2]/255,re.a=Z[_e+3]/255}static Mix(p,_,E){return p*(1-E)+_*E}static Instantiate(p){return k0.Instantiate(p)}static SetImmediate(p){cl.SetImmediate(p)}static IsExponentOfTwo(p){let _=1;do _*=2;while(_<p);return _===p}static FloatRound(p){return Math.fround(p)}static GetFilename(p){const _=p.lastIndexOf("/");return _<0?p:p.substring(_+1)}static GetFolderPath(p,_=!1){const E=p.lastIndexOf("/");return E<0?_?p:"":p.substring(0,E+1)}static ToDegrees(p){return p*180/Math.PI}static ToRadians(p){return p*Math.PI/180}static SmoothAngleChange(p,_,E=.9){const I=this.ToRadians(p),Z=this.ToRadians(_);return this.ToDegrees(Math.atan2((1-E)*Math.sin(Z)+E*Math.sin(I),(1-E)*Math.cos(Z)+E*Math.cos(I)))}static MakeArray(p,_){return _!==!0&&(p===void 0||p==null)?null:Array.isArray(p)?p:[p]}static GetPointerPrefix(p){let _="pointer";return va()&&!window.PointerEvent&&(_="mouse"),p._badDesktopOS&&!p._badOS&&!(document&&"ontouchend"in document)&&(_="mouse"),_}static SetCorsBehavior(p,_){Xl(p,_)}static SetReferrerPolicyBehavior(p,_){_.referrerPolicy=p}static CleanUrl(p){return p=p.replace(/#/gm,"%23"),p}static get PreprocessUrl(){return Ra.PreprocessUrl}static set PreprocessUrl(p){Ra.PreprocessUrl=p}static LoadImage(p,_,E,I,Z,re){return ul(p,_,E,I,Z,re)}static LoadFile(p,_,E,I,Z,re){return lo(p,_,E,I,Z,re)}static LoadFileAsync(p,_=!0){return new Promise((E,I)=>{lo(p,Z=>{E(Z)},void 0,void 0,_,(Z,re)=>{I(re)})})}static GetBabylonScriptURL(p,_){if(!p)return"";if(lt.ScriptBaseUrl&&p.startsWith(lt._DefaultCdnUrl)){const E=lt.ScriptBaseUrl[lt.ScriptBaseUrl.length-1]==="/"?lt.ScriptBaseUrl.substring(0,lt.ScriptBaseUrl.length-1):lt.ScriptBaseUrl;p=p.replace(lt._DefaultCdnUrl,E)}return p=lt.ScriptPreprocessUrl(p),_&&(p=lt.GetAbsoluteUrl(p)),p}static LoadBabylonScript(p,_,E,I){p=lt.GetBabylonScriptURL(p),lt.LoadScript(p,_,E)}static LoadBabylonScriptAsync(p){return p=lt.GetBabylonScriptURL(p),lt.LoadScriptAsync(p)}static LoadScript(p,_,E,I){if(typeof importScripts=="function"){try{importScripts(p),_()}catch(ae){E?.(`Unable to load script '${p}' in worker`,ae)}return}else if(!va()){E?.(`Cannot load script '${p}' outside of a window or a worker`);return}const Z=document.getElementsByTagName("head")[0],re=document.createElement("script");re.setAttribute("type","text/javascript"),re.setAttribute("src",p),I&&(re.id=I),re.onload=()=>{_&&_()},re.onerror=ae=>{E&&E(`Unable to load script '${p}'`,ae)},Z.appendChild(re)}static LoadScriptAsync(p,_){return new Promise((E,I)=>{this.LoadScript(p,()=>{E()},(Z,re)=>{I(re||new Error(Z))},_)})}static ReadFileAsDataURL(p,_,E){const I=new FileReader,Z={onCompleteObservable:new Ri,abort:()=>I.abort()};return I.onloadend=()=>{Z.onCompleteObservable.notifyObservers(Z)},I.onload=re=>{_(re.target.result)},I.onprogress=E,I.readAsDataURL(p),Z}static ReadFile(p,_,E,I,Z){return v2(p,_,E,I,Z)}static FileAsURL(p){const _=new Blob([p]);return window.URL.createObjectURL(_)}static Format(p,_=2){return p.toFixed(_)}static DeepCopy(p,_,E,I){jo.DeepCopy(p,_,E,I)}static IsEmpty(p){for(const _ in p)if(Object.prototype.hasOwnProperty.call(p,_))return!1;return!0}static RegisterTopRootEvents(p,_){for(let E=0;E<_.length;E++){const I=_[E];p.addEventListener(I.name,I.handler,!1);try{window.parent&&window.parent.addEventListener(I.name,I.handler,!1)}catch{}}}static UnregisterTopRootEvents(p,_){for(let E=0;E<_.length;E++){const I=_[E];p.removeEventListener(I.name,I.handler);try{p.parent&&p.parent.removeEventListener(I.name,I.handler)}catch{}}}static async DumpFramebuffer(p,_,E,I,Z="image/png",re,ae){throw ur("DumpTools")}static DumpData(p,_,E,I,Z="image/png",re,ae=!1,he=!1,_e){throw ur("DumpTools")}static DumpDataAsync(p,_,E,I="image/png",Z,re=!1,ae=!1,he){throw ur("DumpTools")}static _IsOffScreenCanvas(p){return p.convertToBlob!==void 0}static ToBlob(p,_,E="image/png",I){!lt._IsOffScreenCanvas(p)&&!p.toBlob&&(p.toBlob=function(Z,re,ae){setTimeout(()=>{const he=atob(this.toDataURL(re,ae).split(",")[1]),_e=he.length,ve=new Uint8Array(_e);for(let Le=0;Le<_e;Le++)ve[Le]=he.charCodeAt(Le);Z(new Blob([ve]))})}),lt._IsOffScreenCanvas(p)?p.convertToBlob({type:E,quality:I}).then(Z=>_(Z)):p.toBlob(function(Z){_(Z)},E,I)}static DownloadBlob(p,_){if("download"in document.createElement("a")){if(!_){const E=new Date;_="screenshot_"+((E.getFullYear()+"-"+(E.getMonth()+1)).slice(2)+"-"+E.getDate()+"_"+E.getHours()+"-"+("0"+E.getMinutes()).slice(-2))+".png"}lt.Download(p,_)}else if(p&&typeof URL<"u"){const E=URL.createObjectURL(p),I=window.open("");if(!I)return;const Z=I.document.createElement("img");Z.onload=function(){URL.revokeObjectURL(E)},Z.src=E,I.document.body.appendChild(Z)}}static EncodeScreenshotCanvasData(p,_,E="image/png",I,Z){if(typeof I=="string"||!_)this.ToBlob(p,function(re){re&&lt.DownloadBlob(re,I),_&&_("")},E,Z);else if(_){if(lt._IsOffScreenCanvas(p)){p.convertToBlob({type:E,quality:Z}).then(ae=>{const he=new FileReader;he.readAsDataURL(ae),he.onloadend=()=>{const _e=he.result;_(_e)}});return}const re=p.toDataURL(E,Z);_(re)}}static Download(p,_){if(typeof URL>"u")return;const E=window.URL.createObjectURL(p),I=document.createElement("a");document.body.appendChild(I),I.style.display="none",I.href=E,I.download=_,I.addEventListener("click",()=>{I.parentElement&&I.parentElement.removeChild(I)}),I.click(),window.URL.revokeObjectURL(E)}static BackCompatCameraNoPreventDefault(p){return typeof p[0]=="boolean"?p[0]:typeof p[1]=="boolean"?p[1]:!1}static CreateScreenshot(p,_,E,I,Z="image/png",re=!1,ae){throw ur("ScreenshotTools")}static CreateScreenshotAsync(p,_,E,I="image/png",Z){throw ur("ScreenshotTools")}static CreateScreenshotUsingRenderTarget(p,_,E,I,Z="image/png",re=1,ae=!1,he,_e=!1,ve=!1,Le=!0,ze){throw ur("ScreenshotTools")}static CreateScreenshotUsingRenderTargetAsync(p,_,E,I="image/png",Z=1,re=!1,ae,he=!1,_e=!1,ve=!0,Le){throw ur("ScreenshotTools")}static RandomId(){return Y0()}static IsBase64(p){return R2(p)}static DecodeBase64(p){return M2(p)}static get errorsCount(){return Ti.errorsCount}static Log(p){Ti.Log(p)}static Warn(p){Ti.Warn(p)}static Error(p){Ti.Error(p)}static get LogCache(){return Ti.LogCache}static ClearLogCache(){Ti.ClearLogCache()}static set LogLevels(p){Ti.LogLevels=p}static set PerformanceLogLevel(p){if((p&lt.PerformanceUserMarkLogLevel)===lt.PerformanceUserMarkLogLevel){lt.StartPerformanceCounter=lt._StartUserMark,lt.EndPerformanceCounter=lt._EndUserMark;return}if((p&lt.PerformanceConsoleLogLevel)===lt.PerformanceConsoleLogLevel){lt.StartPerformanceCounter=lt._StartPerformanceConsole,lt.EndPerformanceCounter=lt._EndPerformanceConsole;return}lt.StartPerformanceCounter=lt._StartPerformanceCounterDisabled,lt.EndPerformanceCounter=lt._EndPerformanceCounterDisabled}static _StartPerformanceCounterDisabled(p,_){}static _EndPerformanceCounterDisabled(p,_){}static _StartUserMark(p,_=!0){if(!lt._Performance){if(!va())return;lt._Performance=window.performance}!_||!lt._Performance.mark||lt._Performance.mark(p+"-Begin")}static _EndUserMark(p,_=!0){!_||!lt._Performance.mark||(lt._Performance.mark(p+"-End"),lt._Performance.measure(p,p+"-Begin",p+"-End"))}static _StartPerformanceConsole(p,_=!0){_&&(lt._StartUserMark(p,_),console.time&&console.time(p))}static _EndPerformanceConsole(p,_=!0){_&&(lt._EndUserMark(p,_),console.timeEnd(p))}static get Now(){return zx.Now}static GetClassName(p,_=!1){let E=null;return!_&&p.getClassName?E=p.getClassName():(p instanceof Object&&(E=(_?p:Object.getPrototypeOf(p)).constructor.__bjsclassName__),E||(E=typeof p)),E}static First(p,_){for(const E of p)if(_(E))return E;return null}static getFullClassName(p,_=!1){let E=null,I=null;if(!_&&p.getClassName)E=p.getClassName();else{if(p instanceof Object){const Z=_?p:Object.getPrototypeOf(p);E=Z.constructor.__bjsclassName__,I=Z.constructor.__bjsmoduleName__}E||(E=typeof p)}return E?(I!=null?I+".":"")+E:null}static DelayAsync(p){return new Promise(_=>{setTimeout(()=>{_()},p)})}static IsSafari(){return Ux()?/^((?!chrome|android).)*safari/i.test(navigator.userAgent):!1}}lt.UseCustomRequestHeaders=!1,lt.CustomRequestHeaders=Ua.CustomRequestHeaders,lt.GetDOMTextContent=H0,lt._DefaultCdnUrl="https://cdn.babylonjs.com",lt.GetAbsoluteUrl=typeof document=="object"?pe=>{const p=document.createElement("a");return p.href=pe,p.href}:typeof URL=="function"&&typeof location=="object"?pe=>new URL(pe,location.origin).href:()=>{throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.")},lt.NoneLogLevel=Ti.NoneLogLevel,lt.MessageLogLevel=Ti.MessageLogLevel,lt.WarningLogLevel=Ti.WarningLogLevel,lt.ErrorLogLevel=Ti.ErrorLogLevel,lt.AllLogLevel=Ti.AllLogLevel,lt.IsWindowObjectExist=va,lt.PerformanceNoneLogLevel=0,lt.PerformanceUserMarkLogLevel=1,lt.PerformanceConsoleLogLevel=2,lt.StartPerformanceCounter=lt._StartPerformanceCounterDisabled,lt.EndPerformanceCounter=lt._EndPerformanceCounterDisabled;function ni(pe,p){return _=>{_.__bjsclassName__=pe,_.__bjsmoduleName__=p??null}}class wi{constructor(p,_,E,I=0){this.iterations=p,this.index=I-1,this._done=!1,this._fn=_,this._successCallback=E}executeNext(){this._done||(this.index+1<this.iterations?(++this.index,this._fn(this)):this.breakLoop())}breakLoop(){this._done=!0,this._successCallback()}static Run(p,_,E,I=0){const Z=new wi(p,_,E,I);return Z.executeNext(),Z}static SyncAsyncForLoop(p,_,E,I,Z,re=0){return wi.Run(Math.ceil(p/_),ae=>{Z&&Z()?ae.breakLoop():setTimeout(()=>{for(let he=0;he<_;++he){const _e=ae.index*_+he;if(_e>=p)break;if(E(_e),Z&&Z()){ae.breakLoop();break}}ae.executeNext()},re)},I)}}Mr.FallbackTexture="data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";class ct{constructor(p){this.length=0,this.data=new Array(p),this._id=ct._GlobalId++}push(p){this.data[this.length++]=p,this.length>this.data.length&&(this.data.length*=2)}forEach(p){for(let _=0;_<this.length;_++)p(this.data[_])}sort(p){this.data.sort(p)}reset(){this.length=0}dispose(){this.reset(),this.data&&(this.data.length=0)}concat(p){if(p.length!==0){this.length+p.length>this.data.length&&(this.data.length=(this.length+p.length)*2);for(let _=0;_<p.length;_++)this.data[this.length++]=(p.data||p)[_]}}indexOf(p){const _=this.data.indexOf(p);return _>=this.length?-1:_}contains(p){return this.indexOf(p)!==-1}}ct._GlobalId=0;class _t extends ct{constructor(){super(...arguments),this._duplicateId=0}push(p){super.push(p),p.__smartArrayFlags||(p.__smartArrayFlags={}),p.__smartArrayFlags[this._id]=this._duplicateId}pushNoDuplicate(p){return p.__smartArrayFlags&&p.__smartArrayFlags[this._id]===this._duplicateId?!1:(this.push(p),!0)}reset(){super.reset(),this._duplicateId++}concatWithNoDuplicate(p){if(p.length!==0){this.length+p.length>this.data.length&&(this.data.length=(this.length+p.length)*2);for(let _=0;_<p.length;_++){const E=(p.data||p)[_];this.pushNoDuplicate(E)}}}}class kt{constructor(){this._count=0,this._data={}}copyFrom(p){this.clear(),p.forEach((_,E)=>this.add(_,E))}get(p){const _=this._data[p];if(_!==void 0)return _}getOrAddWithFactory(p,_){let E=this.get(p);return E!==void 0||(E=_(p),E&&this.add(p,E)),E}getOrAdd(p,_){const E=this.get(p);return E!==void 0?E:(this.add(p,_),_)}contains(p){return this._data[p]!==void 0}add(p,_){return this._data[p]!==void 0?!1:(this._data[p]=_,++this._count,!0)}set(p,_){return this._data[p]===void 0?!1:(this._data[p]=_,!0)}getAndRemove(p){const _=this.get(p);return _!==void 0?(delete this._data[p],--this._count,_):null}remove(p){return this.contains(p)?(delete this._data[p],--this._count,!0):!1}clear(){this._data={},this._count=0}get count(){return this._count}forEach(p){for(const _ in this._data){const E=this._data[_];p(_,E)}}first(p){for(const _ in this._data){const E=this._data[_],I=p(_,E);if(I)return I}return null}}class Yt{static Eval(p,_){return p.match(/\([^()]*\)/g)?p=p.replace(/\([^()]*\)/g,E=>(E=E.slice(1,E.length-1),Yt._HandleParenthesisContent(E,_))):p=Yt._HandleParenthesisContent(p,_),p==="true"?!0:p==="false"?!1:Yt.Eval(p,_)}static _HandleParenthesisContent(p,_){_=_||(Z=>Z==="true");let E;const I=p.split("||");for(const Z in I)if(Object.prototype.hasOwnProperty.call(I,Z)){let re=Yt._SimplifyNegation(I[Z].trim());const ae=re.split("&&");if(ae.length>1)for(let he=0;he<ae.length;++he){const _e=Yt._SimplifyNegation(ae[he].trim());if(_e!=="true"&&_e!=="false"?_e[0]==="!"?E=!_(_e.substring(1)):E=_(_e):E=_e==="true",!E){re="false";break}}if(E||re==="true"){E=!0;break}re!=="true"&&re!=="false"?re[0]==="!"?E=!_(re.substring(1)):E=_(re):E=re==="true"}return E?"true":"false"}static _SimplifyNegation(p){return p=p.replace(/^[\s!]+/,_=>(_=_.replace(/[\s]/g,()=>""),_.length%2?"!":"")),p=p.trim(),p==="!true"?p="false":p==="!false"&&(p="true"),p}}class ri{static EnableFor(p){p._tags=p._tags||{},p.hasTags=()=>ri.HasTags(p),p.addTags=_=>ri.AddTagsTo(p,_),p.removeTags=_=>ri.RemoveTagsFrom(p,_),p.matchesTagsQuery=_=>ri.MatchesQuery(p,_)}static DisableFor(p){delete p._tags,delete p.hasTags,delete p.addTags,delete p.removeTags,delete p.matchesTagsQuery}static HasTags(p){if(!p._tags)return!1;const _=p._tags;for(const E in _)if(Object.prototype.hasOwnProperty.call(_,E))return!0;return!1}static GetTags(p,_=!0){if(!p._tags)return null;if(_){const E=[];for(const I in p._tags)Object.prototype.hasOwnProperty.call(p._tags,I)&&p._tags[I]===!0&&E.push(I);return E.join(" ")}else return p._tags}static AddTagsTo(p,_){if(!_||typeof _!="string")return;_.split(" ").forEach(function(I){ri._AddTagTo(p,I)})}static _AddTagTo(p,_){_=_.trim(),!(_===""||_==="true"||_==="false")&&(_.match(/[\s]/)||_.match(/^([!]|([|]|[&]){2})/)||(ri.EnableFor(p),p._tags[_]=!0))}static RemoveTagsFrom(p,_){if(!ri.HasTags(p))return;const E=_.split(" ");for(const I in E)ri._RemoveTagFrom(p,E[I])}static _RemoveTagFrom(p,_){delete p._tags[_]}static MatchesQuery(p,_){return _===void 0?!0:_===""?ri.HasTags(p):Yt.Eval(_,E=>ri.HasTags(p)&&p._tags[E])}}class $t{static WithinEpsilon(p,_,E=1401298e-51){return Math.abs(p-_)<=E}static ToHex(p){const _=p.toString(16);return p<=15?("0"+_).toUpperCase():_.toUpperCase()}static Sign(p){return p=+p,p===0||isNaN(p)?p:p>0?1:-1}static Clamp(p,_=0,E=1){return Math.min(E,Math.max(_,p))}static Log2(p){return Math.log(p)*Math.LOG2E}static ILog2(p){if(Math.log2)return Math.floor(Math.log2(p));if(p<0)return NaN;if(p===0)return-1/0;let _=0;if(p<1){for(;p<1;)_++,p=p*2;_=-_}else if(p>1)for(;p>1;)_++,p=Math.floor(p/2);return _}static Repeat(p,_){return p-Math.floor(p/_)*_}static Normalize(p,_,E){return(p-_)/(E-_)}static Denormalize(p,_,E){return p*(E-_)+_}static DeltaAngle(p,_){let E=$t.Repeat(_-p,360);return E>180&&(E-=360),E}static PingPong(p,_){const E=$t.Repeat(p,_*2);return _-Math.abs(E-_)}static SmoothStep(p,_,E){let I=$t.Clamp(E);return I=-2*I*I*I+3*I*I,_*I+p*(1-I)}static MoveTowards(p,_,E){let I=0;return Math.abs(_-p)<=E?I=_:I=p+$t.Sign(_-p)*E,I}static MoveTowardsAngle(p,_,E){const I=$t.DeltaAngle(p,_);let Z=0;return-E<I&&I<E?Z=_:(_=p+I,Z=$t.MoveTowards(p,_,E)),Z}static Lerp(p,_,E){return p+(_-p)*E}static LerpAngle(p,_,E){let I=$t.Repeat(_-p,360);return I>180&&(I-=360),p+I*$t.Clamp(E)}static InverseLerp(p,_,E){let I=0;return p!=_?I=$t.Clamp((E-p)/(_-p)):I=0,I}static Hermite(p,_,E,I,Z){const re=Z*Z,ae=Z*re,he=2*ae-3*re+1,_e=-2*ae+3*re,ve=ae-2*re+Z,Le=ae-re;return p*he+E*_e+_*ve+I*Le}static Hermite1stDerivative(p,_,E,I,Z){const re=Z*Z;return(re-Z)*6*p+(3*re-4*Z+1)*_+(-re+Z)*6*E+(3*re-2*Z)*I}static RandomRange(p,_){return p===_?p:Math.random()*(_-p)+p}static RangeToPercent(p,_,E){return(p-_)/(E-_)}static PercentToRange(p,_,E){return(E-_)*p+_}static NormalizeRadians(p){return p-=$t.TwoPi*Math.floor((p+Math.PI)/$t.TwoPi),p}static HCF(p,_){const E=p%_;return E===0?_:$t.HCF(_,E)}}$t.TwoPi=Math.PI*2;const Mi=1/2.2,ki=2.2,_s=(1+Math.sqrt(5))/2,ns=.001;class Ts{static BuildArray(p,_){const E=[];for(let I=0;I<p;++I)E.push(_());return E}static BuildTuple(p,_){return Ts.BuildArray(p,_)}}function $r(pe,p,_){const E=pe[p];if(typeof E!="function")return null;const I=function(){const Z=pe.length,re=I.previous.apply(pe,arguments);return _(p,Z),re};return E.next=I,I.previous=E,pe[p]=I,()=>{const Z=I.previous;if(!Z)return;const re=I.next;re?(Z.next=re,re.previous=Z):(Z.next=void 0,pe[p]=Z),I.next=void 0,I.previous=void 0}}const nn=["push","splice","pop","shift","unshift"];function vn(pe,p){const _=nn.map(E=>$r(pe,E,p));return()=>{_.forEach(E=>{E?.()})}}const Rn=pe=>parseInt(pe.toString().replace(/\W/g,""));class xr{constructor(p=0,_=0){this.x=p,this.y=_}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){const p=Rn(this.x),_=Rn(this.y);let E=p;return E=E*397^_,E}toArray(p,_=0){return p[_]=this.x,p[_+1]=this.y,this}fromArray(p,_=0){return xr.FromArrayToRef(p,_,this),this}asArray(){const p=[];return this.toArray(p,0),p}copyFrom(p){return this.x=p.x,this.y=p.y,this}copyFromFloats(p,_){return this.x=p,this.y=_,this}set(p,_){return this.copyFromFloats(p,_)}add(p){return new this.constructor(this.x+p.x,this.y+p.y)}addToRef(p,_){return _.x=this.x+p.x,_.y=this.y+p.y,_}addInPlace(p){return this.x+=p.x,this.y+=p.y,this}addVector3(p){return new this.constructor(this.x+p.x,this.y+p.y)}subtract(p){return new this.constructor(this.x-p.x,this.y-p.y)}subtractToRef(p,_){return _.x=this.x-p.x,_.y=this.y-p.y,_}subtractInPlace(p){return this.x-=p.x,this.y-=p.y,this}multiplyInPlace(p){return this.x*=p.x,this.y*=p.y,this}multiply(p){return new this.constructor(this.x*p.x,this.y*p.y)}multiplyToRef(p,_){return _.x=this.x*p.x,_.y=this.y*p.y,_}multiplyByFloats(p,_){return new this.constructor(this.x*p,this.y*_)}divide(p){return new this.constructor(this.x/p.x,this.y/p.y)}divideToRef(p,_){return _.x=this.x/p.x,_.y=this.y/p.y,_}divideInPlace(p){return this.divideToRef(p,this)}negate(){return new this.constructor(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(p){return p.copyFromFloats(this.x*-1,this.y*-1)}scaleInPlace(p){return this.x*=p,this.y*=p,this}scale(p){const _=new this.constructor(0,0);return this.scaleToRef(p,_),_}scaleToRef(p,_){return _.x=this.x*p,_.y=this.y*p,_}scaleAndAddToRef(p,_){return _.x+=this.x*p,_.y+=this.y*p,_}equals(p){return p&&this.x===p.x&&this.y===p.y}equalsWithEpsilon(p,_=ns){return p&&$t.WithinEpsilon(this.x,p.x,_)&&$t.WithinEpsilon(this.y,p.y,_)}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y))}fract(){return new this.constructor(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}rotateToRef(p,_){const E=Math.cos(p),I=Math.sin(p),Z=E*this.x-I*this.y,re=I*this.x+E*this.y;return _.x=Z,_.y=re,_}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(p){return p===0||p===1?this:this.scaleInPlace(1/p)}normalizeToNew(){const p=new this.constructor(0,0);return this.normalizeToRef(p),p}normalizeToRef(p){const _=this.length();return _===0||_===1?p.copyFromFloats(this.x,this.y):this.scaleToRef(1/_,p)}clone(){return new this.constructor(this.x,this.y)}dot(p){return this.x*p.x+this.y*p.y}static Zero(){return new xr(0,0)}static One(){return new xr(1,1)}static Random(p=0,_=1){return new xr($t.RandomRange(p,_),$t.RandomRange(p,_))}static get ZeroReadOnly(){return xr._ZeroReadOnly}static FromArray(p,_=0){return new xr(p[_],p[_+1])}static FromArrayToRef(p,_,E){return E.x=p[_],E.y=p[_+1],E}static CatmullRom(p,_,E,I,Z){const re=Z*Z,ae=Z*re,he=.5*(2*_.x+(-p.x+E.x)*Z+(2*p.x-5*_.x+4*E.x-I.x)*re+(-p.x+3*_.x-3*E.x+I.x)*ae),_e=.5*(2*_.y+(-p.y+E.y)*Z+(2*p.y-5*_.y+4*E.y-I.y)*re+(-p.y+3*_.y-3*E.y+I.y)*ae);return new p.constructor(he,_e)}static Clamp(p,_,E){let I=p.x;I=I>E.x?E.x:I,I=I<_.x?_.x:I;let Z=p.y;return Z=Z>E.y?E.y:Z,Z=Z<_.y?_.y:Z,new p.constructor(I,Z)}static Hermite(p,_,E,I,Z){const re=Z*Z,ae=Z*re,he=2*ae-3*re+1,_e=-2*ae+3*re,ve=ae-2*re+Z,Le=ae-re,ze=p.x*he+E.x*_e+_.x*ve+I.x*Le,He=p.y*he+E.y*_e+_.y*ve+I.y*Le;return new p.constructor(ze,He)}static Hermite1stDerivative(p,_,E,I,Z){const re=new p.constructor;return this.Hermite1stDerivativeToRef(p,_,E,I,Z,re),re}static Hermite1stDerivativeToRef(p,_,E,I,Z,re){const ae=Z*Z;return re.x=(ae-Z)*6*p.x+(3*ae-4*Z+1)*_.x+(-ae+Z)*6*E.x+(3*ae-2*Z)*I.x,re.y=(ae-Z)*6*p.y+(3*ae-4*Z+1)*_.y+(-ae+Z)*6*E.y+(3*ae-2*Z)*I.y,re}static Lerp(p,_,E){const I=p.x+(_.x-p.x)*E,Z=p.y+(_.y-p.y)*E;return new p.constructor(I,Z)}static Dot(p,_){return p.x*_.x+p.y*_.y}static Normalize(p){const _=new p.constructor;return xr.NormalizeToRef(p,_),_}static NormalizeToRef(p,_){return p.normalizeToRef(_),_}static Minimize(p,_){const E=p.x<_.x?p.x:_.x,I=p.y<_.y?p.y:_.y;return new p.constructor(E,I)}static Maximize(p,_){const E=p.x>_.x?p.x:_.x,I=p.y>_.y?p.y:_.y;return new p.constructor(E,I)}static Transform(p,_){const E=new p.constructor;return xr.TransformToRef(p,_,E),E}static TransformToRef(p,_,E){const I=_.m,Z=p.x*I[0]+p.y*I[4]+I[12],re=p.x*I[1]+p.y*I[5]+I[13];return E.x=Z,E.y=re,E}static PointInTriangle(p,_,E,I){const Z=.5*(-E.y*I.x+_.y*(-E.x+I.x)+_.x*(E.y-I.y)+E.x*I.y),re=Z<0?-1:1,ae=(_.y*I.x-_.x*I.y+(I.y-_.y)*p.x+(_.x-I.x)*p.y)*re,he=(_.x*E.y-_.y*E.x+(_.y-E.y)*p.x+(E.x-_.x)*p.y)*re;return ae>0&&he>0&&ae+he<2*Z*re}static Distance(p,_){return Math.sqrt(xr.DistanceSquared(p,_))}static DistanceSquared(p,_){const E=p.x-_.x,I=p.y-_.y;return E*E+I*I}static Center(p,_){const E=new p.constructor;return xr.CenterToRef(p,_,E)}static CenterToRef(p,_,E){return E.copyFromFloats((p.x+_.x)/2,(p.y+_.y)/2)}static DistanceOfPointFromSegment(p,_,E){const I=xr.DistanceSquared(_,E);if(I===0)return xr.Distance(p,_);const Z=E.subtract(_),re=Math.max(0,Math.min(1,xr.Dot(p.subtract(_),Z)/I)),ae=_.add(Z.multiplyByFloats(re,re));return xr.Distance(p,ae)}}xr._ZeroReadOnly=xr.Zero();class at{get x(){return this._x}set x(p){this._x=p,this._isDirty=!0}get y(){return this._y}set y(p){this._y=p,this._isDirty=!0}get z(){return this._z}set z(p){this._z=p,this._isDirty=!0}constructor(p=0,_=0,E=0){this._isDirty=!0,this._x=p,this._y=_,this._z=E}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vector3"}getHashCode(){const p=Rn(this._x),_=Rn(this._y),E=Rn(this._z);let I=p;return I=I*397^_,I=I*397^E,I}asArray(){const p=[];return this.toArray(p,0),p}toArray(p,_=0){return p[_]=this._x,p[_+1]=this._y,p[_+2]=this._z,this}fromArray(p,_=0){return at.FromArrayToRef(p,_,this),this}toQuaternion(){return us.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(p){return this.addInPlaceFromFloats(p._x,p._y,p._z)}addInPlaceFromFloats(p,_,E){return this._x+=p,this._y+=_,this._z+=E,this._isDirty=!0,this}add(p){return new this.constructor(this._x+p._x,this._y+p._y,this._z+p._z)}addToRef(p,_){return _.copyFromFloats(this._x+p._x,this._y+p._y,this._z+p._z)}subtractInPlace(p){return this._x-=p._x,this._y-=p._y,this._z-=p._z,this._isDirty=!0,this}subtract(p){return new this.constructor(this._x-p._x,this._y-p._y,this._z-p._z)}subtractToRef(p,_){return this.subtractFromFloatsToRef(p._x,p._y,p._z,_)}subtractFromFloats(p,_,E){return new this.constructor(this._x-p,this._y-_,this._z-E)}subtractFromFloatsToRef(p,_,E,I){return I.copyFromFloats(this._x-p,this._y-_,this._z-E)}negate(){return new this.constructor(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(p){return p.copyFromFloats(this._x*-1,this._y*-1,this._z*-1)}scaleInPlace(p){return this._x*=p,this._y*=p,this._z*=p,this._isDirty=!0,this}scale(p){return new this.constructor(this._x*p,this._y*p,this._z*p)}scaleToRef(p,_){return _.copyFromFloats(this._x*p,this._y*p,this._z*p)}getNormalToRef(p){const _=this.length();let E=Math.acos(this.y/_);const I=Math.atan2(this.z,this.x);E>Math.PI/2?E-=Math.PI/2:E+=Math.PI/2;const Z=_*Math.sin(E)*Math.cos(I),re=_*Math.cos(E),ae=_*Math.sin(E)*Math.sin(I);return p.set(Z,re,ae),p}applyRotationQuaternionToRef(p,_){const E=this._x,I=this._y,Z=this._z,re=p._x,ae=p._y,he=p._z,_e=p._w,ve=2*(ae*Z-he*I),Le=2*(he*E-re*Z),ze=2*(re*I-ae*E);return _._x=E+_e*ve+ae*ze-he*Le,_._y=I+_e*Le+he*ve-re*ze,_._z=Z+_e*ze+re*Le-ae*ve,_._isDirty=!0,_}applyRotationQuaternionInPlace(p){return this.applyRotationQuaternionToRef(p,this)}applyRotationQuaternion(p){return this.applyRotationQuaternionToRef(p,new this.constructor)}scaleAndAddToRef(p,_){return _.addInPlaceFromFloats(this._x*p,this._y*p,this._z*p)}projectOnPlane(p,_){const E=new this.constructor;return this.projectOnPlaneToRef(p,_,E),E}projectOnPlaneToRef(p,_,E){const I=p.normal,Z=p.d,re=Ls.Vector3[0];this.subtractToRef(_,re),re.normalize();const ae=at.Dot(re,I);if(Math.abs(ae)<1e-10)E.setAll(1/0);else{const he=-(at.Dot(_,I)+Z)/ae,_e=re.scaleInPlace(he);_.addToRef(_e,E)}return E}equals(p){return p&&this._x===p._x&&this._y===p._y&&this._z===p._z}equalsWithEpsilon(p,_=ns){return p&&$t.WithinEpsilon(this._x,p._x,_)&&$t.WithinEpsilon(this._y,p._y,_)&&$t.WithinEpsilon(this._z,p._z,_)}equalsToFloats(p,_,E){return this._x===p&&this._y===_&&this._z===E}multiplyInPlace(p){return this._x*=p._x,this._y*=p._y,this._z*=p._z,this._isDirty=!0,this}multiply(p){return this.multiplyByFloats(p._x,p._y,p._z)}multiplyToRef(p,_){return _.copyFromFloats(this._x*p._x,this._y*p._y,this._z*p._z)}multiplyByFloats(p,_,E){return new this.constructor(this._x*p,this._y*_,this._z*E)}divide(p){return new this.constructor(this._x/p._x,this._y/p._y,this._z/p._z)}divideToRef(p,_){return _.copyFromFloats(this._x/p._x,this._y/p._y,this._z/p._z)}divideInPlace(p){return this.divideToRef(p,this)}minimizeInPlace(p){return this.minimizeInPlaceFromFloats(p._x,p._y,p._z)}maximizeInPlace(p){return this.maximizeInPlaceFromFloats(p._x,p._y,p._z)}minimizeInPlaceFromFloats(p,_,E){return p<this._x&&(this.x=p),_<this._y&&(this.y=_),E<this._z&&(this.z=E),this}maximizeInPlaceFromFloats(p,_,E){return p>this._x&&(this.x=p),_>this._y&&(this.y=_),E>this._z&&(this.z=E),this}isNonUniformWithinEpsilon(p){const _=Math.abs(this._x),E=Math.abs(this._y);if(!$t.WithinEpsilon(_,E,p))return!0;const I=Math.abs(this._z);return!$t.WithinEpsilon(_,I,p)||!$t.WithinEpsilon(E,I,p)}get isNonUniform(){const p=Math.abs(this._x),_=Math.abs(this._y);if(p!==_)return!0;const E=Math.abs(this._z);return p!==E}floor(){return new this.constructor(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fract(){return new this.constructor(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(p){if(p=p.toLowerCase(),p==="xyz")return this;const _=Ls.Vector3[0].copyFrom(this);return this.x=_[p[0]],this.y=_[p[1]],this.z=_[p[2]],this}rotateByQuaternionToRef(p,_){return p.toRotationMatrix(Ls.Matrix[0]),at.TransformCoordinatesToRef(this,Ls.Matrix[0],_),_}rotateByQuaternionAroundPointToRef(p,_,E){return this.subtractToRef(_,Ls.Vector3[0]),Ls.Vector3[0].rotateByQuaternionToRef(p,Ls.Vector3[0]),_.addToRef(Ls.Vector3[0],E),E}cross(p){const _=new this.constructor;return at.CrossToRef(this,p,_)}normalizeFromLength(p){return p===0||p===1?this:this.scaleInPlace(1/p)}normalizeToNew(){const p=new this.constructor(0,0,0);return this.normalizeToRef(p),p}normalizeToRef(p){const _=this.length();return _===0||_===1?p.copyFromFloats(this._x,this._y,this._z):this.scaleToRef(1/_,p)}clone(){return new this.constructor(this._x,this._y,this._z)}copyFrom(p){return this.copyFromFloats(p._x,p._y,p._z)}copyFromFloats(p,_,E){return this._x=p,this._y=_,this._z=E,this._isDirty=!0,this}set(p,_,E){return this.copyFromFloats(p,_,E)}setAll(p){return this._x=this._y=this._z=p,this._isDirty=!0,this}static GetClipFactor(p,_,E,I){const Z=at.Dot(p,E),re=at.Dot(_,E);return(Z-I)/(Z-re)}static GetAngleBetweenVectors(p,_,E){const I=p.normalizeToRef(Ls.Vector3[1]),Z=_.normalizeToRef(Ls.Vector3[2]);let re=at.Dot(I,Z);re=$t.Clamp(re,-1,1);const ae=Math.acos(re),he=Ls.Vector3[3];return at.CrossToRef(I,Z,he),at.Dot(he,E)>0?isNaN(ae)?0:ae:isNaN(ae)?-Math.PI:-Math.acos(re)}static GetAngleBetweenVectorsOnPlane(p,_,E){Ls.Vector3[0].copyFrom(p);const I=Ls.Vector3[0];Ls.Vector3[1].copyFrom(_);const Z=Ls.Vector3[1];Ls.Vector3[2].copyFrom(E);const re=Ls.Vector3[2],ae=Ls.Vector3[3],he=Ls.Vector3[4];I.normalize(),Z.normalize(),re.normalize(),at.CrossToRef(re,I,ae),at.CrossToRef(ae,re,he);const _e=Math.atan2(at.Dot(Z,ae),at.Dot(Z,he));return $t.NormalizeRadians(_e)}static PitchYawRollToMoveBetweenPointsToRef(p,_,E){const I=ui.Vector3[0];return _.subtractToRef(p,I),E._y=Math.atan2(I.x,I.z)||0,E._x=Math.atan2(Math.sqrt(I.x**2+I.z**2),I.y)||0,E._z=0,E._isDirty=!0,E}static PitchYawRollToMoveBetweenPoints(p,_){const E=at.Zero();return at.PitchYawRollToMoveBetweenPointsToRef(p,_,E)}static SlerpToRef(p,_,E,I){E=$t.Clamp(E,0,1);const Z=Ls.Vector3[0],re=Ls.Vector3[1];Z.copyFrom(p);const ae=Z.length();Z.normalizeFromLength(ae),re.copyFrom(_);const he=re.length();re.normalizeFromLength(he);const _e=at.Dot(Z,re);let ve,Le;if(_e<1-ns){const ze=Math.acos(_e),He=1/Math.sin(ze);ve=Math.sin((1-E)*ze)*He,Le=Math.sin(E*ze)*He}else ve=1-E,Le=E;return Z.scaleInPlace(ve),re.scaleInPlace(Le),I.copyFrom(Z).addInPlace(re),I.scaleInPlace($t.Lerp(ae,he,E)),I}static SmoothToRef(p,_,E,I,Z){return at.SlerpToRef(p,_,I===0?1:E/I,Z),Z}static FromArray(p,_=0){return new at(p[_],p[_+1],p[_+2])}static FromFloatArray(p,_){return at.FromArray(p,_)}static FromArrayToRef(p,_,E){return E._x=p[_],E._y=p[_+1],E._z=p[_+2],E._isDirty=!0,E}static FromFloatArrayToRef(p,_,E){return at.FromArrayToRef(p,_,E)}static FromFloatsToRef(p,_,E,I){return I.copyFromFloats(p,_,E),I}static Zero(){return new at(0,0,0)}static One(){return new at(1,1,1)}static Up(){return new at(0,1,0)}static get UpReadOnly(){return at._UpReadOnly}static get DownReadOnly(){return at._DownReadOnly}static get RightReadOnly(){return at._RightReadOnly}static get LeftReadOnly(){return at._LeftReadOnly}static get LeftHandedForwardReadOnly(){return at._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return at._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return at._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return at._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return at._ZeroReadOnly}static get OneReadOnly(){return at._OneReadOnly}static Down(){return new at(0,-1,0)}static Forward(p=!1){return new at(0,0,p?-1:1)}static Backward(p=!1){return new at(0,0,p?1:-1)}static Right(){return new at(1,0,0)}static Left(){return new at(-1,0,0)}static Random(p=0,_=1){return new at($t.RandomRange(p,_),$t.RandomRange(p,_),$t.RandomRange(p,_))}static TransformCoordinates(p,_){const E=at.Zero();return at.TransformCoordinatesToRef(p,_,E),E}static TransformCoordinatesToRef(p,_,E){return at.TransformCoordinatesFromFloatsToRef(p._x,p._y,p._z,_,E),E}static TransformCoordinatesFromFloatsToRef(p,_,E,I,Z){const re=I.m,ae=p*re[0]+_*re[4]+E*re[8]+re[12],he=p*re[1]+_*re[5]+E*re[9]+re[13],_e=p*re[2]+_*re[6]+E*re[10]+re[14],ve=1/(p*re[3]+_*re[7]+E*re[11]+re[15]);return Z._x=ae*ve,Z._y=he*ve,Z._z=_e*ve,Z._isDirty=!0,Z}static TransformNormal(p,_){const E=at.Zero();return at.TransformNormalToRef(p,_,E),E}static TransformNormalToRef(p,_,E){return this.TransformNormalFromFloatsToRef(p._x,p._y,p._z,_,E),E}static TransformNormalFromFloatsToRef(p,_,E,I,Z){const re=I.m;return Z._x=p*re[0]+_*re[4]+E*re[8],Z._y=p*re[1]+_*re[5]+E*re[9],Z._z=p*re[2]+_*re[6]+E*re[10],Z._isDirty=!0,Z}static CatmullRom(p,_,E,I,Z){const re=Z*Z,ae=Z*re,he=.5*(2*_._x+(-p._x+E._x)*Z+(2*p._x-5*_._x+4*E._x-I._x)*re+(-p._x+3*_._x-3*E._x+I._x)*ae),_e=.5*(2*_._y+(-p._y+E._y)*Z+(2*p._y-5*_._y+4*E._y-I._y)*re+(-p._y+3*_._y-3*E._y+I._y)*ae),ve=.5*(2*_._z+(-p._z+E._z)*Z+(2*p._z-5*_._z+4*E._z-I._z)*re+(-p._z+3*_._z-3*E._z+I._z)*ae);return new p.constructor(he,_e,ve)}static Clamp(p,_,E){const I=new p.constructor;return at.ClampToRef(p,_,E,I),I}static ClampToRef(p,_,E,I){let Z=p._x;Z=Z>E._x?E._x:Z,Z=Z<_._x?_._x:Z;let re=p._y;re=re>E._y?E._y:re,re=re<_._y?_._y:re;let ae=p._z;return ae=ae>E._z?E._z:ae,ae=ae<_._z?_._z:ae,I.copyFromFloats(Z,re,ae),I}static CheckExtends(p,_,E){_.minimizeInPlace(p),E.maximizeInPlace(p)}static Hermite(p,_,E,I,Z){const re=Z*Z,ae=Z*re,he=2*ae-3*re+1,_e=-2*ae+3*re,ve=ae-2*re+Z,Le=ae-re,ze=p._x*he+E._x*_e+_._x*ve+I._x*Le,He=p._y*he+E._y*_e+_._y*ve+I._y*Le,xt=p._z*he+E._z*_e+_._z*ve+I._z*Le;return new p.constructor(ze,He,xt)}static Hermite1stDerivative(p,_,E,I,Z){const re=new p.constructor;return this.Hermite1stDerivativeToRef(p,_,E,I,Z,re),re}static Hermite1stDerivativeToRef(p,_,E,I,Z,re){const ae=Z*Z;return re._x=(ae-Z)*6*p._x+(3*ae-4*Z+1)*_._x+(-ae+Z)*6*E._x+(3*ae-2*Z)*I._x,re._y=(ae-Z)*6*p._y+(3*ae-4*Z+1)*_._y+(-ae+Z)*6*E._y+(3*ae-2*Z)*I._y,re._z=(ae-Z)*6*p._z+(3*ae-4*Z+1)*_._z+(-ae+Z)*6*E._z+(3*ae-2*Z)*I._z,re._isDirty=!0,re}static Lerp(p,_,E){const I=new p.constructor(0,0,0);return at.LerpToRef(p,_,E,I),I}static LerpToRef(p,_,E,I){return I._x=p._x+(_._x-p._x)*E,I._y=p._y+(_._y-p._y)*E,I._z=p._z+(_._z-p._z)*E,I._isDirty=!0,I}static Dot(p,_){return p._x*_._x+p._y*_._y+p._z*_._z}dot(p){return this._x*p._x+this._y*p._y+this._z*p._z}static Cross(p,_){const E=new p.constructor;return at.CrossToRef(p,_,E),E}static CrossToRef(p,_,E){const I=p._y*_._z-p._z*_._y,Z=p._z*_._x-p._x*_._z,re=p._x*_._y-p._y*_._x;return E.copyFromFloats(I,Z,re),E}static Normalize(p){const _=at.Zero();return at.NormalizeToRef(p,_),_}static NormalizeToRef(p,_){return p.normalizeToRef(_),_}static Project(p,_,E,I){const Z=new p.constructor;return at.ProjectToRef(p,_,E,I,Z),Z}static ProjectToRef(p,_,E,I,Z){const re=I.width,ae=I.height,he=I.x,_e=I.y,ve=Ls.Matrix[1];jt.FromValuesToRef(re/2,0,0,0,0,-ae/2,0,0,0,0,.5,0,he+re/2,ae/2+_e,.5,1,ve);const Le=Ls.Matrix[0];return _.multiplyToRef(E,Le),Le.multiplyToRef(ve,Le),at.TransformCoordinatesToRef(p,Le,Z),Z}static Reflect(p,_){return this.ReflectToRef(p,_,new at)}static ReflectToRef(p,_,E){const I=ui.Vector3[0];return I.copyFrom(_).scaleInPlace(2*at.Dot(p,_)),E.copyFrom(p).subtractInPlace(I)}static _UnprojectFromInvertedMatrixToRef(p,_,E){at.TransformCoordinatesToRef(p,_,E);const I=_.m,Z=p._x*I[3]+p._y*I[7]+p._z*I[11]+I[15];return $t.WithinEpsilon(Z,1)&&E.scaleInPlace(1/Z),E}static UnprojectFromTransform(p,_,E,I,Z){return this.Unproject(p,_,E,I,Z,jt.IdentityReadOnly)}static Unproject(p,_,E,I,Z,re){const ae=new p.constructor;return at.UnprojectToRef(p,_,E,I,Z,re,ae),ae}static UnprojectToRef(p,_,E,I,Z,re,ae){return at.UnprojectFloatsToRef(p._x,p._y,p._z,_,E,I,Z,re,ae),ae}static UnprojectFloatsToRef(p,_,E,I,Z,re,ae,he,_e){const ve=Ls.Matrix[0];re.multiplyToRef(ae,ve),ve.multiplyToRef(he,ve),ve.invert();const Le=Ls.Vector3[0];return Le.x=p/I*2-1,Le.y=-(_/Z*2-1),Mr.LastCreatedEngine?.isNDCHalfZRange?Le.z=E:Le.z=2*E-1,at._UnprojectFromInvertedMatrixToRef(Le,ve,_e),_e}static Minimize(p,_){const E=new p.constructor;return E.copyFrom(p),E.minimizeInPlace(_),E}static Maximize(p,_){const E=new p.constructor;return E.copyFrom(p),E.maximizeInPlace(_),E}static Distance(p,_){return Math.sqrt(at.DistanceSquared(p,_))}static DistanceSquared(p,_){const E=p._x-_._x,I=p._y-_._y,Z=p._z-_._z;return E*E+I*I+Z*Z}static ProjectOnTriangleToRef(p,_,E,I,Z){const re=Ls.Vector3[0],ae=Ls.Vector3[1],he=Ls.Vector3[2],_e=Ls.Vector3[3],ve=Ls.Vector3[4];E.subtractToRef(_,re),I.subtractToRef(_,ae),I.subtractToRef(E,he);const Le=re.length(),ze=ae.length(),He=he.length();if(Le<ns||ze<ns||He<ns)return Z.copyFrom(_),at.Distance(p,_);p.subtractToRef(_,ve),at.CrossToRef(re,ae,_e);const xt=_e.length();if(xt<ns)return Z.copyFrom(_),at.Distance(p,_);_e.normalizeFromLength(xt);let rt=ve.length();if(rt<ns)return Z.copyFrom(_),0;ve.normalizeFromLength(rt);const Tt=at.Dot(_e,ve),Lt=Ls.Vector3[5],Nt=Ls.Vector3[6];Lt.copyFrom(_e).scaleInPlace(-rt*Tt),Nt.copyFrom(p).addInPlace(Lt);const qt=Ls.Vector3[4],Xt=Ls.Vector3[5],zt=Ls.Vector3[7],Gt=Ls.Vector3[8];qt.copyFrom(re).scaleInPlace(1/Le),Gt.copyFrom(ae).scaleInPlace(1/ze),qt.addInPlace(Gt).scaleInPlace(-1),Xt.copyFrom(re).scaleInPlace(-1/Le),Gt.copyFrom(he).scaleInPlace(1/He),Xt.addInPlace(Gt).scaleInPlace(-1),zt.copyFrom(he).scaleInPlace(-1/He),Gt.copyFrom(ae).scaleInPlace(-1/ze),zt.addInPlace(Gt).scaleInPlace(-1);const xi=Ls.Vector3[9];let Gi;xi.copyFrom(Nt).subtractInPlace(_),at.CrossToRef(qt,xi,Gt),Gi=at.Dot(Gt,_e);const vs=Gi;xi.copyFrom(Nt).subtractInPlace(E),at.CrossToRef(Xt,xi,Gt),Gi=at.Dot(Gt,_e);const ks=Gi;xi.copyFrom(Nt).subtractInPlace(I),at.CrossToRef(zt,xi,Gt),Gi=at.Dot(Gt,_e);const Ur=Gi,hn=Ls.Vector3[10];let pn,_n;vs>0&&ks<0?(hn.copyFrom(re),pn=_,_n=E):ks>0&&Ur<0?(hn.copyFrom(he),pn=E,_n=I):(hn.copyFrom(ae).scaleInPlace(-1),pn=I,_n=_);const x0=Ls.Vector3[9],Ta=Ls.Vector3[4];if(pn.subtractToRef(Nt,Gt),_n.subtractToRef(Nt,x0),at.CrossToRef(Gt,x0,Ta),!(at.Dot(Ta,_e)<0))return Z.copyFrom(Nt),Math.abs(rt*Tt);const z0=Ls.Vector3[5];at.CrossToRef(hn,Ta,z0),z0.normalize();const W0=Ls.Vector3[9];W0.copyFrom(pn).subtractInPlace(Nt);const Ho=W0.length();if(Ho<ns)return Z.copyFrom(pn),at.Distance(p,pn);W0.normalizeFromLength(Ho);const vo=at.Dot(z0,W0),Ml=Ls.Vector3[7];Ml.copyFrom(Nt).addInPlace(z0.scaleInPlace(Ho*vo)),Gt.copyFrom(Ml).subtractInPlace(pn),rt=hn.length(),hn.normalizeFromLength(rt);let ac=at.Dot(Gt,hn)/Math.max(rt,ns);return ac=$t.Clamp(ac,0,1),Ml.copyFrom(pn).addInPlace(hn.scaleInPlace(ac*rt)),Z.copyFrom(Ml),at.Distance(p,Ml)}static Center(p,_){return at.CenterToRef(p,_,at.Zero())}static CenterToRef(p,_,E){return E.copyFromFloats((p._x+_._x)/2,(p._y+_._y)/2,(p._z+_._z)/2)}static RotationFromAxis(p,_,E){const I=new p.constructor;return at.RotationFromAxisToRef(p,_,E,I),I}static RotationFromAxisToRef(p,_,E,I){const Z=Ls.Quaternion[0];return us.RotationQuaternionFromAxisToRef(p,_,E,Z),Z.toEulerAnglesToRef(I),I}}at._UpReadOnly=at.Up(),at._DownReadOnly=at.Down(),at._LeftHandedForwardReadOnly=at.Forward(!1),at._RightHandedForwardReadOnly=at.Forward(!0),at._LeftHandedBackwardReadOnly=at.Backward(!1),at._RightHandedBackwardReadOnly=at.Backward(!0),at._RightReadOnly=at.Right(),at._LeftReadOnly=at.Left(),at._ZeroReadOnly=at.Zero(),at._OneReadOnly=at.One();class Lr{constructor(p=0,_=0,E=0,I=0){this.x=p,this.y=_,this.z=E,this.w=I}toString(){return`{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`}getClassName(){return"Vector4"}getHashCode(){const p=Rn(this.x),_=Rn(this.y),E=Rn(this.z),I=Rn(this.w);let Z=p;return Z=Z*397^_,Z=Z*397^E,Z=Z*397^I,Z}asArray(){const p=[];return this.toArray(p,0),p}toArray(p,_){return _===void 0&&(_=0),p[_]=this.x,p[_+1]=this.y,p[_+2]=this.z,p[_+3]=this.w,this}fromArray(p,_=0){return Lr.FromArrayToRef(p,_,this),this}addInPlace(p){return this.x+=p.x,this.y+=p.y,this.z+=p.z,this.w+=p.w,this}add(p){return new this.constructor(this.x+p.x,this.y+p.y,this.z+p.z,this.w+p.w)}addToRef(p,_){return _.x=this.x+p.x,_.y=this.y+p.y,_.z=this.z+p.z,_.w=this.w+p.w,_}subtractInPlace(p){return this.x-=p.x,this.y-=p.y,this.z-=p.z,this.w-=p.w,this}subtract(p){return new this.constructor(this.x-p.x,this.y-p.y,this.z-p.z,this.w-p.w)}subtractToRef(p,_){return _.x=this.x-p.x,_.y=this.y-p.y,_.z=this.z-p.z,_.w=this.w-p.w,_}subtractFromFloats(p,_,E,I){return new this.constructor(this.x-p,this.y-_,this.z-E,this.w-I)}subtractFromFloatsToRef(p,_,E,I,Z){return Z.x=this.x-p,Z.y=this.y-_,Z.z=this.z-E,Z.w=this.w-I,Z}negate(){return new this.constructor(-this.x,-this.y,-this.z,-this.w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(p){return p.copyFromFloats(this.x*-1,this.y*-1,this.z*-1,this.w*-1)}scaleInPlace(p){return this.x*=p,this.y*=p,this.z*=p,this.w*=p,this}scale(p){return new this.constructor(this.x*p,this.y*p,this.z*p,this.w*p)}scaleToRef(p,_){return _.x=this.x*p,_.y=this.y*p,_.z=this.z*p,_.w=this.w*p,_}scaleAndAddToRef(p,_){return _.x+=this.x*p,_.y+=this.y*p,_.z+=this.z*p,_.w+=this.w*p,_}equals(p){return p&&this.x===p.x&&this.y===p.y&&this.z===p.z&&this.w===p.w}equalsWithEpsilon(p,_=ns){return p&&$t.WithinEpsilon(this.x,p.x,_)&&$t.WithinEpsilon(this.y,p.y,_)&&$t.WithinEpsilon(this.z,p.z,_)&&$t.WithinEpsilon(this.w,p.w,_)}equalsToFloats(p,_,E,I){return this.x===p&&this.y===_&&this.z===E&&this.w===I}multiplyInPlace(p){return this.x*=p.x,this.y*=p.y,this.z*=p.z,this.w*=p.w,this}multiply(p){return new this.constructor(this.x*p.x,this.y*p.y,this.z*p.z,this.w*p.w)}multiplyToRef(p,_){return _.x=this.x*p.x,_.y=this.y*p.y,_.z=this.z*p.z,_.w=this.w*p.w,_}multiplyByFloats(p,_,E,I){return new this.constructor(this.x*p,this.y*_,this.z*E,this.w*I)}divide(p){return new this.constructor(this.x/p.x,this.y/p.y,this.z/p.z,this.w/p.w)}divideToRef(p,_){return _.x=this.x/p.x,_.y=this.y/p.y,_.z=this.z/p.z,_.w=this.w/p.w,_}divideInPlace(p){return this.divideToRef(p,this)}minimizeInPlace(p){return p.x<this.x&&(this.x=p.x),p.y<this.y&&(this.y=p.y),p.z<this.z&&(this.z=p.z),p.w<this.w&&(this.w=p.w),this}maximizeInPlace(p){return p.x>this.x&&(this.x=p.x),p.y>this.y&&(this.y=p.y),p.z>this.z&&(this.z=p.z),p.w>this.w&&(this.w=p.w),this}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z),Math.floor(this.w))}fract(){return new this.constructor(this.x-Math.floor(this.x),this.y-Math.floor(this.y),this.z-Math.floor(this.z),this.w-Math.floor(this.w))}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(p){return p===0||p===1?this:this.scaleInPlace(1/p)}normalizeToNew(){const p=new this.constructor(0,0,0,0);return this.normalizeToRef(p),p}normalizeToRef(p){const _=this.length();return _===0||_===1?p.copyFromFloats(this.x,this.y,this.z,this.w):this.scaleToRef(1/_,p)}toVector3(){return new at(this.x,this.y,this.z)}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copyFrom(p){return this.x=p.x,this.y=p.y,this.z=p.z,this.w=p.w,this}copyFromFloats(p,_,E,I){return this.x=p,this.y=_,this.z=E,this.w=I,this}set(p,_,E,I){return this.copyFromFloats(p,_,E,I)}setAll(p){return this.x=this.y=this.z=this.w=p,this}dot(p){return this.x*p.x+this.y*p.y+this.z*p.z+this.w*p.w}static FromArray(p,_){return _||(_=0),new Lr(p[_],p[_+1],p[_+2],p[_+3])}static FromArrayToRef(p,_,E){return E.x=p[_],E.y=p[_+1],E.z=p[_+2],E.w=p[_+3],E}static FromFloatArrayToRef(p,_,E){return Lr.FromArrayToRef(p,_,E),E}static FromFloatsToRef(p,_,E,I,Z){return Z.x=p,Z.y=_,Z.z=E,Z.w=I,Z}static Zero(){return new Lr(0,0,0,0)}static One(){return new Lr(1,1,1,1)}static Random(p=0,_=1){return new Lr($t.RandomRange(p,_),$t.RandomRange(p,_),$t.RandomRange(p,_),$t.RandomRange(p,_))}static get ZeroReadOnly(){return Lr._ZeroReadOnly}static Normalize(p){const _=Lr.Zero();return Lr.NormalizeToRef(p,_),_}static NormalizeToRef(p,_){return p.normalizeToRef(_),_}static Minimize(p,_){const E=new p.constructor;return E.copyFrom(p),E.minimizeInPlace(_),E}static Maximize(p,_){const E=new p.constructor;return E.copyFrom(p),E.maximizeInPlace(_),E}static Distance(p,_){return Math.sqrt(Lr.DistanceSquared(p,_))}static DistanceSquared(p,_){const E=p.x-_.x,I=p.y-_.y,Z=p.z-_.z,re=p.w-_.w;return E*E+I*I+Z*Z+re*re}static Center(p,_){return Lr.CenterToRef(p,_,Lr.Zero())}static CenterToRef(p,_,E){return E.copyFromFloats((p.x+_.x)/2,(p.y+_.y)/2,(p.z+_.z)/2,(p.w+_.w)/2)}static TransformCoordinates(p,_){const E=Lr.Zero();return Lr.TransformCoordinatesToRef(p,_,E),E}static TransformCoordinatesToRef(p,_,E){return Lr.TransformCoordinatesFromFloatsToRef(p._x,p._y,p._z,_,E),E}static TransformCoordinatesFromFloatsToRef(p,_,E,I,Z){const re=I.m,ae=p*re[0]+_*re[4]+E*re[8]+re[12],he=p*re[1]+_*re[5]+E*re[9]+re[13],_e=p*re[2]+_*re[6]+E*re[10]+re[14],ve=p*re[3]+_*re[7]+E*re[11]+re[15];return Z.x=ae,Z.y=he,Z.z=_e,Z.w=ve,Z}static TransformNormal(p,_){const E=new p.constructor;return Lr.TransformNormalToRef(p,_,E),E}static TransformNormalToRef(p,_,E){const I=_.m,Z=p.x*I[0]+p.y*I[4]+p.z*I[8],re=p.x*I[1]+p.y*I[5]+p.z*I[9],ae=p.x*I[2]+p.y*I[6]+p.z*I[10];return E.x=Z,E.y=re,E.z=ae,E.w=p.w,E}static TransformNormalFromFloatsToRef(p,_,E,I,Z,re){const ae=Z.m;return re.x=p*ae[0]+_*ae[4]+E*ae[8],re.y=p*ae[1]+_*ae[5]+E*ae[9],re.z=p*ae[2]+_*ae[6]+E*ae[10],re.w=I,re}static FromVector3(p,_=0){return new Lr(p._x,p._y,p._z,_)}static Dot(p,_){return p.dot(_)}}Lr._ZeroReadOnly=Lr.Zero();class us{get x(){return this._x}set x(p){this._x=p,this._isDirty=!0}get y(){return this._y}set y(p){this._y=p,this._isDirty=!0}get z(){return this._z}set z(p){this._z=p,this._isDirty=!0}get w(){return this._w}set w(p){this._w=p,this._isDirty=!0}constructor(p=0,_=0,E=0,I=1){this._isDirty=!0,this._x=p,this._y=_,this._z=E,this._w=I}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){const p=Rn(this._x),_=Rn(this._y),E=Rn(this._z),I=Rn(this._w);let Z=p;return Z=Z*397^_,Z=Z*397^E,Z=Z*397^I,Z}asArray(){return[this._x,this._y,this._z,this._w]}toArray(p,_=0){return p[_]=this._x,p[_+1]=this._y,p[_+2]=this._z,p[_+3]=this._w,this}equals(p){return p&&this._x===p._x&&this._y===p._y&&this._z===p._z&&this._w===p._w}equalsWithEpsilon(p,_=ns){return p&&$t.WithinEpsilon(this._x,p._x,_)&&$t.WithinEpsilon(this._y,p._y,_)&&$t.WithinEpsilon(this._z,p._z,_)&&$t.WithinEpsilon(this._w,p._w,_)}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copyFrom(p){return this._x=p._x,this._y=p._y,this._z=p._z,this._w=p._w,this._isDirty=!0,this}copyFromFloats(p,_,E,I){return this._x=p,this._y=_,this._z=E,this._w=I,this._isDirty=!0,this}set(p,_,E,I){return this.copyFromFloats(p,_,E,I)}add(p){return new this.constructor(this._x+p._x,this._y+p._y,this._z+p._z,this._w+p._w)}addInPlace(p){return this._x+=p._x,this._y+=p._y,this._z+=p._z,this._w+=p._w,this._isDirty=!0,this}subtract(p){return new this.constructor(this._x-p._x,this._y-p._y,this._z-p._z,this._w-p._w)}subtractInPlace(p){return this._x-=p._x,this._y-=p._y,this._z-=p._z,this._w-=p._w,this._isDirty=!0,this}scale(p){return new this.constructor(this._x*p,this._y*p,this._z*p,this._w*p)}scaleToRef(p,_){return _._x=this._x*p,_._y=this._y*p,_._z=this._z*p,_._w=this._w*p,_._isDirty=!0,_}scaleInPlace(p){return this._x*=p,this._y*=p,this._z*=p,this._w*=p,this._isDirty=!0,this}scaleAndAddToRef(p,_){return _._x+=this._x*p,_._y+=this._y*p,_._z+=this._z*p,_._w+=this._w*p,_._isDirty=!0,_}multiply(p){const _=new this.constructor(0,0,0,1);return this.multiplyToRef(p,_),_}multiplyToRef(p,_){const E=this._x*p._w+this._y*p._z-this._z*p._y+this._w*p._x,I=-this._x*p._z+this._y*p._w+this._z*p._x+this._w*p._y,Z=this._x*p._y-this._y*p._x+this._z*p._w+this._w*p._z,re=-this._x*p._x-this._y*p._y-this._z*p._z+this._w*p._w;return _.copyFromFloats(E,I,Z,re),_}multiplyInPlace(p){return this.multiplyToRef(p,this),this}conjugateToRef(p){return p.copyFromFloats(-this._x,-this._y,-this._z,this._w),p}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new this.constructor(-this._x,-this._y,-this._z,this._w)}invert(){const p=this.conjugate(),_=this.lengthSquared();return _==0||_==1||p.scaleInPlace(1/_),p}invertInPlace(){this.conjugateInPlace();const p=this.lengthSquared();return p==0||p==1?this:(this.scaleInPlace(1/p),this)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(p){return p===0||p===1?this:this.scaleInPlace(1/p)}normalizeToNew(){const p=new this.constructor(0,0,0,1);return this.normalizeToRef(p),p}normalizeToRef(p){const _=this.length();return _===0||_===1?p.copyFromFloats(this._x,this._y,this._z,this._w):this.scaleToRef(1/_,p)}toEulerAngles(){const p=at.Zero();return this.toEulerAnglesToRef(p),p}toEulerAnglesToRef(p){const _=this._z,E=this._x,I=this._y,Z=this._w,re=I*_-E*Z,ae=.4999999;if(re<-ae)p._y=2*Math.atan2(I,Z),p._x=Math.PI/2,p._z=0,p._isDirty=!0;else if(re>ae)p._y=2*Math.atan2(I,Z),p._x=-Math.PI/2,p._z=0,p._isDirty=!0;else{const he=Z*Z,_e=_*_,ve=E*E,Le=I*I;p._z=Math.atan2(2*(E*I+_*Z),-_e-ve+Le+he),p._x=Math.asin(-2*re),p._y=Math.atan2(2*(_*E+I*Z),_e-ve-Le+he),p._isDirty=!0}return p}toRotationMatrix(p){return jt.FromQuaternionToRef(this,p),p}fromRotationMatrix(p){return us.FromRotationMatrixToRef(p,this),this}dot(p){return this._x*p._x+this._y*p._y+this._z*p._z+this._w*p._w}static FromRotationMatrix(p){const _=new us;return us.FromRotationMatrixToRef(p,_),_}static FromRotationMatrixToRef(p,_){const E=p.m,I=E[0],Z=E[4],re=E[8],ae=E[1],he=E[5],_e=E[9],ve=E[2],Le=E[6],ze=E[10],He=I+he+ze;let xt;return He>0?(xt=.5/Math.sqrt(He+1),_._w=.25/xt,_._x=(Le-_e)*xt,_._y=(re-ve)*xt,_._z=(ae-Z)*xt,_._isDirty=!0):I>he&&I>ze?(xt=2*Math.sqrt(1+I-he-ze),_._w=(Le-_e)/xt,_._x=.25*xt,_._y=(Z+ae)/xt,_._z=(re+ve)/xt,_._isDirty=!0):he>ze?(xt=2*Math.sqrt(1+he-I-ze),_._w=(re-ve)/xt,_._x=(Z+ae)/xt,_._y=.25*xt,_._z=(_e+Le)/xt,_._isDirty=!0):(xt=2*Math.sqrt(1+ze-I-he),_._w=(ae-Z)/xt,_._x=(re+ve)/xt,_._y=(_e+Le)/xt,_._z=.25*xt,_._isDirty=!0),_}static Dot(p,_){return p._x*_._x+p._y*_._y+p._z*_._z+p._w*_._w}static AreClose(p,_,E=.1){const I=us.Dot(p,_);return 1-I*I<=E}static SmoothToRef(p,_,E,I,Z){let re=I===0?1:E/I;return re=$t.Clamp(re,0,1),us.SlerpToRef(p,_,re,Z),Z}static Zero(){return new us(0,0,0,0)}static Inverse(p){return new p.constructor(-p._x,-p._y,-p._z,p._w)}static InverseToRef(p,_){return _.set(-p._x,-p._y,-p._z,p._w),_}static Identity(){return new us(0,0,0,1)}static IsIdentity(p){return p&&p._x===0&&p._y===0&&p._z===0&&p._w===1}static RotationAxis(p,_){return us.RotationAxisToRef(p,_,new us)}static RotationAxisToRef(p,_,E){const I=Math.sin(_/2);return p.normalize(),E._w=Math.cos(_/2),E._x=p._x*I,E._y=p._y*I,E._z=p._z*I,E._isDirty=!0,E}static FromArray(p,_){return _||(_=0),new us(p[_],p[_+1],p[_+2],p[_+3])}static FromArrayToRef(p,_,E){return E._x=p[_],E._y=p[_+1],E._z=p[_+2],E._w=p[_+3],E._isDirty=!0,E}static FromEulerAngles(p,_,E){const I=new us;return us.RotationYawPitchRollToRef(_,p,E,I),I}static FromEulerAnglesToRef(p,_,E,I){return us.RotationYawPitchRollToRef(_,p,E,I),I}static FromEulerVector(p){const _=new us;return us.RotationYawPitchRollToRef(p._y,p._x,p._z,_),_}static FromEulerVectorToRef(p,_){return us.RotationYawPitchRollToRef(p._y,p._x,p._z,_),_}static FromUnitVectorsToRef(p,_,E,I=ns){const Z=at.Dot(p,_)+1;return Z<I?Math.abs(p.x)>Math.abs(p.z)?E.set(-p.y,p.x,0,0):E.set(0,-p.z,p.y,0):(at.CrossToRef(p,_,ui.Vector3[0]),E.set(ui.Vector3[0].x,ui.Vector3[0].y,ui.Vector3[0].z,Z)),E.normalize()}static RotationYawPitchRoll(p,_,E){const I=new us;return us.RotationYawPitchRollToRef(p,_,E,I),I}static RotationYawPitchRollToRef(p,_,E,I){const Z=E*.5,re=_*.5,ae=p*.5,he=Math.sin(Z),_e=Math.cos(Z),ve=Math.sin(re),Le=Math.cos(re),ze=Math.sin(ae),He=Math.cos(ae);return I._x=He*ve*_e+ze*Le*he,I._y=ze*Le*_e-He*ve*he,I._z=He*Le*he-ze*ve*_e,I._w=He*Le*_e+ze*ve*he,I._isDirty=!0,I}static RotationAlphaBetaGamma(p,_,E){const I=new us;return us.RotationAlphaBetaGammaToRef(p,_,E,I),I}static RotationAlphaBetaGammaToRef(p,_,E,I){const Z=(E+p)*.5,re=(E-p)*.5,ae=_*.5;return I._x=Math.cos(re)*Math.sin(ae),I._y=Math.sin(re)*Math.sin(ae),I._z=Math.sin(Z)*Math.cos(ae),I._w=Math.cos(Z)*Math.cos(ae),I._isDirty=!0,I}static RotationQuaternionFromAxis(p,_,E){const I=new us(0,0,0,0);return us.RotationQuaternionFromAxisToRef(p,_,E,I),I}static RotationQuaternionFromAxisToRef(p,_,E,I){const Z=Ls.Matrix[0];return jt.FromXYZAxesToRef(p.normalize(),_.normalize(),E.normalize(),Z),us.FromRotationMatrixToRef(Z,I),I}static FromLookDirectionLH(p,_){const E=new us;return us.FromLookDirectionLHToRef(p,_,E),E}static FromLookDirectionLHToRef(p,_,E){const I=Ls.Matrix[0];return jt.LookDirectionLHToRef(p,_,I),us.FromRotationMatrixToRef(I,E),E}static FromLookDirectionRH(p,_){const E=new us;return us.FromLookDirectionRHToRef(p,_,E),E}static FromLookDirectionRHToRef(p,_,E){const I=Ls.Matrix[0];return jt.LookDirectionRHToRef(p,_,I),us.FromRotationMatrixToRef(I,E)}static Slerp(p,_,E){const I=us.Identity();return us.SlerpToRef(p,_,E,I),I}static SlerpToRef(p,_,E,I){let Z,re,ae=p._x*_._x+p._y*_._y+p._z*_._z+p._w*_._w,he=!1;if(ae<0&&(he=!0,ae=-ae),ae>.999999)re=1-E,Z=he?-E:E;else{const _e=Math.acos(ae),ve=1/Math.sin(_e);re=Math.sin((1-E)*_e)*ve,Z=he?-Math.sin(E*_e)*ve:Math.sin(E*_e)*ve}return I._x=re*p._x+Z*_._x,I._y=re*p._y+Z*_._y,I._z=re*p._z+Z*_._z,I._w=re*p._w+Z*_._w,I._isDirty=!0,I}static Hermite(p,_,E,I,Z){const re=Z*Z,ae=Z*re,he=2*ae-3*re+1,_e=-2*ae+3*re,ve=ae-2*re+Z,Le=ae-re,ze=p._x*he+E._x*_e+_._x*ve+I._x*Le,He=p._y*he+E._y*_e+_._y*ve+I._y*Le,xt=p._z*he+E._z*_e+_._z*ve+I._z*Le,rt=p._w*he+E._w*_e+_._w*ve+I._w*Le;return new p.constructor(ze,He,xt,rt)}static Hermite1stDerivative(p,_,E,I,Z){const re=new p.constructor;return this.Hermite1stDerivativeToRef(p,_,E,I,Z,re),re}static Hermite1stDerivativeToRef(p,_,E,I,Z,re){const ae=Z*Z;return re._x=(ae-Z)*6*p._x+(3*ae-4*Z+1)*_._x+(-ae+Z)*6*E._x+(3*ae-2*Z)*I._x,re._y=(ae-Z)*6*p._y+(3*ae-4*Z+1)*_._y+(-ae+Z)*6*E._y+(3*ae-2*Z)*I._y,re._z=(ae-Z)*6*p._z+(3*ae-4*Z+1)*_._z+(-ae+Z)*6*E._z+(3*ae-2*Z)*I._z,re._w=(ae-Z)*6*p._w+(3*ae-4*Z+1)*_._w+(-ae+Z)*6*E._w+(3*ae-2*Z)*I._w,re._isDirty=!0,re}static Normalize(p){const _=us.Zero();return us.NormalizeToRef(p,_),_}static NormalizeToRef(p,_){return p.normalizeToRef(_),_}}class jt{static get Use64Bits(){return aa.MatrixUse64Bits}get m(){return this._m}markAsUpdated(){this.updateFlag=jt._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(p,_=!1,E=!1,I=!0){this._isIdentity=p,this._isIdentity3x2=p||E,this._isIdentityDirty=this._isIdentity?!1:_,this._isIdentity3x2Dirty=this._isIdentity3x2?!1:I}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,aa.MatrixTrackPrecisionChange&&aa.MatrixTrackedMatrices.push(this),this._m=new aa.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const p=this._m;this._isIdentity=p[0]===1&&p[1]===0&&p[2]===0&&p[3]===0&&p[4]===0&&p[5]===1&&p[6]===0&&p[7]===0&&p[8]===0&&p[9]===0&&p[10]===1&&p[11]===0&&p[12]===0&&p[13]===0&&p[14]===0&&p[15]===1}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,this._m[0]!==1||this._m[5]!==1||this._m[15]!==1?this._isIdentity3x2=!1:this._m[1]!==0||this._m[2]!==0||this._m[3]!==0||this._m[4]!==0||this._m[6]!==0||this._m[7]!==0||this._m[8]!==0||this._m[9]!==0||this._m[10]!==0||this._m[11]!==0||this._m[12]!==0||this._m[13]!==0||this._m[14]!==0?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(this._isIdentity===!0)return 1;const p=this._m,_=p[0],E=p[1],I=p[2],Z=p[3],re=p[4],ae=p[5],he=p[6],_e=p[7],ve=p[8],Le=p[9],ze=p[10],He=p[11],xt=p[12],rt=p[13],Tt=p[14],Lt=p[15],Nt=ze*Lt-Tt*He,qt=Le*Lt-rt*He,Xt=Le*Tt-rt*ze,zt=ve*Lt-xt*He,Gt=ve*Tt-ze*xt,xi=ve*rt-xt*Le,Gi=+(ae*Nt-he*qt+_e*Xt),vs=-(re*Nt-he*zt+_e*Gt),ks=+(re*qt-ae*zt+_e*xi),Ur=-(re*Xt-ae*Gt+he*xi);return _*Gi+E*vs+I*ks+Z*Ur}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}
${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}
${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}
${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(){return this._m}asArray(){return this._m}invert(){return this.invertToRef(this),this}reset(){return jt.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(p){const _=new this.constructor;return this.addToRef(p,_),_}addToRef(p,_){const E=this._m,I=_._m,Z=p.m;for(let re=0;re<16;re++)I[re]=E[re]+Z[re];return _.markAsUpdated(),_}addToSelf(p){const _=this._m,E=p.m;for(let I=0;I<16;I++)_[I]+=E[I];return this.markAsUpdated(),this}invertToRef(p){if(this._isIdentity===!0)return jt.IdentityToRef(p),p;const _=this._m,E=_[0],I=_[1],Z=_[2],re=_[3],ae=_[4],he=_[5],_e=_[6],ve=_[7],Le=_[8],ze=_[9],He=_[10],xt=_[11],rt=_[12],Tt=_[13],Lt=_[14],Nt=_[15],qt=He*Nt-Lt*xt,Xt=ze*Nt-Tt*xt,zt=ze*Lt-Tt*He,Gt=Le*Nt-rt*xt,xi=Le*Lt-He*rt,Gi=Le*Tt-rt*ze,vs=+(he*qt-_e*Xt+ve*zt),ks=-(ae*qt-_e*Gt+ve*xi),Ur=+(ae*Xt-he*Gt+ve*Gi),hn=-(ae*zt-he*xi+_e*Gi),pn=E*vs+I*ks+Z*Ur+re*hn;if(pn===0)return p.copyFrom(this),p;const _n=1/pn,x0=_e*Nt-Lt*ve,Ta=he*Nt-Tt*ve,n0=he*Lt-Tt*_e,z0=ae*Nt-rt*ve,W0=ae*Lt-rt*_e,Ho=ae*Tt-rt*he,vo=_e*xt-He*ve,Ml=he*xt-ze*ve,ac=he*He-ze*_e,wg=ae*xt-Le*ve,Lg=ae*He-Le*_e,kg=ae*ze-Le*he,hy=-(I*qt-Z*Xt+re*zt),cy=+(E*qt-Z*Gt+re*xi),uy=-(E*Xt-I*Gt+re*Gi),py=+(E*zt-I*xi+Z*Gi),_y=+(I*x0-Z*Ta+re*n0),Ty=-(E*x0-Z*z0+re*W0),uh=+(E*Ta-I*z0+re*Ho),ph=-(E*n0-I*W0+Z*Ho),_h=-(I*vo-Z*Ml+re*ac),Th=+(E*vo-Z*wg+re*Lg),HL=-(E*Ml-I*wg+re*kg),XL=+(E*ac-I*Lg+Z*kg);return jt.FromValuesToRef(vs*_n,hy*_n,_y*_n,_h*_n,ks*_n,cy*_n,Ty*_n,Th*_n,Ur*_n,uy*_n,uh*_n,HL*_n,hn*_n,py*_n,ph*_n,XL*_n,p),p}addAtIndex(p,_){return this._m[p]+=_,this.markAsUpdated(),this}multiplyAtIndex(p,_){return this._m[p]*=_,this.markAsUpdated(),this}setTranslationFromFloats(p,_,E){return this._m[12]=p,this._m[13]=_,this._m[14]=E,this.markAsUpdated(),this}addTranslationFromFloats(p,_,E){return this._m[12]+=p,this._m[13]+=_,this._m[14]+=E,this.markAsUpdated(),this}setTranslation(p){return this.setTranslationFromFloats(p._x,p._y,p._z)}getTranslation(){return new at(this._m[12],this._m[13],this._m[14])}getTranslationToRef(p){return p.x=this._m[12],p.y=this._m[13],p.z=this._m[14],p}removeRotationAndScaling(){const p=this.m;return jt.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,p[12],p[13],p[14],p[15],this),this._updateIdentityStatus(p[12]===0&&p[13]===0&&p[14]===0&&p[15]===1),this}multiply(p){const _=new this.constructor;return this.multiplyToRef(p,_),_}copyFrom(p){p.copyToArray(this._m);const _=p;return this.updateFlag=_.updateFlag,this._updateIdentityStatus(_._isIdentity,_._isIdentityDirty,_._isIdentity3x2,_._isIdentity3x2Dirty),this}copyToArray(p,_=0){const E=this._m;return p[_]=E[0],p[_+1]=E[1],p[_+2]=E[2],p[_+3]=E[3],p[_+4]=E[4],p[_+5]=E[5],p[_+6]=E[6],p[_+7]=E[7],p[_+8]=E[8],p[_+9]=E[9],p[_+10]=E[10],p[_+11]=E[11],p[_+12]=E[12],p[_+13]=E[13],p[_+14]=E[14],p[_+15]=E[15],this}multiplyToRef(p,_){return this._isIdentity?(_.copyFrom(p),_):p._isIdentity?(_.copyFrom(this),_):(this.multiplyToArray(p,_._m,0),_.markAsUpdated(),_)}multiplyToArray(p,_,E){const I=this._m,Z=p.m,re=I[0],ae=I[1],he=I[2],_e=I[3],ve=I[4],Le=I[5],ze=I[6],He=I[7],xt=I[8],rt=I[9],Tt=I[10],Lt=I[11],Nt=I[12],qt=I[13],Xt=I[14],zt=I[15],Gt=Z[0],xi=Z[1],Gi=Z[2],vs=Z[3],ks=Z[4],Ur=Z[5],hn=Z[6],pn=Z[7],_n=Z[8],x0=Z[9],Ta=Z[10],n0=Z[11],z0=Z[12],W0=Z[13],Ho=Z[14],vo=Z[15];return _[E]=re*Gt+ae*ks+he*_n+_e*z0,_[E+1]=re*xi+ae*Ur+he*x0+_e*W0,_[E+2]=re*Gi+ae*hn+he*Ta+_e*Ho,_[E+3]=re*vs+ae*pn+he*n0+_e*vo,_[E+4]=ve*Gt+Le*ks+ze*_n+He*z0,_[E+5]=ve*xi+Le*Ur+ze*x0+He*W0,_[E+6]=ve*Gi+Le*hn+ze*Ta+He*Ho,_[E+7]=ve*vs+Le*pn+ze*n0+He*vo,_[E+8]=xt*Gt+rt*ks+Tt*_n+Lt*z0,_[E+9]=xt*xi+rt*Ur+Tt*x0+Lt*W0,_[E+10]=xt*Gi+rt*hn+Tt*Ta+Lt*Ho,_[E+11]=xt*vs+rt*pn+Tt*n0+Lt*vo,_[E+12]=Nt*Gt+qt*ks+Xt*_n+zt*z0,_[E+13]=Nt*xi+qt*Ur+Xt*x0+zt*W0,_[E+14]=Nt*Gi+qt*hn+Xt*Ta+zt*Ho,_[E+15]=Nt*vs+qt*pn+Xt*n0+zt*vo,this}equals(p){const _=p;if(!_)return!1;if((this._isIdentity||_._isIdentity)&&!this._isIdentityDirty&&!_._isIdentityDirty)return this._isIdentity&&_._isIdentity;const E=this.m,I=_.m;return E[0]===I[0]&&E[1]===I[1]&&E[2]===I[2]&&E[3]===I[3]&&E[4]===I[4]&&E[5]===I[5]&&E[6]===I[6]&&E[7]===I[7]&&E[8]===I[8]&&E[9]===I[9]&&E[10]===I[10]&&E[11]===I[11]&&E[12]===I[12]&&E[13]===I[13]&&E[14]===I[14]&&E[15]===I[15]}clone(){const p=new this.constructor;return p.copyFrom(this),p}getClassName(){return"Matrix"}getHashCode(){let p=Rn(this._m[0]);for(let _=1;_<16;_++)p=p*397^Rn(this._m[_]);return p}decomposeToTransformNode(p){return p.rotationQuaternion=p.rotationQuaternion||new us,this.decompose(p.scaling,p.rotationQuaternion,p.position)}decompose(p,_,E,I,Z=!0){if(this._isIdentity)return E&&E.setAll(0),p&&p.setAll(1),_&&_.copyFromFloats(0,0,0,1),!0;const re=this._m;if(E&&E.copyFromFloats(re[12],re[13],re[14]),p=p||Ls.Vector3[0],p.x=Math.sqrt(re[0]*re[0]+re[1]*re[1]+re[2]*re[2]),p.y=Math.sqrt(re[4]*re[4]+re[5]*re[5]+re[6]*re[6]),p.z=Math.sqrt(re[8]*re[8]+re[9]*re[9]+re[10]*re[10]),I){const ae=(Z?I.absoluteScaling.x:I.scaling.x)<0?-1:1,he=(Z?I.absoluteScaling.y:I.scaling.y)<0?-1:1,_e=(Z?I.absoluteScaling.z:I.scaling.z)<0?-1:1;p.x*=ae,p.y*=he,p.z*=_e}else this.determinant()<=0&&(p.y*=-1);if(p._x===0||p._y===0||p._z===0)return _&&_.copyFromFloats(0,0,0,1),!1;if(_){const ae=1/p._x,he=1/p._y,_e=1/p._z;jt.FromValuesToRef(re[0]*ae,re[1]*ae,re[2]*ae,0,re[4]*he,re[5]*he,re[6]*he,0,re[8]*_e,re[9]*_e,re[10]*_e,0,0,0,0,1,Ls.Matrix[0]),us.FromRotationMatrixToRef(Ls.Matrix[0],_)}return!0}getRow(p){if(p<0||p>3)return null;const _=p*4;return new Lr(this._m[_+0],this._m[_+1],this._m[_+2],this._m[_+3])}getRowToRef(p,_){if(p>=0&&p<=3){const E=p*4;_.x=this._m[E+0],_.y=this._m[E+1],_.z=this._m[E+2],_.w=this._m[E+3]}return _}setRow(p,_){return this.setRowFromFloats(p,_.x,_.y,_.z,_.w)}transpose(){const p=new this.constructor;return jt.TransposeToRef(this,p),p}transposeToRef(p){return jt.TransposeToRef(this,p),p}setRowFromFloats(p,_,E,I,Z){if(p<0||p>3)return this;const re=p*4;return this._m[re+0]=_,this._m[re+1]=E,this._m[re+2]=I,this._m[re+3]=Z,this.markAsUpdated(),this}scale(p){const _=new this.constructor;return this.scaleToRef(p,_),_}scaleToRef(p,_){for(let E=0;E<16;E++)_._m[E]=this._m[E]*p;return _.markAsUpdated(),_}scaleAndAddToRef(p,_){for(let E=0;E<16;E++)_._m[E]+=this._m[E]*p;return _.markAsUpdated(),_}toNormalMatrix(p){const _=Ls.Matrix[0];this.invertToRef(_),_.transposeToRef(p);const E=p._m;return jt.FromValuesToRef(E[0],E[1],E[2],0,E[4],E[5],E[6],0,E[8],E[9],E[10],0,0,0,0,1,p),p}getRotationMatrix(){const p=new this.constructor;return this.getRotationMatrixToRef(p),p}getRotationMatrixToRef(p){const _=Ls.Vector3[0];if(!this.decompose(_))return jt.IdentityToRef(p),p;const E=this._m,I=1/_._x,Z=1/_._y,re=1/_._z;return jt.FromValuesToRef(E[0]*I,E[1]*I,E[2]*I,0,E[4]*Z,E[5]*Z,E[6]*Z,0,E[8]*re,E[9]*re,E[10]*re,0,0,0,0,1,p),p}toggleModelMatrixHandInPlace(){const p=this._m;return p[2]*=-1,p[6]*=-1,p[8]*=-1,p[9]*=-1,p[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const p=this._m;return p[8]*=-1,p[9]*=-1,p[10]*=-1,p[11]*=-1,this.markAsUpdated(),this}static FromArray(p,_=0){const E=new jt;return jt.FromArrayToRef(p,_,E),E}static FromArrayToRef(p,_,E){for(let I=0;I<16;I++)E._m[I]=p[I+_];return E.markAsUpdated(),E}static FromFloat32ArrayToRefScaled(p,_,E,I){for(let Z=0;Z<16;Z++)I._m[Z]=p[Z+_]*E;return I.markAsUpdated(),I}static get IdentityReadOnly(){return jt._IdentityReadOnly}static FromValuesToRef(p,_,E,I,Z,re,ae,he,_e,ve,Le,ze,He,xt,rt,Tt,Lt){const Nt=Lt._m;Nt[0]=p,Nt[1]=_,Nt[2]=E,Nt[3]=I,Nt[4]=Z,Nt[5]=re,Nt[6]=ae,Nt[7]=he,Nt[8]=_e,Nt[9]=ve,Nt[10]=Le,Nt[11]=ze,Nt[12]=He,Nt[13]=xt,Nt[14]=rt,Nt[15]=Tt,Lt.markAsUpdated()}static FromValues(p,_,E,I,Z,re,ae,he,_e,ve,Le,ze,He,xt,rt,Tt){const Lt=new jt,Nt=Lt._m;return Nt[0]=p,Nt[1]=_,Nt[2]=E,Nt[3]=I,Nt[4]=Z,Nt[5]=re,Nt[6]=ae,Nt[7]=he,Nt[8]=_e,Nt[9]=ve,Nt[10]=Le,Nt[11]=ze,Nt[12]=He,Nt[13]=xt,Nt[14]=rt,Nt[15]=Tt,Lt.markAsUpdated(),Lt}static Compose(p,_,E){const I=new jt;return jt.ComposeToRef(p,_,E,I),I}static ComposeToRef(p,_,E,I){const Z=I._m,re=_._x,ae=_._y,he=_._z,_e=_._w,ve=re+re,Le=ae+ae,ze=he+he,He=re*ve,xt=re*Le,rt=re*ze,Tt=ae*Le,Lt=ae*ze,Nt=he*ze,qt=_e*ve,Xt=_e*Le,zt=_e*ze,Gt=p._x,xi=p._y,Gi=p._z;return Z[0]=(1-(Tt+Nt))*Gt,Z[1]=(xt+zt)*Gt,Z[2]=(rt-Xt)*Gt,Z[3]=0,Z[4]=(xt-zt)*xi,Z[5]=(1-(He+Nt))*xi,Z[6]=(Lt+qt)*xi,Z[7]=0,Z[8]=(rt+Xt)*Gi,Z[9]=(Lt-qt)*Gi,Z[10]=(1-(He+Tt))*Gi,Z[11]=0,Z[12]=E._x,Z[13]=E._y,Z[14]=E._z,Z[15]=1,I.markAsUpdated(),I}static Identity(){const p=jt.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return p._updateIdentityStatus(!0),p}static IdentityToRef(p){return jt.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,p),p._updateIdentityStatus(!0),p}static Zero(){const p=jt.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return p._updateIdentityStatus(!1),p}static RotationX(p){const _=new jt;return jt.RotationXToRef(p,_),_}static Invert(p){const _=new p.constructor;return p.invertToRef(_),_}static RotationXToRef(p,_){const E=Math.sin(p),I=Math.cos(p);return jt.FromValuesToRef(1,0,0,0,0,I,E,0,0,-E,I,0,0,0,0,1,_),_._updateIdentityStatus(I===1&&E===0),_}static RotationY(p){const _=new jt;return jt.RotationYToRef(p,_),_}static RotationYToRef(p,_){const E=Math.sin(p),I=Math.cos(p);return jt.FromValuesToRef(I,0,-E,0,0,1,0,0,E,0,I,0,0,0,0,1,_),_._updateIdentityStatus(I===1&&E===0),_}static RotationZ(p){const _=new jt;return jt.RotationZToRef(p,_),_}static RotationZToRef(p,_){const E=Math.sin(p),I=Math.cos(p);return jt.FromValuesToRef(I,E,0,0,-E,I,0,0,0,0,1,0,0,0,0,1,_),_._updateIdentityStatus(I===1&&E===0),_}static RotationAxis(p,_){const E=new jt;return jt.RotationAxisToRef(p,_,E),E}static RotationAxisToRef(p,_,E){const I=Math.sin(-_),Z=Math.cos(-_),re=1-Z;p.normalize();const ae=E._m;return ae[0]=p._x*p._x*re+Z,ae[1]=p._x*p._y*re-p._z*I,ae[2]=p._x*p._z*re+p._y*I,ae[3]=0,ae[4]=p._y*p._x*re+p._z*I,ae[5]=p._y*p._y*re+Z,ae[6]=p._y*p._z*re-p._x*I,ae[7]=0,ae[8]=p._z*p._x*re-p._y*I,ae[9]=p._z*p._y*re+p._x*I,ae[10]=p._z*p._z*re+Z,ae[11]=0,ae[12]=0,ae[13]=0,ae[14]=0,ae[15]=1,E.markAsUpdated(),E}static RotationAlignToRef(p,_,E,I=!1){const Z=at.Dot(_,p),re=E._m;if(Z<-1+ns)re[0]=-1,re[1]=0,re[2]=0,re[3]=0,re[4]=0,re[5]=I?1:-1,re[6]=0,re[7]=0,re[8]=0,re[9]=0,re[10]=I?-1:1,re[11]=0;else{const ae=at.Cross(_,p),he=1/(1+Z);re[0]=ae._x*ae._x*he+Z,re[1]=ae._y*ae._x*he-ae._z,re[2]=ae._z*ae._x*he+ae._y,re[3]=0,re[4]=ae._x*ae._y*he+ae._z,re[5]=ae._y*ae._y*he+Z,re[6]=ae._z*ae._y*he-ae._x,re[7]=0,re[8]=ae._x*ae._z*he-ae._y,re[9]=ae._y*ae._z*he+ae._x,re[10]=ae._z*ae._z*he+Z,re[11]=0}return re[12]=0,re[13]=0,re[14]=0,re[15]=1,E.markAsUpdated(),E}static RotationYawPitchRoll(p,_,E){const I=new jt;return jt.RotationYawPitchRollToRef(p,_,E,I),I}static RotationYawPitchRollToRef(p,_,E,I){return us.RotationYawPitchRollToRef(p,_,E,Ls.Quaternion[0]),Ls.Quaternion[0].toRotationMatrix(I),I}static Scaling(p,_,E){const I=new jt;return jt.ScalingToRef(p,_,E,I),I}static ScalingToRef(p,_,E,I){return jt.FromValuesToRef(p,0,0,0,0,_,0,0,0,0,E,0,0,0,0,1,I),I._updateIdentityStatus(p===1&&_===1&&E===1),I}static Translation(p,_,E){const I=new jt;return jt.TranslationToRef(p,_,E,I),I}static TranslationToRef(p,_,E,I){return jt.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,p,_,E,1,I),I._updateIdentityStatus(p===0&&_===0&&E===0),I}static Lerp(p,_,E){const I=new p.constructor;return jt.LerpToRef(p,_,E,I),I}static LerpToRef(p,_,E,I){const Z=I._m,re=p.m,ae=_.m;for(let he=0;he<16;he++)Z[he]=re[he]*(1-E)+ae[he]*E;return I.markAsUpdated(),I}static DecomposeLerp(p,_,E){const I=new p.constructor;return jt.DecomposeLerpToRef(p,_,E,I),I}static DecomposeLerpToRef(p,_,E,I){const Z=Ls.Vector3[0],re=Ls.Quaternion[0],ae=Ls.Vector3[1];p.decompose(Z,re,ae);const he=Ls.Vector3[2],_e=Ls.Quaternion[1],ve=Ls.Vector3[3];_.decompose(he,_e,ve);const Le=Ls.Vector3[4];at.LerpToRef(Z,he,E,Le);const ze=Ls.Quaternion[2];us.SlerpToRef(re,_e,E,ze);const He=Ls.Vector3[5];return at.LerpToRef(ae,ve,E,He),jt.ComposeToRef(Le,ze,He,I),I}static LookAtLH(p,_,E){const I=new jt;return jt.LookAtLHToRef(p,_,E,I),I}static LookAtLHToRef(p,_,E,I){const Z=Ls.Vector3[0],re=Ls.Vector3[1],ae=Ls.Vector3[2];_.subtractToRef(p,ae),ae.normalize(),at.CrossToRef(E,ae,Z);const he=Z.lengthSquared();he===0?Z.x=1:Z.normalizeFromLength(Math.sqrt(he)),at.CrossToRef(ae,Z,re),re.normalize();const _e=-at.Dot(Z,p),ve=-at.Dot(re,p),Le=-at.Dot(ae,p);return jt.FromValuesToRef(Z._x,re._x,ae._x,0,Z._y,re._y,ae._y,0,Z._z,re._z,ae._z,0,_e,ve,Le,1,I),I}static LookAtRH(p,_,E){const I=new jt;return jt.LookAtRHToRef(p,_,E,I),I}static LookAtRHToRef(p,_,E,I){const Z=Ls.Vector3[0],re=Ls.Vector3[1],ae=Ls.Vector3[2];p.subtractToRef(_,ae),ae.normalize(),at.CrossToRef(E,ae,Z);const he=Z.lengthSquared();he===0?Z.x=1:Z.normalizeFromLength(Math.sqrt(he)),at.CrossToRef(ae,Z,re),re.normalize();const _e=-at.Dot(Z,p),ve=-at.Dot(re,p),Le=-at.Dot(ae,p);return jt.FromValuesToRef(Z._x,re._x,ae._x,0,Z._y,re._y,ae._y,0,Z._z,re._z,ae._z,0,_e,ve,Le,1,I),I}static LookDirectionLH(p,_){const E=new jt;return jt.LookDirectionLHToRef(p,_,E),E}static LookDirectionLHToRef(p,_,E){const I=Ls.Vector3[0];I.copyFrom(p),I.scaleInPlace(-1);const Z=Ls.Vector3[1];return at.CrossToRef(_,I,Z),jt.FromValuesToRef(Z._x,Z._y,Z._z,0,_._x,_._y,_._z,0,I._x,I._y,I._z,0,0,0,0,1,E),E}static LookDirectionRH(p,_){const E=new jt;return jt.LookDirectionRHToRef(p,_,E),E}static LookDirectionRHToRef(p,_,E){const I=Ls.Vector3[2];return at.CrossToRef(_,p,I),jt.FromValuesToRef(I._x,I._y,I._z,0,_._x,_._y,_._z,0,p._x,p._y,p._z,0,0,0,0,1,E),E}static OrthoLH(p,_,E,I,Z){const re=new jt;return jt.OrthoLHToRef(p,_,E,I,re,Z),re}static OrthoLHToRef(p,_,E,I,Z,re){const ae=E,he=I,_e=2/p,ve=2/_,Le=2/(he-ae),ze=-(he+ae)/(he-ae);return jt.FromValuesToRef(_e,0,0,0,0,ve,0,0,0,0,Le,0,0,0,ze,1,Z),re&&Z.multiplyToRef(co,Z),Z._updateIdentityStatus(_e===1&&ve===1&&Le===1&&ze===0),Z}static OrthoOffCenterLH(p,_,E,I,Z,re,ae){const he=new jt;return jt.OrthoOffCenterLHToRef(p,_,E,I,Z,re,he,ae),he}static OrthoOffCenterLHToRef(p,_,E,I,Z,re,ae,he){const _e=Z,ve=re,Le=2/(_-p),ze=2/(I-E),He=2/(ve-_e),xt=-(ve+_e)/(ve-_e),rt=(p+_)/(p-_),Tt=(I+E)/(E-I);return jt.FromValuesToRef(Le,0,0,0,0,ze,0,0,0,0,He,0,rt,Tt,xt,1,ae),he&&ae.multiplyToRef(co,ae),ae.markAsUpdated(),ae}static ObliqueOffCenterLHToRef(p,_,E,I,Z,re,ae,he,_e,ve,Le){const ze=-ae*Math.cos(he),He=-ae*Math.sin(he);return jt.TranslationToRef(0,0,-_e,Ls.Matrix[1]),jt.FromValuesToRef(1,0,0,0,0,1,0,0,ze,He,1,0,0,0,0,1,Ls.Matrix[0]),Ls.Matrix[1].multiplyToRef(Ls.Matrix[0],Ls.Matrix[0]),jt.TranslationToRef(0,0,_e,Ls.Matrix[1]),Ls.Matrix[0].multiplyToRef(Ls.Matrix[1],Ls.Matrix[0]),jt.OrthoOffCenterLHToRef(p,_,E,I,Z,re,ve,Le),Ls.Matrix[0].multiplyToRef(ve,ve),ve}static OrthoOffCenterRH(p,_,E,I,Z,re,ae){const he=new jt;return jt.OrthoOffCenterRHToRef(p,_,E,I,Z,re,he,ae),he}static OrthoOffCenterRHToRef(p,_,E,I,Z,re,ae,he){return jt.OrthoOffCenterLHToRef(p,_,E,I,Z,re,ae,he),ae._m[10]*=-1,ae}static ObliqueOffCenterRHToRef(p,_,E,I,Z,re,ae,he,_e,ve,Le){const ze=ae*Math.cos(he),He=ae*Math.sin(he);return jt.TranslationToRef(0,0,_e,Ls.Matrix[1]),jt.FromValuesToRef(1,0,0,0,0,1,0,0,ze,He,1,0,0,0,0,1,Ls.Matrix[0]),Ls.Matrix[1].multiplyToRef(Ls.Matrix[0],Ls.Matrix[0]),jt.TranslationToRef(0,0,-_e,Ls.Matrix[1]),Ls.Matrix[0].multiplyToRef(Ls.Matrix[1],Ls.Matrix[0]),jt.OrthoOffCenterRHToRef(p,_,E,I,Z,re,ve,Le),Ls.Matrix[0].multiplyToRef(ve,ve),ve}static PerspectiveLH(p,_,E,I,Z,re=0){const ae=new jt,he=E,_e=I,ve=2*he/p,Le=2*he/_,ze=(_e+he)/(_e-he),He=-2*_e*he/(_e-he),xt=Math.tan(re);return jt.FromValuesToRef(ve,0,0,0,0,Le,0,xt,0,0,ze,1,0,0,He,0,ae),Z&&ae.multiplyToRef(co,ae),ae._updateIdentityStatus(!1),ae}static PerspectiveFovLH(p,_,E,I,Z,re=0,ae=!1){const he=new jt;return jt.PerspectiveFovLHToRef(p,_,E,I,he,!0,Z,re,ae),he}static PerspectiveFovLHToRef(p,_,E,I,Z,re=!0,ae,he=0,_e=!1){const ve=E,Le=I,ze=1/Math.tan(p*.5),He=re?ze/_:ze,xt=re?ze:ze*_,rt=_e&&ve===0?-1:Le!==0?(Le+ve)/(Le-ve):1,Tt=_e&&ve===0?2*Le:Le!==0?-2*Le*ve/(Le-ve):-2*ve,Lt=Math.tan(he);return jt.FromValuesToRef(He,0,0,0,0,xt,0,Lt,0,0,rt,1,0,0,Tt,0,Z),ae&&Z.multiplyToRef(co,Z),Z._updateIdentityStatus(!1),Z}static PerspectiveFovReverseLHToRef(p,_,E,I,Z,re=!0,ae,he=0){const _e=1/Math.tan(p*.5),ve=re?_e/_:_e,Le=re?_e:_e*_,ze=Math.tan(he);return jt.FromValuesToRef(ve,0,0,0,0,Le,0,ze,0,0,-E,1,0,0,1,0,Z),ae&&Z.multiplyToRef(co,Z),Z._updateIdentityStatus(!1),Z}static PerspectiveFovRH(p,_,E,I,Z,re=0,ae=!1){const he=new jt;return jt.PerspectiveFovRHToRef(p,_,E,I,he,!0,Z,re,ae),he}static PerspectiveFovRHToRef(p,_,E,I,Z,re=!0,ae,he=0,_e=!1){const ve=E,Le=I,ze=1/Math.tan(p*.5),He=re?ze/_:ze,xt=re?ze:ze*_,rt=_e&&ve===0?1:Le!==0?-(Le+ve)/(Le-ve):-1,Tt=_e&&ve===0?2*Le:Le!==0?-2*Le*ve/(Le-ve):-2*ve,Lt=Math.tan(he);return jt.FromValuesToRef(He,0,0,0,0,xt,0,Lt,0,0,rt,-1,0,0,Tt,0,Z),ae&&Z.multiplyToRef(co,Z),Z._updateIdentityStatus(!1),Z}static PerspectiveFovReverseRHToRef(p,_,E,I,Z,re=!0,ae,he=0){const _e=1/Math.tan(p*.5),ve=re?_e/_:_e,Le=re?_e:_e*_,ze=Math.tan(he);return jt.FromValuesToRef(ve,0,0,0,0,Le,0,ze,0,0,-E,-1,0,0,-1,0,Z),ae&&Z.multiplyToRef(co,Z),Z._updateIdentityStatus(!1),Z}static GetFinalMatrix(p,_,E,I,Z,re){const ae=p.width,he=p.height,_e=p.x,ve=p.y,Le=jt.FromValues(ae/2,0,0,0,0,-he/2,0,0,0,0,re-Z,0,_e+ae/2,he/2+ve,Z,1),ze=new _.constructor;return _.multiplyToRef(E,ze),ze.multiplyToRef(I,ze),ze.multiplyToRef(Le,ze)}static GetAsMatrix2x2(p){const _=p.m,E=[_[0],_[1],_[4],_[5]];return aa.MatrixUse64Bits?E:new Float32Array(E)}static GetAsMatrix3x3(p){const _=p.m,E=[_[0],_[1],_[2],_[4],_[5],_[6],_[8],_[9],_[10]];return aa.MatrixUse64Bits?E:new Float32Array(E)}static Transpose(p){const _=new p.constructor;return jt.TransposeToRef(p,_),_}static TransposeToRef(p,_){const E=p.m,I=E[0],Z=E[4],re=E[8],ae=E[12],he=E[1],_e=E[5],ve=E[9],Le=E[13],ze=E[2],He=E[6],xt=E[10],rt=E[14],Tt=E[3],Lt=E[7],Nt=E[11],qt=E[15],Xt=_._m;return Xt[0]=I,Xt[1]=Z,Xt[2]=re,Xt[3]=ae,Xt[4]=he,Xt[5]=_e,Xt[6]=ve,Xt[7]=Le,Xt[8]=ze,Xt[9]=He,Xt[10]=xt,Xt[11]=rt,Xt[12]=Tt,Xt[13]=Lt,Xt[14]=Nt,Xt[15]=qt,_.markAsUpdated(),_._updateIdentityStatus(p._isIdentity,p._isIdentityDirty),_}static Reflection(p){const _=new jt;return jt.ReflectionToRef(p,_),_}static ReflectionToRef(p,_){p.normalize();const E=p.normal.x,I=p.normal.y,Z=p.normal.z,re=-2*E,ae=-2*I,he=-2*Z;return jt.FromValuesToRef(re*E+1,ae*E,he*E,0,re*I,ae*I+1,he*I,0,re*Z,ae*Z,he*Z+1,0,re*p.d,ae*p.d,he*p.d,1,_),_}static FromXYZAxesToRef(p,_,E,I){return jt.FromValuesToRef(p._x,p._y,p._z,0,_._x,_._y,_._z,0,E._x,E._y,E._z,0,0,0,0,1,I),I}static FromQuaternionToRef(p,_){const E=p._x*p._x,I=p._y*p._y,Z=p._z*p._z,re=p._x*p._y,ae=p._z*p._w,he=p._z*p._x,_e=p._y*p._w,ve=p._y*p._z,Le=p._x*p._w;return _._m[0]=1-2*(I+Z),_._m[1]=2*(re+ae),_._m[2]=2*(he-_e),_._m[3]=0,_._m[4]=2*(re-ae),_._m[5]=1-2*(Z+E),_._m[6]=2*(ve+Le),_._m[7]=0,_._m[8]=2*(he+_e),_._m[9]=2*(ve-Le),_._m[10]=1-2*(I+E),_._m[11]=0,_._m[12]=0,_._m[13]=0,_._m[14]=0,_._m[15]=1,_.markAsUpdated(),_}}jt._UpdateFlagSeed=0,jt._IdentityReadOnly=jt.Identity();class Ls{}Ls.Vector3=Ts.BuildTuple(11,at.Zero),Ls.Matrix=Ts.BuildTuple(2,jt.Identity),Ls.Quaternion=Ts.BuildTuple(3,us.Zero);class ui{}ui.Vector2=Ts.BuildTuple(3,xr.Zero),ui.Vector3=Ts.BuildTuple(13,at.Zero),ui.Vector4=Ts.BuildTuple(3,Lr.Zero),ui.Quaternion=Ts.BuildTuple(2,us.Zero),ui.Matrix=Ts.BuildTuple(8,jt.Identity),Gs("BABYLON.Vector2",xr),Gs("BABYLON.Vector3",at),Gs("BABYLON.Vector4",Lr),Gs("BABYLON.Matrix",jt);const co=jt.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1);class wo{constructor(){this.rootNodes=[],this.cameras=[],this.lights=[],this.meshes=[],this.skeletons=[],this.particleSystems=[],this.animations=[],this.animationGroups=[],this.multiMaterials=[],this.materials=[],this.morphTargetManagers=[],this.geometries=[],this.transformNodes=[],this.actionManagers=[],this.textures=[],this._environmentTexture=null,this.postProcesses=[]}static AddParser(p,_){this._BabylonFileParsers[p]=_}static GetParser(p){return this._BabylonFileParsers[p]?this._BabylonFileParsers[p]:null}static AddIndividualParser(p,_){this._IndividualBabylonFileParsers[p]=_}static GetIndividualParser(p){return this._IndividualBabylonFileParsers[p]?this._IndividualBabylonFileParsers[p]:null}static Parse(p,_,E,I){for(const Z in this._BabylonFileParsers)Object.prototype.hasOwnProperty.call(this._BabylonFileParsers,Z)&&this._BabylonFileParsers[Z](p,_,E,I)}get environmentTexture(){return this._environmentTexture}set environmentTexture(p){this._environmentTexture=p}getNodes(){let p=[];return p=p.concat(this.meshes),p=p.concat(this.lights),p=p.concat(this.cameras),p=p.concat(this.transformNodes),this.skeletons.forEach(_=>p=p.concat(_.bones)),p}}wo._BabylonFileParsers={},wo._IndividualBabylonFileParsers={};var Kl=function(pe,p){return Kl=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(_,E){_.__proto__=E}||function(_,E){for(var I in E)Object.prototype.hasOwnProperty.call(E,I)&&(_[I]=E[I])},Kl(pe,p)};function nu(pe,p){if(typeof p!="function"&&p!==null)throw new TypeError("Class extends value "+String(p)+" is not a constructor or null");Kl(pe,p);function _(){this.constructor=pe}pe.prototype=p===null?Object.create(p):(_.prototype=p.prototype,new _)}var Gp=function(){return Gp=Object.assign||function(p){for(var _,E=1,I=arguments.length;E<I;E++){_=arguments[E];for(var Z in _)Object.prototype.hasOwnProperty.call(_,Z)&&(p[Z]=_[Z])}return p},Gp.apply(this,arguments)};function vy(pe,p){var _={};for(var E in pe)Object.prototype.hasOwnProperty.call(pe,E)&&p.indexOf(E)<0&&(_[E]=pe[E]);if(pe!=null&&typeof Object.getOwnPropertySymbols=="function")for(var I=0,E=Object.getOwnPropertySymbols(pe);I<E.length;I++)p.indexOf(E[I])<0&&Object.prototype.propertyIsEnumerable.call(pe,E[I])&&(_[E[I]]=pe[E[I]]);return _}function Rt(pe,p,_,E){var I=arguments.length,Z=I<3?p:E===null?E=Object.getOwnPropertyDescriptor(p,_):E,re;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")Z=Reflect.decorate(pe,p,_,E);else for(var ae=pe.length-1;ae>=0;ae--)(re=pe[ae])&&(Z=(I<3?re(Z):I>3?re(p,_,Z):re(p,_))||Z);return I>3&&Z&&Object.defineProperty(p,_,Z),Z}function Ry(pe,p){return function(_,E){p(_,E,pe)}}function My(pe,p){if(typeof Reflect=="object"&&typeof Reflect.metadata=="function")return Reflect.metadata(pe,p)}function wy(pe,p,_,E){function I(Z){return Z instanceof _?Z:new _(function(re){re(Z)})}return new(_||(_=Promise))(function(Z,re){function ae(ve){try{_e(E.next(ve))}catch(Le){re(Le)}}function he(ve){try{_e(E.throw(ve))}catch(Le){re(Le)}}function _e(ve){ve.done?Z(ve.value):I(ve.value).then(ae,he)}_e((E=E.apply(pe,p||[])).next())})}function Ly(pe,p){var _={label:0,sent:function(){if(Z[0]&1)throw Z[1];return Z[1]},trys:[],ops:[]},E,I,Z,re;return re={next:ae(0),throw:ae(1),return:ae(2)},typeof Symbol=="function"&&(re[Symbol.iterator]=function(){return this}),re;function ae(_e){return function(ve){return he([_e,ve])}}function he(_e){if(E)throw new TypeError("Generator is already executing.");for(;_;)try{if(E=1,I&&(Z=_e[0]&2?I.return:_e[0]?I.throw||((Z=I.return)&&Z.call(I),0):I.next)&&!(Z=Z.call(I,_e[1])).done)return Z;switch(I=0,Z&&(_e=[_e[0]&2,Z.value]),_e[0]){case 0:case 1:Z=_e;break;case 4:return _.label++,{value:_e[1],done:!1};case 5:_.label++,I=_e[1],_e=[0];continue;case 7:_e=_.ops.pop(),_.trys.pop();continue;default:if(Z=_.trys,!(Z=Z.length>0&&Z[Z.length-1])&&(_e[0]===6||_e[0]===2)){_=0;continue}if(_e[0]===3&&(!Z||_e[1]>Z[0]&&_e[1]<Z[3])){_.label=_e[1];break}if(_e[0]===6&&_.label<Z[1]){_.label=Z[1],Z=_e;break}if(Z&&_.label<Z[2]){_.label=Z[2],_.ops.push(_e);break}Z[2]&&_.ops.pop(),_.trys.pop();continue}_e=p.call(pe,_)}catch(ve){_e=[6,ve],I=0}finally{E=Z=0}if(_e[0]&5)throw _e[1];return{value:_e[0]?_e[1]:void 0,done:!0}}}var Xx=Object.create?function(pe,p,_,E){E===void 0&&(E=_);var I=Object.getOwnPropertyDescriptor(p,_);(!I||("get"in I?!p.__esModule:I.writable||I.configurable))&&(I={enumerable:!0,get:function(){return p[_]}}),Object.defineProperty(pe,E,I)}:function(pe,p,_,E){E===void 0&&(E=_),pe[E]=p[_]};function kc(pe,p){for(var _ in pe)_!=="default"&&!Object.prototype.hasOwnProperty.call(p,_)&&Xx(p,pe,_)}function Lo(pe){var p=typeof Symbol=="function"&&Symbol.iterator,_=p&&pe[p],E=0;if(_)return _.call(pe);if(pe&&typeof pe.length=="number")return{next:function(){return pe&&E>=pe.length&&(pe=void 0),{value:pe&&pe[E++],done:!pe}}};throw new TypeError(p?"Object is not iterable.":"Symbol.iterator is not defined.")}function Lm(pe,p){var _=typeof Symbol=="function"&&pe[Symbol.iterator];if(!_)return pe;var E=_.call(pe),I,Z=[],re;try{for(;(p===void 0||p-- >0)&&!(I=E.next()).done;)Z.push(I.value)}catch(ae){re={error:ae}}finally{try{I&&!I.done&&(_=E.return)&&_.call(E)}finally{if(re)throw re.error}}return Z}function Ug(){for(var pe=[],p=0;p<arguments.length;p++)pe=pe.concat(Lm(arguments[p]));return pe}function zp(){for(var pe=0,p=0,_=arguments.length;p<_;p++)pe+=arguments[p].length;for(var E=Array(pe),I=0,p=0;p<_;p++)for(var Z=arguments[p],re=0,ae=Z.length;re<ae;re++,I++)E[I]=Z[re];return E}function Gg(pe,p,_){if(_||arguments.length===2)for(var E=0,I=p.length,Z;E<I;E++)(Z||!(E in p))&&(Z||(Z=Array.prototype.slice.call(p,0,E)),Z[E]=p[E]);return pe.concat(Z||Array.prototype.slice.call(p))}function pt(pe){return this instanceof pt?(this.v=pe,this):new pt(pe)}function ht(pe,p,_){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var E=_.apply(pe,p||[]),I,Z=[];return I={},re("next"),re("throw"),re("return"),I[Symbol.asyncIterator]=function(){return this},I;function re(ze){E[ze]&&(I[ze]=function(He){return new Promise(function(xt,rt){Z.push([ze,He,xt,rt])>1||ae(ze,He)})})}function ae(ze,He){try{he(E[ze](He))}catch(xt){Le(Z[0][3],xt)}}function he(ze){ze.value instanceof pt?Promise.resolve(ze.value.v).then(_e,ve):Le(Z[0][2],ze)}function _e(ze){ae("next",ze)}function ve(ze){ae("throw",ze)}function Le(ze,He){ze(He),Z.shift(),Z.length&&ae(Z[0][0],Z[0][1])}}function Wt(pe){var p,_;return p={},E("next"),E("throw",function(I){throw I}),E("return"),p[Symbol.iterator]=function(){return this},p;function E(I,Z){p[I]=pe[I]?function(re){return(_=!_)?{value:pt(pe[I](re)),done:I==="return"}:Z?Z(re):re}:Z}}function _i(pe){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var p=pe[Symbol.asyncIterator],_;return p?p.call(pe):(pe=typeof Lo=="function"?Lo(pe):pe[Symbol.iterator](),_={},E("next"),E("throw"),E("return"),_[Symbol.asyncIterator]=function(){return this},_);function E(Z){_[Z]=pe[Z]&&function(re){return new Promise(function(ae,he){re=pe[Z](re),I(ae,he,re.done,re.value)})}}function I(Z,re,ae,he){Promise.resolve(he).then(function(_e){Z({value:_e,done:ae})},re)}}function Xi(pe,p){return Object.defineProperty?Object.defineProperty(pe,"raw",{value:p}):pe.raw=p,pe}var $i=Object.create?function(pe,p){Object.defineProperty(pe,"default",{enumerable:!0,value:p})}:function(pe,p){pe.default=p};function ps(pe){if(pe&&pe.__esModule)return pe;var p={};if(pe!=null)for(var _ in pe)_!=="default"&&Object.prototype.hasOwnProperty.call(pe,_)&&Xx(p,pe,_);return $i(p,pe),p}function xs(pe){return pe&&pe.__esModule?pe:{default:pe}}function nr(pe,p,_,E){if(_==="a"&&!E)throw new TypeError("Private accessor was defined without a getter");if(typeof p=="function"?pe!==p||!E:!p.has(pe))throw new TypeError("Cannot read private member from an object whose class did not declare it");return _==="m"?E:_==="a"?E.call(pe):E?E.value:p.get(pe)}function pr(pe,p,_,E,I){if(E==="m")throw new TypeError("Private method is not writable");if(E==="a"&&!I)throw new TypeError("Private accessor was defined without a setter");if(typeof p=="function"?pe!==p||!I:!p.has(pe))throw new TypeError("Cannot write private member to an object whose class did not declare it");return E==="a"?I.call(pe,_):I?I.value=_:p.set(pe,_),_}function ar(pe,p){if(p===null||typeof p!="object"&&typeof p!="function")throw new TypeError("Cannot use 'in' operator on non-object");return typeof pe=="function"?p===pe:pe.has(p)}function ln(pe){return Math.pow(pe,ki)}function an(pe){return pe<=.04045?.0773993808*pe:Math.pow(.947867299*(pe+.055),2.4)}function Ln(pe){return Math.pow(pe,Mi)}function xa(pe){return pe<=.0031308?12.92*pe:1.055*Math.pow(pe,.41666)-.055}class Rs{constructor(p=0,_=0,E=0){this.r=p,this.g=_,this.b=E}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Color3"}getHashCode(){let p=this.r*255|0;return p=p*397^(this.g*255|0),p=p*397^(this.b*255|0),p}toArray(p,_=0){return p[_]=this.r,p[_+1]=this.g,p[_+2]=this.b,this}fromArray(p,_=0){return Rs.FromArrayToRef(p,_,this),this}toColor4(p=1){return new Tr(this.r,this.g,this.b,p)}asArray(){return[this.r,this.g,this.b]}toLuminance(){return this.r*.3+this.g*.59+this.b*.11}multiply(p){return new Rs(this.r*p.r,this.g*p.g,this.b*p.b)}multiplyToRef(p,_){return _.r=this.r*p.r,_.g=this.g*p.g,_.b=this.b*p.b,this}equals(p){return p&&this.r===p.r&&this.g===p.g&&this.b===p.b}equalsFloats(p,_,E){return this.r===p&&this.g===_&&this.b===E}scale(p){return new Rs(this.r*p,this.g*p,this.b*p)}scaleInPlace(p){return this.r*=p,this.g*=p,this.b*=p,this}scaleToRef(p,_){return _.r=this.r*p,_.g=this.g*p,_.b=this.b*p,this}scaleAndAddToRef(p,_){return _.r+=this.r*p,_.g+=this.g*p,_.b+=this.b*p,this}clampToRef(p=0,_=1,E){return E.r=$t.Clamp(this.r,p,_),E.g=$t.Clamp(this.g,p,_),E.b=$t.Clamp(this.b,p,_),this}add(p){return new Rs(this.r+p.r,this.g+p.g,this.b+p.b)}addToRef(p,_){return _.r=this.r+p.r,_.g=this.g+p.g,_.b=this.b+p.b,this}subtract(p){return new Rs(this.r-p.r,this.g-p.g,this.b-p.b)}subtractToRef(p,_){return _.r=this.r-p.r,_.g=this.g-p.g,_.b=this.b-p.b,this}clone(){return new Rs(this.r,this.g,this.b)}copyFrom(p){return this.r=p.r,this.g=p.g,this.b=p.b,this}copyFromFloats(p,_,E){return this.r=p,this.g=_,this.b=E,this}set(p,_,E){return this.copyFromFloats(p,_,E)}toHexString(){const p=Math.round(this.r*255),_=Math.round(this.g*255),E=Math.round(this.b*255);return"#"+$t.ToHex(p)+$t.ToHex(_)+$t.ToHex(E)}toHSV(){const p=new Rs;return this.toHSVToRef(p),p}toHSVToRef(p){const _=this.r,E=this.g,I=this.b,Z=Math.max(_,E,I),re=Math.min(_,E,I);let ae=0,he=0;const _e=Z,ve=Z-re;Z!==0&&(he=ve/Z),Z!=re&&(Z==_?(ae=(E-I)/ve,E<I&&(ae+=6)):Z==E?ae=(I-_)/ve+2:Z==I&&(ae=(_-E)/ve+4),ae*=60),p.r=ae,p.g=he,p.b=_e}toLinearSpace(p=!1){const _=new Rs;return this.toLinearSpaceToRef(_,p),_}toLinearSpaceToRef(p,_=!1){return _?(p.r=an(this.r),p.g=an(this.g),p.b=an(this.b)):(p.r=ln(this.r),p.g=ln(this.g),p.b=ln(this.b)),this}toGammaSpace(p=!1){const _=new Rs;return this.toGammaSpaceToRef(_,p),_}toGammaSpaceToRef(p,_=!1){return _?(p.r=xa(this.r),p.g=xa(this.g),p.b=xa(this.b)):(p.r=Ln(this.r),p.g=Ln(this.g),p.b=Ln(this.b)),this}static HSVtoRGBToRef(p,_,E,I){const Z=E*_,re=p/60,ae=Z*(1-Math.abs(re%2-1));let he=0,_e=0,ve=0;re>=0&&re<=1?(he=Z,_e=ae):re>=1&&re<=2?(he=ae,_e=Z):re>=2&&re<=3?(_e=Z,ve=ae):re>=3&&re<=4?(_e=ae,ve=Z):re>=4&&re<=5?(he=ae,ve=Z):re>=5&&re<=6&&(he=Z,ve=ae);const Le=E-Z;I.set(he+Le,_e+Le,ve+Le)}static FromHSV(p,_,E){const I=new Rs(0,0,0);return Rs.HSVtoRGBToRef(p,_,E,I),I}static FromHexString(p){if(p.substring(0,1)!=="#"||p.length!==7)return new Rs(0,0,0);const _=parseInt(p.substring(1,3),16),E=parseInt(p.substring(3,5),16),I=parseInt(p.substring(5,7),16);return Rs.FromInts(_,E,I)}static FromArray(p,_=0){return new Rs(p[_],p[_+1],p[_+2])}static FromArrayToRef(p,_=0,E){E.r=p[_],E.g=p[_+1],E.b=p[_+2]}static FromInts(p,_,E){return new Rs(p/255,_/255,E/255)}static Lerp(p,_,E){const I=new Rs(0,0,0);return Rs.LerpToRef(p,_,E,I),I}static LerpToRef(p,_,E,I){I.r=p.r+(_.r-p.r)*E,I.g=p.g+(_.g-p.g)*E,I.b=p.b+(_.b-p.b)*E}static Hermite(p,_,E,I,Z){const re=Z*Z,ae=Z*re,he=2*ae-3*re+1,_e=-2*ae+3*re,ve=ae-2*re+Z,Le=ae-re,ze=p.r*he+E.r*_e+_.r*ve+I.r*Le,He=p.g*he+E.g*_e+_.g*ve+I.g*Le,xt=p.b*he+E.b*_e+_.b*ve+I.b*Le;return new Rs(ze,He,xt)}static Hermite1stDerivative(p,_,E,I,Z){const re=Rs.Black();return this.Hermite1stDerivativeToRef(p,_,E,I,Z,re),re}static Hermite1stDerivativeToRef(p,_,E,I,Z,re){const ae=Z*Z;re.r=(ae-Z)*6*p.r+(3*ae-4*Z+1)*_.r+(-ae+Z)*6*E.r+(3*ae-2*Z)*I.r,re.g=(ae-Z)*6*p.g+(3*ae-4*Z+1)*_.g+(-ae+Z)*6*E.g+(3*ae-2*Z)*I.g,re.b=(ae-Z)*6*p.b+(3*ae-4*Z+1)*_.b+(-ae+Z)*6*E.b+(3*ae-2*Z)*I.b}static Red(){return new Rs(1,0,0)}static Green(){return new Rs(0,1,0)}static Blue(){return new Rs(0,0,1)}static Black(){return new Rs(0,0,0)}static get BlackReadOnly(){return Rs._BlackReadOnly}static White(){return new Rs(1,1,1)}static Purple(){return new Rs(.5,0,.5)}static Magenta(){return new Rs(1,0,1)}static Yellow(){return new Rs(1,1,0)}static Gray(){return new Rs(.5,.5,.5)}static Teal(){return new Rs(0,1,1)}static Random(){return new Rs(Math.random(),Math.random(),Math.random())}}Rs._BlackReadOnly=Rs.Black();class Tr{constructor(p=0,_=0,E=0,I=1){this.r=p,this.g=_,this.b=E,this.a=I}addInPlace(p){return this.r+=p.r,this.g+=p.g,this.b+=p.b,this.a+=p.a,this}asArray(){return[this.r,this.g,this.b,this.a]}toArray(p,_=0){return p[_]=this.r,p[_+1]=this.g,p[_+2]=this.b,p[_+3]=this.a,this}fromArray(p,_=0){return Tr.FromArrayToRef(p,_,this),this}equals(p){return p&&this.r===p.r&&this.g===p.g&&this.b===p.b&&this.a===p.a}add(p){return new Tr(this.r+p.r,this.g+p.g,this.b+p.b,this.a+p.a)}subtract(p){return new Tr(this.r-p.r,this.g-p.g,this.b-p.b,this.a-p.a)}subtractToRef(p,_){return _.r=this.r-p.r,_.g=this.g-p.g,_.b=this.b-p.b,_.a=this.a-p.a,this}scale(p){return new Tr(this.r*p,this.g*p,this.b*p,this.a*p)}scaleInPlace(p){return this.r*=p,this.g*=p,this.b*=p,this.a*=p,this}scaleToRef(p,_){return _.r=this.r*p,_.g=this.g*p,_.b=this.b*p,_.a=this.a*p,this}scaleAndAddToRef(p,_){return _.r+=this.r*p,_.g+=this.g*p,_.b+=this.b*p,_.a+=this.a*p,this}clampToRef(p=0,_=1,E){return E.r=$t.Clamp(this.r,p,_),E.g=$t.Clamp(this.g,p,_),E.b=$t.Clamp(this.b,p,_),E.a=$t.Clamp(this.a,p,_),this}multiply(p){return new Tr(this.r*p.r,this.g*p.g,this.b*p.b,this.a*p.a)}multiplyToRef(p,_){return _.r=this.r*p.r,_.g=this.g*p.g,_.b=this.b*p.b,_.a=this.a*p.a,_}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Color4"}getHashCode(){let p=this.r*255|0;return p=p*397^(this.g*255|0),p=p*397^(this.b*255|0),p=p*397^(this.a*255|0),p}clone(){return new Tr(this.r,this.g,this.b,this.a)}copyFrom(p){return this.r=p.r,this.g=p.g,this.b=p.b,this.a=p.a,this}copyFromFloats(p,_,E,I){return this.r=p,this.g=_,this.b=E,this.a=I,this}set(p,_,E,I){return this.copyFromFloats(p,_,E,I)}toHexString(p=!1){const _=Math.round(this.r*255),E=Math.round(this.g*255),I=Math.round(this.b*255);if(p)return"#"+$t.ToHex(_)+$t.ToHex(E)+$t.ToHex(I);const Z=Math.round(this.a*255);return"#"+$t.ToHex(_)+$t.ToHex(E)+$t.ToHex(I)+$t.ToHex(Z)}toLinearSpace(p=!1){const _=new Tr;return this.toLinearSpaceToRef(_,p),_}toLinearSpaceToRef(p,_=!1){return _?(p.r=an(this.r),p.g=an(this.g),p.b=an(this.b)):(p.r=ln(this.r),p.g=ln(this.g),p.b=ln(this.b)),p.a=this.a,this}toGammaSpace(p=!1){const _=new Tr;return this.toGammaSpaceToRef(_,p),_}toGammaSpaceToRef(p,_=!1){return _?(p.r=xa(this.r),p.g=xa(this.g),p.b=xa(this.b)):(p.r=Ln(this.r),p.g=Ln(this.g),p.b=Ln(this.b)),p.a=this.a,this}static FromHexString(p){if(p.substring(0,1)!=="#"||p.length!==9&&p.length!==7)return new Tr(0,0,0,0);const _=parseInt(p.substring(1,3),16),E=parseInt(p.substring(3,5),16),I=parseInt(p.substring(5,7),16),Z=p.length===9?parseInt(p.substring(7,9),16):255;return Tr.FromInts(_,E,I,Z)}static Lerp(p,_,E){const I=new Tr(0,0,0,0);return Tr.LerpToRef(p,_,E,I),I}static LerpToRef(p,_,E,I){I.r=p.r+(_.r-p.r)*E,I.g=p.g+(_.g-p.g)*E,I.b=p.b+(_.b-p.b)*E,I.a=p.a+(_.a-p.a)*E}static Hermite(p,_,E,I,Z){const re=Z*Z,ae=Z*re,he=2*ae-3*re+1,_e=-2*ae+3*re,ve=ae-2*re+Z,Le=ae-re,ze=p.r*he+E.r*_e+_.r*ve+I.r*Le,He=p.g*he+E.g*_e+_.g*ve+I.g*Le,xt=p.b*he+E.b*_e+_.b*ve+I.b*Le,rt=p.a*he+E.a*_e+_.a*ve+I.a*Le;return new Tr(ze,He,xt,rt)}static Hermite1stDerivative(p,_,E,I,Z){const re=new Tr;return this.Hermite1stDerivativeToRef(p,_,E,I,Z,re),re}static Hermite1stDerivativeToRef(p,_,E,I,Z,re){const ae=Z*Z;re.r=(ae-Z)*6*p.r+(3*ae-4*Z+1)*_.r+(-ae+Z)*6*E.r+(3*ae-2*Z)*I.r,re.g=(ae-Z)*6*p.g+(3*ae-4*Z+1)*_.g+(-ae+Z)*6*E.g+(3*ae-2*Z)*I.g,re.b=(ae-Z)*6*p.b+(3*ae-4*Z+1)*_.b+(-ae+Z)*6*E.b+(3*ae-2*Z)*I.b,re.a=(ae-Z)*6*p.a+(3*ae-4*Z+1)*_.a+(-ae+Z)*6*E.a+(3*ae-2*Z)*I.a}static FromColor3(p,_=1){return new Tr(p.r,p.g,p.b,_)}static FromArray(p,_=0){return new Tr(p[_],p[_+1],p[_+2],p[_+3])}static FromArrayToRef(p,_=0,E){E.r=p[_],E.g=p[_+1],E.b=p[_+2],E.a=p[_+3]}static FromInts(p,_,E,I){return new Tr(p/255,_/255,E/255,I/255)}static CheckColors4(p,_){if(p.length===_*3){const E=[];for(let I=0;I<p.length;I+=3){const Z=I/3*4;E[Z]=p[I],E[Z+1]=p[I+1],E[Z+2]=p[I+2],E[Z+3]=1}return E}return p}}class jn{}jn.Color3=Ts.BuildArray(3,Rs.Black),jn.Color4=Ts.BuildArray(3,()=>new Tr(0,0,0,0)),Gs("BABYLON.Color3",Rs),Gs("BABYLON.Color4",Tr);const Ws={},jr={},la=function(pe,p,_,E={}){const I=pe();ri&&ri.HasTags(p)&&ri.AddTagsTo(I,ri.GetTags(p,!0));const Z=qr(I),re={};for(const ae in Z){const he=Z[ae],_e=p[ae],ve=he.type;if(_e!=null&&(ae!=="uniqueId"||Hr.AllowLoadingUniqueId))switch(ve){case 0:case 6:case 11:I[ae]=_e;break;case 1:E.cloneTexturesOnlyOnce&&re[_e.uniqueId]?I[ae]=re[_e.uniqueId]:(I[ae]=_||_e.isRenderTarget?_e:_e.clone(),re[_e.uniqueId]=I[ae]);break;case 2:case 3:case 4:case 5:case 7:case 10:case 12:I[ae]=_?_e:_e.clone();break}}return I};function Ma(pe){const p=pe.getClassName();return Ws[p]||(Ws[p]={}),Ws[p]}function qr(pe){const p=pe.getClassName();if(jr[p])return jr[p];jr[p]={};const _=jr[p];let E=pe,I=p;for(;I;){const Z=Ws[I];for(const he in Z)_[he]=Z[he];let re,ae=!1;do{if(re=Object.getPrototypeOf(E),!re.getClassName){ae=!0;break}if(re.getClassName()!==I)break;E=re}while(re);if(ae)break;I=re.getClassName(),E=re}return _}function v0(pe,p){return(_,E)=>{const I=Ma(_);I[E]||(I[E]={type:pe,sourceName:p})}}function w2(pe,p=null){return(_,E)=>{const I=p||"_"+E;Object.defineProperty(_,E,{get:function(){return this[I]},set:function(Z){typeof this.equals=="function"&&this.equals(Z)||this[I]!==Z&&(this[I]=Z,_[pe].apply(this))},enumerable:!0,configurable:!0})}}function ws(pe,p=null){return w2(pe,p)}function Ut(pe){return v0(0,pe)}function Hn(pe){return v0(1,pe)}function Ya(pe){return v0(2,pe)}function km(pe){return v0(3,pe)}function au(pe){return v0(4,pe)}function Yn(pe){return v0(5,pe)}function ko(pe){return v0(6,pe)}function $o(pe){return v0(7,pe)}function ky(pe){return v0(8,pe)}function kM(pe){return v0(9,pe)}function UM(pe){return v0(10,pe)}function Uy(pe){return v0(12,pe)}function YL(pe){return v0(11,pe)}class Hr{static AppendSerializedAnimations(p,_){if(p.animations){_.animations=[];for(let E=0;E<p.animations.length;E++){const I=p.animations[E];_.animations.push(I.serialize())}}}static Serialize(p,_){_||(_={}),ri&&(_.tags=ri.GetTags(p));const E=qr(p);for(const I in E){const Z=E[I],re=Z.sourceName||I,ae=Z.type,he=p[I];if(he!=null&&(I!=="uniqueId"||Hr.AllowLoadingUniqueId))switch(ae){case 0:_[re]=he;break;case 1:_[re]=he.serialize();break;case 2:_[re]=he.asArray();break;case 3:_[re]=he.serialize();break;case 4:_[re]=he.asArray();break;case 5:_[re]=he.asArray();break;case 6:_[re]=he.id;break;case 7:_[re]=he.serialize();break;case 8:_[re]=he.asArray();break;case 9:_[re]=he.serialize();break;case 10:_[re]=he.asArray();break;case 11:_[re]=he.id;break;case 12:_[re]=he.asArray();break}}return _}static ParseProperties(p,_,E,I){I||(I="");const Z=qr(_);for(const re in Z){const ae=Z[re],he=p[ae.sourceName||re],_e=ae.type;if(he!=null&&(re!=="uniqueId"||Hr.AllowLoadingUniqueId)){const ve=_;switch(_e){case 0:ve[re]=he;break;case 1:E&&(ve[re]=Hr._TextureParser(he,E,I));break;case 2:ve[re]=Rs.FromArray(he);break;case 3:ve[re]=Hr._FresnelParametersParser(he);break;case 4:ve[re]=xr.FromArray(he);break;case 5:ve[re]=at.FromArray(he);break;case 6:E&&(ve[re]=E.getLastMeshById(he));break;case 7:ve[re]=Hr._ColorCurvesParser(he);break;case 8:ve[re]=Tr.FromArray(he);break;case 9:ve[re]=Hr._ImageProcessingConfigurationParser(he);break;case 10:ve[re]=us.FromArray(he);break;case 11:E&&(ve[re]=E.getCameraById(he));break;case 12:ve[re]=jt.FromArray(he);break}}}}static Parse(p,_,E,I=null){const Z=p();return ri&&ri.AddTagsTo(Z,_.tags),Hr.ParseProperties(_,Z,E,I),Z}static Clone(p,_,E={}){return la(p,_,!1,E)}static Instanciate(p,_){return la(p,_,!0)}}Hr.AllowLoadingUniqueId=!1,Hr._ImageProcessingConfigurationParser=pe=>{throw ur("ImageProcessingConfiguration")},Hr._FresnelParametersParser=pe=>{throw ur("FresnelParameters")},Hr._ColorCurvesParser=pe=>{throw ur("ColorCurves")},Hr._TextureParser=(pe,p,_)=>{throw ur("Texture")};function Wh(pe,p,_,E){const I=_.value;_.value=(...Z)=>{let re=I;if(typeof _native<"u"&&_native[p]){const ae=_native[p];E?re=(...he)=>E(...he)?ae(...he):I(...he):re=ae}return pe[p]=re,re(...Z)}}Wh.filter=function(pe){return(p,_,E)=>Wh(p,_,E,pe)};class Hh{constructor(p){if(this._keys=[],this._isDirty=!0,this._areLightsDirty=!0,this._areLightsDisposed=!1,this._areAttributesDirty=!0,this._areTexturesDirty=!0,this._areFresnelDirty=!0,this._areMiscDirty=!0,this._arePrePassDirty=!0,this._areImageProcessingDirty=!0,this._normals=!1,this._uvs=!1,this._needNormals=!1,this._needUVs=!1,this._externalProperties=p,p)for(const _ in p)Object.prototype.hasOwnProperty.call(p,_)&&this._setDefaultValue(_)}get isDirty(){return this._isDirty}markAsProcessed(){this._isDirty=!1,this._areAttributesDirty=!1,this._areTexturesDirty=!1,this._areFresnelDirty=!1,this._areLightsDirty=!1,this._areLightsDisposed=!1,this._areMiscDirty=!1,this._arePrePassDirty=!1,this._areImageProcessingDirty=!1}markAsUnprocessed(){this._isDirty=!0}markAllAsDirty(){this._areTexturesDirty=!0,this._areAttributesDirty=!0,this._areLightsDirty=!0,this._areFresnelDirty=!0,this._areMiscDirty=!0,this._arePrePassDirty=!1,this._areImageProcessingDirty=!0,this._isDirty=!0}markAsImageProcessingDirty(){this._areImageProcessingDirty=!0,this._isDirty=!0}markAsLightDirty(p=!1){this._areLightsDirty=!0,this._areLightsDisposed=this._areLightsDisposed||p,this._isDirty=!0}markAsAttributesDirty(){this._areAttributesDirty=!0,this._isDirty=!0}markAsTexturesDirty(){this._areTexturesDirty=!0,this._isDirty=!0}markAsFresnelDirty(){this._areFresnelDirty=!0,this._isDirty=!0}markAsMiscDirty(){this._areMiscDirty=!0,this._isDirty=!0}markAsPrePassDirty(){this._arePrePassDirty=!0,this._isDirty=!0}rebuild(){this._keys.length=0;for(const p of Object.keys(this))p[0]!=="_"&&this._keys.push(p);if(this._externalProperties)for(const p in this._externalProperties)this._keys.indexOf(p)===-1&&this._keys.push(p)}isEqual(p){if(this._keys.length!==p._keys.length)return!1;for(let _=0;_<this._keys.length;_++){const E=this._keys[_];if(this[E]!==p[E])return!1}return!0}cloneTo(p){this._keys.length!==p._keys.length&&(p._keys=this._keys.slice(0));for(let _=0;_<this._keys.length;_++){const E=this._keys[_];p[E]=this[E]}}reset(){this._keys.forEach(p=>this._setDefaultValue(p))}_setDefaultValue(p){const _=this._externalProperties?.[p]?.type??typeof this[p],E=this._externalProperties?.[p]?.default;switch(_){case"number":this[p]=E??0;break;case"string":this[p]=E??"";break;default:this[p]=E??!1;break}}toString(){let p="";for(let _=0;_<this._keys.length;_++){const E=this._keys[_],I=this[E];switch(typeof I){case"number":case"string":p+="#define "+E+" "+I+`
`;break;default:I&&(p+="#define "+E+`
`);break}}return p}}class wa{constructor(){this._dirty=!0,this._tempColor=new Tr(0,0,0,0),this._globalCurve=new Tr(0,0,0,0),this._highlightsCurve=new Tr(0,0,0,0),this._midtonesCurve=new Tr(0,0,0,0),this._shadowsCurve=new Tr(0,0,0,0),this._positiveCurve=new Tr(0,0,0,0),this._negativeCurve=new Tr(0,0,0,0),this._globalHue=30,this._globalDensity=0,this._globalSaturation=0,this._globalExposure=0,this._highlightsHue=30,this._highlightsDensity=0,this._highlightsSaturation=0,this._highlightsExposure=0,this._midtonesHue=30,this._midtonesDensity=0,this._midtonesSaturation=0,this._midtonesExposure=0,this._shadowsHue=30,this._shadowsDensity=0,this._shadowsSaturation=0,this._shadowsExposure=0}get globalHue(){return this._globalHue}set globalHue(p){this._globalHue=p,this._dirty=!0}get globalDensity(){return this._globalDensity}set globalDensity(p){this._globalDensity=p,this._dirty=!0}get globalSaturation(){return this._globalSaturation}set globalSaturation(p){this._globalSaturation=p,this._dirty=!0}get globalExposure(){return this._globalExposure}set globalExposure(p){this._globalExposure=p,this._dirty=!0}get highlightsHue(){return this._highlightsHue}set highlightsHue(p){this._highlightsHue=p,this._dirty=!0}get highlightsDensity(){return this._highlightsDensity}set highlightsDensity(p){this._highlightsDensity=p,this._dirty=!0}get highlightsSaturation(){return this._highlightsSaturation}set highlightsSaturation(p){this._highlightsSaturation=p,this._dirty=!0}get highlightsExposure(){return this._highlightsExposure}set highlightsExposure(p){this._highlightsExposure=p,this._dirty=!0}get midtonesHue(){return this._midtonesHue}set midtonesHue(p){this._midtonesHue=p,this._dirty=!0}get midtonesDensity(){return this._midtonesDensity}set midtonesDensity(p){this._midtonesDensity=p,this._dirty=!0}get midtonesSaturation(){return this._midtonesSaturation}set midtonesSaturation(p){this._midtonesSaturation=p,this._dirty=!0}get midtonesExposure(){return this._midtonesExposure}set midtonesExposure(p){this._midtonesExposure=p,this._dirty=!0}get shadowsHue(){return this._shadowsHue}set shadowsHue(p){this._shadowsHue=p,this._dirty=!0}get shadowsDensity(){return this._shadowsDensity}set shadowsDensity(p){this._shadowsDensity=p,this._dirty=!0}get shadowsSaturation(){return this._shadowsSaturation}set shadowsSaturation(p){this._shadowsSaturation=p,this._dirty=!0}get shadowsExposure(){return this._shadowsExposure}set shadowsExposure(p){this._shadowsExposure=p,this._dirty=!0}getClassName(){return"ColorCurves"}static Bind(p,_,E="vCameraColorCurvePositive",I="vCameraColorCurveNeutral",Z="vCameraColorCurveNegative"){p._dirty&&(p._dirty=!1,p._getColorGradingDataToRef(p._globalHue,p._globalDensity,p._globalSaturation,p._globalExposure,p._globalCurve),p._getColorGradingDataToRef(p._highlightsHue,p._highlightsDensity,p._highlightsSaturation,p._highlightsExposure,p._tempColor),p._tempColor.multiplyToRef(p._globalCurve,p._highlightsCurve),p._getColorGradingDataToRef(p._midtonesHue,p._midtonesDensity,p._midtonesSaturation,p._midtonesExposure,p._tempColor),p._tempColor.multiplyToRef(p._globalCurve,p._midtonesCurve),p._getColorGradingDataToRef(p._shadowsHue,p._shadowsDensity,p._shadowsSaturation,p._shadowsExposure,p._tempColor),p._tempColor.multiplyToRef(p._globalCurve,p._shadowsCurve),p._highlightsCurve.subtractToRef(p._midtonesCurve,p._positiveCurve),p._midtonesCurve.subtractToRef(p._shadowsCurve,p._negativeCurve)),_&&(_.setFloat4(E,p._positiveCurve.r,p._positiveCurve.g,p._positiveCurve.b,p._positiveCurve.a),_.setFloat4(I,p._midtonesCurve.r,p._midtonesCurve.g,p._midtonesCurve.b,p._midtonesCurve.a),_.setFloat4(Z,p._negativeCurve.r,p._negativeCurve.g,p._negativeCurve.b,p._negativeCurve.a))}static PrepareUniforms(p){p.push("vCameraColorCurveNeutral","vCameraColorCurvePositive","vCameraColorCurveNegative")}_getColorGradingDataToRef(p,_,E,I,Z){p!=null&&(p=wa._Clamp(p,0,360),_=wa._Clamp(_,-100,100),E=wa._Clamp(E,-100,100),I=wa._Clamp(I,-100,100),_=wa._ApplyColorGradingSliderNonlinear(_),_*=.5,I=wa._ApplyColorGradingSliderNonlinear(I),_<0&&(_*=-1,p=(p+180)%360),wa._FromHSBToRef(p,_,50+.25*I,Z),Z.scaleToRef(2,Z),Z.a=1+.01*E)}static _ApplyColorGradingSliderNonlinear(p){p/=100;let _=Math.abs(p);return _=Math.pow(_,2),p<0&&(_*=-1),_*=100,_}static _FromHSBToRef(p,_,E,I){let Z=wa._Clamp(p,0,360);const re=wa._Clamp(_/100,0,1),ae=wa._Clamp(E/100,0,1);if(re===0)I.r=ae,I.g=ae,I.b=ae;else{Z/=60;const he=Math.floor(Z),_e=Z-he,ve=ae*(1-re),Le=ae*(1-re*_e),ze=ae*(1-re*(1-_e));switch(he){case 0:I.r=ae,I.g=ze,I.b=ve;break;case 1:I.r=Le,I.g=ae,I.b=ve;break;case 2:I.r=ve,I.g=ae,I.b=ze;break;case 3:I.r=ve,I.g=Le,I.b=ae;break;case 4:I.r=ze,I.g=ve,I.b=ae;break;default:I.r=ae,I.g=ve,I.b=Le;break}}I.a=1}static _Clamp(p,_,E){return Math.min(Math.max(p,_),E)}clone(){return Hr.Clone(()=>new wa,this)}serialize(){return Hr.Serialize(this)}static Parse(p){return Hr.Parse(()=>new wa,p,null,null)}}Rt([Ut()],wa.prototype,"_globalHue",void 0),Rt([Ut()],wa.prototype,"_globalDensity",void 0),Rt([Ut()],wa.prototype,"_globalSaturation",void 0),Rt([Ut()],wa.prototype,"_globalExposure",void 0),Rt([Ut()],wa.prototype,"_highlightsHue",void 0),Rt([Ut()],wa.prototype,"_highlightsDensity",void 0),Rt([Ut()],wa.prototype,"_highlightsSaturation",void 0),Rt([Ut()],wa.prototype,"_highlightsExposure",void 0),Rt([Ut()],wa.prototype,"_midtonesHue",void 0),Rt([Ut()],wa.prototype,"_midtonesDensity",void 0),Rt([Ut()],wa.prototype,"_midtonesSaturation",void 0),Rt([Ut()],wa.prototype,"_midtonesExposure",void 0),Hr._ColorCurvesParser=wa.Parse;class KL extends null{constructor(){super(),this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=!1,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.DITHER=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.EXPOSURE=!1,this.SKIPFINALCOLORCLAMP=!1,this.rebuild()}}class zn{constructor(){this.colorCurves=new wa,this._colorCurvesEnabled=!1,this._colorGradingEnabled=!1,this._colorGradingWithGreenDepth=!0,this._colorGradingBGR=!0,this._exposure=1,this._toneMappingEnabled=!1,this._toneMappingType=zn.TONEMAPPING_STANDARD,this._contrast=1,this.vignetteStretch=0,this.vignetteCenterX=0,this.vignetteCenterY=0,this.vignetteWeight=1.5,this.vignetteColor=new Tr(0,0,0,0),this.vignetteCameraFov=.5,this._vignetteBlendMode=zn.VIGNETTEMODE_MULTIPLY,this._vignetteEnabled=!1,this._ditheringEnabled=!1,this._ditheringIntensity=1/255,this._skipFinalColorClamp=!1,this._applyByPostProcess=!1,this._isEnabled=!0,this.onUpdateParameters=new Ri}get colorCurvesEnabled(){return this._colorCurvesEnabled}set colorCurvesEnabled(p){this._colorCurvesEnabled!==p&&(this._colorCurvesEnabled=p,this._updateParameters())}get colorGradingTexture(){return this._colorGradingTexture}set colorGradingTexture(p){this._colorGradingTexture!==p&&(this._colorGradingTexture=p,this._updateParameters())}get colorGradingEnabled(){return this._colorGradingEnabled}set colorGradingEnabled(p){this._colorGradingEnabled!==p&&(this._colorGradingEnabled=p,this._updateParameters())}get colorGradingWithGreenDepth(){return this._colorGradingWithGreenDepth}set colorGradingWithGreenDepth(p){this._colorGradingWithGreenDepth!==p&&(this._colorGradingWithGreenDepth=p,this._updateParameters())}get colorGradingBGR(){return this._colorGradingBGR}set colorGradingBGR(p){this._colorGradingBGR!==p&&(this._colorGradingBGR=p,this._updateParameters())}get exposure(){return this._exposure}set exposure(p){this._exposure!==p&&(this._exposure=p,this._updateParameters())}get toneMappingEnabled(){return this._toneMappingEnabled}set toneMappingEnabled(p){this._toneMappingEnabled!==p&&(this._toneMappingEnabled=p,this._updateParameters())}get toneMappingType(){return this._toneMappingType}set toneMappingType(p){this._toneMappingType!==p&&(this._toneMappingType=p,this._updateParameters())}get contrast(){return this._contrast}set contrast(p){this._contrast!==p&&(this._contrast=p,this._updateParameters())}get vignetteCentreY(){return this.vignetteCenterY}set vignetteCentreY(p){this.vignetteCenterY=p}get vignetteCentreX(){return this.vignetteCenterX}set vignetteCentreX(p){this.vignetteCenterX=p}get vignetteBlendMode(){return this._vignetteBlendMode}set vignetteBlendMode(p){this._vignetteBlendMode!==p&&(this._vignetteBlendMode=p,this._updateParameters())}get vignetteEnabled(){return this._vignetteEnabled}set vignetteEnabled(p){this._vignetteEnabled!==p&&(this._vignetteEnabled=p,this._updateParameters())}get ditheringEnabled(){return this._ditheringEnabled}set ditheringEnabled(p){this._ditheringEnabled!==p&&(this._ditheringEnabled=p,this._updateParameters())}get ditheringIntensity(){return this._ditheringIntensity}set ditheringIntensity(p){this._ditheringIntensity!==p&&(this._ditheringIntensity=p,this._updateParameters())}get skipFinalColorClamp(){return this._skipFinalColorClamp}set skipFinalColorClamp(p){this._skipFinalColorClamp!==p&&(this._skipFinalColorClamp=p,this._updateParameters())}get applyByPostProcess(){return this._applyByPostProcess}set applyByPostProcess(p){this._applyByPostProcess!==p&&(this._applyByPostProcess=p,this._updateParameters())}get isEnabled(){return this._isEnabled}set isEnabled(p){this._isEnabled!==p&&(this._isEnabled=p,this._updateParameters())}_updateParameters(){this.onUpdateParameters.notifyObservers(this)}getClassName(){return"ImageProcessingConfiguration"}static PrepareUniforms(p,_){_.EXPOSURE&&p.push("exposureLinear"),_.CONTRAST&&p.push("contrast"),_.COLORGRADING&&p.push("colorTransformSettings"),(_.VIGNETTE||_.DITHER)&&p.push("vInverseScreenSize"),_.VIGNETTE&&(p.push("vignetteSettings1"),p.push("vignetteSettings2")),_.COLORCURVES&&wa.PrepareUniforms(p),_.DITHER&&p.push("ditherIntensity")}static PrepareSamplers(p,_){_.COLORGRADING&&p.push("txColorTransform")}prepareDefines(p,_=!1){if(_!==this.applyByPostProcess||!this._isEnabled){p.VIGNETTE=!1,p.TONEMAPPING=!1,p.TONEMAPPING_ACES=!1,p.CONTRAST=!1,p.EXPOSURE=!1,p.COLORCURVES=!1,p.COLORGRADING=!1,p.COLORGRADING3D=!1,p.DITHER=!1,p.IMAGEPROCESSING=!1,p.SKIPFINALCOLORCLAMP=this.skipFinalColorClamp,p.IMAGEPROCESSINGPOSTPROCESS=this.applyByPostProcess&&this._isEnabled;return}switch(p.VIGNETTE=this.vignetteEnabled,p.VIGNETTEBLENDMODEMULTIPLY=this.vignetteBlendMode===zn._VIGNETTEMODE_MULTIPLY,p.VIGNETTEBLENDMODEOPAQUE=!p.VIGNETTEBLENDMODEMULTIPLY,p.TONEMAPPING=this.toneMappingEnabled,this._toneMappingType){case zn.TONEMAPPING_ACES:p.TONEMAPPING_ACES=!0;break;default:p.TONEMAPPING_ACES=!1;break}p.CONTRAST=this.contrast!==1,p.EXPOSURE=this.exposure!==1,p.COLORCURVES=this.colorCurvesEnabled&&!!this.colorCurves,p.COLORGRADING=this.colorGradingEnabled&&!!this.colorGradingTexture,p.COLORGRADING?p.COLORGRADING3D=this.colorGradingTexture.is3D:p.COLORGRADING3D=!1,p.SAMPLER3DGREENDEPTH=this.colorGradingWithGreenDepth,p.SAMPLER3DBGRMAP=this.colorGradingBGR,p.DITHER=this._ditheringEnabled,p.IMAGEPROCESSINGPOSTPROCESS=this.applyByPostProcess,p.SKIPFINALCOLORCLAMP=this.skipFinalColorClamp,p.IMAGEPROCESSING=p.VIGNETTE||p.TONEMAPPING||p.CONTRAST||p.EXPOSURE||p.COLORCURVES||p.COLORGRADING||p.DITHER}isReady(){return!this.colorGradingEnabled||!this.colorGradingTexture||this.colorGradingTexture.isReady()}bind(p,_){if(this._colorCurvesEnabled&&this.colorCurves&&wa.Bind(this.colorCurves,p),this._vignetteEnabled||this._ditheringEnabled){const E=1/p.getEngine().getRenderWidth(),I=1/p.getEngine().getRenderHeight();if(p.setFloat2("vInverseScreenSize",E,I),this._ditheringEnabled&&p.setFloat("ditherIntensity",.5*this._ditheringIntensity),this._vignetteEnabled){const Z=_??I/E;let re=Math.tan(this.vignetteCameraFov*.5),ae=re*Z;const he=Math.sqrt(ae*re);ae=lt.Mix(ae,he,this.vignetteStretch),re=lt.Mix(re,he,this.vignetteStretch),p.setFloat4("vignetteSettings1",ae,re,-ae*this.vignetteCenterX,-re*this.vignetteCenterY);const _e=-2*this.vignetteWeight;p.setFloat4("vignetteSettings2",this.vignetteColor.r,this.vignetteColor.g,this.vignetteColor.b,_e)}}if(p.setFloat("exposureLinear",this.exposure),p.setFloat("contrast",this.contrast),this.colorGradingTexture){p.setTexture("txColorTransform",this.colorGradingTexture);const E=this.colorGradingTexture.getSize().height;p.setFloat4("colorTransformSettings",(E-1)/E,.5/E,E,this.colorGradingTexture.level)}}clone(){return Hr.Clone(()=>new zn,this)}serialize(){return Hr.Serialize(this)}static Parse(p){const _=Hr.Parse(()=>new zn,p,null,null);return p.vignetteCentreX!==void 0&&(_.vignetteCenterX=p.vignetteCentreX),p.vignetteCentreY!==void 0&&(_.vignetteCenterY=p.vignetteCentreY),_}static get VIGNETTEMODE_MULTIPLY(){return this._VIGNETTEMODE_MULTIPLY}static get VIGNETTEMODE_OPAQUE(){return this._VIGNETTEMODE_OPAQUE}}zn.TONEMAPPING_STANDARD=0,zn.TONEMAPPING_ACES=1,zn._VIGNETTEMODE_MULTIPLY=0,zn._VIGNETTEMODE_OPAQUE=1,Rt([$o()],zn.prototype,"colorCurves",void 0),Rt([Ut()],zn.prototype,"_colorCurvesEnabled",void 0),Rt([Hn("colorGradingTexture")],zn.prototype,"_colorGradingTexture",void 0),Rt([Ut()],zn.prototype,"_colorGradingEnabled",void 0),Rt([Ut()],zn.prototype,"_colorGradingWithGreenDepth",void 0),Rt([Ut()],zn.prototype,"_colorGradingBGR",void 0),Rt([Ut()],zn.prototype,"_exposure",void 0),Rt([Ut()],zn.prototype,"_toneMappingEnabled",void 0),Rt([Ut()],zn.prototype,"_toneMappingType",void 0),Rt([Ut()],zn.prototype,"_contrast",void 0),Rt([Ut()],zn.prototype,"vignetteStretch",void 0),Rt([Ut()],zn.prototype,"vignetteCenterX",void 0),Rt([Ut()],zn.prototype,"vignetteCenterY",void 0),Rt([Ut()],zn.prototype,"vignetteWeight",void 0),Rt([ky()],zn.prototype,"vignetteColor",void 0),Rt([Ut()],zn.prototype,"vignetteCameraFov",void 0),Rt([Ut()],zn.prototype,"_vignetteBlendMode",void 0),Rt([Ut()],zn.prototype,"_vignetteEnabled",void 0),Rt([Ut()],zn.prototype,"_ditheringEnabled",void 0),Rt([Ut()],zn.prototype,"_ditheringIntensity",void 0),Rt([Ut()],zn.prototype,"_skipFinalColorClamp",void 0),Rt([Ut()],zn.prototype,"_applyByPostProcess",void 0),Rt([Ut()],zn.prototype,"_isEnabled",void 0),Hr._ImageProcessingConfigurationParser=zn.Parse,sr.prototype.createUniformBuffer=function(pe,p){const _=this._gl.createBuffer();if(!_)throw new Error("Unable to create uniform buffer");const E=new Gx(_);return this.bindUniformBuffer(E),pe instanceof Float32Array?this._gl.bufferData(this._gl.UNIFORM_BUFFER,pe,this._gl.STATIC_DRAW):this._gl.bufferData(this._gl.UNIFORM_BUFFER,new Float32Array(pe),this._gl.STATIC_DRAW),this.bindUniformBuffer(null),E.references=1,E},sr.prototype.createDynamicUniformBuffer=function(pe,p){const _=this._gl.createBuffer();if(!_)throw new Error("Unable to create dynamic uniform buffer");const E=new Gx(_);return this.bindUniformBuffer(E),pe instanceof Float32Array?this._gl.bufferData(this._gl.UNIFORM_BUFFER,pe,this._gl.DYNAMIC_DRAW):this._gl.bufferData(this._gl.UNIFORM_BUFFER,new Float32Array(pe),this._gl.DYNAMIC_DRAW),this.bindUniformBuffer(null),E.references=1,E},sr.prototype.updateUniformBuffer=function(pe,p,_,E){this.bindUniformBuffer(pe),_===void 0&&(_=0),E===void 0?p instanceof Float32Array?this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,_,p):this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,_,new Float32Array(p)):p instanceof Float32Array?this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,0,p.subarray(_,_+E)):this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,0,new Float32Array(p).subarray(_,_+E)),this.bindUniformBuffer(null)},sr.prototype.bindUniformBuffer=function(pe){this._gl.bindBuffer(this._gl.UNIFORM_BUFFER,pe?pe.underlyingResource:null)},sr.prototype.bindUniformBufferBase=function(pe,p,_){this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER,p,pe?pe.underlyingResource:null)},sr.prototype.bindUniformBlock=function(pe,p,_){const E=pe.program,I=this._gl.getUniformBlockIndex(E,p);I!==4294967295&&this._gl.uniformBlockBinding(E,I,_)};class qs{constructor(p,_,E,I,Z=!1){this._valueCache={},this._engine=p,this._noUBO=!p.supportsUniformBuffers||Z,this._dynamic=E,this._name=I??"no-name",this._data=_||[],this._uniformLocations={},this._uniformSizes={},this._uniformArraySizes={},this._uniformLocationPointer=0,this._needSync=!1,this._engine._features.trackUbosInFrame&&(this._buffers=[],this._bufferIndex=-1,this._createBufferOnWrite=!1,this._currentFrameId=0),this._noUBO?(this.updateMatrix3x3=this._updateMatrix3x3ForEffect,this.updateMatrix2x2=this._updateMatrix2x2ForEffect,this.updateFloat=this._updateFloatForEffect,this.updateFloat2=this._updateFloat2ForEffect,this.updateFloat3=this._updateFloat3ForEffect,this.updateFloat4=this._updateFloat4ForEffect,this.updateFloatArray=this._updateFloatArrayForEffect,this.updateArray=this._updateArrayForEffect,this.updateIntArray=this._updateIntArrayForEffect,this.updateUIntArray=this._updateUIntArrayForEffect,this.updateMatrix=this._updateMatrixForEffect,this.updateMatrices=this._updateMatricesForEffect,this.updateVector3=this._updateVector3ForEffect,this.updateVector4=this._updateVector4ForEffect,this.updateColor3=this._updateColor3ForEffect,this.updateColor4=this._updateColor4ForEffect,this.updateDirectColor4=this._updateDirectColor4ForEffect,this.updateInt=this._updateIntForEffect,this.updateInt2=this._updateInt2ForEffect,this.updateInt3=this._updateInt3ForEffect,this.updateInt4=this._updateInt4ForEffect,this.updateUInt=this._updateUIntForEffect,this.updateUInt2=this._updateUInt2ForEffect,this.updateUInt3=this._updateUInt3ForEffect,this.updateUInt4=this._updateUInt4ForEffect):(this._engine._uniformBuffers.push(this),this.updateMatrix3x3=this._updateMatrix3x3ForUniform,this.updateMatrix2x2=this._updateMatrix2x2ForUniform,this.updateFloat=this._updateFloatForUniform,this.updateFloat2=this._updateFloat2ForUniform,this.updateFloat3=this._updateFloat3ForUniform,this.updateFloat4=this._updateFloat4ForUniform,this.updateFloatArray=this._updateFloatArrayForUniform,this.updateArray=this._updateArrayForUniform,this.updateIntArray=this._updateIntArrayForUniform,this.updateUIntArray=this._updateUIntArrayForUniform,this.updateMatrix=this._updateMatrixForUniform,this.updateMatrices=this._updateMatricesForUniform,this.updateVector3=this._updateVector3ForUniform,this.updateVector4=this._updateVector4ForUniform,this.updateColor3=this._updateColor3ForUniform,this.updateColor4=this._updateColor4ForUniform,this.updateDirectColor4=this._updateDirectColor4ForUniform,this.updateInt=this._updateIntForUniform,this.updateInt2=this._updateInt2ForUniform,this.updateInt3=this._updateInt3ForUniform,this.updateInt4=this._updateInt4ForUniform,this.updateUInt=this._updateUIntForUniform,this.updateUInt2=this._updateUInt2ForUniform,this.updateUInt3=this._updateUInt3ForUniform,this.updateUInt4=this._updateUInt4ForUniform)}get useUbo(){return!this._noUBO}get isSync(){return!this._needSync}isDynamic(){return this._dynamic!==void 0}getData(){return this._bufferData}getBuffer(){return this._buffer}_fillAlignment(p){let _;if(p<=2?_=p:_=4,this._uniformLocationPointer%_!==0){const E=this._uniformLocationPointer;this._uniformLocationPointer+=_-this._uniformLocationPointer%_;const I=this._uniformLocationPointer-E;for(let Z=0;Z<I;Z++)this._data.push(0)}}addUniform(p,_,E=0){if(this._noUBO||this._uniformLocations[p]!==void 0)return;let I;if(E>0){if(_ instanceof Array)throw"addUniform should not be use with Array in UBO: "+p;if(this._fillAlignment(4),this._uniformArraySizes[p]={strideSize:_,arraySize:E},_==16)_=_*E;else{const re=(4-_)*E;_=_*E+re}I=[];for(let Z=0;Z<_;Z++)I.push(0)}else{if(_ instanceof Array)I=_,_=I.length;else{_=_,I=[];for(let Z=0;Z<_;Z++)I.push(0)}this._fillAlignment(_)}this._uniformSizes[p]=_,this._uniformLocations[p]=this._uniformLocationPointer,this._uniformLocationPointer+=_;for(let Z=0;Z<_;Z++)this._data.push(I[Z]);this._needSync=!0}addMatrix(p,_){this.addUniform(p,Array.prototype.slice.call(_.toArray()))}addFloat2(p,_,E){const I=[_,E];this.addUniform(p,I)}addFloat3(p,_,E,I){const Z=[_,E,I];this.addUniform(p,Z)}addColor3(p,_){const E=[_.r,_.g,_.b];this.addUniform(p,E)}addColor4(p,_,E){const I=[_.r,_.g,_.b,E];this.addUniform(p,I)}addVector3(p,_){const E=[_.x,_.y,_.z];this.addUniform(p,E)}addMatrix3x3(p){this.addUniform(p,12)}addMatrix2x2(p){this.addUniform(p,8)}create(){this._noUBO||this._buffer||(this._fillAlignment(4),this._bufferData=new Float32Array(this._data),this._rebuild(),this._needSync=!0)}_getNames(){const p=[];let _=0;for(const E in this._uniformLocations)if(p.push(E),++_===10)break;return p.join(",")}_rebuild(){this._noUBO||!this._bufferData||(this._dynamic?this._buffer=this._engine.createDynamicUniformBuffer(this._bufferData,this._name+"_UniformList:"+this._getNames()):this._buffer=this._engine.createUniformBuffer(this._bufferData,this._name+"_UniformList:"+this._getNames()),this._engine._features.trackUbosInFrame&&(this._buffers.push([this._buffer,this._engine._features.checkUbosContentBeforeUpload?this._bufferData.slice():void 0]),this._bufferIndex=this._buffers.length-1,this._createBufferOnWrite=!1))}_rebuildAfterContextLost(){this._engine._features.trackUbosInFrame&&(this._buffers=[],this._currentFrameId=0),this._rebuild()}get _numBuffers(){return this._buffers.length}get _indexBuffer(){return this._bufferIndex}get name(){return this._name}get currentEffect(){return this._currentEffect}_buffersEqual(p,_){for(let E=0;E<p.length;++E)if(p[E]!==_[E])return!1;return!0}_copyBuffer(p,_){for(let E=0;E<p.length;++E)_[E]=p[E]}update(){if(!this._noUBO){if(this.bindUniformBuffer(),!this._buffer){this.create();return}if(!this._dynamic&&!this._needSync){this._createBufferOnWrite=this._engine._features.trackUbosInFrame;return}if(this._buffers&&this._buffers.length>1&&this._buffers[this._bufferIndex][1])if(this._buffersEqual(this._bufferData,this._buffers[this._bufferIndex][1])){this._needSync=!1,this._createBufferOnWrite=this._engine._features.trackUbosInFrame;return}else this._copyBuffer(this._bufferData,this._buffers[this._bufferIndex][1]);this._engine.updateUniformBuffer(this._buffer,this._bufferData),this._engine._features._collectUbosUpdatedInFrame&&(qs._UpdatedUbosInFrame[this._name]||(qs._UpdatedUbosInFrame[this._name]=0),qs._UpdatedUbosInFrame[this._name]++),this._needSync=!1,this._createBufferOnWrite=this._engine._features.trackUbosInFrame}}_createNewBuffer(){this._bufferIndex+1<this._buffers.length?(this._bufferIndex++,this._buffer=this._buffers[this._bufferIndex][0],this._createBufferOnWrite=!1,this._needSync=!0):this._rebuild()}_checkNewFrame(){this._engine._features.trackUbosInFrame&&this._currentFrameId!==this._engine.frameId&&(this._currentFrameId=this._engine.frameId,this._createBufferOnWrite=!1,this._buffers&&this._buffers.length>0?(this._needSync=this._bufferIndex!==0,this._bufferIndex=0,this._buffer=this._buffers[this._bufferIndex][0]):this._bufferIndex=-1)}updateUniform(p,_,E){this._checkNewFrame();let I=this._uniformLocations[p];if(I===void 0){if(this._buffer){Ti.Error("Cannot add an uniform after UBO has been created. uniformName="+p);return}this.addUniform(p,E),I=this._uniformLocations[p]}if(this._buffer||this.create(),this._dynamic)for(let Z=0;Z<E;Z++)this._bufferData[I+Z]=_[Z];else{let Z=!1;for(let re=0;re<E;re++)(E===16&&!this._engine._features.uniformBufferHardCheckMatrix||this._bufferData[I+re]!==Math.fround(_[re]))&&(Z=!0,this._createBufferOnWrite&&this._createNewBuffer(),this._bufferData[I+re]=_[re]);this._needSync=this._needSync||Z}}updateUniformArray(p,_,E){this._checkNewFrame();const I=this._uniformLocations[p];if(I===void 0){Ti.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");return}this._buffer||this.create();const Z=this._uniformArraySizes[p];if(this._dynamic)for(let re=0;re<E;re++)this._bufferData[I+re]=_[re];else{let re=!1,ae=0,he=0;for(let _e=0;_e<E;_e++)if(this._bufferData[I+he*4+ae]!==lt.FloatRound(_[_e])&&(re=!0,this._createBufferOnWrite&&this._createNewBuffer(),this._bufferData[I+he*4+ae]=_[_e]),ae++,ae===Z.strideSize){for(;ae<4;ae++)this._bufferData[I+he*4+ae]=0;ae=0,he++}this._needSync=this._needSync||re}}_cacheMatrix(p,_){this._checkNewFrame();const E=this._valueCache[p],I=_.updateFlag;return E!==void 0&&E===I?!1:(this._valueCache[p]=I,!0)}_updateMatrix3x3ForUniform(p,_){for(let E=0;E<3;E++)qs._TempBuffer[E*4]=_[E*3],qs._TempBuffer[E*4+1]=_[E*3+1],qs._TempBuffer[E*4+2]=_[E*3+2],qs._TempBuffer[E*4+3]=0;this.updateUniform(p,qs._TempBuffer,12)}_updateMatrix3x3ForEffect(p,_){this._currentEffect.setMatrix3x3(p,_)}_updateMatrix2x2ForEffect(p,_){this._currentEffect.setMatrix2x2(p,_)}_updateMatrix2x2ForUniform(p,_){for(let E=0;E<2;E++)qs._TempBuffer[E*4]=_[E*2],qs._TempBuffer[E*4+1]=_[E*2+1],qs._TempBuffer[E*4+2]=0,qs._TempBuffer[E*4+3]=0;this.updateUniform(p,qs._TempBuffer,8)}_updateFloatForEffect(p,_){this._currentEffect.setFloat(p,_)}_updateFloatForUniform(p,_){qs._TempBuffer[0]=_,this.updateUniform(p,qs._TempBuffer,1)}_updateFloat2ForEffect(p,_,E,I=""){this._currentEffect.setFloat2(p+I,_,E)}_updateFloat2ForUniform(p,_,E){qs._TempBuffer[0]=_,qs._TempBuffer[1]=E,this.updateUniform(p,qs._TempBuffer,2)}_updateFloat3ForEffect(p,_,E,I,Z=""){this._currentEffect.setFloat3(p+Z,_,E,I)}_updateFloat3ForUniform(p,_,E,I){qs._TempBuffer[0]=_,qs._TempBuffer[1]=E,qs._TempBuffer[2]=I,this.updateUniform(p,qs._TempBuffer,3)}_updateFloat4ForEffect(p,_,E,I,Z,re=""){this._currentEffect.setFloat4(p+re,_,E,I,Z)}_updateFloat4ForUniform(p,_,E,I,Z){qs._TempBuffer[0]=_,qs._TempBuffer[1]=E,qs._TempBuffer[2]=I,qs._TempBuffer[3]=Z,this.updateUniform(p,qs._TempBuffer,4)}_updateFloatArrayForEffect(p,_){this._currentEffect.setFloatArray(p,_)}_updateFloatArrayForUniform(p,_){this.updateUniformArray(p,_,_.length)}_updateArrayForEffect(p,_){this._currentEffect.setArray(p,_)}_updateArrayForUniform(p,_){this.updateUniformArray(p,_,_.length)}_updateIntArrayForEffect(p,_){this._currentEffect.setIntArray(p,_)}_updateIntArrayForUniform(p,_){qs._TempBufferInt32View.set(_),this.updateUniformArray(p,qs._TempBuffer,_.length)}_updateUIntArrayForEffect(p,_){this._currentEffect.setUIntArray(p,_)}_updateUIntArrayForUniform(p,_){qs._TempBufferUInt32View.set(_),this.updateUniformArray(p,qs._TempBuffer,_.length)}_updateMatrixForEffect(p,_){this._currentEffect.setMatrix(p,_)}_updateMatrixForUniform(p,_){this._cacheMatrix(p,_)&&this.updateUniform(p,_.toArray(),16)}_updateMatricesForEffect(p,_){this._currentEffect.setMatrices(p,_)}_updateMatricesForUniform(p,_){this.updateUniform(p,_,_.length)}_updateVector3ForEffect(p,_){this._currentEffect.setVector3(p,_)}_updateVector3ForUniform(p,_){qs._TempBuffer[0]=_.x,qs._TempBuffer[1]=_.y,qs._TempBuffer[2]=_.z,this.updateUniform(p,qs._TempBuffer,3)}_updateVector4ForEffect(p,_){this._currentEffect.setVector4(p,_)}_updateVector4ForUniform(p,_){qs._TempBuffer[0]=_.x,qs._TempBuffer[1]=_.y,qs._TempBuffer[2]=_.z,qs._TempBuffer[3]=_.w,this.updateUniform(p,qs._TempBuffer,4)}_updateColor3ForEffect(p,_,E=""){this._currentEffect.setColor3(p+E,_)}_updateColor3ForUniform(p,_){qs._TempBuffer[0]=_.r,qs._TempBuffer[1]=_.g,qs._TempBuffer[2]=_.b,this.updateUniform(p,qs._TempBuffer,3)}_updateColor4ForEffect(p,_,E,I=""){this._currentEffect.setColor4(p+I,_,E)}_updateDirectColor4ForEffect(p,_,E=""){this._currentEffect.setDirectColor4(p+E,_)}_updateColor4ForUniform(p,_,E){qs._TempBuffer[0]=_.r,qs._TempBuffer[1]=_.g,qs._TempBuffer[2]=_.b,qs._TempBuffer[3]=E,this.updateUniform(p,qs._TempBuffer,4)}_updateDirectColor4ForUniform(p,_){qs._TempBuffer[0]=_.r,qs._TempBuffer[1]=_.g,qs._TempBuffer[2]=_.b,qs._TempBuffer[3]=_.a,this.updateUniform(p,qs._TempBuffer,4)}_updateIntForEffect(p,_,E=""){this._currentEffect.setInt(p+E,_)}_updateIntForUniform(p,_){qs._TempBufferInt32View[0]=_,this.updateUniform(p,qs._TempBuffer,1)}_updateInt2ForEffect(p,_,E,I=""){this._currentEffect.setInt2(p+I,_,E)}_updateInt2ForUniform(p,_,E){qs._TempBufferInt32View[0]=_,qs._TempBufferInt32View[1]=E,this.updateUniform(p,qs._TempBuffer,2)}_updateInt3ForEffect(p,_,E,I,Z=""){this._currentEffect.setInt3(p+Z,_,E,I)}_updateInt3ForUniform(p,_,E,I){qs._TempBufferInt32View[0]=_,qs._TempBufferInt32View[1]=E,qs._TempBufferInt32View[2]=I,this.updateUniform(p,qs._TempBuffer,3)}_updateInt4ForEffect(p,_,E,I,Z,re=""){this._currentEffect.setInt4(p+re,_,E,I,Z)}_updateInt4ForUniform(p,_,E,I,Z){qs._TempBufferInt32View[0]=_,qs._TempBufferInt32View[1]=E,qs._TempBufferInt32View[2]=I,qs._TempBufferInt32View[3]=Z,this.updateUniform(p,qs._TempBuffer,4)}_updateUIntForEffect(p,_,E=""){this._currentEffect.setUInt(p+E,_)}_updateUIntForUniform(p,_){qs._TempBufferUInt32View[0]=_,this.updateUniform(p,qs._TempBuffer,1)}_updateUInt2ForEffect(p,_,E,I=""){this._currentEffect.setUInt2(p+I,_,E)}_updateUInt2ForUniform(p,_,E){qs._TempBufferUInt32View[0]=_,qs._TempBufferUInt32View[1]=E,this.updateUniform(p,qs._TempBuffer,2)}_updateUInt3ForEffect(p,_,E,I,Z=""){this._currentEffect.setUInt3(p+Z,_,E,I)}_updateUInt3ForUniform(p,_,E,I){qs._TempBufferUInt32View[0]=_,qs._TempBufferUInt32View[1]=E,qs._TempBufferUInt32View[2]=I,this.updateUniform(p,qs._TempBuffer,3)}_updateUInt4ForEffect(p,_,E,I,Z,re=""){this._currentEffect.setUInt4(p+re,_,E,I,Z)}_updateUInt4ForUniform(p,_,E,I,Z){qs._TempBufferUInt32View[0]=_,qs._TempBufferUInt32View[1]=E,qs._TempBufferUInt32View[2]=I,qs._TempBufferUInt32View[3]=Z,this.updateUniform(p,qs._TempBuffer,4)}setTexture(p,_){this._currentEffect.setTexture(p,_)}bindTexture(p,_){this._currentEffect._bindTexture(p,_)}updateUniformDirectly(p,_){this.updateUniform(p,_,_.length),this.update()}bindToEffect(p,_){this._currentEffect=p,this._currentEffectName=_}bindUniformBuffer(){!this._noUBO&&this._buffer&&this._currentEffect&&this._currentEffect.bindUniformBuffer(this._buffer,this._currentEffectName)}unbindEffect(){this._currentEffect=void 0,this._currentEffectName=void 0}setDataBuffer(p){if(!this._buffers)return this._buffer===p;for(let _=0;_<this._buffers.length;++_)if(this._buffers[_][0]===p)return this._bufferIndex=_,this._buffer=p,this._createBufferOnWrite=!1,this._currentEffect=void 0,!0;return!1}dispose(){if(this._noUBO)return;const p=this._engine._uniformBuffers,_=p.indexOf(this);if(_!==-1&&(p[_]=p[p.length-1],p.pop()),this._engine._features.trackUbosInFrame&&this._buffers)for(let E=0;E<this._buffers.length;++E){const I=this._buffers[E][0];this._engine._releaseBuffer(I)}else this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._buffer=null)}}qs._UpdatedUbosInFrame={},qs._MAX_UNIFORM_SIZE=256,qs._TempBuffer=new Float32Array(qs._MAX_UNIFORM_SIZE),qs._TempBufferInt32View=new Int32Array(qs._TempBuffer.buffer),qs._TempBufferUInt32View=new Uint32Array(qs._TempBuffer.buffer);class xu{get isDisposed(){return this._isDisposed}constructor(p,_,E,I=0,Z=!1,re=!1,ae=!1,he,_e){this._isAlreadyOwned=!1,this._isDisposed=!1,p&&p.getScene?this._engine=p.getScene().getEngine():this._engine=p,this._updatable=E,this._instanced=re,this._divisor=he||1,this._label=_e,_ instanceof hx?(this._data=null,this._buffer=_):(this._data=_,this._buffer=null),this.byteStride=ae?I:I*Float32Array.BYTES_PER_ELEMENT,Z||this.create()}createVertexBuffer(p,_,E,I,Z,re=!1,ae){const he=re?_:_*Float32Array.BYTES_PER_ELEMENT,_e=I?re?I:I*Float32Array.BYTES_PER_ELEMENT:this.byteStride;return new ut(this._engine,this,p,this._updatable,!0,_e,Z===void 0?this._instanced:Z,he,E,void 0,void 0,!0,this._divisor||ae)}isUpdatable(){return this._updatable}getData(){return this._data}getBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Float32Array.BYTES_PER_ELEMENT}create(p=null){!p&&this._buffer||(p=p||this._data,p&&(this._buffer?this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,p),this._data=p):this._updatable?(this._buffer=this._engine.createDynamicVertexBuffer(p,this._label),this._data=p):this._buffer=this._engine.createVertexBuffer(p,void 0,this._label)))}_rebuild(){if(this._data)this._buffer=null,this.create(this._data);else{if(!this._buffer)return;if(this._buffer.capacity>0){this._updatable?this._buffer=this._engine.createDynamicVertexBuffer(this._buffer.capacity,this._label):this._buffer=this._engine.createVertexBuffer(this._buffer.capacity,void 0,this._label);return}Ti.Warn(`Missing data for buffer "${this._label}" ${this._buffer?"(uniqueId: "+this._buffer.uniqueId+")":""}. Buffer reconstruction failed.`),this._buffer=null}}update(p){this.create(p)}updateDirectly(p,_,E,I=!1){this._buffer&&this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,p,I?_:_*Float32Array.BYTES_PER_ELEMENT,E?E*this.byteStride:void 0),_===0&&E===void 0?this._data=p:this._data=null)}_increaseReferences(){if(this._buffer){if(!this._isAlreadyOwned){this._isAlreadyOwned=!0;return}this._buffer.references++}}dispose(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._isDisposed=!0,this._data=null,this._buffer=null)}}class ut{get isDisposed(){return this._isDisposed}get instanceDivisor(){return this._instanceDivisor}set instanceDivisor(p){const _=p!=0;this._instanceDivisor=p,_!==this._instanced&&(this._instanced=_,this._computeHashCode())}get _maxVerticesCount(){const p=this.getData();return p?Array.isArray(p)?p.length/(this.byteStride/4)-this.byteOffset/4:(p.byteLength-this.byteOffset)/this.byteStride:0}constructor(p,_,E,I,Z,re,ae,he,_e,ve,Le=!1,ze=!1,He=1,xt=!1){this._isDisposed=!1;let rt=!1;if(this.engine=p,typeof I=="object"&&I!==null?(rt=I.updatable??!1,Z=I.postponeInternalCreation,re=I.stride,ae=I.instanced,he=I.offset,_e=I.size,ve=I.type,Le=I.normalized??!1,ze=I.useBytes??!1,He=I.divisor??1,xt=I.takeBufferOwnership??!1,this._label=I.label):rt=!!I,_ instanceof xu?(this._buffer=_,this._ownsBuffer=xt):(this._buffer=new xu(p,_,rt,re,Z,ae,ze,He,this._label),this._ownsBuffer=!0),this.uniqueId=ut._Counter++,this._kind=E,ve===void 0){const Lt=this.getData();this.type=Lt?ut.GetDataType(Lt):ut.FLOAT}else this.type=ve;const Tt=ut.GetTypeByteLength(this.type);ze?(this._size=_e||(re?re/Tt:ut.DeduceStride(E)),this.byteStride=re||this._buffer.byteStride||this._size*Tt,this.byteOffset=he||0):(this._size=_e||re||ut.DeduceStride(E),this.byteStride=re?re*Tt:this._buffer.byteStride||this._size*Tt,this.byteOffset=(he||0)*Tt),this.normalized=Le,this._instanced=ae!==void 0?ae:!1,this._instanceDivisor=ae?He:0,this._alignBuffer(),this._computeHashCode()}_computeHashCode(){this.hashCode=(this.type-5120<<0)+((this.normalized?1:0)<<3)+(this._size<<4)+((this._instanced?1:0)<<6)+(this.byteStride<<12)}_rebuild(){this._buffer?._rebuild()}getKind(){return this._kind}isUpdatable(){return this._buffer.isUpdatable()}getData(){return this._buffer.getData()}getFloatData(p,_){const E=this.getData();return E?ut.GetFloatData(E,this._size,this.type,this.byteOffset,this.byteStride,this.normalized,p,_):null}getBuffer(){return this._buffer.getBuffer()}getWrapperBuffer(){return this._buffer}getStrideSize(){return this.byteStride/ut.GetTypeByteLength(this.type)}getOffset(){return this.byteOffset/ut.GetTypeByteLength(this.type)}getSize(p=!1){return p?this._size*ut.GetTypeByteLength(this.type):this._size}getIsInstanced(){return this._instanced}getInstanceDivisor(){return this._instanceDivisor}create(p){this._buffer.create(p),this._alignBuffer()}update(p){this._buffer.update(p),this._alignBuffer()}updateDirectly(p,_,E=!1){this._buffer.updateDirectly(p,_,void 0,E),this._alignBuffer()}dispose(){this._ownsBuffer&&this._buffer.dispose(),this._isDisposed=!0}forEach(p,_){ut.ForEach(this._buffer.getData(),this.byteOffset,this.byteStride,this._size,this.type,p,this.normalized,_)}_alignBuffer(){}static DeduceStride(p){switch(p){case ut.UVKind:case ut.UV2Kind:case ut.UV3Kind:case ut.UV4Kind:case ut.UV5Kind:case ut.UV6Kind:return 2;case ut.NormalKind:case ut.PositionKind:return 3;case ut.ColorKind:case ut.ColorInstanceKind:case ut.MatricesIndicesKind:case ut.MatricesIndicesExtraKind:case ut.MatricesWeightsKind:case ut.MatricesWeightsExtraKind:case ut.TangentKind:return 4;default:throw new Error("Invalid kind '"+p+"'")}}static GetDataType(p){return p instanceof Int8Array?ut.BYTE:p instanceof Uint8Array?ut.UNSIGNED_BYTE:p instanceof Int16Array?ut.SHORT:p instanceof Uint16Array?ut.UNSIGNED_SHORT:p instanceof Int32Array?ut.INT:p instanceof Uint32Array?ut.UNSIGNED_INT:ut.FLOAT}static GetTypeByteLength(p){switch(p){case ut.BYTE:case ut.UNSIGNED_BYTE:return 1;case ut.SHORT:case ut.UNSIGNED_SHORT:return 2;case ut.INT:case ut.UNSIGNED_INT:case ut.FLOAT:return 4;default:throw new Error(`Invalid type '${p}'`)}}static ForEach(p,_,E,I,Z,re,ae,he){if(p instanceof Array){let _e=_/4;const ve=E/4;for(let Le=0;Le<re;Le+=I){for(let ze=0;ze<I;ze++)he(p[_e+ze],Le+ze);_e+=ve}}else{const _e=p instanceof ArrayBuffer?new DataView(p):new DataView(p.buffer,p.byteOffset,p.byteLength),ve=ut.GetTypeByteLength(Z);for(let Le=0;Le<re;Le+=I){let ze=_;for(let He=0;He<I;He++){const xt=ut._GetFloatValue(_e,Z,ze,ae);he(xt,Le+He),ze+=ve}_+=E}}}static _GetFloatValue(p,_,E,I){switch(_){case ut.BYTE:{let Z=p.getInt8(E);return I&&(Z=Math.max(Z/127,-1)),Z}case ut.UNSIGNED_BYTE:{let Z=p.getUint8(E);return I&&(Z=Z/255),Z}case ut.SHORT:{let Z=p.getInt16(E,!0);return I&&(Z=Math.max(Z/32767,-1)),Z}case ut.UNSIGNED_SHORT:{let Z=p.getUint16(E,!0);return I&&(Z=Z/65535),Z}case ut.INT:return p.getInt32(E,!0);case ut.UNSIGNED_INT:return p.getUint32(E,!0);case ut.FLOAT:return p.getFloat32(E,!0);default:throw new Error(`Invalid component type ${_}`)}}static GetFloatData(p,_,E,I,Z,re,ae,he){const _e=_*ut.GetTypeByteLength(E),ve=ae*_;if(E!==ut.FLOAT||Z!==_e){const Le=new Float32Array(ve);return ut.ForEach(p,I,Z,_,E,ve,re,(ze,He)=>Le[He]=ze),Le}if(!(p instanceof Array||p instanceof Float32Array)||I!==0||p.length!==ve)if(p instanceof Array){const Le=I/4;return p.slice(Le,Le+ve)}else{if(p instanceof ArrayBuffer)return new Float32Array(p,I,ve);{let Le=p.byteOffset+I;if(he){const He=new Float32Array(ve),xt=new Float32Array(p.buffer,Le,ve);return He.set(xt),He}const ze=Le%4;return ze&&(Le=Math.max(0,Le-ze)),new Float32Array(p.buffer,Le,ve)}}return he?p.slice():p}}ut._Counter=0,ut.BYTE=5120,ut.UNSIGNED_BYTE=5121,ut.SHORT=5122,ut.UNSIGNED_SHORT=5123,ut.INT=5124,ut.UNSIGNED_INT=5125,ut.FLOAT=5126,ut.PositionKind="position",ut.NormalKind="normal",ut.TangentKind="tangent",ut.UVKind="uv",ut.UV2Kind="uv2",ut.UV3Kind="uv3",ut.UV4Kind="uv4",ut.UV5Kind="uv5",ut.UV6Kind="uv6",ut.ColorKind="color",ut.ColorInstanceKind="instanceColor",ut.MatricesIndicesKind="matricesIndices",ut.MatricesWeightsKind="matricesWeights",ut.MatricesIndicesExtraKind="matricesIndicesExtra",ut.MatricesWeightsExtraKind="matricesWeightsExtra";class Wp{constructor(){this.hit=!1,this.distance=0,this.pickedPoint=null,this.pickedMesh=null,this.bu=0,this.bv=0,this.faceId=-1,this.subMeshFaceId=-1,this.subMeshId=0,this.pickedSprite=null,this.thinInstanceIndex=-1,this.ray=null,this.originMesh=null,this.aimTransform=null,this.gripTransform=null}getNormal(p=!1,_=!0){if(!this.pickedMesh||_&&!this.pickedMesh.isVerticesDataPresent(ut.NormalKind))return null;let E=this.pickedMesh.getIndices();E?.length===0&&(E=null);let I;const Z=ui.Vector3[0],re=ui.Vector3[1],ae=ui.Vector3[2];if(_){const _e=this.pickedMesh.getVerticesData(ut.NormalKind);let ve=E?at.FromArrayToRef(_e,E[this.faceId*3]*3,Z):Z.copyFromFloats(_e[this.faceId*3*3],_e[this.faceId*3*3+1],_e[this.faceId*3*3+2]),Le=E?at.FromArrayToRef(_e,E[this.faceId*3+1]*3,re):re.copyFromFloats(_e[(this.faceId*3+1)*3],_e[(this.faceId*3+1)*3+1],_e[(this.faceId*3+1)*3+2]),ze=E?at.FromArrayToRef(_e,E[this.faceId*3+2]*3,ae):ae.copyFromFloats(_e[(this.faceId*3+2)*3],_e[(this.faceId*3+2)*3+1],_e[(this.faceId*3+2)*3+2]);ve=ve.scale(this.bu),Le=Le.scale(this.bv),ze=ze.scale(1-this.bu-this.bv),I=new at(ve.x+Le.x+ze.x,ve.y+Le.y+ze.y,ve.z+Le.z+ze.z)}else{const _e=this.pickedMesh.getVerticesData(ut.PositionKind),ve=E?at.FromArrayToRef(_e,E[this.faceId*3]*3,Z):Z.copyFromFloats(_e[this.faceId*3*3],_e[this.faceId*3*3+1],_e[this.faceId*3*3+2]),Le=E?at.FromArrayToRef(_e,E[this.faceId*3+1]*3,re):re.copyFromFloats(_e[(this.faceId*3+1)*3],_e[(this.faceId*3+1)*3+1],_e[(this.faceId*3+1)*3+2]),ze=E?at.FromArrayToRef(_e,E[this.faceId*3+2]*3,ae):ae.copyFromFloats(_e[(this.faceId*3+2)*3],_e[(this.faceId*3+2)*3+1],_e[(this.faceId*3+2)*3+2]),He=ve.subtract(Le),xt=ze.subtract(Le);I=at.Cross(He,xt)}const he=(_e,ve)=>{let Le=_e.getWorldMatrix();_e.nonUniformScaling&&(ui.Matrix[0].copyFrom(Le),Le=ui.Matrix[0],Le.setTranslationFromFloats(0,0,0),Le.invert(),Le.transposeToRef(ui.Matrix[1]),Le=ui.Matrix[1]),at.TransformNormalToRef(ve,Le,ve)};if(p&&he(this.pickedMesh,I),this.ray){const _e=ui.Vector3[0].copyFrom(I);p||he(this.pickedMesh,_e),at.Dot(_e,this.ray.direction)>0&&I.negateInPlace()}return I.normalize(),I}getTextureCoordinates(p=ut.UVKind){if(!this.pickedMesh||!this.pickedMesh.isVerticesDataPresent(p))return null;const _=this.pickedMesh.getIndices();if(!_)return null;const E=this.pickedMesh.getVerticesData(p);if(!E)return null;let I=xr.FromArray(E,_[this.faceId*3]*2),Z=xr.FromArray(E,_[this.faceId*3+1]*2),re=xr.FromArray(E,_[this.faceId*3+2]*2);return I=I.scale(this.bu),Z=Z.scale(this.bv),re=re.scale(1-this.bu-this.bv),new xr(I.x+Z.x+re.x,I.y+Z.y+re.y)}}class q0{constructor(p,_,E,I,Z,re){this.source=p,this.pointerX=_,this.pointerY=E,this.meshUnderPointer=I,this.sourceEvent=Z,this.additionalData=re}static CreateNew(p,_,E){const I=p.getScene();return new q0(p,I.pointerX,I.pointerY,I.meshUnderPointer||p,_,E)}static CreateNewFromSprite(p,_,E,I){return new q0(p,_.pointerX,_.pointerY,_.meshUnderPointer,E,I)}static CreateNewFromScene(p,_){return new q0(null,p.pointerX,p.pointerY,p.meshUnderPointer,_)}static CreateNewFromPrimitive(p,_,E,I){return new q0(p,_.x,_.y,null,E,I)}}class zg{constructor(p){this._vertexBuffers={},this._scene=p}_prepareBuffers(){if(this._vertexBuffers[ut.PositionKind])return;const p=[];p.push(1,1),p.push(-1,1),p.push(-1,-1),p.push(1,-1),this._vertexBuffers[ut.PositionKind]=new ut(this._scene.getEngine(),p,ut.PositionKind,!1,!1,2),this._buildIndexBuffer()}_buildIndexBuffer(){const p=[];p.push(0),p.push(1),p.push(2),p.push(0),p.push(2),p.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(p)}_rebuild(){const p=this._vertexBuffers[ut.PositionKind];p&&(p._rebuild(),this._buildIndexBuffer())}_prepareFrame(p=null,_=null){const E=this._scene.activeCamera;return!E||(_=_||E._postProcesses.filter(I=>I!=null),!_||_.length===0||!this._scene.postProcessesEnabled)?!1:(_[0].activate(E,p,_!=null),!0)}directRender(p,_=null,E=!1,I=0,Z=0,re=!1){const ae=this._scene.getEngine();for(let he=0;he<p.length;he++){he<p.length-1?p[he+1].activate(this._scene.activeCamera,_?.texture):(_?ae.bindFramebuffer(_,I,void 0,void 0,E,Z):re||ae.restoreDefaultFramebuffer(),ae._debugInsertMarker?.(`post process ${p[he].name} output`));const _e=p[he],ve=_e.apply();ve&&(_e.onBeforeRenderObservable.notifyObservers(ve),this._prepareBuffers(),ae.bindBuffers(this._vertexBuffers,this._indexBuffer,ve),ae.drawElementsType(0,0,6),_e.onAfterRenderObservable.notifyObservers(ve))}ae.setDepthBuffer(!0),ae.setDepthWrite(!0)}_finalizeFrame(p,_,E,I,Z=!1){const re=this._scene.activeCamera;if(!re||(I=I||re._postProcesses.filter(he=>he!=null),I.length===0||!this._scene.postProcessesEnabled))return;const ae=this._scene.getEngine();for(let he=0,_e=I.length;he<_e;he++){const ve=I[he];if(he<_e-1?ve._outputTexture=I[he+1].activate(re,_?.texture):(_?(ae.bindFramebuffer(_,E,void 0,void 0,Z),ve._outputTexture=_):(ae.restoreDefaultFramebuffer(),ve._outputTexture=null),ae._debugInsertMarker?.(`post process ${I[he].name} output`)),p)break;const Le=ve.apply();Le&&(ve.onBeforeRenderObservable.notifyObservers(Le),this._prepareBuffers(),ae.bindBuffers(this._vertexBuffers,this._indexBuffer,Le),ae.drawElementsType(0,0,6),ve.onAfterRenderObservable.notifyObservers(Le))}ae.setDepthBuffer(!0),ae.setDepthWrite(!0),ae.setAlphaMode(0)}dispose(){const p=this._vertexBuffers[ut.PositionKind];p&&(p.dispose(),this._vertexBuffers[ut.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}class L2{set opaqueSortCompareFn(p){p?this._opaqueSortCompareFn=p:this._opaqueSortCompareFn=L2.PainterSortCompare,this._renderOpaque=this._renderOpaqueSorted}set alphaTestSortCompareFn(p){p?this._alphaTestSortCompareFn=p:this._alphaTestSortCompareFn=L2.PainterSortCompare,this._renderAlphaTest=this._renderAlphaTestSorted}set transparentSortCompareFn(p){p?this._transparentSortCompareFn=p:this._transparentSortCompareFn=L2.defaultTransparentSortCompare,this._renderTransparent=this._renderTransparentSorted}constructor(p,_,E=null,I=null,Z=null){this.index=p,this._opaqueSubMeshes=new ct(256),this._transparentSubMeshes=new ct(256),this._alphaTestSubMeshes=new ct(256),this._depthOnlySubMeshes=new ct(256),this._particleSystems=new ct(256),this._spriteManagers=new ct(256),this._empty=!0,this._edgesRenderers=new _t(16),this._scene=_,this.opaqueSortCompareFn=E,this.alphaTestSortCompareFn=I,this.transparentSortCompareFn=Z}render(p,_,E,I){if(p){p(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,this._depthOnlySubMeshes);return}const Z=this._scene.getEngine();this._depthOnlySubMeshes.length!==0&&(Z.setColorWrite(!1),this._renderAlphaTest(this._depthOnlySubMeshes),Z.setColorWrite(!0)),this._opaqueSubMeshes.length!==0&&this._renderOpaque(this._opaqueSubMeshes),this._alphaTestSubMeshes.length!==0&&this._renderAlphaTest(this._alphaTestSubMeshes);const re=Z.getStencilBuffer();if(Z.setStencilBuffer(!1),_&&this._renderSprites(),E&&this._renderParticles(I),this.onBeforeTransparentRendering&&this.onBeforeTransparentRendering(),this._transparentSubMeshes.length!==0||this._scene.useOrderIndependentTransparency){if(Z.setStencilBuffer(re),this._scene.useOrderIndependentTransparency){const ae=this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);ae.length&&this._renderTransparent(ae)}else this._renderTransparent(this._transparentSubMeshes);Z.setAlphaMode(0)}if(Z.setStencilBuffer(!1),this._edgesRenderers.length){for(let ae=0;ae<this._edgesRenderers.length;ae++)this._edgesRenderers.data[ae].render();Z.setAlphaMode(0)}Z.setStencilBuffer(re)}_renderOpaqueSorted(p){L2._RenderSorted(p,this._opaqueSortCompareFn,this._scene.activeCamera,!1)}_renderAlphaTestSorted(p){L2._RenderSorted(p,this._alphaTestSortCompareFn,this._scene.activeCamera,!1)}_renderTransparentSorted(p){L2._RenderSorted(p,this._transparentSortCompareFn,this._scene.activeCamera,!0)}static _RenderSorted(p,_,E,I){let Z=0,re;const ae=E?E.globalPosition:L2._ZeroVector;if(I)for(;Z<p.length;Z++)re=p.data[Z],re._alphaIndex=re.getMesh().alphaIndex,re._distanceToCamera=at.Distance(re.getBoundingInfo().boundingSphere.centerWorld,ae);const he=p.length===p.data.length?p.data:p.data.slice(0,p.length);_&&he.sort(_);const _e=he[0].getMesh().getScene();for(Z=0;Z<he.length;Z++)if(re=he[Z],!(_e._activeMeshesFrozenButKeepClipping&&!re.isInFrustum(_e._frustumPlanes))){if(I){const ve=re.getMaterial();if(ve&&ve.needDepthPrePass){const Le=ve.getScene().getEngine();Le.setColorWrite(!1),Le.setAlphaMode(0),re.render(!1),Le.setColorWrite(!0)}}re.render(I)}}static defaultTransparentSortCompare(p,_){return p._alphaIndex>_._alphaIndex?1:p._alphaIndex<_._alphaIndex?-1:L2.backToFrontSortCompare(p,_)}static backToFrontSortCompare(p,_){return p._distanceToCamera<_._distanceToCamera?1:p._distanceToCamera>_._distanceToCamera?-1:0}static frontToBackSortCompare(p,_){return p._distanceToCamera<_._distanceToCamera?-1:p._distanceToCamera>_._distanceToCamera?1:0}static PainterSortCompare(p,_){const E=p.getMesh(),I=_.getMesh();return E.material&&I.material?E.material.uniqueId-I.material.uniqueId:E.uniqueId-I.uniqueId}prepare(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset(),this._depthOnlySubMeshes.reset(),this._particleSystems.reset(),this.prepareSprites(),this._edgesRenderers.reset(),this._empty=!0}prepareSprites(){this._spriteManagers.reset()}dispose(){this._opaqueSubMeshes.dispose(),this._transparentSubMeshes.dispose(),this._alphaTestSubMeshes.dispose(),this._depthOnlySubMeshes.dispose(),this._particleSystems.dispose(),this._spriteManagers.dispose(),this._edgesRenderers.dispose()}dispatch(p,_,E){_===void 0&&(_=p.getMesh()),E===void 0&&(E=p.getMaterial()),E!=null&&(E.needAlphaBlendingForMesh(_)?this._transparentSubMeshes.push(p):E.needAlphaTesting()?(E.needDepthPrePass&&this._depthOnlySubMeshes.push(p),this._alphaTestSubMeshes.push(p)):(E.needDepthPrePass&&this._depthOnlySubMeshes.push(p),this._opaqueSubMeshes.push(p)),_._renderingGroup=this,_._edgesRenderer&&_._edgesRenderer.isEnabled&&this._edgesRenderers.pushNoDuplicate(_._edgesRenderer),this._empty=!1)}dispatchSprites(p){this._spriteManagers.push(p),this._empty=!1}dispatchParticles(p){this._particleSystems.push(p),this._empty=!1}_renderParticles(p){if(this._particleSystems.length===0)return;const _=this._scene.activeCamera;this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);for(let E=0;E<this._particleSystems.length;E++){const I=this._particleSystems.data[E];if((_&&_.layerMask&I.layerMask)===0)continue;const Z=I.emitter;(!Z.position||!p||p.indexOf(Z)!==-1)&&this._scene._activeParticles.addCount(I.render(),!1)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}_renderSprites(){if(!this._scene.spritesEnabled||this._spriteManagers.length===0)return;const p=this._scene.activeCamera;this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);for(let _=0;_<this._spriteManagers.length;_++){const E=this._spriteManagers.data[_];(p&&p.layerMask&E.layerMask)!==0&&E.render()}this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)}}L2._ZeroVector=at.Zero();class GM{}class Tx{get maintainStateBetweenFrames(){return this._maintainStateBetweenFrames}set maintainStateBetweenFrames(p){p!==this._maintainStateBetweenFrames&&(this._maintainStateBetweenFrames=p,this._maintainStateBetweenFrames||this.restoreDispachedFlags())}restoreDispachedFlags(){for(const p of this._scene.meshes)if(p.subMeshes)for(const _ of p.subMeshes)_._wasDispatched=!1;if(this._scene.spriteManagers)for(const p of this._scene.spriteManagers)p._wasDispatched=!1;for(const p of this._scene.particleSystems)p._wasDispatched=!1}constructor(p){this._useSceneAutoClearSetup=!1,this._renderingGroups=new Array,this._autoClearDepthStencil={},this._customOpaqueSortCompareFn={},this._customAlphaTestSortCompareFn={},this._customTransparentSortCompareFn={},this._renderingGroupInfo=new GM,this._maintainStateBetweenFrames=!1,this._scene=p;for(let _=Tx.MIN_RENDERINGGROUPS;_<Tx.MAX_RENDERINGGROUPS;_++)this._autoClearDepthStencil[_]={autoClear:!0,depth:!0,stencil:!0}}getRenderingGroup(p){const _=p||0;return this._prepareRenderingGroup(_),this._renderingGroups[_]}_clearDepthStencilBuffer(p=!0,_=!0){this._depthStencilBufferAlreadyCleaned||(this._scene.getEngine().clear(null,!1,p,_),this._depthStencilBufferAlreadyCleaned=!0)}render(p,_,E,I){const Z=this._renderingGroupInfo;if(Z.scene=this._scene,Z.camera=this._scene.activeCamera,this._scene.spriteManagers&&I)for(let re=0;re<this._scene.spriteManagers.length;re++){const ae=this._scene.spriteManagers[re];this.dispatchSprites(ae)}for(let re=Tx.MIN_RENDERINGGROUPS;re<Tx.MAX_RENDERINGGROUPS;re++){this._depthStencilBufferAlreadyCleaned=re===Tx.MIN_RENDERINGGROUPS;const ae=this._renderingGroups[re];if(!ae||ae._empty)continue;const he=1<<re;if(Z.renderingGroupId=re,this._scene.onBeforeRenderingGroupObservable.notifyObservers(Z,he),Tx.AUTOCLEAR){const _e=this._useSceneAutoClearSetup?this._scene.getAutoClearDepthStencilSetup(re):this._autoClearDepthStencil[re];_e&&_e.autoClear&&this._clearDepthStencilBuffer(_e.depth,_e.stencil)}for(const _e of this._scene._beforeRenderingGroupDrawStage)_e.action(re);ae.render(p,I,E,_);for(const _e of this._scene._afterRenderingGroupDrawStage)_e.action(re);this._scene.onAfterRenderingGroupObservable.notifyObservers(Z,he)}}reset(){if(!this.maintainStateBetweenFrames)for(let p=Tx.MIN_RENDERINGGROUPS;p<Tx.MAX_RENDERINGGROUPS;p++){const _=this._renderingGroups[p];_&&_.prepare()}}resetSprites(){if(!this.maintainStateBetweenFrames)for(let p=Tx.MIN_RENDERINGGROUPS;p<Tx.MAX_RENDERINGGROUPS;p++){const _=this._renderingGroups[p];_&&_.prepareSprites()}}dispose(){this.freeRenderingGroups(),this._renderingGroups.length=0,this._renderingGroupInfo=null}freeRenderingGroups(){for(let p=Tx.MIN_RENDERINGGROUPS;p<Tx.MAX_RENDERINGGROUPS;p++){const _=this._renderingGroups[p];_&&_.dispose()}}_prepareRenderingGroup(p){this._renderingGroups[p]===void 0&&(this._renderingGroups[p]=new L2(p,this._scene,this._customOpaqueSortCompareFn[p],this._customAlphaTestSortCompareFn[p],this._customTransparentSortCompareFn[p]))}dispatchSprites(p){this.maintainStateBetweenFrames&&p._wasDispatched||(p._wasDispatched=!0,this.getRenderingGroup(p.renderingGroupId).dispatchSprites(p))}dispatchParticles(p){this.maintainStateBetweenFrames&&p._wasDispatched||(p._wasDispatched=!0,this.getRenderingGroup(p.renderingGroupId).dispatchParticles(p))}dispatch(p,_,E){_===void 0&&(_=p.getMesh()),!(this.maintainStateBetweenFrames&&p._wasDispatched)&&(p._wasDispatched=!0,this.getRenderingGroup(_.renderingGroupId).dispatch(p,_,E))}setRenderingOrder(p,_=null,E=null,I=null){if(this._customOpaqueSortCompareFn[p]=_,this._customAlphaTestSortCompareFn[p]=E,this._customTransparentSortCompareFn[p]=I,this._renderingGroups[p]){const Z=this._renderingGroups[p];Z.opaqueSortCompareFn=this._customOpaqueSortCompareFn[p],Z.alphaTestSortCompareFn=this._customAlphaTestSortCompareFn[p],Z.transparentSortCompareFn=this._customTransparentSortCompareFn[p]}}setRenderingAutoClearDepthStencil(p,_,E=!0,I=!0){this._autoClearDepthStencil[p]={autoClear:_,depth:E,stencil:I}}getAutoClearDepthStencilSetup(p){return this._autoClearDepthStencil[p]}}Tx.MAX_RENDERINGGROUPS=4,Tx.MIN_RENDERINGGROUPS=0,Tx.AUTOCLEAR=!0;class _r{}_r.NAME_EFFECTLAYER="EffectLayer",_r.NAME_LAYER="Layer",_r.NAME_LENSFLARESYSTEM="LensFlareSystem",_r.NAME_BOUNDINGBOXRENDERER="BoundingBoxRenderer",_r.NAME_PARTICLESYSTEM="ParticleSystem",_r.NAME_GAMEPAD="Gamepad",_r.NAME_SIMPLIFICATIONQUEUE="SimplificationQueue",_r.NAME_GEOMETRYBUFFERRENDERER="GeometryBufferRenderer",_r.NAME_PREPASSRENDERER="PrePassRenderer",_r.NAME_DEPTHRENDERER="DepthRenderer",_r.NAME_DEPTHPEELINGRENDERER="DepthPeelingRenderer",_r.NAME_POSTPROCESSRENDERPIPELINEMANAGER="PostProcessRenderPipelineManager",_r.NAME_SPRITE="Sprite",_r.NAME_SUBSURFACE="SubSurface",_r.NAME_OUTLINERENDERER="Outline",_r.NAME_PROCEDURALTEXTURE="ProceduralTexture",_r.NAME_SHADOWGENERATOR="ShadowGenerator",_r.NAME_OCTREE="Octree",_r.NAME_PHYSICSENGINE="PhysicsEngine",_r.NAME_AUDIO="Audio",_r.NAME_FLUIDRENDERER="FluidRenderer",_r.STEP_ISREADYFORMESH_EFFECTLAYER=0,_r.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER=0,_r.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER=0,_r.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER=0,_r.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER=1,_r.STEP_BEFORECAMERADRAW_PREPASS=0,_r.STEP_BEFORECAMERADRAW_EFFECTLAYER=1,_r.STEP_BEFORECAMERADRAW_LAYER=2,_r.STEP_BEFORERENDERTARGETDRAW_PREPASS=0,_r.STEP_BEFORERENDERTARGETDRAW_LAYER=1,_r.STEP_BEFORERENDERINGMESH_PREPASS=0,_r.STEP_BEFORERENDERINGMESH_OUTLINE=1,_r.STEP_AFTERRENDERINGMESH_PREPASS=0,_r.STEP_AFTERRENDERINGMESH_OUTLINE=1,_r.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW=0,_r.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER=1,_r.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE=0,_r.STEP_BEFORECAMERAUPDATE_GAMEPAD=1,_r.STEP_BEFORECLEAR_PROCEDURALTEXTURE=0,_r.STEP_BEFORECLEAR_PREPASS=1,_r.STEP_BEFORERENDERTARGETCLEAR_PREPASS=0,_r.STEP_AFTERRENDERTARGETDRAW_PREPASS=0,_r.STEP_AFTERRENDERTARGETDRAW_LAYER=1,_r.STEP_AFTERCAMERADRAW_PREPASS=0,_r.STEP_AFTERCAMERADRAW_EFFECTLAYER=1,_r.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM=2,_r.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW=3,_r.STEP_AFTERCAMERADRAW_LAYER=4,_r.STEP_AFTERCAMERADRAW_FLUIDRENDERER=5,_r.STEP_AFTERCAMERAPOSTPROCESS_LAYER=0,_r.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER=0,_r.STEP_AFTERRENDER_AUDIO=0,_r.STEP_GATHERRENDERTARGETS_DEPTHRENDERER=0,_r.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER=1,_r.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR=2,_r.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER=3,_r.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER=0,_r.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER=1,_r.STEP_POINTERMOVE_SPRITE=0,_r.STEP_POINTERDOWN_SPRITE=0,_r.STEP_POINTERUP_SPRITE=0;class Ka extends Array{constructor(p){super(...p)}static Create(){return Object.create(Ka.prototype)}registerStep(p,_,E){let I=0,Z=Number.MAX_VALUE;for(;I<this.length&&(Z=this[I].index,!(p<Z));I++);this.splice(I,0,{index:p,component:_,action:E.bind(_)})}clear(){this.length=0}}class zr{}zr.POINTERDOWN=1,zr.POINTERUP=2,zr.POINTERMOVE=4,zr.POINTERWHEEL=8,zr.POINTERPICK=16,zr.POINTERTAP=32,zr.POINTERDOUBLETAP=64;class Gy{constructor(p,_){this.type=p,this.event=_}}class zM extends Gy{constructor(p,_,E,I){super(p,_),this.ray=null,this.originalPickingInfo=null,this.skipOnPointerObservable=!1,this.localPosition=new xr(E,I)}}class jl extends Gy{get pickInfo(){return this._pickInfo||this._generatePickInfo(),this._pickInfo}constructor(p,_,E,I=null){super(p,_),this._pickInfo=E,this._inputManager=I}_generatePickInfo(){this._inputManager&&(this._pickInfo=this._inputManager._pickMove(this.event),this._inputManager._setRayOnPointerInfo(this._pickInfo,this.event),this._inputManager=null)}}class Uo{constructor(){this.hoverCursor="",this.actions=[],this.isRecursive=!1}static get HasTriggers(){for(const p in Uo.Triggers)if(Object.prototype.hasOwnProperty.call(Uo.Triggers,p))return!0;return!1}static get HasPickTriggers(){for(const p in Uo.Triggers)if(Object.prototype.hasOwnProperty.call(Uo.Triggers,p)){const _=parseInt(p);if(_>=1&&_<=7)return!0}return!1}static HasSpecificTrigger(p){for(const _ in Uo.Triggers)if(Object.prototype.hasOwnProperty.call(Uo.Triggers,_)&&parseInt(_)===p)return!0;return!1}}Uo.Triggers={};class lu{}lu.KEYDOWN=1,lu.KEYUP=2;class Wg{constructor(p,_){this.type=p,this.event=_}}class zy extends Wg{get skipOnPointerObservable(){return this.skipOnKeyboardObservable}set skipOnPointerObservable(p){this.skipOnKeyboardObservable=p}constructor(p,_){super(p,_),this.type=p,this.event=_,this.skipOnKeyboardObservable=!1}}var rr;(function(pe){pe[pe.Generic=0]="Generic",pe[pe.Keyboard=1]="Keyboard",pe[pe.Mouse=2]="Mouse",pe[pe.Touch=3]="Touch",pe[pe.DualShock=4]="DualShock",pe[pe.Xbox=5]="Xbox",pe[pe.Switch=6]="Switch",pe[pe.DualSense=7]="DualSense"})(rr||(rr={}));var wr;(function(pe){pe[pe.Horizontal=0]="Horizontal",pe[pe.Vertical=1]="Vertical",pe[pe.LeftClick=2]="LeftClick",pe[pe.MiddleClick=3]="MiddleClick",pe[pe.RightClick=4]="RightClick",pe[pe.BrowserBack=5]="BrowserBack",pe[pe.BrowserForward=6]="BrowserForward",pe[pe.MouseWheelX=7]="MouseWheelX",pe[pe.MouseWheelY=8]="MouseWheelY",pe[pe.MouseWheelZ=9]="MouseWheelZ",pe[pe.Move=12]="Move"})(wr||(wr={}));var Um;(function(pe){pe[pe.Horizontal=0]="Horizontal",pe[pe.Vertical=1]="Vertical",pe[pe.LeftClick=2]="LeftClick",pe[pe.MiddleClick=3]="MiddleClick",pe[pe.RightClick=4]="RightClick",pe[pe.BrowserBack=5]="BrowserBack",pe[pe.BrowserForward=6]="BrowserForward",pe[pe.MouseWheelX=7]="MouseWheelX",pe[pe.MouseWheelY=8]="MouseWheelY",pe[pe.MouseWheelZ=9]="MouseWheelZ",pe[pe.DeltaHorizontal=10]="DeltaHorizontal",pe[pe.DeltaVertical=11]="DeltaVertical"})(Um||(Um={}));var Wy;(function(pe){pe[pe.Cross=0]="Cross",pe[pe.Circle=1]="Circle",pe[pe.Square=2]="Square",pe[pe.Triangle=3]="Triangle",pe[pe.L1=4]="L1",pe[pe.R1=5]="R1",pe[pe.L2=6]="L2",pe[pe.R2=7]="R2",pe[pe.Share=8]="Share",pe[pe.Options=9]="Options",pe[pe.L3=10]="L3",pe[pe.R3=11]="R3",pe[pe.DPadUp=12]="DPadUp",pe[pe.DPadDown=13]="DPadDown",pe[pe.DPadLeft=14]="DPadLeft",pe[pe.DPadRight=15]="DPadRight",pe[pe.Home=16]="Home",pe[pe.TouchPad=17]="TouchPad",pe[pe.LStickXAxis=18]="LStickXAxis",pe[pe.LStickYAxis=19]="LStickYAxis",pe[pe.RStickXAxis=20]="RStickXAxis",pe[pe.RStickYAxis=21]="RStickYAxis"})(Wy||(Wy={}));var Hy;(function(pe){pe[pe.Cross=0]="Cross",pe[pe.Circle=1]="Circle",pe[pe.Square=2]="Square",pe[pe.Triangle=3]="Triangle",pe[pe.L1=4]="L1",pe[pe.R1=5]="R1",pe[pe.L2=6]="L2",pe[pe.R2=7]="R2",pe[pe.Create=8]="Create",pe[pe.Options=9]="Options",pe[pe.L3=10]="L3",pe[pe.R3=11]="R3",pe[pe.DPadUp=12]="DPadUp",pe[pe.DPadDown=13]="DPadDown",pe[pe.DPadLeft=14]="DPadLeft",pe[pe.DPadRight=15]="DPadRight",pe[pe.Home=16]="Home",pe[pe.TouchPad=17]="TouchPad",pe[pe.LStickXAxis=18]="LStickXAxis",pe[pe.LStickYAxis=19]="LStickYAxis",pe[pe.RStickXAxis=20]="RStickXAxis",pe[pe.RStickYAxis=21]="RStickYAxis"})(Hy||(Hy={}));var Xy;(function(pe){pe[pe.A=0]="A",pe[pe.B=1]="B",pe[pe.X=2]="X",pe[pe.Y=3]="Y",pe[pe.LB=4]="LB",pe[pe.RB=5]="RB",pe[pe.LT=6]="LT",pe[pe.RT=7]="RT",pe[pe.Back=8]="Back",pe[pe.Start=9]="Start",pe[pe.LS=10]="LS",pe[pe.RS=11]="RS",pe[pe.DPadUp=12]="DPadUp",pe[pe.DPadDown=13]="DPadDown",pe[pe.DPadLeft=14]="DPadLeft",pe[pe.DPadRight=15]="DPadRight",pe[pe.Home=16]="Home",pe[pe.LStickXAxis=17]="LStickXAxis",pe[pe.LStickYAxis=18]="LStickYAxis",pe[pe.RStickXAxis=19]="RStickXAxis",pe[pe.RStickYAxis=20]="RStickYAxis"})(Xy||(Xy={}));var Yy;(function(pe){pe[pe.B=0]="B",pe[pe.A=1]="A",pe[pe.Y=2]="Y",pe[pe.X=3]="X",pe[pe.L=4]="L",pe[pe.R=5]="R",pe[pe.ZL=6]="ZL",pe[pe.ZR=7]="ZR",pe[pe.Minus=8]="Minus",pe[pe.Plus=9]="Plus",pe[pe.LS=10]="LS",pe[pe.RS=11]="RS",pe[pe.DPadUp=12]="DPadUp",pe[pe.DPadDown=13]="DPadDown",pe[pe.DPadLeft=14]="DPadLeft",pe[pe.DPadRight=15]="DPadRight",pe[pe.Home=16]="Home",pe[pe.Capture=17]="Capture",pe[pe.LStickXAxis=18]="LStickXAxis",pe[pe.LStickYAxis=19]="LStickYAxis",pe[pe.RStickXAxis=20]="RStickXAxis",pe[pe.RStickYAxis=21]="RStickYAxis"})(Yy||(Yy={}));var Ky;(function(pe){pe[pe.PointerMove=0]="PointerMove",pe[pe.PointerDown=1]="PointerDown",pe[pe.PointerUp=2]="PointerUp"})(Ky||(Ky={}));class hu{}hu.DOM_DELTA_PIXEL=0,hu.DOM_DELTA_LINE=1,hu.DOM_DELTA_PAGE=2;class Uc{static CreateDeviceEvent(p,_,E,I,Z,re,ae){switch(p){case rr.Keyboard:return this._CreateKeyboardEvent(E,I,Z,re);case rr.Mouse:if(E===wr.MouseWheelX||E===wr.MouseWheelY||E===wr.MouseWheelZ)return this._CreateWheelEvent(p,_,E,I,Z,re);case rr.Touch:return this._CreatePointerEvent(p,_,E,I,Z,re,ae);default:throw`Unable to generate event for device ${rr[p]}`}}static _CreatePointerEvent(p,_,E,I,Z,re,ae){const he=this._CreateMouseEvent(p,_,E,I,Z,re);p===rr.Mouse?(he.deviceType=rr.Mouse,he.pointerId=1,he.pointerType="mouse"):(he.deviceType=rr.Touch,he.pointerId=ae??_,he.pointerType="touch");let _e=0;return _e+=Z.pollInput(p,_,wr.LeftClick),_e+=Z.pollInput(p,_,wr.RightClick)*2,_e+=Z.pollInput(p,_,wr.MiddleClick)*4,he.buttons=_e,E===wr.Move?he.type="pointermove":E>=wr.LeftClick&&E<=wr.RightClick&&(he.type=I===1?"pointerdown":"pointerup",he.button=E-2),he}static _CreateWheelEvent(p,_,E,I,Z,re){const ae=this._CreateMouseEvent(p,_,E,I,Z,re);switch(ae.pointerId=1,ae.type="wheel",ae.deltaMode=hu.DOM_DELTA_PIXEL,ae.deltaX=0,ae.deltaY=0,ae.deltaZ=0,E){case wr.MouseWheelX:ae.deltaX=I;break;case wr.MouseWheelY:ae.deltaY=I;break;case wr.MouseWheelZ:ae.deltaZ=I;break}return ae}static _CreateMouseEvent(p,_,E,I,Z,re){const ae=this._CreateEvent(re),he=Z.pollInput(p,_,wr.Horizontal),_e=Z.pollInput(p,_,wr.Vertical);return re?(ae.movementX=0,ae.movementY=0,ae.offsetX=ae.movementX-re.getBoundingClientRect().x,ae.offsetY=ae.movementY-re.getBoundingClientRect().y):(ae.movementX=Z.pollInput(p,_,Um.DeltaHorizontal),ae.movementY=Z.pollInput(p,_,Um.DeltaVertical),ae.offsetX=0,ae.offsetY=0),this._CheckNonCharacterKeys(ae,Z),ae.clientX=he,ae.clientY=_e,ae.x=he,ae.y=_e,ae.deviceType=p,ae.deviceSlot=_,ae.inputIndex=E,ae}static _CreateKeyboardEvent(p,_,E,I){const Z=this._CreateEvent(I);return this._CheckNonCharacterKeys(Z,E),Z.deviceType=rr.Keyboard,Z.deviceSlot=0,Z.inputIndex=p,Z.type=_===1?"keydown":"keyup",Z.key=String.fromCharCode(p),Z.keyCode=p,Z}static _CheckNonCharacterKeys(p,_){const E=_.isDeviceAvailable(rr.Keyboard),I=E&&_.pollInput(rr.Keyboard,0,18)===1,Z=E&&_.pollInput(rr.Keyboard,0,17)===1,re=E&&(_.pollInput(rr.Keyboard,0,91)===1||_.pollInput(rr.Keyboard,0,92)===1||_.pollInput(rr.Keyboard,0,93)===1),ae=E&&_.pollInput(rr.Keyboard,0,16)===1;p.altKey=I,p.ctrlKey=Z,p.metaKey=re,p.shiftKey=ae}static _CreateEvent(p){const _={};return _.preventDefault=()=>{},_.target=p,_}}class WM{constructor(p,_,E){this._nativeInput=_native.DeviceInputSystem?new _native.DeviceInputSystem(p,_,(I,Z,re,ae)=>{const he=Uc.CreateDeviceEvent(I,Z,re,ae,this);E(I,Z,he)}):this._createDummyNativeInput()}pollInput(p,_,E){return this._nativeInput.pollInput(p,_,E)}isDeviceAvailable(p){return p===rr.Mouse||p===rr.Touch}dispose(){this._nativeInput.dispose()}_createDummyNativeInput(){return{pollInput:()=>0,isDeviceAvailable:()=>!1,dispose:()=>{}}}}const jy=255,qy=Object.keys(wr).length/2;class HM{constructor(p,_,E,I){this._inputs=[],this._keyboardActive=!1,this._pointerActive=!1,this._usingSafari=lt.IsSafari(),this._usingMacOS=Ux()&&/(Mac|iPhone|iPod|iPad)/i.test(navigator.platform),this._keyboardDownEvent=Z=>{},this._keyboardUpEvent=Z=>{},this._keyboardBlurEvent=Z=>{},this._pointerMoveEvent=Z=>{},this._pointerDownEvent=Z=>{},this._pointerUpEvent=Z=>{},this._pointerCancelEvent=Z=>{},this._pointerWheelEvent=Z=>{},this._pointerBlurEvent=Z=>{},this._pointerMacOSChromeOutEvent=Z=>{},this._eventsAttached=!1,this._mouseId=-1,this._isUsingFirefox=Ux()&&navigator.userAgent&&navigator.userAgent.indexOf("Firefox")!==-1,this._isUsingChromium=Ux()&&navigator.userAgent&&navigator.userAgent.indexOf("Chrome")!==-1,this._maxTouchPoints=0,this._pointerInputClearObserver=null,this._gamepadConnectedEvent=Z=>{},this._gamepadDisconnectedEvent=Z=>{},this._eventPrefix=lt.GetPointerPrefix(p),this._engine=p,this._onDeviceConnected=_,this._onDeviceDisconnected=E,this._onInputChanged=I,this._mouseId=this._isUsingFirefox?0:1,this._enableEvents(),this._usingMacOS&&(this._metaKeys=[]),this._engine._onEngineViewChanged||(this._engine._onEngineViewChanged=()=>{this._enableEvents()})}pollInput(p,_,E){const I=this._inputs[p][_];if(!I)throw`Unable to find device ${rr[p]}`;p>=rr.DualShock&&p<=rr.DualSense&&this._updateDevice(p,_,E);const Z=I[E];if(Z===void 0)throw`Unable to find input ${E} for device ${rr[p]} in slot ${_}`;return E===wr.Move&&lt.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data."),Z}isDeviceAvailable(p){return this._inputs[p]!==void 0}dispose(){this._onDeviceConnected=()=>{},this._onDeviceDisconnected=()=>{},this._onInputChanged=()=>{},delete this._engine._onEngineViewChanged,this._elementToAttachTo&&this._disableEvents()}_enableEvents(){const p=this?._engine.getInputElement();if(p&&(!this._eventsAttached||this._elementToAttachTo!==p)){if(this._disableEvents(),this._inputs){for(const _ of this._inputs)if(_)for(const E in _){const I=+E,Z=_[I];if(Z)for(let re=0;re<Z.length;re++)Z[re]=0}}this._elementToAttachTo=p,this._elementToAttachTo.tabIndex=this._elementToAttachTo.tabIndex!==-1?this._elementToAttachTo.tabIndex:this._engine.canvasTabIndex,this._handleKeyActions(),this._handlePointerActions(),this._handleGamepadActions(),this._eventsAttached=!0,this._checkForConnectedDevices()}}_disableEvents(){this._elementToAttachTo&&(this._elementToAttachTo.removeEventListener("blur",this._keyboardBlurEvent),this._elementToAttachTo.removeEventListener("blur",this._pointerBlurEvent),this._elementToAttachTo.removeEventListener("keydown",this._keyboardDownEvent),this._elementToAttachTo.removeEventListener("keyup",this._keyboardUpEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"move",this._pointerMoveEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"down",this._pointerDownEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"up",this._pointerUpEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"cancel",this._pointerCancelEvent),this._elementToAttachTo.removeEventListener(this._wheelEventName,this._pointerWheelEvent),this._usingMacOS&&this._isUsingChromium&&this._elementToAttachTo.removeEventListener("lostpointercapture",this._pointerMacOSChromeOutEvent),window.removeEventListener("gamepadconnected",this._gamepadConnectedEvent),window.removeEventListener("gamepaddisconnected",this._gamepadDisconnectedEvent)),this._pointerInputClearObserver&&this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver),this._eventsAttached=!1}_checkForConnectedDevices(){if(navigator.getGamepads){const p=navigator.getGamepads();for(const _ of p)_&&this._addGamePad(_)}typeof matchMedia=="function"&&matchMedia("(pointer:fine)").matches&&this._addPointerDevice(rr.Mouse,0,0,0)}_addGamePad(p){const _=this._getGamepadDeviceType(p.id),E=p.index;this._gamepads=this._gamepads||new Array(p.index+1),this._registerDevice(_,E,p.buttons.length+p.axes.length),this._gamepads[E]=_}_addPointerDevice(p,_,E,I){this._pointerActive||(this._pointerActive=!0),this._registerDevice(p,_,qy);const Z=this._inputs[p][_];Z[0]=E,Z[1]=I}_registerDevice(p,_,E){if(_===void 0)throw`Unable to register device ${rr[p]} to undefined slot.`;if(this._inputs[p]||(this._inputs[p]={}),!this._inputs[p][_]){const I=new Array(E);I.fill(0),this._inputs[p][_]=I,this._onDeviceConnected(p,_)}}_unregisterDevice(p,_){this._inputs[p][_]&&(delete this._inputs[p][_],this._onDeviceDisconnected(p,_))}_handleKeyActions(){this._keyboardDownEvent=p=>{this._keyboardActive||(this._keyboardActive=!0,this._registerDevice(rr.Keyboard,0,jy));const _=this._inputs[rr.Keyboard][0];if(_){_[p.keyCode]=1;const E=p;E.inputIndex=p.keyCode,this._usingMacOS&&p.metaKey&&p.key!=="Meta"&&(this._metaKeys.includes(p.keyCode)||this._metaKeys.push(p.keyCode)),this._onInputChanged(rr.Keyboard,0,E)}},this._keyboardUpEvent=p=>{this._keyboardActive||(this._keyboardActive=!0,this._registerDevice(rr.Keyboard,0,jy));const _=this._inputs[rr.Keyboard][0];if(_){_[p.keyCode]=0;const E=p;if(E.inputIndex=p.keyCode,this._usingMacOS&&p.key==="Meta"&&this._metaKeys.length>0){for(const I of this._metaKeys){const Z=Uc.CreateDeviceEvent(rr.Keyboard,0,I,0,this,this._elementToAttachTo);_[I]=0,this._onInputChanged(rr.Keyboard,0,Z)}this._metaKeys.splice(0,this._metaKeys.length)}this._onInputChanged(rr.Keyboard,0,E)}},this._keyboardBlurEvent=()=>{if(this._keyboardActive){const p=this._inputs[rr.Keyboard][0];for(let _=0;_<p.length;_++)if(p[_]!==0){p[_]=0;const E=Uc.CreateDeviceEvent(rr.Keyboard,0,_,0,this,this._elementToAttachTo);this._onInputChanged(rr.Keyboard,0,E)}this._usingMacOS&&this._metaKeys.splice(0,this._metaKeys.length)}},this._elementToAttachTo.addEventListener("keydown",this._keyboardDownEvent),this._elementToAttachTo.addEventListener("keyup",this._keyboardUpEvent),this._elementToAttachTo.addEventListener("blur",this._keyboardBlurEvent)}_handlePointerActions(){this._maxTouchPoints=Ux()&&navigator.maxTouchPoints||2,this._activeTouchIds||(this._activeTouchIds=new Array(this._maxTouchPoints));for(let E=0;E<this._maxTouchPoints;E++)this._activeTouchIds[E]=-1;this._pointerMoveEvent=E=>{const I=this._getPointerType(E);let Z=I===rr.Mouse?0:this._activeTouchIds.indexOf(E.pointerId);if(I===rr.Touch&&Z===-1){const ae=this._activeTouchIds.indexOf(-1);if(ae>=0)Z=ae,this._activeTouchIds[ae]=E.pointerId,this._onDeviceConnected(I,Z);else{lt.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);return}}this._inputs[I]||(this._inputs[I]={}),this._inputs[I][Z]||this._addPointerDevice(I,Z,E.clientX,E.clientY);const re=this._inputs[I][Z];if(re){const ae=E;ae.inputIndex=wr.Move,re[wr.Horizontal]=E.clientX,re[wr.Vertical]=E.clientY,I===rr.Touch&&re[wr.LeftClick]===0&&(re[wr.LeftClick]=1),E.pointerId===void 0&&(E.pointerId=this._mouseId),this._onInputChanged(I,Z,ae),!this._usingSafari&&E.button!==-1&&(ae.inputIndex=E.button+2,re[E.button+2]=re[E.button+2]?0:1,this._onInputChanged(I,Z,ae))}},this._pointerDownEvent=E=>{const I=this._getPointerType(E);let Z=I===rr.Mouse?0:E.pointerId;if(I===rr.Touch){const ae=this._activeTouchIds.indexOf(-1);if(ae>=0)Z=ae,this._activeTouchIds[ae]=E.pointerId;else{lt.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);return}}this._inputs[I]||(this._inputs[I]={}),this._inputs[I][Z]?I===rr.Touch&&this._onDeviceConnected(I,Z):this._addPointerDevice(I,Z,E.clientX,E.clientY);const re=this._inputs[I][Z];if(re){const ae=re[wr.Horizontal],he=re[wr.Vertical];if(I===rr.Mouse){if(E.pointerId===void 0&&(E.pointerId=this._mouseId),!document.pointerLockElement)try{this._elementToAttachTo.setPointerCapture(this._mouseId)}catch{}}else if(E.pointerId&&!document.pointerLockElement)try{this._elementToAttachTo.setPointerCapture(E.pointerId)}catch{}re[wr.Horizontal]=E.clientX,re[wr.Vertical]=E.clientY,re[E.button+2]=1;const _e=E;_e.inputIndex=E.button+2,this._onInputChanged(I,Z,_e),(ae!==E.clientX||he!==E.clientY)&&(_e.inputIndex=wr.Move,this._onInputChanged(I,Z,_e))}},this._pointerUpEvent=E=>{const I=this._getPointerType(E),Z=I===rr.Mouse?0:this._activeTouchIds.indexOf(E.pointerId);if(I===rr.Touch){if(Z===-1)return;this._activeTouchIds[Z]=-1}const re=this._inputs[I]?.[Z];if(re&&re[E.button+2]!==0){const ae=re[wr.Horizontal],he=re[wr.Vertical];re[wr.Horizontal]=E.clientX,re[wr.Vertical]=E.clientY,re[E.button+2]=0;const _e=E;E.pointerId===void 0&&(E.pointerId=this._mouseId),(ae!==E.clientX||he!==E.clientY)&&(_e.inputIndex=wr.Move,this._onInputChanged(I,Z,_e)),_e.inputIndex=E.button+2,I===rr.Mouse&&this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)?this._elementToAttachTo.releasePointerCapture(this._mouseId):E.pointerId&&this._elementToAttachTo.hasPointerCapture?.(E.pointerId)&&this._elementToAttachTo.releasePointerCapture(E.pointerId),this._onInputChanged(I,Z,_e),I===rr.Touch&&this._onDeviceDisconnected(I,Z)}},this._pointerCancelEvent=E=>{if(E.pointerType==="mouse"){const I=this._inputs[rr.Mouse][0];this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)&&this._elementToAttachTo.releasePointerCapture(this._mouseId);for(let Z=wr.LeftClick;Z<=wr.BrowserForward;Z++)if(I[Z]===1){I[Z]=0;const re=Uc.CreateDeviceEvent(rr.Mouse,0,Z,0,this,this._elementToAttachTo);this._onInputChanged(rr.Mouse,0,re)}}else{const I=this._activeTouchIds.indexOf(E.pointerId);if(I===-1)return;this._elementToAttachTo.hasPointerCapture?.(E.pointerId)&&this._elementToAttachTo.releasePointerCapture(E.pointerId),this._inputs[rr.Touch][I][wr.LeftClick]=0;const Z=Uc.CreateDeviceEvent(rr.Touch,I,wr.LeftClick,0,this,this._elementToAttachTo,E.pointerId);this._onInputChanged(rr.Touch,I,Z),this._activeTouchIds[I]=-1,this._onDeviceDisconnected(rr.Touch,I)}},this._wheelEventName="onwheel"in document.createElement("div")?"wheel":document.onmousewheel!==void 0?"mousewheel":"DOMMouseScroll";let p=!1;const _=function(){};try{const E=Object.defineProperty({},"passive",{get:function(){p=!0}});this._elementToAttachTo.addEventListener("test",_,E),this._elementToAttachTo.removeEventListener("test",_,E)}catch{}this._pointerBlurEvent=()=>{if(this.isDeviceAvailable(rr.Mouse)){const E=this._inputs[rr.Mouse][0];this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)&&this._elementToAttachTo.releasePointerCapture(this._mouseId);for(let I=wr.LeftClick;I<=wr.BrowserForward;I++)if(E[I]===1){E[I]=0;const Z=Uc.CreateDeviceEvent(rr.Mouse,0,I,0,this,this._elementToAttachTo);this._onInputChanged(rr.Mouse,0,Z)}}if(this.isDeviceAvailable(rr.Touch)){const E=this._inputs[rr.Touch];for(let I=0;I<this._activeTouchIds.length;I++){const Z=this._activeTouchIds[I];if(this._elementToAttachTo.hasPointerCapture?.(Z)&&this._elementToAttachTo.releasePointerCapture(Z),Z!==-1&&E[I]?.[wr.LeftClick]===1){E[I][wr.LeftClick]=0;const re=Uc.CreateDeviceEvent(rr.Touch,I,wr.LeftClick,0,this,this._elementToAttachTo,Z);this._onInputChanged(rr.Touch,I,re),this._activeTouchIds[I]=-1,this._onDeviceDisconnected(rr.Touch,I)}}}},this._pointerWheelEvent=E=>{const I=rr.Mouse,Z=0;this._inputs[I]||(this._inputs[I]=[]),this._inputs[I][Z]||(this._pointerActive=!0,this._registerDevice(I,Z,qy));const re=this._inputs[I][Z];if(re){re[wr.MouseWheelX]=E.deltaX||0,re[wr.MouseWheelY]=E.deltaY||E.wheelDelta||0,re[wr.MouseWheelZ]=E.deltaZ||0;const ae=E;E.pointerId===void 0&&(E.pointerId=this._mouseId),re[wr.MouseWheelX]!==0&&(ae.inputIndex=wr.MouseWheelX,this._onInputChanged(I,Z,ae)),re[wr.MouseWheelY]!==0&&(ae.inputIndex=wr.MouseWheelY,this._onInputChanged(I,Z,ae)),re[wr.MouseWheelZ]!==0&&(ae.inputIndex=wr.MouseWheelZ,this._onInputChanged(I,Z,ae))}},this._usingMacOS&&this._isUsingChromium&&(this._pointerMacOSChromeOutEvent=E=>{E.buttons>1&&this._pointerCancelEvent(E)},this._elementToAttachTo.addEventListener("lostpointercapture",this._pointerMacOSChromeOutEvent)),this._elementToAttachTo.addEventListener(this._eventPrefix+"move",this._pointerMoveEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"down",this._pointerDownEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"up",this._pointerUpEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"cancel",this._pointerCancelEvent),this._elementToAttachTo.addEventListener("blur",this._pointerBlurEvent),this._elementToAttachTo.addEventListener(this._wheelEventName,this._pointerWheelEvent,p?{passive:!1}:!1),this._pointerInputClearObserver=this._engine.onEndFrameObservable.add(()=>{if(this.isDeviceAvailable(rr.Mouse)){const E=this._inputs[rr.Mouse][0];E[wr.MouseWheelX]=0,E[wr.MouseWheelY]=0,E[wr.MouseWheelZ]=0}})}_handleGamepadActions(){this._gamepadConnectedEvent=p=>{this._addGamePad(p.gamepad)},this._gamepadDisconnectedEvent=p=>{if(this._gamepads){const _=this._getGamepadDeviceType(p.gamepad.id),E=p.gamepad.index;this._unregisterDevice(_,E),delete this._gamepads[E]}},window.addEventListener("gamepadconnected",this._gamepadConnectedEvent),window.addEventListener("gamepaddisconnected",this._gamepadDisconnectedEvent)}_updateDevice(p,_,E){const I=navigator.getGamepads()[_];if(I&&p===this._gamepads[_]){const Z=this._inputs[p][_];E>=I.buttons.length?Z[E]=I.axes[E-I.buttons.length].valueOf():Z[E]=I.buttons[E].value}}_getGamepadDeviceType(p){return p.indexOf("054c")!==-1?p.indexOf("0ce6")!==-1?rr.DualSense:rr.DualShock:p.indexOf("Xbox One")!==-1||p.search("Xbox 360")!==-1||p.search("xinput")!==-1?rr.Xbox:p.indexOf("057e")!==-1?rr.Switch:rr.Generic}_getPointerType(p){let _=rr.Mouse;return(p.pointerType==="touch"||p.pointerType==="pen"||p.touches)&&(_=rr.Touch),_}}class $y{constructor(p,_,E=0){this.deviceType=_,this.deviceSlot=E,this.onInputChangedObservable=new Ri,this._deviceInputSystem=p}getInput(p){return this._deviceInputSystem.pollInput(this.deviceType,this.deviceSlot,p)}}class XM{constructor(p){this._registeredManagers=new Array,this._refCount=0,this.registerManager=re=>{for(let ae=0;ae<this._devices.length;ae++){const he=this._devices[ae];for(const _e in he){const ve=+_e;re._addDevice(new $y(this._deviceInputSystem,ae,ve))}}this._registeredManagers.push(re)},this.unregisterManager=re=>{const ae=this._registeredManagers.indexOf(re);ae>-1&&this._registeredManagers.splice(ae,1)};const _=Object.keys(rr).length/2;this._devices=new Array(_);const E=(re,ae)=>{this._devices[re]||(this._devices[re]=new Array),this._devices[re][ae]||(this._devices[re][ae]=ae);for(const he of this._registeredManagers){const _e=new $y(this._deviceInputSystem,re,ae);he._addDevice(_e)}},I=(re,ae)=>{this._devices[re]?.[ae]&&delete this._devices[re][ae];for(const he of this._registeredManagers)he._removeDevice(re,ae)},Z=(re,ae,he)=>{if(he)for(const _e of this._registeredManagers)_e._onInputChanged(re,ae,he)};typeof _native<"u"?this._deviceInputSystem=new WM(E,I,Z):this._deviceInputSystem=new HM(p,E,I,Z)}dispose(){this._deviceInputSystem.dispose()}}class YM{getDeviceSource(p,_){if(_===void 0){if(this._firstDevice[p]===void 0)return null;_=this._firstDevice[p]}return!this._devices[p]||this._devices[p][_]===void 0?null:this._devices[p][_]}getDeviceSources(p){return this._devices[p]?this._devices[p].filter(_=>!!_):[]}constructor(p){const _=Object.keys(rr).length/2;this._devices=new Array(_),this._firstDevice=new Array(_),this._engine=p,this._engine._deviceSourceManager||(this._engine._deviceSourceManager=new XM(p)),this._engine._deviceSourceManager._refCount++,this.onDeviceConnectedObservable=new Ri(E=>{for(const I of this._devices)if(I)for(const Z of I)Z&&this.onDeviceConnectedObservable.notifyObserver(E,Z)}),this.onDeviceDisconnectedObservable=new Ri,this._engine._deviceSourceManager.registerManager(this),this._onDisposeObserver=p.onDisposeObservable.add(()=>{this.dispose()})}dispose(){this.onDeviceConnectedObservable.clear(),this.onDeviceDisconnectedObservable.clear(),this._engine._deviceSourceManager&&(this._engine._deviceSourceManager.unregisterManager(this),--this._engine._deviceSourceManager._refCount<1&&(this._engine._deviceSourceManager.dispose(),delete this._engine._deviceSourceManager)),this._engine.onDisposeObservable.remove(this._onDisposeObserver)}_addDevice(p){this._devices[p.deviceType]||(this._devices[p.deviceType]=new Array),this._devices[p.deviceType][p.deviceSlot]||(this._devices[p.deviceType][p.deviceSlot]=p,this._updateFirstDevices(p.deviceType)),this.onDeviceConnectedObservable.notifyObservers(p)}_removeDevice(p,_){const E=this._devices[p]?.[_];this.onDeviceDisconnectedObservable.notifyObservers(E),this._devices[p]?.[_]&&delete this._devices[p][_],this._updateFirstDevices(p)}_onInputChanged(p,_,E){this._devices[p]?.[_]?.onInputChangedObservable.notifyObservers(E)}_updateFirstDevices(p){switch(p){case rr.Keyboard:case rr.Mouse:this._firstDevice[p]=0;break;case rr.Touch:case rr.DualSense:case rr.DualShock:case rr.Xbox:case rr.Switch:case rr.Generic:{delete this._firstDevice[p];const _=this._devices[p];if(_){for(let E=0;E<_.length;E++)if(_[E]){this._firstDevice[p]=E;break}}break}}}}class rb{constructor(){this._singleClick=!1,this._doubleClick=!1,this._hasSwiped=!1,this._ignore=!1}get singleClick(){return this._singleClick}get doubleClick(){return this._doubleClick}get hasSwiped(){return this._hasSwiped}get ignore(){return this._ignore}set singleClick(p){this._singleClick=p}set doubleClick(p){this._doubleClick=p}set hasSwiped(p){this._hasSwiped=p}set ignore(p){this._ignore=p}}class ja{constructor(p){this._alreadyAttached=!1,this._meshPickProceed=!1,this._currentPickResult=null,this._previousPickResult=null,this._totalPointersPressed=0,this._doubleClickOccured=!1,this._isSwiping=!1,this._swipeButtonPressed=-1,this._skipPointerTap=!1,this._isMultiTouchGesture=!1,this._pointerX=0,this._pointerY=0,this._startingPointerPosition=new xr(0,0),this._previousStartingPointerPosition=new xr(0,0),this._startingPointerTime=0,this._previousStartingPointerTime=0,this._pointerCaptures={},this._meshUnderPointerId={},this._movePointerInfo=null,this._cameraObserverCount=0,this._delayedClicks=[null,null,null,null,null],this._deviceSourceManager=null,this._scene=p||Mr.LastCreatedScene,this._scene}get meshUnderPointer(){return this._movePointerInfo&&(this._movePointerInfo._generatePickInfo(),this._movePointerInfo=null),this._pointerOverMesh}getMeshUnderPointerByPointerId(p){return this._meshUnderPointerId[p]||null}get unTranslatedPointer(){return new xr(this._unTranslatedPointerX,this._unTranslatedPointerY)}get pointerX(){return this._pointerX}set pointerX(p){this._pointerX=p}get pointerY(){return this._pointerY}set pointerY(p){this._pointerY=p}_updatePointerPosition(p){const _=this._scene.getEngine().getInputElementClientRect();_&&(this._pointerX=p.clientX-_.left,this._pointerY=p.clientY-_.top,this._unTranslatedPointerX=this._pointerX,this._unTranslatedPointerY=this._pointerY)}_processPointerMove(p,_){const E=this._scene,I=E.getEngine(),Z=I.getInputElement();Z&&(Z.tabIndex=I.canvasTabIndex,E.doNotHandleCursors||(Z.style.cursor=E.defaultCursor)),this._setCursorAndPointerOverMesh(p,_,E);for(const he of E._pointerMoveStage){p=p||this._pickMove(_);const _e=!!p?.pickedMesh;p=he.action(this._unTranslatedPointerX,this._unTranslatedPointerY,p,_e,Z)}const re=_.inputIndex>=wr.MouseWheelX&&_.inputIndex<=wr.MouseWheelZ?zr.POINTERWHEEL:zr.POINTERMOVE;E.onPointerMove&&(p=p||this._pickMove(_),E.onPointerMove(_,p,re));let ae;p?(ae=new jl(re,_,p),this._setRayOnPointerInfo(p,_)):(ae=new jl(re,_,null,this),this._movePointerInfo=ae),E.onPointerObservable.hasObservers()&&E.onPointerObservable.notifyObservers(ae,re)}_setRayOnPointerInfo(p,_){const E=this._scene;p&&E._pickingAvailable&&(p.ray||(p.ray=E.createPickingRay(_.offsetX,_.offsetY,jt.Identity(),E.activeCamera)))}_addCameraPointerObserver(p,_){return this._cameraObserverCount++,this._scene.onPointerObservable.add(p,_)}_removeCameraPointerObserver(p){return this._cameraObserverCount--,this._scene.onPointerObservable.remove(p)}_checkForPicking(){return!!(this._scene.onPointerObservable.observers.length>this._cameraObserverCount||this._scene.onPointerPick)}_checkPrePointerObservable(p,_,E){const I=this._scene,Z=new zM(E,_,this._unTranslatedPointerX,this._unTranslatedPointerY);return p&&(Z.originalPickingInfo=p,Z.ray=p.ray,_.pointerType==="xr-near"&&p.originMesh&&(Z.nearInteractionPickingInfo=p)),I.onPrePointerObservable.notifyObservers(Z,E),!!Z.skipOnPointerObservable}_pickMove(p){const _=this._scene,E=_.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,_.pointerMovePredicate,_.pointerMoveFastCheck,_.cameraToUseForPointers,_.pointerMoveTrianglePredicate);return this._setCursorAndPointerOverMesh(E,p,_),E}_setCursorAndPointerOverMesh(p,_,E){const Z=E.getEngine().getInputElement();if(p?.pickedMesh){if(this.setPointerOverMesh(p.pickedMesh,_.pointerId,p,_),!E.doNotHandleCursors&&Z&&this._pointerOverMesh){const re=this._pointerOverMesh._getActionManagerForTrigger();re&&re.hasPointerTriggers&&(Z.style.cursor=re.hoverCursor||E.hoverCursor)}}else this.setPointerOverMesh(null,_.pointerId,p,_)}simulatePointerMove(p,_){const E=new PointerEvent("pointermove",_);E.inputIndex=wr.Move,!this._checkPrePointerObservable(p,E,zr.POINTERMOVE)&&this._processPointerMove(p,E)}simulatePointerDown(p,_){const E=new PointerEvent("pointerdown",_);E.inputIndex=E.button+2,!this._checkPrePointerObservable(p,E,zr.POINTERDOWN)&&this._processPointerDown(p,E)}_processPointerDown(p,_){const E=this._scene;if(p?.pickedMesh){this._pickedDownMesh=p.pickedMesh;const re=p.pickedMesh._getActionManagerForTrigger();if(re){if(re.hasPickTriggers)switch(re.processTrigger(5,q0.CreateNew(p.pickedMesh,_,p)),_.button){case 0:re.processTrigger(2,q0.CreateNew(p.pickedMesh,_,p));break;case 1:re.processTrigger(4,q0.CreateNew(p.pickedMesh,_,p));break;case 2:re.processTrigger(3,q0.CreateNew(p.pickedMesh,_,p));break}re.hasSpecificTrigger(8)&&window.setTimeout(()=>{const ae=E.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,he=>he.isPickable&&he.isVisible&&he.isReady()&&he.actionManager&&he.actionManager.hasSpecificTrigger(8)&&he===this._pickedDownMesh,!1,E.cameraToUseForPointers);ae?.pickedMesh&&re&&this._totalPointersPressed!==0&&Date.now()-this._startingPointerTime>ja.LongPressDelay&&!this._isPointerSwiping()&&(this._startingPointerTime=0,re.processTrigger(8,q0.CreateNew(ae.pickedMesh,_)))},ja.LongPressDelay)}}else for(const re of E._pointerDownStage)p=re.action(this._unTranslatedPointerX,this._unTranslatedPointerY,p,_,!1);let I;const Z=zr.POINTERDOWN;p?(E.onPointerDown&&E.onPointerDown(_,p,Z),I=new jl(Z,_,p),this._setRayOnPointerInfo(p,_)):I=new jl(Z,_,null,this),E.onPointerObservable.hasObservers()&&E.onPointerObservable.notifyObservers(I,Z)}_isPointerSwiping(){return this._isSwiping}simulatePointerUp(p,_,E){const I=new PointerEvent("pointerup",_);I.inputIndex=wr.Move;const Z=new rb;E?Z.doubleClick=!0:Z.singleClick=!0,!this._checkPrePointerObservable(p,I,zr.POINTERUP)&&this._processPointerUp(p,I,Z)}_processPointerUp(p,_,E){const I=this._scene;if(p?.pickedMesh){if(this._pickedUpMesh=p.pickedMesh,this._pickedDownMesh===this._pickedUpMesh&&(I.onPointerPick&&I.onPointerPick(_,p),E.singleClick&&!E.ignore&&I.onPointerObservable.observers.length>this._cameraObserverCount)){const re=zr.POINTERPICK,ae=new jl(re,_,p);this._setRayOnPointerInfo(p,_),I.onPointerObservable.notifyObservers(ae,re)}const Z=p.pickedMesh._getActionManagerForTrigger();if(Z&&!E.ignore){Z.processTrigger(7,q0.CreateNew(p.pickedMesh,_,p)),!E.hasSwiped&&E.singleClick&&Z.processTrigger(1,q0.CreateNew(p.pickedMesh,_,p));const re=p.pickedMesh._getActionManagerForTrigger(6);E.doubleClick&&re&&re.processTrigger(6,q0.CreateNew(p.pickedMesh,_,p))}}else if(!E.ignore)for(const Z of I._pointerUpStage)p=Z.action(this._unTranslatedPointerX,this._unTranslatedPointerY,p,_,E.doubleClick);if(this._pickedDownMesh&&this._pickedDownMesh!==this._pickedUpMesh){const Z=this._pickedDownMesh._getActionManagerForTrigger(16);Z&&Z.processTrigger(16,q0.CreateNew(this._pickedDownMesh,_))}if(!E.ignore){const Z=new jl(zr.POINTERUP,_,p);if(this._setRayOnPointerInfo(p,_),I.onPointerObservable.notifyObservers(Z,zr.POINTERUP),I.onPointerUp&&I.onPointerUp(_,p,zr.POINTERUP),!E.hasSwiped&&!this._skipPointerTap&&!this._isMultiTouchGesture){let re=0;if(E.singleClick?re=zr.POINTERTAP:E.doubleClick&&(re=zr.POINTERDOUBLETAP),re){const ae=new jl(re,_,p);I.onPointerObservable.hasObservers()&&I.onPointerObservable.hasSpecificMask(re)&&I.onPointerObservable.notifyObservers(ae,re)}}}}isPointerCaptured(p=0){return this._pointerCaptures[p]}attachControl(p=!0,_=!0,E=!0,I=null){const Z=this._scene,re=Z.getEngine();I||(I=re.getInputElement()),this._alreadyAttached&&this.detachControl(),I&&(this._alreadyAttachedTo=I),this._deviceSourceManager=new YM(re),this._initActionManager=ae=>{if(!this._meshPickProceed){const he=Z.skipPointerUpPicking||Z._registeredActions===0&&!this._checkForPicking()&&!Z.onPointerUp?null:Z.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,Z.pointerUpPredicate,Z.pointerUpFastCheck,Z.cameraToUseForPointers);this._currentPickResult=he,he&&(ae=he.hit&&he.pickedMesh?he.pickedMesh._getActionManagerForTrigger():null),this._meshPickProceed=!0}return ae},this._delayedSimpleClick=(ae,he,_e)=>{if((Date.now()-this._previousStartingPointerTime>ja.DoubleClickDelay&&!this._doubleClickOccured||ae!==this._previousButtonPressed)&&(this._doubleClickOccured=!1,he.singleClick=!0,he.ignore=!1,this._delayedClicks[ae])){const ve=this._delayedClicks[ae].evt,Le=zr.POINTERTAP,ze=new jl(Le,ve,this._currentPickResult);Z.onPointerObservable.hasObservers()&&Z.onPointerObservable.hasSpecificMask(Le)&&Z.onPointerObservable.notifyObservers(ze,Le),this._delayedClicks[ae]=null}},this._initClickEvent=(ae,he,_e,ve)=>{const Le=new rb;this._currentPickResult=null;let ze=null,He=ae.hasSpecificMask(zr.POINTERPICK)||he.hasSpecificMask(zr.POINTERPICK)||ae.hasSpecificMask(zr.POINTERTAP)||he.hasSpecificMask(zr.POINTERTAP)||ae.hasSpecificMask(zr.POINTERDOUBLETAP)||he.hasSpecificMask(zr.POINTERDOUBLETAP);!He&&Uo&&(ze=this._initActionManager(ze,Le),ze&&(He=ze.hasPickTriggers));let xt=!1;if(He){const rt=_e.button;if(Le.hasSwiped=this._isPointerSwiping(),!Le.hasSwiped){let Tt=!ja.ExclusiveDoubleClickMode;if(Tt||(Tt=!ae.hasSpecificMask(zr.POINTERDOUBLETAP)&&!he.hasSpecificMask(zr.POINTERDOUBLETAP),Tt&&!Uo.HasSpecificTrigger(6)&&(ze=this._initActionManager(ze,Le),ze&&(Tt=!ze.hasSpecificTrigger(6)))),Tt)(Date.now()-this._previousStartingPointerTime>ja.DoubleClickDelay||rt!==this._previousButtonPressed)&&(Le.singleClick=!0,ve(Le,this._currentPickResult),xt=!0);else{const Nt={evt:_e,clickInfo:Le,timeoutId:window.setTimeout(this._delayedSimpleClick.bind(this,rt,Le,ve),ja.DoubleClickDelay)};this._delayedClicks[rt]=Nt}let Lt=ae.hasSpecificMask(zr.POINTERDOUBLETAP)||he.hasSpecificMask(zr.POINTERDOUBLETAP);!Lt&&Uo.HasSpecificTrigger(6)&&(ze=this._initActionManager(ze,Le),ze&&(Lt=ze.hasSpecificTrigger(6))),Lt&&(rt===this._previousButtonPressed&&Date.now()-this._previousStartingPointerTime<ja.DoubleClickDelay&&!this._doubleClickOccured?(!Le.hasSwiped&&!this._isPointerSwiping()?(this._previousStartingPointerTime=0,this._doubleClickOccured=!0,Le.doubleClick=!0,Le.ignore=!1,ja.ExclusiveDoubleClickMode&&this._delayedClicks[rt]&&(clearTimeout(this._delayedClicks[rt]?.timeoutId),this._delayedClicks[rt]=null),ve(Le,this._currentPickResult)):(this._doubleClickOccured=!1,this._previousStartingPointerTime=this._startingPointerTime,this._previousStartingPointerPosition.x=this._startingPointerPosition.x,this._previousStartingPointerPosition.y=this._startingPointerPosition.y,this._previousButtonPressed=rt,ja.ExclusiveDoubleClickMode?(this._delayedClicks[rt]&&(clearTimeout(this._delayedClicks[rt]?.timeoutId),this._delayedClicks[rt]=null),ve(Le,this._previousPickResult)):ve(Le,this._currentPickResult)),xt=!0):(this._doubleClickOccured=!1,this._previousStartingPointerTime=this._startingPointerTime,this._previousStartingPointerPosition.x=this._startingPointerPosition.x,this._previousStartingPointerPosition.y=this._startingPointerPosition.y,this._previousButtonPressed=rt))}}xt||ve(Le,this._currentPickResult)},this._onPointerMove=ae=>{if(this._updatePointerPosition(ae),!this._isSwiping&&this._swipeButtonPressed!==-1&&(this._isSwiping=Math.abs(this._startingPointerPosition.x-this._pointerX)>ja.DragMovementThreshold||Math.abs(this._startingPointerPosition.y-this._pointerY)>ja.DragMovementThreshold),re.isPointerLock&&re._verifyPointerLock(),this._checkPrePointerObservable(null,ae,ae.inputIndex>=wr.MouseWheelX&&ae.inputIndex<=wr.MouseWheelZ?zr.POINTERWHEEL:zr.POINTERMOVE)||!Z.cameraToUseForPointers&&!Z.activeCamera)return;if(Z.skipPointerMovePicking){this._processPointerMove(new Wp,ae);return}Z.pointerMovePredicate||(Z.pointerMovePredicate=_e=>_e.isPickable&&_e.isVisible&&_e.isReady()&&_e.isEnabled()&&(_e.enablePointerMoveEvents||Z.constantlyUpdateMeshUnderPointer||_e._getActionManagerForTrigger()!==null)&&(!Z.cameraToUseForPointers||(Z.cameraToUseForPointers.layerMask&_e.layerMask)!==0));const he=Z._registeredActions>0||Z.constantlyUpdateMeshUnderPointer?this._pickMove(ae):null;this._processPointerMove(he,ae)},this._onPointerDown=ae=>{if(this._totalPointersPressed++,this._pickedDownMesh=null,this._meshPickProceed=!1,ja.ExclusiveDoubleClickMode){for(let _e=0;_e<this._delayedClicks.length;_e++)if(this._delayedClicks[_e])if(ae.button===_e)clearTimeout(this._delayedClicks[_e]?.timeoutId);else{const ve=this._delayedClicks[_e].clickInfo;this._doubleClickOccured=!1,ve.singleClick=!0,ve.ignore=!1;const Le=this._delayedClicks[_e].evt,ze=zr.POINTERTAP,He=new jl(ze,Le,this._currentPickResult);Z.onPointerObservable.hasObservers()&&Z.onPointerObservable.hasSpecificMask(ze)&&Z.onPointerObservable.notifyObservers(He,ze),this._delayedClicks[_e]=null}}if(this._updatePointerPosition(ae),this._swipeButtonPressed===-1&&(this._swipeButtonPressed=ae.button),Z.preventDefaultOnPointerDown&&I&&(ae.preventDefault(),I.focus()),this._startingPointerPosition.x=this._pointerX,this._startingPointerPosition.y=this._pointerY,this._startingPointerTime=Date.now(),this._checkPrePointerObservable(null,ae,zr.POINTERDOWN)||!Z.cameraToUseForPointers&&!Z.activeCamera)return;this._pointerCaptures[ae.pointerId]=!0,Z.pointerDownPredicate||(Z.pointerDownPredicate=_e=>_e.isPickable&&_e.isVisible&&_e.isReady()&&_e.isEnabled()&&(!Z.cameraToUseForPointers||(Z.cameraToUseForPointers.layerMask&_e.layerMask)!==0)),this._pickedDownMesh=null;let he;Z.skipPointerDownPicking||Z._registeredActions===0&&!this._checkForPicking()&&!Z.onPointerDown?he=new Wp:he=Z.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,Z.pointerDownPredicate,Z.pointerDownFastCheck,Z.cameraToUseForPointers),this._processPointerDown(he,ae)},this._onPointerUp=ae=>{this._totalPointersPressed!==0&&(this._totalPointersPressed--,this._pickedUpMesh=null,this._meshPickProceed=!1,this._updatePointerPosition(ae),Z.preventDefaultOnPointerUp&&I&&(ae.preventDefault(),I.focus()),this._initClickEvent(Z.onPrePointerObservable,Z.onPointerObservable,ae,(he,_e)=>{if(Z.onPrePointerObservable.hasObservers()&&(this._skipPointerTap=!1,!he.ignore)){if(this._checkPrePointerObservable(null,ae,zr.POINTERUP)){this._swipeButtonPressed===ae.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1),ae.buttons===0&&(this._pointerCaptures[ae.pointerId]=!1);return}he.hasSwiped||(he.singleClick&&Z.onPrePointerObservable.hasSpecificMask(zr.POINTERTAP)&&this._checkPrePointerObservable(null,ae,zr.POINTERTAP)&&(this._skipPointerTap=!0),he.doubleClick&&Z.onPrePointerObservable.hasSpecificMask(zr.POINTERDOUBLETAP)&&this._checkPrePointerObservable(null,ae,zr.POINTERDOUBLETAP)&&(this._skipPointerTap=!0))}if(!this._pointerCaptures[ae.pointerId]){this._swipeButtonPressed===ae.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1);return}ae.buttons===0&&(this._pointerCaptures[ae.pointerId]=!1),!(!Z.cameraToUseForPointers&&!Z.activeCamera)&&(Z.pointerUpPredicate||(Z.pointerUpPredicate=ve=>ve.isPickable&&ve.isVisible&&ve.isReady()&&ve.isEnabled()&&(!Z.cameraToUseForPointers||(Z.cameraToUseForPointers.layerMask&ve.layerMask)!==0)),!this._meshPickProceed&&(Uo&&Uo.HasTriggers||this._checkForPicking()||Z.onPointerUp)&&this._initActionManager(null,he),_e||(_e=this._currentPickResult),this._processPointerUp(_e,ae,he),this._previousPickResult=this._currentPickResult,this._swipeButtonPressed===ae.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1))}))},this._onKeyDown=ae=>{const he=lu.KEYDOWN;if(Z.onPreKeyboardObservable.hasObservers()){const _e=new zy(he,ae);if(Z.onPreKeyboardObservable.notifyObservers(_e,he),_e.skipOnKeyboardObservable)return}if(Z.onKeyboardObservable.hasObservers()){const _e=new Wg(he,ae);Z.onKeyboardObservable.notifyObservers(_e,he)}Z.actionManager&&Z.actionManager.processTrigger(14,q0.CreateNewFromScene(Z,ae))},this._onKeyUp=ae=>{const he=lu.KEYUP;if(Z.onPreKeyboardObservable.hasObservers()){const _e=new zy(he,ae);if(Z.onPreKeyboardObservable.notifyObservers(_e,he),_e.skipOnKeyboardObservable)return}if(Z.onKeyboardObservable.hasObservers()){const _e=new Wg(he,ae);Z.onKeyboardObservable.notifyObservers(_e,he)}Z.actionManager&&Z.actionManager.processTrigger(15,q0.CreateNewFromScene(Z,ae))},this._deviceSourceManager.onDeviceConnectedObservable.add(ae=>{ae.deviceType===rr.Mouse?ae.onInputChangedObservable.add(he=>{he.inputIndex===wr.LeftClick||he.inputIndex===wr.MiddleClick||he.inputIndex===wr.RightClick||he.inputIndex===wr.BrowserBack||he.inputIndex===wr.BrowserForward?_&&ae.getInput(he.inputIndex)===1?this._onPointerDown(he):p&&ae.getInput(he.inputIndex)===0&&this._onPointerUp(he):E&&(he.inputIndex===wr.Move?this._onPointerMove(he):(he.inputIndex===wr.MouseWheelX||he.inputIndex===wr.MouseWheelY||he.inputIndex===wr.MouseWheelZ)&&this._onPointerMove(he))}):ae.deviceType===rr.Touch?ae.onInputChangedObservable.add(he=>{he.inputIndex===wr.LeftClick&&(_&&ae.getInput(he.inputIndex)===1?(this._onPointerDown(he),this._totalPointersPressed>1&&(this._isMultiTouchGesture=!0)):p&&ae.getInput(he.inputIndex)===0&&(this._onPointerUp(he),this._totalPointersPressed===0&&(this._isMultiTouchGesture=!1))),E&&he.inputIndex===wr.Move&&this._onPointerMove(he)}):ae.deviceType===rr.Keyboard&&ae.onInputChangedObservable.add(he=>{he.type==="keydown"?this._onKeyDown(he):he.type==="keyup"&&this._onKeyUp(he)})}),this._alreadyAttached=!0}detachControl(){this._alreadyAttached&&(this._deviceSourceManager.dispose(),this._deviceSourceManager=null,this._alreadyAttachedTo&&!this._scene.doNotHandleCursors&&(this._alreadyAttachedTo.style.cursor=this._scene.defaultCursor),this._alreadyAttached=!1,this._alreadyAttachedTo=null)}setPointerOverMesh(p,_=0,E,I){if(this._meshUnderPointerId[_]===p&&(!p||!p._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting))return;const Z=this._meshUnderPointerId[_];let re;Z&&(re=Z._getActionManagerForTrigger(10),re&&re.processTrigger(10,q0.CreateNew(Z,I,{pointerId:_}))),p?(this._meshUnderPointerId[_]=p,this._pointerOverMesh=p,re=p._getActionManagerForTrigger(9),re&&re.processTrigger(9,q0.CreateNew(p,I,{pointerId:_,pickResult:E}))):(delete this._meshUnderPointerId[_],this._pointerOverMesh=null)}getPointerOverMesh(){return this.meshUnderPointer}_invalidateMesh(p){this._pointerOverMesh===p&&(this._pointerOverMesh=null),this._pickedDownMesh===p&&(this._pickedDownMesh=null),this._pickedUpMesh===p&&(this._pickedUpMesh=null);for(const _ in this._meshUnderPointerId)this._meshUnderPointerId[_]===p&&delete this._meshUnderPointerId[_]}}ja.DragMovementThreshold=10,ja.LongPressDelay=500,ja.DoubleClickDelay=300,ja.ExclusiveDoubleClickMode=!1;class r2{constructor(p,_,E,I){this.normal=new at(p,_,E),this.d=I}asArray(){return[this.normal.x,this.normal.y,this.normal.z,this.d]}clone(){return new r2(this.normal.x,this.normal.y,this.normal.z,this.d)}getClassName(){return"Plane"}getHashCode(){let p=this.normal.getHashCode();return p=p*397^(this.d|0),p}normalize(){const p=Math.sqrt(this.normal.x*this.normal.x+this.normal.y*this.normal.y+this.normal.z*this.normal.z);let _=0;return p!==0&&(_=1/p),this.normal.x*=_,this.normal.y*=_,this.normal.z*=_,this.d*=_,this}transform(p){const _=r2._TmpMatrix;p.invertToRef(_);const E=_.m,I=this.normal.x,Z=this.normal.y,re=this.normal.z,ae=this.d,he=I*E[0]+Z*E[1]+re*E[2]+ae*E[3],_e=I*E[4]+Z*E[5]+re*E[6]+ae*E[7],ve=I*E[8]+Z*E[9]+re*E[10]+ae*E[11],Le=I*E[12]+Z*E[13]+re*E[14]+ae*E[15];return new r2(he,_e,ve,Le)}dotCoordinate(p){return this.normal.x*p.x+this.normal.y*p.y+this.normal.z*p.z+this.d}copyFromPoints(p,_,E){const I=_.x-p.x,Z=_.y-p.y,re=_.z-p.z,ae=E.x-p.x,he=E.y-p.y,_e=E.z-p.z,ve=Z*_e-re*he,Le=re*ae-I*_e,ze=I*he-Z*ae,He=Math.sqrt(ve*ve+Le*Le+ze*ze);let xt;return He!==0?xt=1/He:xt=0,this.normal.x=ve*xt,this.normal.y=Le*xt,this.normal.z=ze*xt,this.d=-(this.normal.x*p.x+this.normal.y*p.y+this.normal.z*p.z),this}isFrontFacingTo(p,_){return at.Dot(this.normal,p)<=_}signedDistanceTo(p){return at.Dot(p,this.normal)+this.d}static FromArray(p){return new r2(p[0],p[1],p[2],p[3])}static FromPoints(p,_,E){const I=new r2(0,0,0,0);return I.copyFromPoints(p,_,E),I}static FromPositionAndNormal(p,_){const E=new r2(0,0,0,0);return this.FromPositionAndNormalToRef(p,_,E)}static FromPositionAndNormalToRef(p,_,E){return E.normal.copyFrom(_),E.normal.normalize(),E.d=-p.dot(E.normal),E}static SignedDistanceToPlaneFromPositionAndNormal(p,_,E){const I=-(_.x*p.x+_.y*p.y+_.z*p.z);return at.Dot(E,_)+I}}r2._TmpMatrix=jt.Identity();class n2{static GetPlanes(p){const _=[];for(let E=0;E<6;E++)_.push(new r2(0,0,0,0));return n2.GetPlanesToRef(p,_),_}static GetNearPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]+E[2],_.normal.y=E[7]+E[6],_.normal.z=E[11]+E[10],_.d=E[15]+E[14],_.normalize()}static GetFarPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]-E[2],_.normal.y=E[7]-E[6],_.normal.z=E[11]-E[10],_.d=E[15]-E[14],_.normalize()}static GetLeftPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]+E[0],_.normal.y=E[7]+E[4],_.normal.z=E[11]+E[8],_.d=E[15]+E[12],_.normalize()}static GetRightPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]-E[0],_.normal.y=E[7]-E[4],_.normal.z=E[11]-E[8],_.d=E[15]-E[12],_.normalize()}static GetTopPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]-E[1],_.normal.y=E[7]-E[5],_.normal.z=E[11]-E[9],_.d=E[15]-E[13],_.normalize()}static GetBottomPlaneToRef(p,_){const E=p.m;_.normal.x=E[3]+E[1],_.normal.y=E[7]+E[5],_.normal.z=E[11]+E[9],_.d=E[15]+E[13],_.normalize()}static GetPlanesToRef(p,_){n2.GetNearPlaneToRef(p,_[0]),n2.GetFarPlaneToRef(p,_[1]),n2.GetLeftPlaneToRef(p,_[2]),n2.GetRightPlaneToRef(p,_[3]),n2.GetTopPlaneToRef(p,_[4]),n2.GetBottomPlaneToRef(p,_[5])}static IsPointInFrustum(p,_){for(let E=0;E<6;E++)if(_[E].dotCoordinate(p)<0)return!1;return!0}}class nb{static get UniqueId(){const p=this._UniqueIdCounter;return this._UniqueIdCounter++,p}}nb._UniqueIdCounter=1;class Kn{static CompareLightsPriority(p,_){return p.shadowEnabled!==_.shadowEnabled?(_.shadowEnabled?1:0)-(p.shadowEnabled?1:0):_.renderPriority-p.renderPriority}}Kn.FALLOFF_DEFAULT=0,Kn.FALLOFF_PHYSICAL=1,Kn.FALLOFF_GLTF=2,Kn.FALLOFF_STANDARD=3,Kn.LIGHTMAP_DEFAULT=0,Kn.LIGHTMAP_SPECULAR=1,Kn.LIGHTMAP_SHADOWSONLY=2,Kn.INTENSITYMODE_AUTOMATIC=0,Kn.INTENSITYMODE_LUMINOUSPOWER=1,Kn.INTENSITYMODE_LUMINOUSINTENSITY=2,Kn.INTENSITYMODE_ILLUMINANCE=3,Kn.INTENSITYMODE_LUMINANCE=4,Kn.LIGHTTYPEID_POINTLIGHT=0,Kn.LIGHTTYPEID_DIRECTIONALLIGHT=1,Kn.LIGHTTYPEID_SPOTLIGHT=2,Kn.LIGHTTYPEID_HEMISPHERICLIGHT=3;class KM{constructor(){this.pointerDownFastCheck=!1,this.pointerUpFastCheck=!1,this.pointerMoveFastCheck=!1,this.skipPointerMovePicking=!1,this.skipPointerDownPicking=!1,this.skipPointerUpPicking=!1}}var _l;(function(pe){pe[pe.BackwardCompatible=0]="BackwardCompatible",pe[pe.Intermediate=1]="Intermediate",pe[pe.Aggressive=2]="Aggressive"})(_l||(_l={}));class U0 extends wo{static DefaultMaterialFactory(p){throw ur("StandardMaterial")}static CollisionCoordinatorFactory(){throw ur("DefaultCollisionCoordinator")}get environmentTexture(){return this._environmentTexture}set environmentTexture(p){this._environmentTexture!==p&&(this._environmentTexture=p,this.markAllMaterialsAsDirty(1))}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}get performancePriority(){return this._performancePriority}set performancePriority(p){if(p!==this._performancePriority){switch(this._performancePriority=p,p){case _l.BackwardCompatible:this.skipFrustumClipping=!1,this._renderingManager.maintainStateBetweenFrames=!1,this.skipPointerMovePicking=!1,this.autoClear=!0;break;case _l.Intermediate:this.skipFrustumClipping=!1,this._renderingManager.maintainStateBetweenFrames=!1,this.skipPointerMovePicking=!0,this.autoClear=!1;break;case _l.Aggressive:this.skipFrustumClipping=!0,this._renderingManager.maintainStateBetweenFrames=!0,this.skipPointerMovePicking=!0,this.autoClear=!1;break}this.onScenePerformancePriorityChangedObservable.notifyObservers(p)}}set forceWireframe(p){this._forceWireframe!==p&&(this._forceWireframe=p,this.markAllMaterialsAsDirty(16))}get forceWireframe(){return this._forceWireframe}set skipFrustumClipping(p){this._skipFrustumClipping!==p&&(this._skipFrustumClipping=p)}get skipFrustumClipping(){return this._skipFrustumClipping}set forcePointsCloud(p){this._forcePointsCloud!==p&&(this._forcePointsCloud=p,this.markAllMaterialsAsDirty(16))}get forcePointsCloud(){return this._forcePointsCloud}get animationPropertiesOverride(){return this._animationPropertiesOverride}set animationPropertiesOverride(p){this._animationPropertiesOverride=p}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}set beforeRender(p){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),p&&(this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(p))}set afterRender(p){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),p&&(this._onAfterRenderObserver=this.onAfterRenderObservable.add(p))}set beforeCameraRender(p){this._onBeforeCameraRenderObserver&&this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver),this._onBeforeCameraRenderObserver=this.onBeforeCameraRenderObservable.add(p)}set afterCameraRender(p){this._onAfterCameraRenderObserver&&this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver),this._onAfterCameraRenderObserver=this.onAfterCameraRenderObservable.add(p)}get pointerDownPredicate(){return this._pointerPickingConfiguration.pointerDownPredicate}set pointerDownPredicate(p){this._pointerPickingConfiguration.pointerDownPredicate=p}get pointerUpPredicate(){return this._pointerPickingConfiguration.pointerUpPredicate}set pointerUpPredicate(p){this._pointerPickingConfiguration.pointerUpPredicate=p}get pointerMovePredicate(){return this._pointerPickingConfiguration.pointerMovePredicate}set pointerMovePredicate(p){this._pointerPickingConfiguration.pointerMovePredicate=p}get pointerDownFastCheck(){return this._pointerPickingConfiguration.pointerDownFastCheck}set pointerDownFastCheck(p){this._pointerPickingConfiguration.pointerDownFastCheck=p}get pointerUpFastCheck(){return this._pointerPickingConfiguration.pointerUpFastCheck}set pointerUpFastCheck(p){this._pointerPickingConfiguration.pointerUpFastCheck=p}get pointerMoveFastCheck(){return this._pointerPickingConfiguration.pointerMoveFastCheck}set pointerMoveFastCheck(p){this._pointerPickingConfiguration.pointerMoveFastCheck=p}get skipPointerMovePicking(){return this._pointerPickingConfiguration.skipPointerMovePicking}set skipPointerMovePicking(p){this._pointerPickingConfiguration.skipPointerMovePicking=p}get skipPointerDownPicking(){return this._pointerPickingConfiguration.skipPointerDownPicking}set skipPointerDownPicking(p){this._pointerPickingConfiguration.skipPointerDownPicking=p}get skipPointerUpPicking(){return this._pointerPickingConfiguration.skipPointerUpPicking}set skipPointerUpPicking(p){this._pointerPickingConfiguration.skipPointerUpPicking=p}get unTranslatedPointer(){return this._inputManager.unTranslatedPointer}static get DragMovementThreshold(){return ja.DragMovementThreshold}static set DragMovementThreshold(p){ja.DragMovementThreshold=p}static get LongPressDelay(){return ja.LongPressDelay}static set LongPressDelay(p){ja.LongPressDelay=p}static get DoubleClickDelay(){return ja.DoubleClickDelay}static set DoubleClickDelay(p){ja.DoubleClickDelay=p}static get ExclusiveDoubleClickMode(){return ja.ExclusiveDoubleClickMode}static set ExclusiveDoubleClickMode(p){ja.ExclusiveDoubleClickMode=p}bindEyePosition(p,_="vEyePosition",E=!1){const I=this._forcedViewPosition?this._forcedViewPosition:this._mirroredCameraPosition?this._mirroredCameraPosition:this.activeCamera.globalPosition,Z=this.useRightHandedSystem===(this._mirroredCameraPosition!=null);return ui.Vector4[0].set(I.x,I.y,I.z,Z?-1:1),p&&(E?p.setFloat3(_,ui.Vector4[0].x,ui.Vector4[0].y,ui.Vector4[0].z):p.setVector4(_,ui.Vector4[0])),ui.Vector4[0]}finalizeSceneUbo(){const p=this.getSceneUniformBuffer(),_=this.bindEyePosition(null);return p.updateFloat4("vEyePosition",_.x,_.y,_.z,_.w),p.update(),p}set useRightHandedSystem(p){this._useRightHandedSystem!==p&&(this._useRightHandedSystem=p,this.markAllMaterialsAsDirty(16))}get useRightHandedSystem(){return this._useRightHandedSystem}setStepId(p){this._currentStepId=p}getStepId(){return this._currentStepId}getInternalStep(){return this._currentInternalStep}set fogEnabled(p){this._fogEnabled!==p&&(this._fogEnabled=p,this.markAllMaterialsAsDirty(16))}get fogEnabled(){return this._fogEnabled}set fogMode(p){this._fogMode!==p&&(this._fogMode=p,this.markAllMaterialsAsDirty(16))}get fogMode(){return this._fogMode}get prePass(){return!!this.prePassRenderer&&this.prePassRenderer.defaultRT.enabled}set shadowsEnabled(p){this._shadowsEnabled!==p&&(this._shadowsEnabled=p,this.markAllMaterialsAsDirty(2))}get shadowsEnabled(){return this._shadowsEnabled}set lightsEnabled(p){this._lightsEnabled!==p&&(this._lightsEnabled=p,this.markAllMaterialsAsDirty(2))}get lightsEnabled(){return this._lightsEnabled}get activeCameras(){return this._activeCameras}set activeCameras(p){this._unObserveActiveCameras&&(this._unObserveActiveCameras(),this._unObserveActiveCameras=null),p&&(this._unObserveActiveCameras=vn(p,()=>{this.onActiveCamerasChanged.notifyObservers(this)})),this._activeCameras=p}get activeCamera(){return this._activeCamera}set activeCamera(p){p!==this._activeCamera&&(this._activeCamera=p,this.onActiveCameraChanged.notifyObservers(this))}get defaultMaterial(){return this._defaultMaterial||(this._defaultMaterial=U0.DefaultMaterialFactory(this)),this._defaultMaterial}set defaultMaterial(p){this._defaultMaterial=p}set texturesEnabled(p){this._texturesEnabled!==p&&(this._texturesEnabled=p,this.markAllMaterialsAsDirty(1))}get texturesEnabled(){return this._texturesEnabled}set skeletonsEnabled(p){this._skeletonsEnabled!==p&&(this._skeletonsEnabled=p,this.markAllMaterialsAsDirty(8))}get skeletonsEnabled(){return this._skeletonsEnabled}get collisionCoordinator(){return this._collisionCoordinator||(this._collisionCoordinator=U0.CollisionCoordinatorFactory(),this._collisionCoordinator.init(this)),this._collisionCoordinator}get renderingManager(){return this._renderingManager}get frustumPlanes(){return this._frustumPlanes}_registerTransientComponents(){if(this._transientComponents.length>0){for(const p of this._transientComponents)p.register();this._transientComponents.length=0}}_addComponent(p){this._components.push(p),this._transientComponents.push(p);const _=p;_.addFromContainer&&_.serialize&&this._serializableComponents.push(_)}_getComponent(p){for(const _ of this._components)if(_.name===p)return _;return null}constructor(p,_){super(),this._inputManager=new ja(this),this.cameraToUseForPointers=null,this._isScene=!0,this._blockEntityCollection=!1,this.autoClear=!0,this.autoClearDepthAndStencil=!0,this.clearColor=new Tr(.2,.2,.3,1),this.ambientColor=new Rs(0,0,0),this.environmentIntensity=1,this._performancePriority=_l.BackwardCompatible,this.onScenePerformancePriorityChangedObservable=new Ri,this._forceWireframe=!1,this._skipFrustumClipping=!1,this._forcePointsCloud=!1,this.animationsEnabled=!0,this._animationPropertiesOverride=null,this.useConstantAnimationDeltaTime=!1,this.constantlyUpdateMeshUnderPointer=!1,this.hoverCursor="pointer",this.defaultCursor="",this.doNotHandleCursors=!1,this.preventDefaultOnPointerDown=!0,this.preventDefaultOnPointerUp=!0,this.metadata=null,this.reservedDataStore=null,this.disableOfflineSupportExceptionRules=[],this.onDisposeObservable=new Ri,this._onDisposeObserver=null,this.onBeforeRenderObservable=new Ri,this._onBeforeRenderObserver=null,this.onAfterRenderObservable=new Ri,this.onAfterRenderCameraObservable=new Ri,this._onAfterRenderObserver=null,this.onBeforeAnimationsObservable=new Ri,this.onAfterAnimationsObservable=new Ri,this.onBeforeDrawPhaseObservable=new Ri,this.onAfterDrawPhaseObservable=new Ri,this.onReadyObservable=new Ri,this.onBeforeCameraRenderObservable=new Ri,this._onBeforeCameraRenderObserver=null,this.onAfterCameraRenderObservable=new Ri,this._onAfterCameraRenderObserver=null,this.onBeforeActiveMeshesEvaluationObservable=new Ri,this.onAfterActiveMeshesEvaluationObservable=new Ri,this.onBeforeParticlesRenderingObservable=new Ri,this.onAfterParticlesRenderingObservable=new Ri,this.onDataLoadedObservable=new Ri,this.onNewCameraAddedObservable=new Ri,this.onCameraRemovedObservable=new Ri,this.onNewLightAddedObservable=new Ri,this.onLightRemovedObservable=new Ri,this.onNewGeometryAddedObservable=new Ri,this.onGeometryRemovedObservable=new Ri,this.onNewTransformNodeAddedObservable=new Ri,this.onTransformNodeRemovedObservable=new Ri,this.onNewMeshAddedObservable=new Ri,this.onMeshRemovedObservable=new Ri,this.onNewSkeletonAddedObservable=new Ri,this.onSkeletonRemovedObservable=new Ri,this.onNewMaterialAddedObservable=new Ri,this.onNewMultiMaterialAddedObservable=new Ri,this.onMaterialRemovedObservable=new Ri,this.onMultiMaterialRemovedObservable=new Ri,this.onNewTextureAddedObservable=new Ri,this.onTextureRemovedObservable=new Ri,this.onBeforeRenderTargetsRenderObservable=new Ri,this.onAfterRenderTargetsRenderObservable=new Ri,this.onBeforeStepObservable=new Ri,this.onAfterStepObservable=new Ri,this.onActiveCameraChanged=new Ri,this.onActiveCamerasChanged=new Ri,this.onBeforeRenderingGroupObservable=new Ri,this.onAfterRenderingGroupObservable=new Ri,this.onMeshImportedObservable=new Ri,this.onAnimationFileImportedObservable=new Ri,this._registeredForLateAnimationBindings=new _t(256),this._pointerPickingConfiguration=new KM,this.onPrePointerObservable=new Ri,this.onPointerObservable=new Ri,this.onPreKeyboardObservable=new Ri,this.onKeyboardObservable=new Ri,this._useRightHandedSystem=!1,this._timeAccumulator=0,this._currentStepId=0,this._currentInternalStep=0,this._fogEnabled=!0,this._fogMode=U0.FOGMODE_NONE,this.fogColor=new Rs(.2,.2,.3),this.fogDensity=.1,this.fogStart=0,this.fogEnd=1e3,this.needsPreviousWorldMatrices=!1,this._shadowsEnabled=!0,this._lightsEnabled=!0,this._unObserveActiveCameras=null,this._texturesEnabled=!0,this.physicsEnabled=!0,this.particlesEnabled=!0,this.spritesEnabled=!0,this._skeletonsEnabled=!0,this.lensFlaresEnabled=!0,this.collisionsEnabled=!0,this.gravity=new at(0,-9.807,0),this.postProcessesEnabled=!0,this.renderTargetsEnabled=!0,this.dumpNextRenderTargets=!1,this.customRenderTargets=[],this.importedMeshesFiles=[],this.probesEnabled=!0,this._meshesForIntersections=new _t(256),this.proceduralTexturesEnabled=!0,this._totalVertices=new _0,this._activeIndices=new _0,this._activeParticles=new _0,this._activeBones=new _0,this._animationTime=0,this.animationTimeScale=1,this._renderId=0,this._frameId=0,this._executeWhenReadyTimeoutId=null,this._intermediateRendering=!1,this._defaultFrameBufferCleared=!1,this._viewUpdateFlag=-1,this._projectionUpdateFlag=-1,this._toBeDisposed=new Array(256),this._activeRequests=new Array,this._pendingData=new Array,this._isDisposed=!1,this.dispatchAllSubMeshesOfActiveMeshes=!1,this._activeMeshes=new ct(256),this._processedMaterials=new ct(256),this._renderTargets=new _t(256),this._materialsRenderTargets=new _t(256),this._activeParticleSystems=new ct(256),this._activeSkeletons=new _t(32),this._softwareSkinnedMeshes=new _t(32),this._activeAnimatables=new Array,this._transformMatrix=jt.Zero(),this.requireLightSorting=!1,this._components=[],this._serializableComponents=[],this._transientComponents=[],this._beforeCameraUpdateStage=Ka.Create(),this._beforeClearStage=Ka.Create(),this._beforeRenderTargetClearStage=Ka.Create(),this._gatherRenderTargetsStage=Ka.Create(),this._gatherActiveCameraRenderTargetsStage=Ka.Create(),this._isReadyForMeshStage=Ka.Create(),this._beforeEvaluateActiveMeshStage=Ka.Create(),this._evaluateSubMeshStage=Ka.Create(),this._preActiveMeshStage=Ka.Create(),this._cameraDrawRenderTargetStage=Ka.Create(),this._beforeCameraDrawStage=Ka.Create(),this._beforeRenderTargetDrawStage=Ka.Create(),this._beforeRenderingGroupDrawStage=Ka.Create(),this._beforeRenderingMeshStage=Ka.Create(),this._afterRenderingMeshStage=Ka.Create(),this._afterRenderingGroupDrawStage=Ka.Create(),this._afterCameraDrawStage=Ka.Create(),this._afterCameraPostProcessStage=Ka.Create(),this._afterRenderTargetDrawStage=Ka.Create(),this._afterRenderTargetPostProcessStage=Ka.Create(),this._afterRenderStage=Ka.Create(),this._pointerMoveStage=Ka.Create(),this._pointerDownStage=Ka.Create(),this._pointerUpStage=Ka.Create(),this._geometriesByUniqueId=null,this._defaultMeshCandidates={data:[],length:0},this._defaultSubMeshCandidates={data:[],length:0},this._preventFreeActiveMeshesAndRenderingGroups=!1,this._activeMeshesFrozen=!1,this._activeMeshesFrozenButKeepClipping=!1,this._skipEvaluateActiveMeshesCompletely=!1,this._allowPostProcessClearColor=!0,this.getDeterministicFrameTime=()=>this._engine.getTimeStep(),this._registeredActions=0,this._blockMaterialDirtyMechanism=!1,this._perfCollector=null,this.activeCameras=[];const E={useGeometryUniqueIdsMap:!0,useMaterialMeshMap:!0,useClonedMeshMap:!0,virtual:!1,..._};p=this._engine=p||Mr.LastCreatedEngine,E.virtual?p._virtualScenes.push(this):(Mr._LastCreatedScene=this,p.scenes.push(this)),this._uid=null,this._renderingManager=new Tx(this),zg&&(this.postProcessManager=new zg(this)),va()&&this.attachControl(),this._createUbo(),zn&&(this._imageProcessingConfiguration=new zn),this.setDefaultCandidateProviders(),E.useGeometryUniqueIdsMap&&(this._geometriesByUniqueId={}),this.useMaterialMeshMap=E.useMaterialMeshMap,this.useClonedMeshMap=E.useClonedMeshMap,(!_||!_.virtual)&&p.onNewSceneAddedObservable.notifyObservers(this)}getClassName(){return"Scene"}_getDefaultMeshCandidates(){return this._defaultMeshCandidates.data=this.meshes,this._defaultMeshCandidates.length=this.meshes.length,this._defaultMeshCandidates}_getDefaultSubMeshCandidates(p){return this._defaultSubMeshCandidates.data=p.subMeshes,this._defaultSubMeshCandidates.length=p.subMeshes.length,this._defaultSubMeshCandidates}setDefaultCandidateProviders(){this.getActiveMeshCandidates=()=>this._getDefaultMeshCandidates(),this.getActiveSubMeshCandidates=p=>this._getDefaultSubMeshCandidates(p),this.getIntersectingSubMeshCandidates=(p,_)=>this._getDefaultSubMeshCandidates(p),this.getCollidingSubMeshCandidates=(p,_)=>this._getDefaultSubMeshCandidates(p)}get meshUnderPointer(){return this._inputManager.meshUnderPointer}get pointerX(){return this._inputManager.pointerX}set pointerX(p){this._inputManager.pointerX=p}get pointerY(){return this._inputManager.pointerY}set pointerY(p){this._inputManager.pointerY=p}getCachedMaterial(){return this._cachedMaterial}getCachedEffect(){return this._cachedEffect}getCachedVisibility(){return this._cachedVisibility}isCachedMaterialInvalid(p,_,E=1){return this._cachedEffect!==_||this._cachedMaterial!==p||this._cachedVisibility!==E}getEngine(){return this._engine}getTotalVertices(){return this._totalVertices.current}get totalVerticesPerfCounter(){return this._totalVertices}getActiveIndices(){return this._activeIndices.current}get totalActiveIndicesPerfCounter(){return this._activeIndices}getActiveParticles(){return this._activeParticles.current}get activeParticlesPerfCounter(){return this._activeParticles}getActiveBones(){return this._activeBones.current}get activeBonesPerfCounter(){return this._activeBones}getActiveMeshes(){return this._activeMeshes}getAnimationRatio(){return this._animationRatio!==void 0?this._animationRatio:1}getRenderId(){return this._renderId}getFrameId(){return this._frameId}incrementRenderId(){this._renderId++}_createUbo(){this.setSceneUniformBuffer(this.createSceneUniformBuffer())}simulatePointerMove(p,_){return this._inputManager.simulatePointerMove(p,_),this}simulatePointerDown(p,_){return this._inputManager.simulatePointerDown(p,_),this}simulatePointerUp(p,_,E){return this._inputManager.simulatePointerUp(p,_,E),this}isPointerCaptured(p=0){return this._inputManager.isPointerCaptured(p)}attachControl(p=!0,_=!0,E=!0){this._inputManager.attachControl(p,_,E)}detachControl(){this._inputManager.detachControl()}isReady(p=!0){if(this._isDisposed)return!1;let _;const E=this.getEngine(),I=E.currentRenderPassId;E.currentRenderPassId=this.activeCamera?.renderPassId??I;let Z=!0;for(this._pendingData.length>0&&(Z=!1),this.prePassRenderer?.update(),this.useOrderIndependentTransparency&&this.depthPeelingRenderer&&Z&&(Z=this.depthPeelingRenderer.isReady()),p&&(this._processedMaterials.reset(),this._materialsRenderTargets.reset()),_=0;_<this.meshes.length;_++){const re=this.meshes[_];if(!re.subMeshes||re.subMeshes.length===0)continue;if(!re.isReady(!0)){Z=!1;continue}const ae=re.hasThinInstances||re.getClassName()==="InstancedMesh"||re.getClassName()==="InstancedLinesMesh"||E.getCaps().instancedArrays&&re.instances.length>0;for(const _e of this._isReadyForMeshStage)_e.action(re,ae)||(Z=!1);if(!p)continue;const he=re.material||this.defaultMaterial;if(he)if(he._storeEffectOnSubMeshes)for(const _e of re.subMeshes){const ve=_e.getMaterial();ve&&ve.hasRenderTargetTextures&&ve.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(ve)===-1&&(this._processedMaterials.push(ve),this._materialsRenderTargets.concatWithNoDuplicate(ve.getRenderTargetTextures()))}else he.hasRenderTargetTextures&&he.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(he)===-1&&(this._processedMaterials.push(he),this._materialsRenderTargets.concatWithNoDuplicate(he.getRenderTargetTextures()))}if(p)for(_=0;_<this._materialsRenderTargets.length;++_)this._materialsRenderTargets.data[_].isReadyForRendering()||(Z=!1);for(_=0;_<this.geometries.length;_++)this.geometries[_].delayLoadState===2&&(Z=!1);if(this.activeCameras&&this.activeCameras.length>0)for(const re of this.activeCameras)re.isReady(!0)||(Z=!1);else this.activeCamera&&(this.activeCamera.isReady(!0)||(Z=!1));for(const re of this.particleSystems)re.isReady()||(Z=!1);if(this.layers)for(const re of this.layers)re.isReady()||(Z=!1);return E.areAllEffectsReady()||(Z=!1),E.currentRenderPassId=I,Z}resetCachedMaterial(){this._cachedMaterial=null,this._cachedEffect=null,this._cachedVisibility=null}registerBeforeRender(p){this.onBeforeRenderObservable.add(p)}unregisterBeforeRender(p){this.onBeforeRenderObservable.removeCallback(p)}registerAfterRender(p){this.onAfterRenderObservable.add(p)}unregisterAfterRender(p){this.onAfterRenderObservable.removeCallback(p)}_executeOnceBeforeRender(p){const _=()=>{p(),setTimeout(()=>{this.unregisterBeforeRender(_)})};this.registerBeforeRender(_)}executeOnceBeforeRender(p,_){_!==void 0?setTimeout(()=>{this._executeOnceBeforeRender(p)},_):this._executeOnceBeforeRender(p)}addPendingData(p){this._pendingData.push(p)}removePendingData(p){const _=this.isLoading,E=this._pendingData.indexOf(p);E!==-1&&this._pendingData.splice(E,1),_&&!this.isLoading&&this.onDataLoadedObservable.notifyObservers(this)}getWaitingItemsCount(){return this._pendingData.length}get isLoading(){return this._pendingData.length>0}executeWhenReady(p,_=!1){this.onReadyObservable.addOnce(p),this._executeWhenReadyTimeoutId===null&&this._checkIsReady(_)}whenReadyAsync(p=!1){return new Promise(_=>{this.executeWhenReady(()=>{_()},p)})}_checkIsReady(p=!1){if(this._registerTransientComponents(),this.isReady(p)){this.onReadyObservable.notifyObservers(this),this.onReadyObservable.clear(),this._executeWhenReadyTimeoutId=null;return}if(this._isDisposed){this.onReadyObservable.clear(),this._executeWhenReadyTimeoutId=null;return}this._executeWhenReadyTimeoutId=setTimeout(()=>{this.incrementRenderId(),this._checkIsReady(p)},100)}get animatables(){return this._activeAnimatables}resetLastAnimationTimeFrame(){this._animationTimeLast=zx.Now}getViewMatrix(){return this._viewMatrix}getProjectionMatrix(){return this._projectionMatrix}getTransformMatrix(){return this._transformMatrix}setTransformMatrix(p,_,E,I){!E&&!I&&this._multiviewSceneUbo&&(this._multiviewSceneUbo.dispose(),this._multiviewSceneUbo=null),!(this._viewUpdateFlag===p.updateFlag&&this._projectionUpdateFlag===_.updateFlag)&&(this._viewUpdateFlag=p.updateFlag,this._projectionUpdateFlag=_.updateFlag,this._viewMatrix=p,this._projectionMatrix=_,this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix),this._frustumPlanes?n2.GetPlanesToRef(this._transformMatrix,this._frustumPlanes):this._frustumPlanes=n2.GetPlanes(this._transformMatrix),this._multiviewSceneUbo&&this._multiviewSceneUbo.useUbo?this._updateMultiviewUbo(E,I):this._sceneUbo.useUbo&&(this._sceneUbo.updateMatrix("viewProjection",this._transformMatrix),this._sceneUbo.updateMatrix("view",this._viewMatrix),this._sceneUbo.updateMatrix("projection",this._projectionMatrix)))}getSceneUniformBuffer(){return this._multiviewSceneUbo?this._multiviewSceneUbo:this._sceneUbo}createSceneUniformBuffer(p){const _=new qs(this._engine,void 0,!1,p??"scene");return _.addUniform("viewProjection",16),_.addUniform("view",16),_.addUniform("projection",16),_.addUniform("vEyePosition",4),_}setSceneUniformBuffer(p){this._sceneUbo=p,this._viewUpdateFlag=-1,this._projectionUpdateFlag=-1}getUniqueId(){return nb.UniqueId}addMesh(p,_=!1){this._blockEntityCollection||(this.meshes.push(p),p._resyncLightSources(),p.parent||p._addToSceneRootNodes(),this.onNewMeshAddedObservable.notifyObservers(p),_&&p.getChildMeshes().forEach(E=>{this.addMesh(E)}))}removeMesh(p,_=!1){const E=this.meshes.indexOf(p);return E!==-1&&(this.meshes[E]=this.meshes[this.meshes.length-1],this.meshes.pop(),p.parent||p._removeFromSceneRootNodes()),this._inputManager._invalidateMesh(p),this.onMeshRemovedObservable.notifyObservers(p),_&&p.getChildMeshes().forEach(I=>{this.removeMesh(I)}),E}addTransformNode(p){this._blockEntityCollection||p.getScene()===this&&p._indexInSceneTransformNodesArray!==-1||(p._indexInSceneTransformNodesArray=this.transformNodes.length,this.transformNodes.push(p),p.parent||p._addToSceneRootNodes(),this.onNewTransformNodeAddedObservable.notifyObservers(p))}removeTransformNode(p){const _=p._indexInSceneTransformNodesArray;if(_!==-1){if(_!==this.transformNodes.length-1){const E=this.transformNodes[this.transformNodes.length-1];this.transformNodes[_]=E,E._indexInSceneTransformNodesArray=_}p._indexInSceneTransformNodesArray=-1,this.transformNodes.pop(),p.parent||p._removeFromSceneRootNodes()}return this.onTransformNodeRemovedObservable.notifyObservers(p),_}removeSkeleton(p){const _=this.skeletons.indexOf(p);return _!==-1&&(this.skeletons.splice(_,1),this.onSkeletonRemovedObservable.notifyObservers(p),this._executeActiveContainerCleanup(this._activeSkeletons)),_}removeMorphTargetManager(p){const _=this.morphTargetManagers.indexOf(p);return _!==-1&&this.morphTargetManagers.splice(_,1),_}removeLight(p){const _=this.lights.indexOf(p);if(_!==-1){for(const E of this.meshes)E._removeLightSource(p,!1);this.lights.splice(_,1),this.sortLightsByPriority(),p.parent||p._removeFromSceneRootNodes()}return this.onLightRemovedObservable.notifyObservers(p),_}removeCamera(p){const _=this.cameras.indexOf(p);if(_!==-1&&(this.cameras.splice(_,1),p.parent||p._removeFromSceneRootNodes()),this.activeCameras){const E=this.activeCameras.indexOf(p);E!==-1&&this.activeCameras.splice(E,1)}return this.activeCamera===p&&(this.cameras.length>0?this.activeCamera=this.cameras[0]:this.activeCamera=null),this.onCameraRemovedObservable.notifyObservers(p),_}removeParticleSystem(p){const _=this.particleSystems.indexOf(p);return _!==-1&&(this.particleSystems.splice(_,1),this._executeActiveContainerCleanup(this._activeParticleSystems)),_}removeAnimation(p){const _=this.animations.indexOf(p);return _!==-1&&this.animations.splice(_,1),_}stopAnimation(p,_,E){}removeAnimationGroup(p){const _=this.animationGroups.indexOf(p);return _!==-1&&this.animationGroups.splice(_,1),_}removeMultiMaterial(p){const _=this.multiMaterials.indexOf(p);return _!==-1&&this.multiMaterials.splice(_,1),this.onMultiMaterialRemovedObservable.notifyObservers(p),_}removeMaterial(p){const _=p._indexInSceneMaterialArray;if(_!==-1&&_<this.materials.length){if(_!==this.materials.length-1){const E=this.materials[this.materials.length-1];this.materials[_]=E,E._indexInSceneMaterialArray=_}p._indexInSceneMaterialArray=-1,this.materials.pop()}return this.onMaterialRemovedObservable.notifyObservers(p),_}removeActionManager(p){const _=this.actionManagers.indexOf(p);return _!==-1&&this.actionManagers.splice(_,1),_}removeTexture(p){const _=this.textures.indexOf(p);return _!==-1&&this.textures.splice(_,1),this.onTextureRemovedObservable.notifyObservers(p),_}addLight(p){if(!this._blockEntityCollection){this.lights.push(p),this.sortLightsByPriority(),p.parent||p._addToSceneRootNodes();for(const _ of this.meshes)_.lightSources.indexOf(p)===-1&&(_.lightSources.push(p),_._resyncLightSources());this.onNewLightAddedObservable.notifyObservers(p)}}sortLightsByPriority(){this.requireLightSorting&&this.lights.sort(Kn.CompareLightsPriority)}addCamera(p){this._blockEntityCollection||(this.cameras.push(p),this.onNewCameraAddedObservable.notifyObservers(p),p.parent||p._addToSceneRootNodes())}addSkeleton(p){this._blockEntityCollection||(this.skeletons.push(p),this.onNewSkeletonAddedObservable.notifyObservers(p))}addParticleSystem(p){this._blockEntityCollection||this.particleSystems.push(p)}addAnimation(p){this._blockEntityCollection||this.animations.push(p)}addAnimationGroup(p){this._blockEntityCollection||this.animationGroups.push(p)}addMultiMaterial(p){this._blockEntityCollection||(this.multiMaterials.push(p),this.onNewMultiMaterialAddedObservable.notifyObservers(p))}addMaterial(p){this._blockEntityCollection||p.getScene()===this&&p._indexInSceneMaterialArray!==-1||(p._indexInSceneMaterialArray=this.materials.length,this.materials.push(p),this.onNewMaterialAddedObservable.notifyObservers(p))}addMorphTargetManager(p){this._blockEntityCollection||this.morphTargetManagers.push(p)}addGeometry(p){this._blockEntityCollection||(this._geometriesByUniqueId&&(this._geometriesByUniqueId[p.uniqueId]=this.geometries.length),this.geometries.push(p))}addActionManager(p){this.actionManagers.push(p)}addTexture(p){this._blockEntityCollection||(this.textures.push(p),this.onNewTextureAddedObservable.notifyObservers(p))}switchActiveCamera(p,_=!0){this._engine.getInputElement()&&(this.activeCamera&&this.activeCamera.detachControl(),this.activeCamera=p,_&&p.attachControl())}setActiveCameraById(p){const _=this.getCameraById(p);return _?(this.activeCamera=_,_):null}setActiveCameraByName(p){const _=this.getCameraByName(p);return _?(this.activeCamera=_,_):null}getAnimationGroupByName(p){for(let _=0;_<this.animationGroups.length;_++)if(this.animationGroups[_].name===p)return this.animationGroups[_];return null}_getMaterial(p,_){for(let E=0;E<this.materials.length;E++){const I=this.materials[E];if(_(I))return I}if(p)for(let E=0;E<this.multiMaterials.length;E++){const I=this.multiMaterials[E];if(_(I))return I}return null}getMaterialByUniqueID(p,_=!1){return this._getMaterial(_,E=>E.uniqueId===p)}getMaterialById(p,_=!1){return this._getMaterial(_,E=>E.id===p)}getMaterialByName(p,_=!1){return this._getMaterial(_,E=>E.name===p)}getLastMaterialById(p,_=!1){for(let E=this.materials.length-1;E>=0;E--)if(this.materials[E].id===p)return this.materials[E];if(_){for(let E=this.multiMaterials.length-1;E>=0;E--)if(this.multiMaterials[E].id===p)return this.multiMaterials[E]}return null}getTextureByUniqueId(p){for(let _=0;_<this.textures.length;_++)if(this.textures[_].uniqueId===p)return this.textures[_];return null}getTextureByName(p){for(let _=0;_<this.textures.length;_++)if(this.textures[_].name===p)return this.textures[_];return null}getCameraById(p){for(let _=0;_<this.cameras.length;_++)if(this.cameras[_].id===p)return this.cameras[_];return null}getCameraByUniqueId(p){for(let _=0;_<this.cameras.length;_++)if(this.cameras[_].uniqueId===p)return this.cameras[_];return null}getCameraByName(p){for(let _=0;_<this.cameras.length;_++)if(this.cameras[_].name===p)return this.cameras[_];return null}getBoneById(p){for(let _=0;_<this.skeletons.length;_++){const E=this.skeletons[_];for(let I=0;I<E.bones.length;I++)if(E.bones[I].id===p)return E.bones[I]}return null}getBoneByName(p){for(let _=0;_<this.skeletons.length;_++){const E=this.skeletons[_];for(let I=0;I<E.bones.length;I++)if(E.bones[I].name===p)return E.bones[I]}return null}getLightByName(p){for(let _=0;_<this.lights.length;_++)if(this.lights[_].name===p)return this.lights[_];return null}getLightById(p){for(let _=0;_<this.lights.length;_++)if(this.lights[_].id===p)return this.lights[_];return null}getLightByUniqueId(p){for(let _=0;_<this.lights.length;_++)if(this.lights[_].uniqueId===p)return this.lights[_];return null}getParticleSystemById(p){for(let _=0;_<this.particleSystems.length;_++)if(this.particleSystems[_].id===p)return this.particleSystems[_];return null}getGeometryById(p){for(let _=0;_<this.geometries.length;_++)if(this.geometries[_].id===p)return this.geometries[_];return null}_getGeometryByUniqueId(p){if(this._geometriesByUniqueId){const _=this._geometriesByUniqueId[p];if(_!==void 0)return this.geometries[_]}else for(let _=0;_<this.geometries.length;_++)if(this.geometries[_].uniqueId===p)return this.geometries[_];return null}pushGeometry(p,_){return!_&&this._getGeometryByUniqueId(p.uniqueId)?!1:(this.addGeometry(p),this.onNewGeometryAddedObservable.notifyObservers(p),!0)}removeGeometry(p){let _;if(this._geometriesByUniqueId){if(_=this._geometriesByUniqueId[p.uniqueId],_===void 0)return!1}else if(_=this.geometries.indexOf(p),_<0)return!1;if(_!==this.geometries.length-1){const E=this.geometries[this.geometries.length-1];E&&(this.geometries[_]=E,this._geometriesByUniqueId&&(this._geometriesByUniqueId[E.uniqueId]=_))}return this._geometriesByUniqueId&&(this._geometriesByUniqueId[p.uniqueId]=void 0),this.geometries.pop(),this.onGeometryRemovedObservable.notifyObservers(p),!0}getGeometries(){return this.geometries}getMeshById(p){for(let _=0;_<this.meshes.length;_++)if(this.meshes[_].id===p)return this.meshes[_];return null}getMeshesById(p){return this.meshes.filter(function(_){return _.id===p})}getTransformNodeById(p){for(let _=0;_<this.transformNodes.length;_++)if(this.transformNodes[_].id===p)return this.transformNodes[_];return null}getTransformNodeByUniqueId(p){for(let _=0;_<this.transformNodes.length;_++)if(this.transformNodes[_].uniqueId===p)return this.transformNodes[_];return null}getTransformNodesById(p){return this.transformNodes.filter(function(_){return _.id===p})}getMeshByUniqueId(p){for(let _=0;_<this.meshes.length;_++)if(this.meshes[_].uniqueId===p)return this.meshes[_];return null}getLastMeshById(p){for(let _=this.meshes.length-1;_>=0;_--)if(this.meshes[_].id===p)return this.meshes[_];return null}getLastTransformNodeById(p){for(let _=this.transformNodes.length-1;_>=0;_--)if(this.transformNodes[_].id===p)return this.transformNodes[_];return null}getLastEntryById(p){let _;for(_=this.meshes.length-1;_>=0;_--)if(this.meshes[_].id===p)return this.meshes[_];for(_=this.transformNodes.length-1;_>=0;_--)if(this.transformNodes[_].id===p)return this.transformNodes[_];for(_=this.cameras.length-1;_>=0;_--)if(this.cameras[_].id===p)return this.cameras[_];for(_=this.lights.length-1;_>=0;_--)if(this.lights[_].id===p)return this.lights[_];return null}getNodeById(p){const _=this.getMeshById(p);if(_)return _;const E=this.getTransformNodeById(p);if(E)return E;const I=this.getLightById(p);if(I)return I;const Z=this.getCameraById(p);if(Z)return Z;const re=this.getBoneById(p);return re||null}getNodeByName(p){const _=this.getMeshByName(p);if(_)return _;const E=this.getTransformNodeByName(p);if(E)return E;const I=this.getLightByName(p);if(I)return I;const Z=this.getCameraByName(p);if(Z)return Z;const re=this.getBoneByName(p);return re||null}getMeshByName(p){for(let _=0;_<this.meshes.length;_++)if(this.meshes[_].name===p)return this.meshes[_];return null}getTransformNodeByName(p){for(let _=0;_<this.transformNodes.length;_++)if(this.transformNodes[_].name===p)return this.transformNodes[_];return null}getLastSkeletonById(p){for(let _=this.skeletons.length-1;_>=0;_--)if(this.skeletons[_].id===p)return this.skeletons[_];return null}getSkeletonByUniqueId(p){for(let _=0;_<this.skeletons.length;_++)if(this.skeletons[_].uniqueId===p)return this.skeletons[_];return null}getSkeletonById(p){for(let _=0;_<this.skeletons.length;_++)if(this.skeletons[_].id===p)return this.skeletons[_];return null}getSkeletonByName(p){for(let _=0;_<this.skeletons.length;_++)if(this.skeletons[_].name===p)return this.skeletons[_];return null}getMorphTargetManagerById(p){for(let _=0;_<this.morphTargetManagers.length;_++)if(this.morphTargetManagers[_].uniqueId===p)return this.morphTargetManagers[_];return null}getMorphTargetById(p){for(let _=0;_<this.morphTargetManagers.length;++_){const E=this.morphTargetManagers[_];for(let I=0;I<E.numTargets;++I){const Z=E.getTarget(I);if(Z.id===p)return Z}}return null}getMorphTargetByName(p){for(let _=0;_<this.morphTargetManagers.length;++_){const E=this.morphTargetManagers[_];for(let I=0;I<E.numTargets;++I){const Z=E.getTarget(I);if(Z.name===p)return Z}}return null}getPostProcessByName(p){for(let _=0;_<this.postProcesses.length;++_){const E=this.postProcesses[_];if(E.name===p)return E}return null}isActiveMesh(p){return this._activeMeshes.indexOf(p)!==-1}get uid(){return this._uid||(this._uid=lt.RandomId()),this._uid}addExternalData(p,_){return this._externalData||(this._externalData=new kt),this._externalData.add(p,_)}getExternalData(p){return this._externalData?this._externalData.get(p):null}getOrAddExternalDataWithFactory(p,_){return this._externalData||(this._externalData=new kt),this._externalData.getOrAddWithFactory(p,_)}removeExternalData(p){return this._externalData.remove(p)}_evaluateSubMesh(p,_,E,I){if(I||p.isInFrustum(this._frustumPlanes)){for(const re of this._evaluateSubMeshStage)re.action(_,p);const Z=p.getMaterial();Z!=null&&(Z.hasRenderTargetTextures&&Z.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(Z)===-1&&(this._processedMaterials.push(Z),this._materialsRenderTargets.concatWithNoDuplicate(Z.getRenderTargetTextures())),this._renderingManager.dispatch(p,_,Z))}}freeProcessedMaterials(){this._processedMaterials.dispose()}get blockfreeActiveMeshesAndRenderingGroups(){return this._preventFreeActiveMeshesAndRenderingGroups}set blockfreeActiveMeshesAndRenderingGroups(p){this._preventFreeActiveMeshesAndRenderingGroups!==p&&(p&&(this.freeActiveMeshes(),this.freeRenderingGroups()),this._preventFreeActiveMeshesAndRenderingGroups=p)}freeActiveMeshes(){if(!this.blockfreeActiveMeshesAndRenderingGroups&&(this._activeMeshes.dispose(),this.activeCamera&&this.activeCamera._activeMeshes&&this.activeCamera._activeMeshes.dispose(),this.activeCameras))for(let p=0;p<this.activeCameras.length;p++){const _=this.activeCameras[p];_&&_._activeMeshes&&_._activeMeshes.dispose()}}freeRenderingGroups(){if(!this.blockfreeActiveMeshesAndRenderingGroups&&(this._renderingManager&&this._renderingManager.freeRenderingGroups(),this.textures))for(let p=0;p<this.textures.length;p++){const _=this.textures[p];_&&_.renderList&&_.freeRenderingGroups()}}_isInIntermediateRendering(){return this._intermediateRendering}freezeActiveMeshes(p=!1,_,E,I=!0,Z=!1){return this.executeWhenReady(()=>{if(!this.activeCamera){E&&E("No active camera found");return}if(this._frustumPlanes||this.updateTransformMatrix(),this._evaluateActiveMeshes(),this._activeMeshesFrozen=!0,this._activeMeshesFrozenButKeepClipping=Z,this._skipEvaluateActiveMeshesCompletely=p,I)for(let re=0;re<this._activeMeshes.length;re++)this._activeMeshes.data[re]._freeze();_&&_()}),this}unfreezeActiveMeshes(){for(let p=0;p<this.meshes.length;p++){const _=this.meshes[p];_._internalAbstractMeshDataInfo&&(_._internalAbstractMeshDataInfo._isActive=!1)}for(let p=0;p<this._activeMeshes.length;p++)this._activeMeshes.data[p]._unFreeze();return this._activeMeshesFrozen=!1,this}_executeActiveContainerCleanup(p){!(this._engine.snapshotRendering&&this._engine.snapshotRenderingMode===1)&&this._activeMeshesFrozen&&this._activeMeshes.length||this.onBeforeRenderObservable.addOnce(()=>p.dispose())}_evaluateActiveMeshes(){if(this._engine.snapshotRendering&&this._engine.snapshotRenderingMode===1){this._activeMeshes.length>0&&(this.activeCamera?._activeMeshes.reset(),this._activeMeshes.reset(),this._renderingManager.reset(),this._processedMaterials.reset(),this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._softwareSkinnedMeshes.reset());return}if(this._activeMeshesFrozen&&this._activeMeshes.length){if(!this._skipEvaluateActiveMeshesCompletely){const E=this._activeMeshes.length;for(let I=0;I<E;I++)this._activeMeshes.data[I].computeWorldMatrix()}if(this._activeParticleSystems){const E=this._activeParticleSystems.length;for(let I=0;I<E;I++)this._activeParticleSystems.data[I].animate()}this._renderingManager.resetSprites();return}if(!this.activeCamera)return;this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this),this.activeCamera._activeMeshes.reset(),this._activeMeshes.reset(),this._renderingManager.reset(),this._processedMaterials.reset(),this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._softwareSkinnedMeshes.reset(),this._materialsRenderTargets.reset();for(const E of this._beforeEvaluateActiveMeshStage)E.action();const p=this.getActiveMeshCandidates(),_=p.length;for(let E=0;E<_;E++){const I=p.data[E];if(I._internalAbstractMeshDataInfo._currentLODIsUpToDate=!1,I.isBlocked||(this._totalVertices.addCount(I.getTotalVertices(),!1),!I.isReady()||!I.isEnabled()||I.scaling.hasAZeroComponent))continue;I.computeWorldMatrix(),I.actionManager&&I.actionManager.hasSpecificTriggers2(12,13)&&this._meshesForIntersections.pushNoDuplicate(I);let Z=this.customLODSelector?this.customLODSelector(I,this.activeCamera):I.getLOD(this.activeCamera);if(I._internalAbstractMeshDataInfo._currentLOD=Z,I._internalAbstractMeshDataInfo._currentLODIsUpToDate=!0,Z!=null&&(Z!==I&&Z.billboardMode!==0&&Z.computeWorldMatrix(),I._preActivate(),I.isVisible&&I.visibility>0&&I.layerMask&this.activeCamera.layerMask&&(this._skipFrustumClipping||I.alwaysSelectAsActiveMesh||I.isInFrustum(this._frustumPlanes)))){this._activeMeshes.push(I),this.activeCamera._activeMeshes.push(I),Z!==I&&Z._activate(this._renderId,!1);for(const re of this._preActiveMeshStage)re.action(I);I._activate(this._renderId,!1)&&(I.isAnInstance?I._internalAbstractMeshDataInfo._actAsRegularMesh&&(Z=I):Z._internalAbstractMeshDataInfo._onlyForInstances=!1,Z._internalAbstractMeshDataInfo._isActive=!0,this._activeMesh(I,Z)),I._postActivate()}}if(this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this),this.particlesEnabled){this.onBeforeParticlesRenderingObservable.notifyObservers(this);for(let E=0;E<this.particleSystems.length;E++){const I=this.particleSystems[E];if(!I.isStarted()||!I.emitter)continue;const Z=I.emitter;(!Z.position||Z.isEnabled())&&(this._activeParticleSystems.push(I),I.animate(),this._renderingManager.dispatchParticles(I))}this.onAfterParticlesRenderingObservable.notifyObservers(this)}}_activeMesh(p,_){this._skeletonsEnabled&&_.skeleton!==null&&_.skeleton!==void 0&&(this._activeSkeletons.pushNoDuplicate(_.skeleton)&&(_.skeleton.prepare(),this._activeBones.addCount(_.skeleton.bones.length,!1)),_.computeBonesUsingShaders||this._softwareSkinnedMeshes.pushNoDuplicate(_));let E=p.hasInstances||p.isAnInstance||this.dispatchAllSubMeshesOfActiveMeshes||this._skipFrustumClipping||_.alwaysSelectAsActiveMesh;if(_&&_.subMeshes&&_.subMeshes.length>0){const I=this.getActiveSubMeshCandidates(_),Z=I.length;E=E||Z===1;for(let re=0;re<Z;re++){const ae=I.data[re];this._evaluateSubMesh(ae,_,p,E)}}}updateTransformMatrix(p){const _=this.activeCamera;if(_)if(_._renderingMultiview){const E=_._rigCameras[0],I=_._rigCameras[1];this.setTransformMatrix(E.getViewMatrix(),E.getProjectionMatrix(p),I.getViewMatrix(),I.getProjectionMatrix(p))}else this.setTransformMatrix(_.getViewMatrix(),_.getProjectionMatrix(p))}_bindFrameBuffer(p,_=!0){p&&p._multiviewTexture?p._multiviewTexture._bindFrameBuffer():p&&p.outputRenderTarget?p.outputRenderTarget._bindFrameBuffer():this._engine._currentFrameBufferIsDefaultFrameBuffer()||this._engine.restoreDefaultFramebuffer(),_&&this._clearFrameBuffer(p)}_clearFrameBuffer(p){if(!(p&&p._multiviewTexture))if(p&&p.outputRenderTarget&&!p._renderingMultiview){const _=p.outputRenderTarget;_.onClearObservable.hasObservers()?_.onClearObservable.notifyObservers(this._engine):_.skipInitialClear||(this.autoClear&&this._engine.clear(_.clearColor||this.clearColor,!_._cleared,!0,!0),_._cleared=!0)}else this._defaultFrameBufferCleared?this._engine.clear(null,!1,!0,!0):(this._defaultFrameBufferCleared=!0,this._clear())}_renderForCamera(p,_,E=!0){if(p&&p._skipRendering)return;const I=this._engine;if(this._activeCamera=p,!this.activeCamera)throw new Error("Active camera not set");if(I.setViewport(this.activeCamera.viewport),this.resetCachedMaterial(),this._renderId++,!this.prePass&&E){let re=!0;p._renderingMultiview&&p.outputRenderTarget&&(re=p.outputRenderTarget.skipInitialClear,this.autoClear&&(this._defaultFrameBufferCleared=!1,p.outputRenderTarget.skipInitialClear=!1)),this._bindFrameBuffer(this._activeCamera),p._renderingMultiview&&p.outputRenderTarget&&(p.outputRenderTarget.skipInitialClear=re)}this.updateTransformMatrix(),this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera),this._evaluateActiveMeshes();for(let re=0;re<this._softwareSkinnedMeshes.length;re++){const ae=this._softwareSkinnedMeshes.data[re];ae.applySkeleton(ae.skeleton)}this.onBeforeRenderTargetsRenderObservable.notifyObservers(this),this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets),p.customRenderTargets&&p.customRenderTargets.length>0&&this._renderTargets.concatWithNoDuplicate(p.customRenderTargets),_&&_.customRenderTargets&&_.customRenderTargets.length>0&&this._renderTargets.concatWithNoDuplicate(_.customRenderTargets),this.environmentTexture&&this.environmentTexture.isRenderTarget&&this._renderTargets.pushNoDuplicate(this.environmentTexture);for(const re of this._gatherActiveCameraRenderTargetsStage)re.action(this._renderTargets);let Z=!1;if(this.renderTargetsEnabled){if(this._intermediateRendering=!0,this._renderTargets.length>0){lt.StartPerformanceCounter("Render targets",this._renderTargets.length>0);for(let re=0;re<this._renderTargets.length;re++){const ae=this._renderTargets.data[re];if(ae._shouldRender()){this._renderId++;const he=ae.activeCamera&&ae.activeCamera!==this.activeCamera;ae.render(he,this.dumpNextRenderTargets),Z=!0}}lt.EndPerformanceCounter("Render targets",this._renderTargets.length>0),this._renderId++}for(const re of this._cameraDrawRenderTargetStage)Z=re.action(this.activeCamera)||Z;this._intermediateRendering=!1}this._engine.currentRenderPassId=p.outputRenderTarget?.renderPassId??p.renderPassId??0,Z&&!this.prePass&&(this._bindFrameBuffer(this._activeCamera,!1),this.updateTransformMatrix()),this.onAfterRenderTargetsRenderObservable.notifyObservers(this),this.postProcessManager&&!p._multiviewTexture&&!this.prePass&&this.postProcessManager._prepareFrame();for(const re of this._beforeCameraDrawStage)re.action(this.activeCamera);this.onBeforeDrawPhaseObservable.notifyObservers(this),I.snapshotRendering&&I.snapshotRenderingMode===1&&this.finalizeSceneUbo(),this._renderingManager.render(null,null,!0,!0),this.onAfterDrawPhaseObservable.notifyObservers(this);for(const re of this._afterCameraDrawStage)re.action(this.activeCamera);if(this.postProcessManager&&!p._multiviewTexture){const re=p.outputRenderTarget?p.outputRenderTarget.renderTarget:void 0;this.postProcessManager._finalizeFrame(p.isIntermediate,re)}for(const re of this._afterCameraPostProcessStage)re.action(this.activeCamera);this._renderTargets.reset(),this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera)}_processSubCameras(p,_=!0){if(p.cameraRigMode===0||p._renderingMultiview){p._renderingMultiview&&!this._multiviewSceneUbo&&this._createMultiviewUbo(),this._renderForCamera(p,void 0,_),this.onAfterRenderCameraObservable.notifyObservers(p);return}if(p._useMultiviewToSingleView)this._renderMultiviewToSingleView(p);else{this.onBeforeCameraRenderObservable.notifyObservers(p);for(let E=0;E<p._rigCameras.length;E++)this._renderForCamera(p._rigCameras[E],p)}this._activeCamera=p,this.updateTransformMatrix(),this.onAfterRenderCameraObservable.notifyObservers(p)}_checkIntersections(){for(let p=0;p<this._meshesForIntersections.length;p++){const _=this._meshesForIntersections.data[p];if(_.actionManager)for(let E=0;_.actionManager&&E<_.actionManager.actions.length;E++){const I=_.actionManager.actions[E];if(I.trigger===12||I.trigger===13){const Z=I.getTriggerParameter(),re=Z.mesh?Z.mesh:Z,ae=re.intersectsMesh(_,Z.usePreciseIntersection),he=_._intersectionsInProgress.indexOf(re);ae&&he===-1?I.trigger===12?(I._executeCurrent(q0.CreateNew(_,void 0,re)),_._intersectionsInProgress.push(re)):I.trigger===13&&_._intersectionsInProgress.push(re):!ae&&he>-1&&(I.trigger===13&&I._executeCurrent(q0.CreateNew(_,void 0,re)),(!_.actionManager.hasSpecificTrigger(13,_e=>{const ve=_e.mesh?_e.mesh:_e;return re===ve})||I.trigger===13)&&_._intersectionsInProgress.splice(he,1))}}}}_advancePhysicsEngineStep(p){}_animate(){}animate(){if(this._engine.isDeterministicLockStep()){let p=Math.max(U0.MinDeltaTime,Math.min(this._engine.getDeltaTime(),U0.MaxDeltaTime))+this._timeAccumulator;const _=this._engine.getTimeStep(),E=1e3/_/1e3;let I=0;const Z=this._engine.getLockstepMaxSteps();let re=Math.floor(p/_);for(re=Math.min(re,Z);p>0&&I<re;)this.onBeforeStepObservable.notifyObservers(this),this._animationRatio=_*E,this._animate(),this.onAfterAnimationsObservable.notifyObservers(this),this.physicsEnabled&&this._advancePhysicsEngineStep(_),this.onAfterStepObservable.notifyObservers(this),this._currentStepId++,I++,p-=_;this._timeAccumulator=p<0?0:p}else{const p=this.useConstantAnimationDeltaTime?16:Math.max(U0.MinDeltaTime,Math.min(this._engine.getDeltaTime(),U0.MaxDeltaTime));this._animationRatio=p*(60/1e3),this._animate(),this.onAfterAnimationsObservable.notifyObservers(this),this.physicsEnabled&&this._advancePhysicsEngineStep(p)}}_clear(){(this.autoClearDepthAndStencil||this.autoClear)&&this._engine.clear(this.clearColor,this.autoClear||this.forceWireframe||this.forcePointsCloud,this.autoClearDepthAndStencil,this.autoClearDepthAndStencil)}_checkCameraRenderTarget(p){if(p?.outputRenderTarget&&!p?.isRigCamera&&(p.outputRenderTarget._cleared=!1),p?.rigCameras?.length)for(let _=0;_<p.rigCameras.length;++_){const E=p.rigCameras[_].outputRenderTarget;E&&(E._cleared=!1)}}resetDrawCache(p){if(this.meshes)for(const _ of this.meshes)_.resetDrawCache(p)}render(p=!0,_=!1){if(this.isDisposed)return;this.onReadyObservable.hasObservers()&&this._executeWhenReadyTimeoutId===null&&this._checkIsReady(),this._frameId++,this._defaultFrameBufferCleared=!1,this._checkCameraRenderTarget(this.activeCamera),this.activeCameras?.length&&this.activeCameras.forEach(this._checkCameraRenderTarget),this._registerTransientComponents(),this._activeParticles.fetchNewFrame(),this._totalVertices.fetchNewFrame(),this._activeIndices.fetchNewFrame(),this._activeBones.fetchNewFrame(),this._meshesForIntersections.reset(),this.resetCachedMaterial(),this.onBeforeAnimationsObservable.notifyObservers(this),this.actionManager&&this.actionManager.processTrigger(11),_||this.animate();for(const Z of this._beforeCameraUpdateStage)Z.action();if(p){if(this.activeCameras&&this.activeCameras.length>0)for(let Z=0;Z<this.activeCameras.length;Z++){const re=this.activeCameras[Z];if(re.update(),re.cameraRigMode!==0)for(let ae=0;ae<re._rigCameras.length;ae++)re._rigCameras[ae].update()}else if(this.activeCamera&&(this.activeCamera.update(),this.activeCamera.cameraRigMode!==0))for(let Z=0;Z<this.activeCamera._rigCameras.length;Z++)this.activeCamera._rigCameras[Z].update()}this.onBeforeRenderObservable.notifyObservers(this);const E=this.getEngine();this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);const I=this.activeCameras?.length?this.activeCameras[0]:this.activeCamera;if(this.renderTargetsEnabled){lt.StartPerformanceCounter("Custom render targets",this.customRenderTargets.length>0),this._intermediateRendering=!0;for(let Z=0;Z<this.customRenderTargets.length;Z++){const re=this.customRenderTargets[Z];if(re._shouldRender()){if(this._renderId++,this.activeCamera=re.activeCamera||this.activeCamera,!this.activeCamera)throw new Error("Active camera not set");E.setViewport(this.activeCamera.viewport),this.updateTransformMatrix(),re.render(I!==this.activeCamera,this.dumpNextRenderTargets)}}lt.EndPerformanceCounter("Custom render targets",this.customRenderTargets.length>0),this._intermediateRendering=!1,this._renderId++}this._engine.currentRenderPassId=I?.renderPassId??0,this.activeCamera=I,this._activeCamera&&this._activeCamera.cameraRigMode!==22&&!this.prePass&&this._bindFrameBuffer(this._activeCamera,!1),this.onAfterRenderTargetsRenderObservable.notifyObservers(this);for(const Z of this._beforeClearStage)Z.action();this._clearFrameBuffer(this.activeCamera);for(const Z of this._gatherRenderTargetsStage)Z.action(this._renderTargets);if(this.activeCameras&&this.activeCameras.length>0)for(let Z=0;Z<this.activeCameras.length;Z++)this._processSubCameras(this.activeCameras[Z],Z>0);else{if(!this.activeCamera)throw new Error("No camera defined");this._processSubCameras(this.activeCamera,!!this.activeCamera.outputRenderTarget)}this._checkIntersections();for(const Z of this._afterRenderStage)Z.action();if(this.afterRender&&this.afterRender(),this.onAfterRenderObservable.notifyObservers(this),this._toBeDisposed.length){for(let Z=0;Z<this._toBeDisposed.length;Z++){const re=this._toBeDisposed[Z];re&&re.dispose()}this._toBeDisposed.length=0}this.dumpNextRenderTargets&&(this.dumpNextRenderTargets=!1),this._activeBones.addCount(0,!0),this._activeIndices.addCount(0,!0),this._activeParticles.addCount(0,!0),this._engine.restoreDefaultFramebuffer()}freezeMaterials(){for(let p=0;p<this.materials.length;p++)this.materials[p].freeze()}unfreezeMaterials(){for(let p=0;p<this.materials.length;p++)this.materials[p].unfreeze()}dispose(){if(this.isDisposed)return;this.beforeRender=null,this.afterRender=null,this.metadata=null,this.skeletons.length=0,this.morphTargetManagers.length=0,this._transientComponents.length=0,this._isReadyForMeshStage.clear(),this._beforeEvaluateActiveMeshStage.clear(),this._evaluateSubMeshStage.clear(),this._preActiveMeshStage.clear(),this._cameraDrawRenderTargetStage.clear(),this._beforeCameraDrawStage.clear(),this._beforeRenderTargetDrawStage.clear(),this._beforeRenderingGroupDrawStage.clear(),this._beforeRenderingMeshStage.clear(),this._afterRenderingMeshStage.clear(),this._afterRenderingGroupDrawStage.clear(),this._afterCameraDrawStage.clear(),this._afterRenderTargetDrawStage.clear(),this._afterRenderStage.clear(),this._beforeCameraUpdateStage.clear(),this._beforeClearStage.clear(),this._gatherRenderTargetsStage.clear(),this._gatherActiveCameraRenderTargetsStage.clear(),this._pointerMoveStage.clear(),this._pointerDownStage.clear(),this._pointerUpStage.clear(),this.importedMeshesFiles=[],this.stopAllAnimations&&(this._activeAnimatables.forEach(Z=>{Z.onAnimationEndObservable.clear(),Z.onAnimationEnd=null}),this.stopAllAnimations()),this.resetCachedMaterial(),this.activeCamera&&(this.activeCamera._activeMeshes.dispose(),this.activeCamera=null),this.activeCameras=null,this._activeMeshes.dispose(),this._renderingManager.dispose(),this._processedMaterials.dispose(),this._activeParticleSystems.dispose(),this._activeSkeletons.dispose(),this._softwareSkinnedMeshes.dispose(),this._renderTargets.dispose(),this._materialsRenderTargets.dispose(),this._registeredForLateAnimationBindings.dispose(),this._meshesForIntersections.dispose(),this._toBeDisposed.length=0;const p=this._activeRequests.slice();for(const Z of p)Z.abort();this._activeRequests.length=0;try{this.onDisposeObservable.notifyObservers(this)}catch(Z){Ti.Error("An error occurred while calling onDisposeObservable!",Z)}if(this.detachControl(),this._engine.getInputElement())for(let Z=0;Z<this.cameras.length;Z++)this.cameras[Z].detachControl();this._disposeList(this.animationGroups),this._disposeList(this.lights),this._disposeList(this.meshes,Z=>Z.dispose(!0)),this._disposeList(this.transformNodes,Z=>Z.dispose(!0));const E=this.cameras;this._disposeList(E),this._defaultMaterial&&this._defaultMaterial.dispose(),this._disposeList(this.multiMaterials),this._disposeList(this.materials),this._disposeList(this.particleSystems),this._disposeList(this.postProcesses),this._disposeList(this.textures),this._disposeList(this.morphTargetManagers),this._sceneUbo.dispose(),this._multiviewSceneUbo&&this._multiviewSceneUbo.dispose(),this.postProcessManager.dispose(),this._disposeList(this._components);let I=this._engine.scenes.indexOf(this);I>-1&&this._engine.scenes.splice(I,1),Mr._LastCreatedScene===this&&(this._engine.scenes.length>0?Mr._LastCreatedScene=this._engine.scenes[this._engine.scenes.length-1]:Mr._LastCreatedScene=null),I=this._engine._virtualScenes.indexOf(this),I>-1&&this._engine._virtualScenes.splice(I,1),this._engine.wipeCaches(!0),this.onDisposeObservable.clear(),this.onBeforeRenderObservable.clear(),this.onAfterRenderObservable.clear(),this.onBeforeRenderTargetsRenderObservable.clear(),this.onAfterRenderTargetsRenderObservable.clear(),this.onAfterStepObservable.clear(),this.onBeforeStepObservable.clear(),this.onBeforeActiveMeshesEvaluationObservable.clear(),this.onAfterActiveMeshesEvaluationObservable.clear(),this.onBeforeParticlesRenderingObservable.clear(),this.onAfterParticlesRenderingObservable.clear(),this.onBeforeDrawPhaseObservable.clear(),this.onAfterDrawPhaseObservable.clear(),this.onBeforeAnimationsObservable.clear(),this.onAfterAnimationsObservable.clear(),this.onDataLoadedObservable.clear(),this.onBeforeRenderingGroupObservable.clear(),this.onAfterRenderingGroupObservable.clear(),this.onMeshImportedObservable.clear(),this.onBeforeCameraRenderObservable.clear(),this.onAfterCameraRenderObservable.clear(),this.onAfterRenderCameraObservable.clear(),this.onReadyObservable.clear(),this.onNewCameraAddedObservable.clear(),this.onCameraRemovedObservable.clear(),this.onNewLightAddedObservable.clear(),this.onLightRemovedObservable.clear(),this.onNewGeometryAddedObservable.clear(),this.onGeometryRemovedObservable.clear(),this.onNewTransformNodeAddedObservable.clear(),this.onTransformNodeRemovedObservable.clear(),this.onNewMeshAddedObservable.clear(),this.onMeshRemovedObservable.clear(),this.onNewSkeletonAddedObservable.clear(),this.onSkeletonRemovedObservable.clear(),this.onNewMaterialAddedObservable.clear(),this.onNewMultiMaterialAddedObservable.clear(),this.onMaterialRemovedObservable.clear(),this.onMultiMaterialRemovedObservable.clear(),this.onNewTextureAddedObservable.clear(),this.onTextureRemovedObservable.clear(),this.onPrePointerObservable.clear(),this.onPointerObservable.clear(),this.onPreKeyboardObservable.clear(),this.onKeyboardObservable.clear(),this.onActiveCameraChanged.clear(),this.onScenePerformancePriorityChangedObservable.clear(),this._isDisposed=!0}_disposeList(p,_){const E=p.slice(0);_=_??(I=>I.dispose());for(const I of E)_(I);p.length=0}get isDisposed(){return this._isDisposed}clearCachedVertexData(){for(let p=0;p<this.meshes.length;p++){const E=this.meshes[p].geometry;E&&E.clearCachedData()}}cleanCachedTextureBuffer(){for(const p of this.textures)p._buffer&&(p._buffer=null)}getWorldExtends(p){const _=new at(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),E=new at(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return p=p||(()=>!0),this.meshes.filter(p).forEach(I=>{if(I.computeWorldMatrix(!0),!I.subMeshes||I.subMeshes.length===0||I.infiniteDistance)return;const Z=I.getBoundingInfo(),re=Z.boundingBox.minimumWorld,ae=Z.boundingBox.maximumWorld;at.CheckExtends(re,_,E),at.CheckExtends(ae,_,E)}),{min:_,max:E}}createPickingRay(p,_,E,I,Z=!1){throw ur("Ray")}createPickingRayToRef(p,_,E,I,Z,re=!1,ae=!1){throw ur("Ray")}createPickingRayInCameraSpace(p,_,E){throw ur("Ray")}createPickingRayInCameraSpaceToRef(p,_,E,I){throw ur("Ray")}get _pickingAvailable(){return!1}pick(p,_,E,I,Z,re){const ae=ur("Ray",!0);return ae&&Ti.Warn(ae),new Wp}pickWithBoundingInfo(p,_,E,I,Z){const re=ur("Ray",!0);return re&&Ti.Warn(re),new Wp}pickWithRay(p,_,E,I){throw ur("Ray")}multiPick(p,_,E,I,Z){throw ur("Ray")}multiPickWithRay(p,_,E){throw ur("Ray")}setPointerOverMesh(p,_,E){this._inputManager.setPointerOverMesh(p,_,E)}getPointerOverMesh(){return this._inputManager.getPointerOverMesh()}_rebuildGeometries(){for(const p of this.geometries)p._rebuild();for(const p of this.meshes)p._rebuild();this.postProcessManager&&this.postProcessManager._rebuild();for(const p of this._components)p.rebuild();for(const p of this.particleSystems)p.rebuild();if(this.spriteManagers)for(const p of this.spriteManagers)p.rebuild()}_rebuildTextures(){for(const p of this.textures)p._rebuild(!0);this.markAllMaterialsAsDirty(1)}_getByTags(p,_,E){if(_===void 0)return p;const I=[];for(const Z in p){const re=p[Z];ri&&ri.MatchesQuery(re,_)&&(!E||E(re))&&I.push(re)}return I}getMeshesByTags(p,_){return this._getByTags(this.meshes,p,_)}getCamerasByTags(p,_){return this._getByTags(this.cameras,p,_)}getLightsByTags(p,_){return this._getByTags(this.lights,p,_)}getMaterialByTags(p,_){return this._getByTags(this.materials,p,_).concat(this._getByTags(this.multiMaterials,p,_))}getTransformNodesByTags(p,_){return this._getByTags(this.transformNodes,p,_)}setRenderingOrder(p,_=null,E=null,I=null){this._renderingManager.setRenderingOrder(p,_,E,I)}setRenderingAutoClearDepthStencil(p,_,E=!0,I=!0){this._renderingManager.setRenderingAutoClearDepthStencil(p,_,E,I)}getAutoClearDepthStencilSetup(p){return this._renderingManager.getAutoClearDepthStencilSetup(p)}_forceBlockMaterialDirtyMechanism(p){this._blockMaterialDirtyMechanism=p}get blockMaterialDirtyMechanism(){return this._blockMaterialDirtyMechanism}set blockMaterialDirtyMechanism(p){this._blockMaterialDirtyMechanism!==p&&(this._blockMaterialDirtyMechanism=p,p||this.markAllMaterialsAsDirty(63))}markAllMaterialsAsDirty(p,_){if(!this._blockMaterialDirtyMechanism)for(const E of this.materials)_&&!_(E)||E.markAsDirty(p)}_loadFile(p,_,E,I,Z,re,ae){const he=lo(p,_,E,I?this.offlineProvider:void 0,Z,re,ae);return this._activeRequests.push(he),he.onCompleteObservable.add(_e=>{this._activeRequests.splice(this._activeRequests.indexOf(_e),1)}),he}_loadFileAsync(p,_,E,I,Z){return new Promise((re,ae)=>{this._loadFile(p,he=>{re(he)},_,E,I,(he,_e)=>{ae(_e)},Z)})}_requestFile(p,_,E,I,Z,re,ae){const he=Yl(p,_,E,I?this.offlineProvider:void 0,Z,re,ae);return this._activeRequests.push(he),he.onCompleteObservable.add(_e=>{this._activeRequests.splice(this._activeRequests.indexOf(_e),1)}),he}_requestFileAsync(p,_,E,I,Z){return new Promise((re,ae)=>{this._requestFile(p,he=>{re(he)},_,E,I,he=>{ae(he)},Z)})}_readFile(p,_,E,I,Z){const re=v2(p,_,E,I,Z);return this._activeRequests.push(re),re.onCompleteObservable.add(ae=>{this._activeRequests.splice(this._activeRequests.indexOf(ae),1)}),re}_readFileAsync(p,_,E){return new Promise((I,Z)=>{this._readFile(p,re=>{I(re)},_,E,re=>{Z(re)})})}getPerfCollector(){throw ur("performanceViewerSceneExtension")}setActiveCameraByID(p){return this.setActiveCameraById(p)}getMaterialByID(p){return this.getMaterialById(p)}getLastMaterialByID(p){return this.getLastMaterialById(p)}getTextureByUniqueID(p){return this.getTextureByUniqueId(p)}getCameraByID(p){return this.getCameraById(p)}getCameraByUniqueID(p){return this.getCameraByUniqueId(p)}getBoneByID(p){return this.getBoneById(p)}getLightByID(p){return this.getLightById(p)}getLightByUniqueID(p){return this.getLightByUniqueId(p)}getParticleSystemByID(p){return this.getParticleSystemById(p)}getGeometryByID(p){return this.getGeometryById(p)}getMeshByID(p){return this.getMeshById(p)}getMeshByUniqueID(p){return this.getMeshByUniqueId(p)}getLastMeshByID(p){return this.getLastMeshById(p)}getMeshesByID(p){return this.getMeshesById(p)}getTransformNodeByID(p){return this.getTransformNodeById(p)}getTransformNodeByUniqueID(p){return this.getTransformNodeByUniqueId(p)}getTransformNodesByID(p){return this.getTransformNodesById(p)}getNodeByID(p){return this.getNodeById(p)}getLastEntryByID(p){return this.getLastEntryById(p)}getLastSkeletonByID(p){return this.getLastSkeletonById(p)}}U0.FOGMODE_NONE=0,U0.FOGMODE_EXP=1,U0.FOGMODE_EXP2=2,U0.FOGMODE_LINEAR=3,U0.MinDeltaTime=1,U0.MaxDeltaTime=1e3;class jM{constructor(){this._doNotSerialize=!1,this._isDisposed=!1,this._sceneRootNodesIndex=-1,this._isEnabled=!0,this._isParentEnabled=!0,this._isReady=!0,this._onEnabledStateChangedObservable=new Ri,this._onClonedObservable=new Ri}}class Ha{static AddNodeConstructor(p,_){this._NodeConstructors[p]=_}static Construct(p,_,E,I){const Z=this._NodeConstructors[p];return Z?Z(_,E,I):null}set accessibilityTag(p){this._accessibilityTag=p,this.onAccessibilityTagChangedObservable.notifyObservers(p)}get accessibilityTag(){return this._accessibilityTag}get doNotSerialize(){return this._nodeDataStorage._doNotSerialize?!0:this._parentNode?this._parentNode.doNotSerialize:!1}set doNotSerialize(p){this._nodeDataStorage._doNotSerialize=p}isDisposed(){return this._nodeDataStorage._isDisposed}set parent(p){if(this._parentNode===p)return;const _=this._parentNode;if(this._parentNode&&this._parentNode._children!==void 0&&this._parentNode._children!==null){const E=this._parentNode._children.indexOf(this);E!==-1&&this._parentNode._children.splice(E,1),!p&&!this._nodeDataStorage._isDisposed&&this._addToSceneRootNodes()}this._parentNode=p,this._parentNode&&((this._parentNode._children===void 0||this._parentNode._children===null)&&(this._parentNode._children=new Array),this._parentNode._children.push(this),_||this._removeFromSceneRootNodes()),this._syncParentEnabledState()}get parent(){return this._parentNode}_serializeAsParent(p){p.parentId=this.uniqueId}_addToSceneRootNodes(){this._nodeDataStorage._sceneRootNodesIndex===-1&&(this._nodeDataStorage._sceneRootNodesIndex=this._scene.rootNodes.length,this._scene.rootNodes.push(this))}_removeFromSceneRootNodes(){if(this._nodeDataStorage._sceneRootNodesIndex!==-1){const p=this._scene.rootNodes,_=p.length-1;p[this._nodeDataStorage._sceneRootNodesIndex]=p[_],p[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex=this._nodeDataStorage._sceneRootNodesIndex,this._scene.rootNodes.pop(),this._nodeDataStorage._sceneRootNodesIndex=-1}}get animationPropertiesOverride(){return this._animationPropertiesOverride?this._animationPropertiesOverride:this._scene.animationPropertiesOverride}set animationPropertiesOverride(p){this._animationPropertiesOverride=p}getClassName(){return"Node"}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}get onEnabledStateChangedObservable(){return this._nodeDataStorage._onEnabledStateChangedObservable}get onClonedObservable(){return this._nodeDataStorage._onClonedObservable}constructor(p,_=null){this._isDirty=!1,this._nodeDataStorage=new jM,this.state="",this.metadata=null,this.reservedDataStore=null,this._accessibilityTag=null,this.onAccessibilityTagChangedObservable=new Ri,this._parentContainer=null,this.animations=[],this._ranges={},this.onReady=null,this._currentRenderId=-1,this._parentUpdateId=-1,this._childUpdateId=-1,this._waitingParentId=null,this._waitingParentInstanceIndex=null,this._waitingParsedUniqueId=null,this._cache={},this._parentNode=null,this._children=null,this._worldMatrix=jt.Identity(),this._worldMatrixDeterminant=0,this._worldMatrixDeterminantIsDirty=!0,this._animationPropertiesOverride=null,this._isNode=!0,this.onDisposeObservable=new Ri,this._onDisposeObserver=null,this._behaviors=new Array,this.name=p,this.id=p,this._scene=_||Mr.LastCreatedScene,this.uniqueId=this._scene.getUniqueId(),this._initCache()}getScene(){return this._scene}getEngine(){return this._scene.getEngine()}addBehavior(p,_=!1){return this._behaviors.indexOf(p)!==-1?this:(p.init(),this._scene.isLoading&&!_?this._scene.onDataLoadedObservable.addOnce(()=>{p.attach(this)}):p.attach(this),this._behaviors.push(p),this)}removeBehavior(p){const _=this._behaviors.indexOf(p);return _===-1?this:(this._behaviors[_].detach(),this._behaviors.splice(_,1),this)}get behaviors(){return this._behaviors}getBehaviorByName(p){for(const _ of this._behaviors)if(_.name===p)return _;return null}getWorldMatrix(){return this._currentRenderId!==this._scene.getRenderId()&&this.computeWorldMatrix(),this._worldMatrix}_getWorldMatrixDeterminant(){return this._worldMatrixDeterminantIsDirty&&(this._worldMatrixDeterminantIsDirty=!1,this._worldMatrixDeterminant=this._worldMatrix.determinant()),this._worldMatrixDeterminant}get worldMatrixFromCache(){return this._worldMatrix}_initCache(){this._cache={},this._cache.parent=void 0}updateCache(p){!p&&this.isSynchronized()||(this._cache.parent=this.parent,this._updateCache())}_getActionManagerForTrigger(p,_=!0){return this.parent?this.parent._getActionManagerForTrigger(p,!1):null}_updateCache(p){}_isSynchronized(){return!0}_markSyncedWithParent(){this._parentNode&&(this._parentUpdateId=this._parentNode._childUpdateId)}isSynchronizedWithParent(){return this._parentNode?this._parentNode._isDirty||this._parentUpdateId!==this._parentNode._childUpdateId?!1:this._parentNode.isSynchronized():!0}isSynchronized(){return this._cache.parent!==this._parentNode?(this._cache.parent=this._parentNode,!1):this._parentNode&&!this.isSynchronizedWithParent()?!1:this._isSynchronized()}isReady(p=!1){return this._nodeDataStorage._isReady}markAsDirty(p){return this._currentRenderId=Number.MAX_VALUE,this._isDirty=!0,this}isEnabled(p=!0){return p===!1?this._nodeDataStorage._isEnabled:this._nodeDataStorage._isEnabled?this._nodeDataStorage._isParentEnabled:!1}_syncParentEnabledState(){this._nodeDataStorage._isParentEnabled=this._parentNode?this._parentNode.isEnabled():!0,this._children&&this._children.forEach(p=>{p._syncParentEnabledState()})}setEnabled(p){this._nodeDataStorage._isEnabled!==p&&(this._nodeDataStorage._isEnabled=p,this._syncParentEnabledState(),this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(p))}isDescendantOf(p){return this.parent?this.parent===p?!0:this.parent.isDescendantOf(p):!1}_getDescendants(p,_=!1,E){if(this._children)for(let I=0;I<this._children.length;I++){const Z=this._children[I];(!E||E(Z))&&p.push(Z),_||Z._getDescendants(p,!1,E)}}getDescendants(p,_){const E=[];return this._getDescendants(E,p,_),E}getChildMeshes(p,_){const E=[];return this._getDescendants(E,p,I=>(!_||_(I))&&I.cullingStrategy!==void 0),E}getChildren(p,_=!0){return this.getDescendants(_,p)}_setReady(p){if(p!==this._nodeDataStorage._isReady){if(!p){this._nodeDataStorage._isReady=!1;return}this.onReady&&this.onReady(this),this._nodeDataStorage._isReady=!0}}getAnimationByName(p){for(let _=0;_<this.animations.length;_++){const E=this.animations[_];if(E.name===p)return E}return null}createAnimationRange(p,_,E){if(!this._ranges[p]){this._ranges[p]=Ha._AnimationRangeFactory(p,_,E);for(let I=0,Z=this.animations.length;I<Z;I++)this.animations[I]&&this.animations[I].createRange(p,_,E)}}deleteAnimationRange(p,_=!0){for(let E=0,I=this.animations.length;E<I;E++)this.animations[E]&&this.animations[E].deleteRange(p,_);this._ranges[p]=null}getAnimationRange(p){return this._ranges[p]||null}clone(p,_,E){const I=Hr.Clone(()=>new Ha(p,this.getScene()),this);if(_&&(I.parent=_),!E){const Z=this.getDescendants(!0);for(let re=0;re<Z.length;re++){const ae=Z[re];ae.clone(p+"."+ae.name,I)}}return I}getAnimationRanges(){const p=[];let _;for(_ in this._ranges)p.push(this._ranges[_]);return p}beginAnimation(p,_,E,I){const Z=this.getAnimationRange(p);return Z?this._scene.beginAnimation(this,Z.from,Z.to,_,E,I):null}serializeAnimationRanges(){const p=[];for(const _ in this._ranges){const E=this._ranges[_];if(!E)continue;const I={};I.name=_,I.from=E.from,I.to=E.to,p.push(I)}return p}computeWorldMatrix(p){return this._worldMatrix||(this._worldMatrix=jt.Identity()),this._worldMatrix}dispose(p,_=!1){if(this._nodeDataStorage._isDisposed=!0,!p){const E=this.getDescendants(!0);for(const I of E)I.dispose(p,_)}this.parent?this.parent=null:this._removeFromSceneRootNodes(),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onEnabledStateChangedObservable.clear(),this.onClonedObservable.clear();for(const E of this._behaviors)E.detach();this._behaviors.length=0,this.metadata=null}static ParseAnimationRanges(p,_,E){if(_.ranges)for(let I=0;I<_.ranges.length;I++){const Z=_.ranges[I];p.createAnimationRange(Z.name,Z.from,Z.to)}}getHierarchyBoundingVectors(p=!0,_=null){this.getScene().incrementRenderId(),this.computeWorldMatrix(!0);let E,I;const Z=this;if(Z.getBoundingInfo&&Z.subMeshes){const re=Z.getBoundingInfo();E=re.boundingBox.minimumWorld.clone(),I=re.boundingBox.maximumWorld.clone()}else E=new at(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),I=new at(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);if(p){const re=this.getDescendants(!1);for(const ae of re){const he=ae;if(he.computeWorldMatrix(!0),_&&!_(he)||!he.getBoundingInfo||he.getTotalVertices()===0)continue;const ve=he.getBoundingInfo().boundingBox,Le=ve.minimumWorld,ze=ve.maximumWorld;at.CheckExtends(Le,E,I),at.CheckExtends(ze,E,I)}}return{min:E,max:I}}}Ha._AnimationRangeFactory=(pe,p,_)=>{throw ur("AnimationRange")},Ha._NodeConstructors={},Rt([Ut()],Ha.prototype,"name",void 0),Rt([Ut()],Ha.prototype,"id",void 0),Rt([Ut()],Ha.prototype,"uniqueId",void 0),Rt([Ut()],Ha.prototype,"state",void 0),Rt([Ut()],Ha.prototype,"metadata",void 0);class Hp{constructor(p,_,E,I){this.x=p,this.y=_,this.width=E,this.height=I}toGlobal(p,_){return new Hp(this.x*p,this.y*_,this.width*p,this.height*_)}toGlobalToRef(p,_,E){return E.x=this.x*p,E.y=this.y*_,E.width=this.width*p,E.height=this.height*_,this}clone(){return new Hp(this.x,this.y,this.width,this.height)}}class Wr extends Ha{get position(){return this._position}set position(p){this._position=p}set upVector(p){this._upVector=p}get upVector(){return this._upVector}get screenArea(){let p=0,_=0;if(this.mode===Wr.PERSPECTIVE_CAMERA)this.fovMode===Wr.FOVMODE_VERTICAL_FIXED?(_=this.minZ*2*Math.tan(this.fov/2),p=this.getEngine().getAspectRatio(this)*_):(p=this.minZ*2*Math.tan(this.fov/2),_=p/this.getEngine().getAspectRatio(this));else{const E=this.getEngine().getRenderWidth()/2,I=this.getEngine().getRenderHeight()/2;p=(this.orthoRight??E)-(this.orthoLeft??-E),_=(this.orthoTop??I)-(this.orthoBottom??-I)}return p*_}set orthoLeft(p){this._orthoLeft=p;for(const _ of this._rigCameras)_.orthoLeft=p}get orthoLeft(){return this._orthoLeft}set orthoRight(p){this._orthoRight=p;for(const _ of this._rigCameras)_.orthoRight=p}get orthoRight(){return this._orthoRight}set orthoBottom(p){this._orthoBottom=p;for(const _ of this._rigCameras)_.orthoBottom=p}get orthoBottom(){return this._orthoBottom}set orthoTop(p){this._orthoTop=p;for(const _ of this._rigCameras)_.orthoTop=p}get orthoTop(){return this._orthoTop}set mode(p){this._mode=p;for(const _ of this._rigCameras)_.mode=p}get mode(){return this._mode}get hasMoved(){return this._hasMoved}constructor(p,_,E,I=!0){super(p,E),this._position=at.Zero(),this._upVector=at.Up(),this.oblique=null,this._orthoLeft=null,this._orthoRight=null,this._orthoBottom=null,this._orthoTop=null,this.fov=.8,this.projectionPlaneTilt=0,this.minZ=1,this.maxZ=1e4,this.inertia=.9,this._mode=Wr.PERSPECTIVE_CAMERA,this.isIntermediate=!1,this.viewport=new Hp(0,0,1,1),this.layerMask=268435455,this.fovMode=Wr.FOVMODE_VERTICAL_FIXED,this.cameraRigMode=Wr.RIG_MODE_NONE,this.customRenderTargets=[],this.outputRenderTarget=null,this.onViewMatrixChangedObservable=new Ri,this.onProjectionMatrixChangedObservable=new Ri,this.onAfterCheckInputsObservable=new Ri,this.onRestoreStateObservable=new Ri,this.isRigCamera=!1,this._hasMoved=!1,this._rigCameras=new Array,this._skipRendering=!1,this._projectionMatrix=new jt,this._postProcesses=new Array,this._activeMeshes=new ct(256),this._globalPosition=at.Zero(),this._computedViewMatrix=jt.Identity(),this._doNotComputeProjectionMatrix=!1,this._transformMatrix=jt.Zero(),this._refreshFrustumPlanes=!0,this._absoluteRotation=us.Identity(),this._isCamera=!0,this._isLeftCamera=!1,this._isRightCamera=!1,this.getScene().addCamera(this),I&&!this.getScene().activeCamera&&(this.getScene().activeCamera=this),this.position=_,this.renderPassId=this.getScene().getEngine().createRenderPassId(`Camera ${p}`)}storeState(){return this._stateStored=!0,this._storedFov=this.fov,this}_restoreStateValues(){return this._stateStored?(this.fov=this._storedFov,!0):!1}restoreState(){return this._restoreStateValues()?(this.onRestoreStateObservable.notifyObservers(this),!0):!1}getClassName(){return"Camera"}toString(p){let _="Name: "+this.name;if(_+=", type: "+this.getClassName(),this.animations)for(let E=0;E<this.animations.length;E++)_+=", animation[0]: "+this.animations[E].toString(p);return _}applyVerticalCorrection(){const p=this.absoluteRotation.toEulerAngles();this.projectionPlaneTilt=this._scene.useRightHandedSystem?-p.x:p.x}get globalPosition(){return this._globalPosition}getActiveMeshes(){return this._activeMeshes}isActiveMesh(p){return this._activeMeshes.indexOf(p)!==-1}isReady(p=!1){if(p){for(const _ of this._postProcesses)if(_&&!_.isReady())return!1}return super.isReady(p)}_initCache(){super._initCache(),this._cache.position=new at(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.upVector=new at(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.mode=void 0,this._cache.minZ=void 0,this._cache.maxZ=void 0,this._cache.fov=void 0,this._cache.fovMode=void 0,this._cache.aspectRatio=void 0,this._cache.orthoLeft=void 0,this._cache.orthoRight=void 0,this._cache.orthoBottom=void 0,this._cache.orthoTop=void 0,this._cache.obliqueAngle=void 0,this._cache.obliqueLength=void 0,this._cache.obliqueOffset=void 0,this._cache.renderWidth=void 0,this._cache.renderHeight=void 0}_updateCache(p){p||super._updateCache(),this._cache.position.copyFrom(this.position),this._cache.upVector.copyFrom(this.upVector)}_isSynchronized(){return this._isSynchronizedViewMatrix()&&this._isSynchronizedProjectionMatrix()}_isSynchronizedViewMatrix(){return super._isSynchronized()?this._cache.position.equals(this.position)&&this._cache.upVector.equals(this.upVector)&&this.isSynchronizedWithParent():!1}_isSynchronizedProjectionMatrix(){let p=this._cache.mode===this.mode&&this._cache.minZ===this.minZ&&this._cache.maxZ===this.maxZ;if(!p)return!1;const _=this.getEngine();return this.mode===Wr.PERSPECTIVE_CAMERA?p=this._cache.fov===this.fov&&this._cache.fovMode===this.fovMode&&this._cache.aspectRatio===_.getAspectRatio(this)&&this._cache.projectionPlaneTilt===this.projectionPlaneTilt:(p=this._cache.orthoLeft===this.orthoLeft&&this._cache.orthoRight===this.orthoRight&&this._cache.orthoBottom===this.orthoBottom&&this._cache.orthoTop===this.orthoTop&&this._cache.renderWidth===_.getRenderWidth()&&this._cache.renderHeight===_.getRenderHeight(),this.oblique&&(p=p&&this._cache.obliqueAngle===this.oblique.angle&&this._cache.obliqueLength===this.oblique.length&&this._cache.obliqueOffset===this.oblique.offset)),p}attachControl(p,_){}detachControl(p){}update(){this._hasMoved=!1,this._checkInputs(),this.cameraRigMode!==Wr.RIG_MODE_NONE&&this._updateRigCameras(),this.getViewMatrix(),this.getProjectionMatrix()}_checkInputs(){this.onAfterCheckInputsObservable.notifyObservers(this)}get rigCameras(){return this._rigCameras}get rigPostProcess(){return this._rigPostProcess}_getFirstPostProcess(){for(let p=0;p<this._postProcesses.length;p++)if(this._postProcesses[p]!==null)return this._postProcesses[p];return null}_cascadePostProcessesToRigCams(){const p=this._getFirstPostProcess();p&&p.markTextureDirty();for(let _=0,E=this._rigCameras.length;_<E;_++){const I=this._rigCameras[_],Z=I._rigPostProcess;Z?(Z.getEffectName()==="pass"&&(I.isIntermediate=this._postProcesses.length===0),I._postProcesses=this._postProcesses.slice(0).concat(Z),Z.markTextureDirty()):I._postProcesses=this._postProcesses.slice(0)}}attachPostProcess(p,_=null){return!p.isReusable()&&this._postProcesses.indexOf(p)>-1?(Ti.Error("You're trying to reuse a post process not defined as reusable."),0):(_==null||_<0?this._postProcesses.push(p):this._postProcesses[_]===null?this._postProcesses[_]=p:this._postProcesses.splice(_,0,p),this._cascadePostProcessesToRigCams(),this._scene.prePassRenderer&&this._scene.prePassRenderer.markAsDirty(),this._postProcesses.indexOf(p))}detachPostProcess(p){const _=this._postProcesses.indexOf(p);_!==-1&&(this._postProcesses[_]=null),this._scene.prePassRenderer&&this._scene.prePassRenderer.markAsDirty(),this._cascadePostProcessesToRigCams()}getWorldMatrix(){return this._isSynchronizedViewMatrix()?this._worldMatrix:(this.getViewMatrix(),this._worldMatrix)}_getViewMatrix(){return jt.Identity()}getViewMatrix(p){return!p&&this._isSynchronizedViewMatrix()?this._computedViewMatrix:(this._hasMoved=!0,this.updateCache(),this._computedViewMatrix=this._getViewMatrix(),this._currentRenderId=this.getScene().getRenderId(),this._childUpdateId++,this._refreshFrustumPlanes=!0,this._cameraRigParams&&this._cameraRigParams.vrPreViewMatrix&&this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix,this._computedViewMatrix),this.parent&&this.parent.onViewMatrixChangedObservable&&this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent),this.onViewMatrixChangedObservable.notifyObservers(this),this._computedViewMatrix.invertToRef(this._worldMatrix),this._computedViewMatrix)}freezeProjectionMatrix(p){this._doNotComputeProjectionMatrix=!0,p!==void 0&&(this._projectionMatrix=p)}unfreezeProjectionMatrix(){this._doNotComputeProjectionMatrix=!1}getProjectionMatrix(p){if(this._doNotComputeProjectionMatrix||!p&&this._isSynchronizedProjectionMatrix())return this._projectionMatrix;this._cache.mode=this.mode,this._cache.minZ=this.minZ,this._cache.maxZ=this.maxZ,this._refreshFrustumPlanes=!0;const _=this.getEngine(),E=this.getScene(),I=_.useReverseDepthBuffer;if(this.mode===Wr.PERSPECTIVE_CAMERA){this._cache.fov=this.fov,this._cache.fovMode=this.fovMode,this._cache.aspectRatio=_.getAspectRatio(this),this._cache.projectionPlaneTilt=this.projectionPlaneTilt,this.minZ<=0&&(this.minZ=.1);let Z;E.useRightHandedSystem?Z=jt.PerspectiveFovRHToRef:Z=jt.PerspectiveFovLHToRef,Z(this.fov,_.getAspectRatio(this),I?this.maxZ:this.minZ,I?this.minZ:this.maxZ,this._projectionMatrix,this.fovMode===Wr.FOVMODE_VERTICAL_FIXED,_.isNDCHalfZRange,this.projectionPlaneTilt,I)}else{const Z=_.getRenderWidth()/2,re=_.getRenderHeight()/2;E.useRightHandedSystem?this.oblique?jt.ObliqueOffCenterRHToRef(this.orthoLeft??-Z,this.orthoRight??Z,this.orthoBottom??-re,this.orthoTop??re,I?this.maxZ:this.minZ,I?this.minZ:this.maxZ,this.oblique.length,this.oblique.angle,this._computeObliqueDistance(this.oblique.offset),this._projectionMatrix,_.isNDCHalfZRange):jt.OrthoOffCenterRHToRef(this.orthoLeft??-Z,this.orthoRight??Z,this.orthoBottom??-re,this.orthoTop??re,I?this.maxZ:this.minZ,I?this.minZ:this.maxZ,this._projectionMatrix,_.isNDCHalfZRange):this.oblique?jt.ObliqueOffCenterLHToRef(this.orthoLeft??-Z,this.orthoRight??Z,this.orthoBottom??-re,this.orthoTop??re,I?this.maxZ:this.minZ,I?this.minZ:this.maxZ,this.oblique.length,this.oblique.angle,this._computeObliqueDistance(this.oblique.offset),this._projectionMatrix,_.isNDCHalfZRange):jt.OrthoOffCenterLHToRef(this.orthoLeft??-Z,this.orthoRight??Z,this.orthoBottom??-re,this.orthoTop??re,I?this.maxZ:this.minZ,I?this.minZ:this.maxZ,this._projectionMatrix,_.isNDCHalfZRange),this._cache.orthoLeft=this.orthoLeft,this._cache.orthoRight=this.orthoRight,this._cache.orthoBottom=this.orthoBottom,this._cache.orthoTop=this.orthoTop,this._cache.obliqueAngle=this.oblique?.angle,this._cache.obliqueLength=this.oblique?.length,this._cache.obliqueOffset=this.oblique?.offset,this._cache.renderWidth=_.getRenderWidth(),this._cache.renderHeight=_.getRenderHeight()}return this.onProjectionMatrixChangedObservable.notifyObservers(this),this._projectionMatrix}getTransformationMatrix(){return this._computedViewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix),this._transformMatrix}_computeObliqueDistance(p){const _=this,E=this;return(_.radius||(E.target?at.Distance(this.position,E.target):this.position.length()))+p}_updateFrustumPlanes(){this._refreshFrustumPlanes&&(this.getTransformationMatrix(),this._frustumPlanes?n2.GetPlanesToRef(this._transformMatrix,this._frustumPlanes):this._frustumPlanes=n2.GetPlanes(this._transformMatrix),this._refreshFrustumPlanes=!1)}isInFrustum(p,_=!1){if(this._updateFrustumPlanes(),_&&this.rigCameras.length>0){let E=!1;return this.rigCameras.forEach(I=>{I._updateFrustumPlanes(),E=E||p.isInFrustum(I._frustumPlanes)}),E}else return p.isInFrustum(this._frustumPlanes)}isCompletelyInFrustum(p){return this._updateFrustumPlanes(),p.isCompletelyInFrustum(this._frustumPlanes)}getForwardRay(p=100,_,E){throw ur("Ray")}getForwardRayToRef(p,_=100,E,I){throw ur("Ray")}dispose(p,_=!1){for(this.onViewMatrixChangedObservable.clear(),this.onProjectionMatrixChangedObservable.clear(),this.onAfterCheckInputsObservable.clear(),this.onRestoreStateObservable.clear(),this.inputs&&this.inputs.clear(),this.getScene().stopAnimation(this),this.getScene().removeCamera(this);this._rigCameras.length>0;){const I=this._rigCameras.pop();I&&I.dispose()}if(this._parentContainer){const I=this._parentContainer.cameras.indexOf(this);I>-1&&this._parentContainer.cameras.splice(I,1),this._parentContainer=null}if(this._rigPostProcess)this._rigPostProcess.dispose(this),this._rigPostProcess=null,this._postProcesses.length=0;else if(this.cameraRigMode!==Wr.RIG_MODE_NONE)this._rigPostProcess=null,this._postProcesses.length=0;else{let I=this._postProcesses.length;for(;--I>=0;){const Z=this._postProcesses[I];Z&&Z.dispose(this)}}let E=this.customRenderTargets.length;for(;--E>=0;)this.customRenderTargets[E].dispose();this.customRenderTargets.length=0,this._activeMeshes.dispose(),this.getScene().getEngine().releaseRenderPassId(this.renderPassId),super.dispose(p,_)}get isLeftCamera(){return this._isLeftCamera}get isRightCamera(){return this._isRightCamera}get leftCamera(){return this._rigCameras.length<1?null:this._rigCameras[0]}get rightCamera(){return this._rigCameras.length<2?null:this._rigCameras[1]}getLeftTarget(){return this._rigCameras.length<1?null:this._rigCameras[0].getTarget()}getRightTarget(){return this._rigCameras.length<2?null:this._rigCameras[1].getTarget()}setCameraRigMode(p,_){if(this.cameraRigMode!==p){for(;this._rigCameras.length>0;){const E=this._rigCameras.pop();E&&E.dispose()}if(this.cameraRigMode=p,this._cameraRigParams={},this._cameraRigParams.interaxialDistance=_.interaxialDistance||.0637,this._cameraRigParams.stereoHalfAngle=lt.ToRadians(this._cameraRigParams.interaxialDistance/.0637),this.cameraRigMode!==Wr.RIG_MODE_NONE){const E=this.createRigCamera(this.name+"_L",0);E&&(E._isLeftCamera=!0);const I=this.createRigCamera(this.name+"_R",1);I&&(I._isRightCamera=!0),E&&I&&(this._rigCameras.push(E),this._rigCameras.push(I))}this._setRigMode(_),this._cascadePostProcessesToRigCams(),this.update()}}_setRigMode(p){}_getVRProjectionMatrix(){return jt.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov,this._cameraRigParams.vrMetrics.aspectRatio,this.minZ,this.maxZ,this._cameraRigParams.vrWorkMatrix,!0,this.getEngine().isNDCHalfZRange),this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix,this._projectionMatrix),this._projectionMatrix}setCameraRigParameter(p,_){this._cameraRigParams||(this._cameraRigParams={}),this._cameraRigParams[p]=_,p==="interaxialDistance"&&(this._cameraRigParams.stereoHalfAngle=lt.ToRadians(_/.0637))}createRigCamera(p,_){return null}_updateRigCameras(){for(let p=0;p<this._rigCameras.length;p++)this._rigCameras[p].minZ=this.minZ,this._rigCameras[p].maxZ=this.maxZ,this._rigCameras[p].fov=this.fov,this._rigCameras[p].upVector.copyFrom(this.upVector);this.cameraRigMode===Wr.RIG_MODE_STEREOSCOPIC_ANAGLYPH&&(this._rigCameras[0].viewport=this._rigCameras[1].viewport=this.viewport)}_setupInputs(){}serialize(){const p=Hr.Serialize(this);return p.uniqueId=this.uniqueId,p.type=this.getClassName(),this.parent&&this.parent._serializeAsParent(p),this.inputs&&this.inputs.serialize(p),Hr.AppendSerializedAnimations(this,p),p.ranges=this.serializeAnimationRanges(),p.isEnabled=this.isEnabled(),p}clone(p,_=null){const E=Hr.Clone(Wr.GetConstructorFromName(this.getClassName(),p,this.getScene(),this.interaxialDistance,this.isStereoscopicSideBySide),this);return E.name=p,E.parent=_,this.onClonedObservable.notifyObservers(E),E}getDirection(p){const _=at.Zero();return this.getDirectionToRef(p,_),_}get absoluteRotation(){return this.getWorldMatrix().decompose(void 0,this._absoluteRotation),this._absoluteRotation}getDirectionToRef(p,_){at.TransformNormalToRef(p,this.getWorldMatrix(),_)}static GetConstructorFromName(p,_,E,I=0,Z=!0){const re=Ha.Construct(p,_,E,{interaxial_distance:I,isStereoscopicSideBySide:Z});return re||(()=>Wr._CreateDefaultParsedCamera(_,E))}computeWorldMatrix(){return this.getWorldMatrix()}static Parse(p,_){const E=p.type,I=Wr.GetConstructorFromName(E,p.name,_,p.interaxial_distance,p.isStereoscopicSideBySide),Z=Hr.Parse(I,p,_);if(p.parentId!==void 0&&(Z._waitingParentId=p.parentId),p.parentInstanceIndex!==void 0&&(Z._waitingParentInstanceIndex=p.parentInstanceIndex),Z.inputs&&(Z.inputs.parse(p),Z._setupInputs()),p.upVector&&(Z.upVector=at.FromArray(p.upVector)),Z.setPosition&&(Z.position.copyFromFloats(0,0,0),Z.setPosition(at.FromArray(p.position))),p.target&&Z.setTarget&&Z.setTarget(at.FromArray(p.target)),p.cameraRigMode){const re=p.interaxial_distance?{interaxialDistance:p.interaxial_distance}:{};Z.setCameraRigMode(p.cameraRigMode,re)}if(p.animations){for(let re=0;re<p.animations.length;re++){const ae=p.animations[re],he=r0("BABYLON.Animation");he&&Z.animations.push(he.Parse(ae))}Ha.ParseAnimationRanges(Z,p,_)}return p.autoAnimate&&_.beginAnimation(Z,p.autoAnimateFrom,p.autoAnimateTo,p.autoAnimateLoop,p.autoAnimateSpeed||1),p.isEnabled!==void 0&&Z.setEnabled(p.isEnabled),Z}_calculateHandednessMultiplier(){let p=this.getScene().useRightHandedSystem?-1:1;return this.parent&&this.parent._getWorldMatrixDeterminant()<0&&(p*=-1),p}}Wr._CreateDefaultParsedCamera=(pe,p)=>{throw ur("UniversalCamera")},Wr.PERSPECTIVE_CAMERA=0,Wr.ORTHOGRAPHIC_CAMERA=1,Wr.FOVMODE_VERTICAL_FIXED=0,Wr.FOVMODE_HORIZONTAL_FIXED=1,Wr.RIG_MODE_NONE=0,Wr.RIG_MODE_STEREOSCOPIC_ANAGLYPH=10,Wr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL=11,Wr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED=12,Wr.RIG_MODE_STEREOSCOPIC_OVERUNDER=13,Wr.RIG_MODE_STEREOSCOPIC_INTERLACED=14,Wr.RIG_MODE_VR=20,Wr.RIG_MODE_CUSTOM=22,Wr.ForceAttachControlToAlwaysPreventDefault=!1,Rt([Yn("position")],Wr.prototype,"_position",void 0),Rt([Yn("upVector")],Wr.prototype,"_upVector",void 0),Rt([Ut()],Wr.prototype,"orthoLeft",null),Rt([Ut()],Wr.prototype,"orthoRight",null),Rt([Ut()],Wr.prototype,"orthoBottom",null),Rt([Ut()],Wr.prototype,"orthoTop",null),Rt([Ut()],Wr.prototype,"fov",void 0),Rt([Ut()],Wr.prototype,"projectionPlaneTilt",void 0),Rt([Ut()],Wr.prototype,"minZ",void 0),Rt([Ut()],Wr.prototype,"maxZ",void 0),Rt([Ut()],Wr.prototype,"inertia",void 0),Rt([Ut()],Wr.prototype,"mode",null),Rt([Ut()],Wr.prototype,"layerMask",void 0),Rt([Ut()],Wr.prototype,"fovMode",void 0),Rt([Ut()],Wr.prototype,"cameraRigMode",void 0),Rt([Ut()],Wr.prototype,"interaxialDistance",void 0),Rt([Ut()],Wr.prototype,"isStereoscopicSideBySide",void 0);var Wn;(function(pe){pe[pe.LOCAL=0]="LOCAL",pe[pe.WORLD=1]="WORLD",pe[pe.BONE=2]="BONE"})(Wn||(Wn={}));class Gc{}Gc.X=new at(1,0,0),Gc.Y=new at(0,1,0),Gc.Z=new at(0,0,1);var zc;(function(pe){pe[pe.X=0]="X",pe[pe.Y=1]="Y",pe[pe.Z=2]="Z"})(zc||(zc={}));class $0 extends Wr{constructor(p,_,E,I=!0){super(p,_,E,I),this._tmpUpVector=at.Zero(),this._tmpTargetVector=at.Zero(),this.cameraDirection=new at(0,0,0),this.cameraRotation=new xr(0,0),this.ignoreParentScaling=!1,this.updateUpVectorFromRotation=!1,this._tmpQuaternion=new us,this.rotation=new at(0,0,0),this.speed=2,this.noRotationConstraint=!1,this.invertRotation=!1,this.inverseRotationSpeed=.2,this.lockedTarget=null,this._currentTarget=at.Zero(),this._initialFocalDistance=1,this._viewMatrix=jt.Zero(),this._camMatrix=jt.Zero(),this._cameraTransformMatrix=jt.Zero(),this._cameraRotationMatrix=jt.Zero(),this._referencePoint=new at(0,0,1),this._transformedReferencePoint=at.Zero(),this._deferredPositionUpdate=new at,this._deferredRotationQuaternionUpdate=new us,this._deferredRotationUpdate=new at,this._deferredUpdated=!1,this._deferOnly=!1,this._defaultUp=at.Up(),this._cachedRotationZ=0,this._cachedQuaternionRotationZ=0}getFrontPosition(p){this.getWorldMatrix();const _=this.getTarget().subtract(this.position);return _.normalize(),_.scaleInPlace(p),this.globalPosition.add(_)}_getLockedTargetPosition(){if(!this.lockedTarget)return null;if(this.lockedTarget.absolutePosition){const p=this.lockedTarget;p.computeWorldMatrix().getTranslationToRef(p.absolutePosition)}return this.lockedTarget.absolutePosition||this.lockedTarget}storeState(){return this._storedPosition=this.position.clone(),this._storedRotation=this.rotation.clone(),this.rotationQuaternion&&(this._storedRotationQuaternion=this.rotationQuaternion.clone()),super.storeState()}_restoreStateValues(){return super._restoreStateValues()?(this.position=this._storedPosition.clone(),this.rotation=this._storedRotation.clone(),this.rotationQuaternion&&(this.rotationQuaternion=this._storedRotationQuaternion.clone()),this.cameraDirection.copyFromFloats(0,0,0),this.cameraRotation.copyFromFloats(0,0),!0):!1}_initCache(){super._initCache(),this._cache.lockedTarget=new at(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotation=new at(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotationQuaternion=new us(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}_updateCache(p){p||super._updateCache();const _=this._getLockedTargetPosition();_?this._cache.lockedTarget?this._cache.lockedTarget.copyFrom(_):this._cache.lockedTarget=_.clone():this._cache.lockedTarget=null,this._cache.rotation.copyFrom(this.rotation),this.rotationQuaternion&&this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)}_isSynchronizedViewMatrix(){if(!super._isSynchronizedViewMatrix())return!1;const p=this._getLockedTargetPosition();return(this._cache.lockedTarget?this._cache.lockedTarget.equals(p):!p)&&(this.rotationQuaternion?this.rotationQuaternion.equals(this._cache.rotationQuaternion):this._cache.rotation.equals(this.rotation))}_computeLocalCameraSpeed(){const p=this.getEngine();return this.speed*Math.sqrt(p.getDeltaTime()/(p.getFps()*100))}setTarget(p){this.upVector.normalize(),this._initialFocalDistance=p.subtract(this.position).length(),this.position.z===p.z&&(this.position.z+=ns),this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance),jt.LookAtLHToRef(this.position,p,this._defaultUp,this._camMatrix),this._camMatrix.invert(),this.rotation.x=Math.atan(this._camMatrix.m[6]/this._camMatrix.m[10]);const _=p.subtract(this.position);_.x>=0?this.rotation.y=-Math.atan(_.z/_.x)+Math.PI/2:this.rotation.y=-Math.atan(_.z/_.x)-Math.PI/2,this.rotation.z=0,isNaN(this.rotation.x)&&(this.rotation.x=0),isNaN(this.rotation.y)&&(this.rotation.y=0),isNaN(this.rotation.z)&&(this.rotation.z=0),this.rotationQuaternion&&us.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this.rotationQuaternion)}get target(){return this.getTarget()}set target(p){this.setTarget(p)}getTarget(){return this._currentTarget}_decideIfNeedsToMove(){return Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0}_updatePosition(){if(this.parent){this.parent.getWorldMatrix().invertToRef(ui.Matrix[0]),at.TransformNormalToRef(this.cameraDirection,ui.Matrix[0],ui.Vector3[0]),this._deferredPositionUpdate.addInPlace(ui.Vector3[0]),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate);return}this._deferredPositionUpdate.addInPlace(this.cameraDirection),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate)}_checkInputs(){const p=this.invertRotation?-this.inverseRotationSpeed:1,_=this._decideIfNeedsToMove(),E=this.cameraRotation.x||this.cameraRotation.y;this._deferredUpdated=!1,this._deferredRotationUpdate.copyFrom(this.rotation),this._deferredPositionUpdate.copyFrom(this.position),this.rotationQuaternion&&this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion),_&&this._updatePosition(),E&&(this.rotationQuaternion&&this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate),this._deferredRotationUpdate.x+=this.cameraRotation.x*p,this._deferredRotationUpdate.y+=this.cameraRotation.y*p,this.noRotationConstraint||(this._deferredRotationUpdate.x>1.570796&&(this._deferredRotationUpdate.x=1.570796),this._deferredRotationUpdate.x<-1.570796&&(this._deferredRotationUpdate.x=-1.570796)),this._deferOnly?this._deferredUpdated=!0:this.rotation.copyFrom(this._deferredRotationUpdate),this.rotationQuaternion&&this._deferredRotationUpdate.lengthSquared()&&(us.RotationYawPitchRollToRef(this._deferredRotationUpdate.y,this._deferredRotationUpdate.x,this._deferredRotationUpdate.z,this._deferredRotationQuaternionUpdate),this._deferOnly?this._deferredUpdated=!0:this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate))),_&&(Math.abs(this.cameraDirection.x)<this.speed*ns&&(this.cameraDirection.x=0),Math.abs(this.cameraDirection.y)<this.speed*ns&&(this.cameraDirection.y=0),Math.abs(this.cameraDirection.z)<this.speed*ns&&(this.cameraDirection.z=0),this.cameraDirection.scaleInPlace(this.inertia)),E&&(Math.abs(this.cameraRotation.x)<this.speed*ns&&(this.cameraRotation.x=0),Math.abs(this.cameraRotation.y)<this.speed*ns&&(this.cameraRotation.y=0),this.cameraRotation.scaleInPlace(this.inertia)),super._checkInputs()}_updateCameraRotationMatrix(){this.rotationQuaternion?this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix):jt.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix)}_rotateUpVectorWithCameraRotationMatrix(){return at.TransformNormalToRef(this._defaultUp,this._cameraRotationMatrix,this.upVector),this}_getViewMatrix(){return this.lockedTarget&&this.setTarget(this._getLockedTargetPosition()),this._updateCameraRotationMatrix(),this.rotationQuaternion&&this._cachedQuaternionRotationZ!=this.rotationQuaternion.z?(this._rotateUpVectorWithCameraRotationMatrix(),this._cachedQuaternionRotationZ=this.rotationQuaternion.z):this._cachedRotationZ!==this.rotation.z&&(this._rotateUpVectorWithCameraRotationMatrix(),this._cachedRotationZ=this.rotation.z),at.TransformCoordinatesToRef(this._referencePoint,this._cameraRotationMatrix,this._transformedReferencePoint),this.position.addToRef(this._transformedReferencePoint,this._currentTarget),this.updateUpVectorFromRotation&&(this.rotationQuaternion?Gc.Y.rotateByQuaternionToRef(this.rotationQuaternion,this.upVector):(us.FromEulerVectorToRef(this.rotation,this._tmpQuaternion),Gc.Y.rotateByQuaternionToRef(this._tmpQuaternion,this.upVector))),this._computeViewMatrix(this.position,this._currentTarget,this.upVector),this._viewMatrix}_computeViewMatrix(p,_,E){if(this.ignoreParentScaling){if(this.parent){const I=this.parent.getWorldMatrix();at.TransformCoordinatesToRef(p,I,this._globalPosition),at.TransformCoordinatesToRef(_,I,this._tmpTargetVector),at.TransformNormalToRef(E,I,this._tmpUpVector),this._markSyncedWithParent()}else this._globalPosition.copyFrom(p),this._tmpTargetVector.copyFrom(_),this._tmpUpVector.copyFrom(E);this.getScene().useRightHandedSystem?jt.LookAtRHToRef(this._globalPosition,this._tmpTargetVector,this._tmpUpVector,this._viewMatrix):jt.LookAtLHToRef(this._globalPosition,this._tmpTargetVector,this._tmpUpVector,this._viewMatrix);return}if(this.getScene().useRightHandedSystem?jt.LookAtRHToRef(p,_,E,this._viewMatrix):jt.LookAtLHToRef(p,_,E,this._viewMatrix),this.parent){const I=this.parent.getWorldMatrix();this._viewMatrix.invert(),this._viewMatrix.multiplyToRef(I,this._viewMatrix),this._viewMatrix.getTranslationToRef(this._globalPosition),this._viewMatrix.invert(),this._markSyncedWithParent()}else this._globalPosition.copyFrom(p)}createRigCamera(p,_){if(this.cameraRigMode!==Wr.RIG_MODE_NONE){const E=new $0(p,this.position.clone(),this.getScene());return E.isRigCamera=!0,E.rigParent=this,this.cameraRigMode===Wr.RIG_MODE_VR&&(this.rotationQuaternion||(this.rotationQuaternion=new us),E._cameraRigParams={},E.rotationQuaternion=new us),E.mode=this.mode,E.orthoLeft=this.orthoLeft,E.orthoRight=this.orthoRight,E.orthoTop=this.orthoTop,E.orthoBottom=this.orthoBottom,E}return null}_updateRigCameras(){const p=this._rigCameras[0],_=this._rigCameras[1];switch(this.computeWorldMatrix(),this.cameraRigMode){case Wr.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case Wr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case Wr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:case Wr.RIG_MODE_STEREOSCOPIC_OVERUNDER:case Wr.RIG_MODE_STEREOSCOPIC_INTERLACED:{const E=this.cameraRigMode===Wr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED?1:-1,I=this.cameraRigMode===Wr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED?-1:1;this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle*E,p),this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle*I,_);break}case Wr.RIG_MODE_VR:p.rotationQuaternion?(p.rotationQuaternion.copyFrom(this.rotationQuaternion),_.rotationQuaternion.copyFrom(this.rotationQuaternion)):(p.rotation.copyFrom(this.rotation),_.rotation.copyFrom(this.rotation)),p.position.copyFrom(this.position),_.position.copyFrom(this.position);break}super._updateRigCameras()}_getRigCamPositionAndTarget(p,_){this.getTarget().subtractToRef(this.position,$0._TargetFocalPoint),$0._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);const I=$0._TargetFocalPoint.addInPlace(this.position);jt.TranslationToRef(-I.x,-I.y,-I.z,$0._TargetTransformMatrix),$0._TargetTransformMatrix.multiplyToRef(jt.RotationAxis(_.upVector,p),$0._RigCamTransformMatrix),jt.TranslationToRef(I.x,I.y,I.z,$0._TargetTransformMatrix),$0._RigCamTransformMatrix.multiplyToRef($0._TargetTransformMatrix,$0._RigCamTransformMatrix),at.TransformCoordinatesToRef(this.position,$0._RigCamTransformMatrix,_.position),_.setTarget(I)}getClassName(){return"TargetCamera"}}$0._RigCamTransformMatrix=new jt,$0._TargetTransformMatrix=new jt,$0._TargetFocalPoint=new at,Rt([Yn()],$0.prototype,"rotation",void 0),Rt([Ut()],$0.prototype,"speed",void 0),Rt([ko("lockedTargetId")],$0.prototype,"lockedTarget",void 0);var k2={};class ab{constructor(p){this.attachedToElement=!1,this.attached={},this.camera=p,this.checkInputs=()=>{}}add(p){const _=p.getSimpleName();if(this.attached[_]){Ti.Warn("camera input of type "+_+" already exists on camera");return}this.attached[_]=p,p.camera=this.camera,p.checkInputs&&(this.checkInputs=this._addCheckInputs(p.checkInputs.bind(p))),this.attachedToElement&&p.attachControl(this.noPreventDefault)}remove(p){for(const _ in this.attached){const E=this.attached[_];if(E===p){E.detachControl(),E.camera=null,delete this.attached[_],this.rebuildInputCheck();return}}}removeByType(p){for(const _ in this.attached){const E=this.attached[_];E.getClassName()===p&&(E.detachControl(),E.camera=null,delete this.attached[_],this.rebuildInputCheck())}}_addCheckInputs(p){const _=this.checkInputs;return()=>{_(),p()}}attachInput(p){this.attachedToElement&&p.attachControl(this.noPreventDefault)}attachElement(p=!1){if(!this.attachedToElement){p=Wr.ForceAttachControlToAlwaysPreventDefault?!1:p,this.attachedToElement=!0,this.noPreventDefault=p;for(const _ in this.attached)this.attached[_].attachControl(p)}}detachElement(p=!1){for(const _ in this.attached)this.attached[_].detachControl(),p&&(this.attached[_].camera=null);this.attachedToElement=!1}rebuildInputCheck(){this.checkInputs=()=>{};for(const p in this.attached){const _=this.attached[p];_.checkInputs&&(this.checkInputs=this._addCheckInputs(_.checkInputs.bind(_)))}}clear(){this.attachedToElement&&this.detachElement(!0),this.attached={},this.attachedToElement=!1,this.checkInputs=()=>{}}serialize(p){const _={};for(const E in this.attached){const I=this.attached[E],Z=Hr.Serialize(I);_[I.getClassName()]=Z}p.inputsmgr=_}parse(p){const _=p.inputsmgr;if(_){this.clear();for(const E in _){const I=k2[E];if(I){const Z=_[E],re=Hr.Parse(()=>new I,Z,null);this.add(re)}}}else for(const E in this.attached){const I=k2[this.attached[E].getClassName()];if(I){const Z=Hr.Parse(()=>new I,p,null);this.remove(this.attached[E]),this.add(Z)}}}}class Go{constructor(){this.keysUp=[38],this.keysUpward=[33],this.keysDown=[40],this.keysDownward=[34],this.keysLeft=[37],this.keysRight=[39],this.rotationSpeed=.5,this.keysRotateLeft=[],this.keysRotateRight=[],this.keysRotateUp=[],this.keysRotateDown=[],this._keys=new Array}attachControl(p){p=lt.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(_=>{const E=_.event;if(!E.metaKey){if(_.type===lu.KEYDOWN)(this.keysUp.indexOf(E.keyCode)!==-1||this.keysDown.indexOf(E.keyCode)!==-1||this.keysLeft.indexOf(E.keyCode)!==-1||this.keysRight.indexOf(E.keyCode)!==-1||this.keysUpward.indexOf(E.keyCode)!==-1||this.keysDownward.indexOf(E.keyCode)!==-1||this.keysRotateLeft.indexOf(E.keyCode)!==-1||this.keysRotateRight.indexOf(E.keyCode)!==-1||this.keysRotateUp.indexOf(E.keyCode)!==-1||this.keysRotateDown.indexOf(E.keyCode)!==-1)&&(this._keys.indexOf(E.keyCode)===-1&&this._keys.push(E.keyCode),p||E.preventDefault());else if(this.keysUp.indexOf(E.keyCode)!==-1||this.keysDown.indexOf(E.keyCode)!==-1||this.keysLeft.indexOf(E.keyCode)!==-1||this.keysRight.indexOf(E.keyCode)!==-1||this.keysUpward.indexOf(E.keyCode)!==-1||this.keysDownward.indexOf(E.keyCode)!==-1||this.keysRotateLeft.indexOf(E.keyCode)!==-1||this.keysRotateRight.indexOf(E.keyCode)!==-1||this.keysRotateUp.indexOf(E.keyCode)!==-1||this.keysRotateDown.indexOf(E.keyCode)!==-1){const I=this._keys.indexOf(E.keyCode);I>=0&&this._keys.splice(I,1),p||E.preventDefault()}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){if(this._onKeyboardObserver){const p=this.camera;for(let _=0;_<this._keys.length;_++){const E=this._keys[_],I=p._computeLocalCameraSpeed();this.keysLeft.indexOf(E)!==-1?p._localDirection.copyFromFloats(-I,0,0):this.keysUp.indexOf(E)!==-1?p._localDirection.copyFromFloats(0,0,I):this.keysRight.indexOf(E)!==-1?p._localDirection.copyFromFloats(I,0,0):this.keysDown.indexOf(E)!==-1?p._localDirection.copyFromFloats(0,0,-I):this.keysUpward.indexOf(E)!==-1?p._localDirection.copyFromFloats(0,I,0):this.keysDownward.indexOf(E)!==-1?p._localDirection.copyFromFloats(0,-I,0):this.keysRotateLeft.indexOf(E)!==-1?(p._localDirection.copyFromFloats(0,0,0),p.cameraRotation.y-=this._getLocalRotation()):this.keysRotateRight.indexOf(E)!==-1?(p._localDirection.copyFromFloats(0,0,0),p.cameraRotation.y+=this._getLocalRotation()):this.keysRotateUp.indexOf(E)!==-1?(p._localDirection.copyFromFloats(0,0,0),p.cameraRotation.x-=this._getLocalRotation()):this.keysRotateDown.indexOf(E)!==-1&&(p._localDirection.copyFromFloats(0,0,0),p.cameraRotation.x+=this._getLocalRotation()),p.getScene().useRightHandedSystem&&(p._localDirection.z*=-1),p.getViewMatrix().invertToRef(p._cameraTransformMatrix),at.TransformNormalToRef(p._localDirection,p._cameraTransformMatrix,p._transformedDirection),p.cameraDirection.addInPlace(p._transformedDirection)}}}getClassName(){return"FreeCameraKeyboardMoveInput"}_onLostFocus(){this._keys.length=0}getSimpleName(){return"keyboard"}_getLocalRotation(){const p=this.camera._calculateHandednessMultiplier();return this.rotationSpeed*this._engine.getDeltaTime()/1e3*p}}Rt([Ut()],Go.prototype,"keysUp",void 0),Rt([Ut()],Go.prototype,"keysUpward",void 0),Rt([Ut()],Go.prototype,"keysDown",void 0),Rt([Ut()],Go.prototype,"keysDownward",void 0),Rt([Ut()],Go.prototype,"keysLeft",void 0),Rt([Ut()],Go.prototype,"keysRight",void 0),Rt([Ut()],Go.prototype,"rotationSpeed",void 0),Rt([Ut()],Go.prototype,"keysRotateLeft",void 0),Rt([Ut()],Go.prototype,"keysRotateRight",void 0),Rt([Ut()],Go.prototype,"keysRotateUp",void 0),Rt([Ut()],Go.prototype,"keysRotateDown",void 0),k2.FreeCameraKeyboardMoveInput=Go;class Gm{constructor(p=!0){this.touchEnabled=p,this.buttons=[0,1,2],this.angularSensibility=2e3,this._previousPosition=null,this.onPointerMovedObservable=new Ri,this._allowCameraRotation=!0,this._currentActiveButton=-1,this._activePointerId=-1}attachControl(p){p=lt.BackCompatCameraNoPreventDefault(arguments);const _=this.camera.getEngine(),E=_.getInputElement();this._pointerInput||(this._pointerInput=I=>{const Z=I.event,re=Z.pointerType==="touch";if(!this.touchEnabled&&re||I.type!==zr.POINTERMOVE&&this.buttons.indexOf(Z.button)===-1)return;const ae=Z.target;if(I.type===zr.POINTERDOWN){if(re&&this._activePointerId!==-1||!re&&this._currentActiveButton!==-1)return;this._activePointerId=Z.pointerId;try{ae?.setPointerCapture(Z.pointerId)}catch{}this._currentActiveButton===-1&&(this._currentActiveButton=Z.button),this._previousPosition={x:Z.clientX,y:Z.clientY},p||(Z.preventDefault(),E&&E.focus()),_.isPointerLock&&this._onMouseMove&&this._onMouseMove(I.event)}else if(I.type===zr.POINTERUP){if(re&&this._activePointerId!==Z.pointerId||!re&&this._currentActiveButton!==Z.button)return;try{ae?.releasePointerCapture(Z.pointerId)}catch{}this._currentActiveButton=-1,this._previousPosition=null,p||Z.preventDefault(),this._activePointerId=-1}else if(I.type===zr.POINTERMOVE&&(this._activePointerId===Z.pointerId||!re)){if(_.isPointerLock&&this._onMouseMove)this._onMouseMove(I.event);else if(this._previousPosition){const he=this.camera._calculateHandednessMultiplier(),_e=(Z.clientX-this._previousPosition.x)*he,ve=Z.clientY-this._previousPosition.y;this._allowCameraRotation&&(this.camera.cameraRotation.y+=_e/this.angularSensibility,this.camera.cameraRotation.x+=ve/this.angularSensibility),this.onPointerMovedObservable.notifyObservers({offsetX:_e,offsetY:ve}),this._previousPosition={x:Z.clientX,y:Z.clientY},p||Z.preventDefault()}}}),this._onMouseMove=I=>{if(!_.isPointerLock)return;const Z=this.camera._calculateHandednessMultiplier(),re=I.movementX*Z;this.camera.cameraRotation.y+=re/this.angularSensibility;const ae=I.movementY;this.camera.cameraRotation.x+=ae/this.angularSensibility,this._previousPosition=null,p||I.preventDefault()},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,zr.POINTERDOWN|zr.POINTERUP|zr.POINTERMOVE),E&&(this._contextMenuBind=I=>this.onContextMenu(I),E.addEventListener("contextmenu",this._contextMenuBind,!1))}onContextMenu(p){p.preventDefault()}detachControl(){if(this._observer){if(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._contextMenuBind){const _=this.camera.getEngine().getInputElement();_&&_.removeEventListener("contextmenu",this._contextMenuBind)}this.onPointerMovedObservable&&this.onPointerMovedObservable.clear(),this._observer=null,this._onMouseMove=null,this._previousPosition=null}this._activePointerId=-1,this._currentActiveButton=-1}getClassName(){return"FreeCameraMouseInput"}getSimpleName(){return"mouse"}}Rt([Ut()],Gm.prototype,"buttons",void 0),Rt([Ut()],Gm.prototype,"angularSensibility",void 0),k2.FreeCameraMouseInput=Gm;class zm{constructor(){this.wheelPrecisionX=3,this.wheelPrecisionY=3,this.wheelPrecisionZ=3,this.onChangedObservable=new Ri,this._wheelDeltaX=0,this._wheelDeltaY=0,this._wheelDeltaZ=0,this._ffMultiplier=12,this._normalize=120}attachControl(p){p=lt.BackCompatCameraNoPreventDefault(arguments),this._wheel=_=>{if(_.type!==zr.POINTERWHEEL)return;const E=_.event,I=E.deltaMode===hu.DOM_DELTA_LINE?this._ffMultiplier:1;this._wheelDeltaX+=this.wheelPrecisionX*I*E.deltaX/this._normalize,this._wheelDeltaY-=this.wheelPrecisionY*I*E.deltaY/this._normalize,this._wheelDeltaZ+=this.wheelPrecisionZ*I*E.deltaZ/this._normalize,E.preventDefault&&(p||E.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,zr.POINTERWHEEL)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null),this.onChangedObservable&&this.onChangedObservable.clear()}checkInputs(){this.onChangedObservable.notifyObservers({wheelDeltaX:this._wheelDeltaX,wheelDeltaY:this._wheelDeltaY,wheelDeltaZ:this._wheelDeltaZ}),this._wheelDeltaX=0,this._wheelDeltaY=0,this._wheelDeltaZ=0}getClassName(){return"BaseCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}}Rt([Ut()],zm.prototype,"wheelPrecisionX",void 0),Rt([Ut()],zm.prototype,"wheelPrecisionY",void 0),Rt([Ut()],zm.prototype,"wheelPrecisionZ",void 0);var ra;(function(pe){pe[pe.MoveRelative=0]="MoveRelative",pe[pe.RotateRelative=1]="RotateRelative",pe[pe.MoveScene=2]="MoveScene"})(ra||(ra={}));class U2 extends zm{constructor(){super(...arguments),this._moveRelative=at.Zero(),this._rotateRelative=at.Zero(),this._moveScene=at.Zero(),this._wheelXAction=ra.MoveRelative,this._wheelXActionCoordinate=zc.X,this._wheelYAction=ra.MoveRelative,this._wheelYActionCoordinate=zc.Z,this._wheelZAction=null,this._wheelZActionCoordinate=null}getClassName(){return"FreeCameraMouseWheelInput"}set wheelXMoveRelative(p){p===null&&this._wheelXAction!==ra.MoveRelative||(this._wheelXAction=ra.MoveRelative,this._wheelXActionCoordinate=p)}get wheelXMoveRelative(){return this._wheelXAction!==ra.MoveRelative?null:this._wheelXActionCoordinate}set wheelYMoveRelative(p){p===null&&this._wheelYAction!==ra.MoveRelative||(this._wheelYAction=ra.MoveRelative,this._wheelYActionCoordinate=p)}get wheelYMoveRelative(){return this._wheelYAction!==ra.MoveRelative?null:this._wheelYActionCoordinate}set wheelZMoveRelative(p){p===null&&this._wheelZAction!==ra.MoveRelative||(this._wheelZAction=ra.MoveRelative,this._wheelZActionCoordinate=p)}get wheelZMoveRelative(){return this._wheelZAction!==ra.MoveRelative?null:this._wheelZActionCoordinate}set wheelXRotateRelative(p){p===null&&this._wheelXAction!==ra.RotateRelative||(this._wheelXAction=ra.RotateRelative,this._wheelXActionCoordinate=p)}get wheelXRotateRelative(){return this._wheelXAction!==ra.RotateRelative?null:this._wheelXActionCoordinate}set wheelYRotateRelative(p){p===null&&this._wheelYAction!==ra.RotateRelative||(this._wheelYAction=ra.RotateRelative,this._wheelYActionCoordinate=p)}get wheelYRotateRelative(){return this._wheelYAction!==ra.RotateRelative?null:this._wheelYActionCoordinate}set wheelZRotateRelative(p){p===null&&this._wheelZAction!==ra.RotateRelative||(this._wheelZAction=ra.RotateRelative,this._wheelZActionCoordinate=p)}get wheelZRotateRelative(){return this._wheelZAction!==ra.RotateRelative?null:this._wheelZActionCoordinate}set wheelXMoveScene(p){p===null&&this._wheelXAction!==ra.MoveScene||(this._wheelXAction=ra.MoveScene,this._wheelXActionCoordinate=p)}get wheelXMoveScene(){return this._wheelXAction!==ra.MoveScene?null:this._wheelXActionCoordinate}set wheelYMoveScene(p){p===null&&this._wheelYAction!==ra.MoveScene||(this._wheelYAction=ra.MoveScene,this._wheelYActionCoordinate=p)}get wheelYMoveScene(){return this._wheelYAction!==ra.MoveScene?null:this._wheelYActionCoordinate}set wheelZMoveScene(p){p===null&&this._wheelZAction!==ra.MoveScene||(this._wheelZAction=ra.MoveScene,this._wheelZActionCoordinate=p)}get wheelZMoveScene(){return this._wheelZAction!==ra.MoveScene?null:this._wheelZActionCoordinate}checkInputs(){if(this._wheelDeltaX===0&&this._wheelDeltaY===0&&this._wheelDeltaZ==0)return;this._moveRelative.setAll(0),this._rotateRelative.setAll(0),this._moveScene.setAll(0),this._updateCamera(),this.camera.getScene().useRightHandedSystem&&(this._moveRelative.z*=-1);const p=jt.Zero();this.camera.getViewMatrix().invertToRef(p);const _=at.Zero();at.TransformNormalToRef(this._moveRelative,p,_),this.camera.cameraRotation.x+=this._rotateRelative.x/200,this.camera.cameraRotation.y+=this._rotateRelative.y/200,this.camera.cameraDirection.addInPlace(_),this.camera.cameraDirection.addInPlace(this._moveScene),super.checkInputs()}_updateCamera(){this._updateCameraProperty(this._wheelDeltaX,this._wheelXAction,this._wheelXActionCoordinate),this._updateCameraProperty(this._wheelDeltaY,this._wheelYAction,this._wheelYActionCoordinate),this._updateCameraProperty(this._wheelDeltaZ,this._wheelZAction,this._wheelZActionCoordinate)}_updateCameraProperty(p,_,E){if(p===0||_===null||E===null)return;let I=null;switch(_){case ra.MoveRelative:I=this._moveRelative;break;case ra.RotateRelative:I=this._rotateRelative;break;case ra.MoveScene:I=this._moveScene;break}switch(E){case zc.X:I.set(p,0,0);break;case zc.Y:I.set(0,p,0);break;case zc.Z:I.set(0,0,p);break}}}Rt([Ut()],U2.prototype,"wheelXMoveRelative",null),Rt([Ut()],U2.prototype,"wheelYMoveRelative",null),Rt([Ut()],U2.prototype,"wheelZMoveRelative",null),Rt([Ut()],U2.prototype,"wheelXRotateRelative",null),Rt([Ut()],U2.prototype,"wheelYRotateRelative",null),Rt([Ut()],U2.prototype,"wheelZRotateRelative",null),Rt([Ut()],U2.prototype,"wheelXMoveScene",null),Rt([Ut()],U2.prototype,"wheelYMoveScene",null),Rt([Ut()],U2.prototype,"wheelZMoveScene",null),k2.FreeCameraMouseWheelInput=U2;class Wm{constructor(p=!1){this.allowMouse=p,this.touchAngularSensibility=2e5,this.touchMoveSensibility=250,this.singleFingerRotate=!1,this._offsetX=null,this._offsetY=null,this._pointerPressed=new Array,this._isSafari=lt.IsSafari()}attachControl(p){p=lt.BackCompatCameraNoPreventDefault(arguments);let _=null;if(this._pointerInput===void 0&&(this._onLostFocus=()=>{this._offsetX=null,this._offsetY=null},this._pointerInput=E=>{const I=E.event,Z=I.pointerType==="mouse"||this._isSafari&&typeof I.pointerType>"u";if(!(!this.allowMouse&&Z)){if(E.type===zr.POINTERDOWN){if(p||I.preventDefault(),this._pointerPressed.push(I.pointerId),this._pointerPressed.length!==1)return;_={x:I.clientX,y:I.clientY}}else if(E.type===zr.POINTERUP){p||I.preventDefault();const re=this._pointerPressed.indexOf(I.pointerId);if(re===-1||(this._pointerPressed.splice(re,1),re!=0))return;_=null,this._offsetX=null,this._offsetY=null}else if(E.type===zr.POINTERMOVE){if(p||I.preventDefault(),!_||this._pointerPressed.indexOf(I.pointerId)!=0)return;this._offsetX=I.clientX-_.x,this._offsetY=-(I.clientY-_.y)}}}),this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,zr.POINTERDOWN|zr.POINTERUP|zr.POINTERMOVE),this._onLostFocus){const I=this.camera.getEngine().getInputElement();I&&I.addEventListener("blur",this._onLostFocus)}}detachControl(){if(this._pointerInput){if(this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null),this._onLostFocus){const _=this.camera.getEngine().getInputElement();_&&_.removeEventListener("blur",this._onLostFocus),this._onLostFocus=null}this._pointerPressed.length=0,this._offsetX=null,this._offsetY=null}}checkInputs(){if(this._offsetX===null||this._offsetY===null||this._offsetX===0&&this._offsetY===0)return;const p=this.camera,_=p._calculateHandednessMultiplier();if(p.cameraRotation.y=_*this._offsetX/this.touchAngularSensibility,this.singleFingerRotate&&this._pointerPressed.length===1||!this.singleFingerRotate&&this._pointerPressed.length>1)p.cameraRotation.x=-this._offsetY/this.touchAngularSensibility;else{const I=p._computeLocalCameraSpeed(),Z=new at(0,0,this.touchMoveSensibility!==0?I*this._offsetY/this.touchMoveSensibility:0);jt.RotationYawPitchRollToRef(p.rotation.y,p.rotation.x,0,p._cameraRotationMatrix),p.cameraDirection.addInPlace(at.TransformCoordinates(Z,p._cameraRotationMatrix))}}getClassName(){return"FreeCameraTouchInput"}getSimpleName(){return"touch"}}Rt([Ut()],Wm.prototype,"touchAngularSensibility",void 0),Rt([Ut()],Wm.prototype,"touchMoveSensibility",void 0),k2.FreeCameraTouchInput=Wm;class xb extends ab{constructor(p){super(p),this._mouseInput=null,this._mouseWheelInput=null}addKeyboard(){return this.add(new Go),this}addMouse(p=!0){return this._mouseInput||(this._mouseInput=new Gm(p),this.add(this._mouseInput)),this}removeMouse(){return this._mouseInput&&this.remove(this._mouseInput),this}addMouseWheel(){return this._mouseWheelInput||(this._mouseWheelInput=new U2,this.add(this._mouseWheelInput)),this}removeMouseWheel(){return this._mouseWheelInput&&this.remove(this._mouseWheelInput),this}addTouch(){return this.add(new Wm),this}clear(){super.clear(),this._mouseInput=null}}class cu extends $0{get angularSensibility(){const p=this.inputs.attached.mouse;return p?p.angularSensibility:0}set angularSensibility(p){const _=this.inputs.attached.mouse;_&&(_.angularSensibility=p)}get keysUp(){const p=this.inputs.attached.keyboard;return p?p.keysUp:[]}set keysUp(p){const _=this.inputs.attached.keyboard;_&&(_.keysUp=p)}get keysUpward(){const p=this.inputs.attached.keyboard;return p?p.keysUpward:[]}set keysUpward(p){const _=this.inputs.attached.keyboard;_&&(_.keysUpward=p)}get keysDown(){const p=this.inputs.attached.keyboard;return p?p.keysDown:[]}set keysDown(p){const _=this.inputs.attached.keyboard;_&&(_.keysDown=p)}get keysDownward(){const p=this.inputs.attached.keyboard;return p?p.keysDownward:[]}set keysDownward(p){const _=this.inputs.attached.keyboard;_&&(_.keysDownward=p)}get keysLeft(){const p=this.inputs.attached.keyboard;return p?p.keysLeft:[]}set keysLeft(p){const _=this.inputs.attached.keyboard;_&&(_.keysLeft=p)}get keysRight(){const p=this.inputs.attached.keyboard;return p?p.keysRight:[]}set keysRight(p){const _=this.inputs.attached.keyboard;_&&(_.keysRight=p)}get keysRotateLeft(){const p=this.inputs.attached.keyboard;return p?p.keysRotateLeft:[]}set keysRotateLeft(p){const _=this.inputs.attached.keyboard;_&&(_.keysRotateLeft=p)}get keysRotateRight(){const p=this.inputs.attached.keyboard;return p?p.keysRotateRight:[]}set keysRotateRight(p){const _=this.inputs.attached.keyboard;_&&(_.keysRotateRight=p)}get keysRotateUp(){const p=this.inputs.attached.keyboard;return p?p.keysRotateUp:[]}set keysRotateUp(p){const _=this.inputs.attached.keyboard;_&&(_.keysRotateUp=p)}get keysRotateDown(){const p=this.inputs.attached.keyboard;return p?p.keysRotateDown:[]}set keysRotateDown(p){const _=this.inputs.attached.keyboard;_&&(_.keysRotateDown=p)}constructor(p,_,E,I=!0){super(p,_,E,I),this.ellipsoid=new at(.5,1,.5),this.ellipsoidOffset=new at(0,0,0),this.checkCollisions=!1,this.applyGravity=!1,this._needMoveForGravity=!1,this._oldPosition=at.Zero(),this._diffPosition=at.Zero(),this._newPosition=at.Zero(),this._collisionMask=-1,this._onCollisionPositionChange=(Z,re,ae=null)=>{this._newPosition.copyFrom(re),this._newPosition.subtractToRef(this._oldPosition,this._diffPosition),this._diffPosition.length()>ci.CollisionsEpsilon&&(this.position.addToRef(this._diffPosition,this._deferredPositionUpdate),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate),this.onCollide&&ae&&this.onCollide(ae))},this.inputs=new xb(this),this.inputs.addKeyboard().addMouse()}attachControl(p,_){_=lt.BackCompatCameraNoPreventDefault(arguments),this.inputs.attachElement(_)}detachControl(){this.inputs.detachElement(),this.cameraDirection=new at(0,0,0),this.cameraRotation=new xr(0,0)}get collisionMask(){return this._collisionMask}set collisionMask(p){this._collisionMask=isNaN(p)?-1:p}_collideWithWorld(p){let _;this.parent?_=at.TransformCoordinates(this.position,this.parent.getWorldMatrix()):_=this.position,_.subtractFromFloatsToRef(0,this.ellipsoid.y,0,this._oldPosition),this._oldPosition.addInPlace(this.ellipsoidOffset);const E=this.getScene().collisionCoordinator;this._collider||(this._collider=E.createCollider()),this._collider._radius=this.ellipsoid,this._collider.collisionMask=this._collisionMask;let I=p;this.applyGravity&&(I=p.add(this.getScene().gravity)),E.getNewPosition(this._oldPosition,I,this._collider,3,null,this._onCollisionPositionChange,this.uniqueId)}_checkInputs(){this._localDirection||(this._localDirection=at.Zero(),this._transformedDirection=at.Zero()),this.inputs.checkInputs(),super._checkInputs()}set needMoveForGravity(p){this._needMoveForGravity=p}get needMoveForGravity(){return this._needMoveForGravity}_decideIfNeedsToMove(){return this._needMoveForGravity||Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0}_updatePosition(){this.checkCollisions&&this.getScene().collisionsEnabled?this._collideWithWorld(this.cameraDirection):super._updatePosition()}dispose(){this.inputs.clear(),super.dispose()}getClassName(){return"FreeCamera"}}Rt([Yn()],cu.prototype,"ellipsoid",void 0),Rt([Yn()],cu.prototype,"ellipsoidOffset",void 0),Rt([Ut()],cu.prototype,"checkCollisions",void 0),Rt([Ut()],cu.prototype,"applyGravity",void 0),Ha.AddNodeConstructor("TouchCamera",(pe,p)=>()=>new lb(pe,at.Zero(),p));class lb extends cu{get touchAngularSensibility(){const p=this.inputs.attached.touch;return p?p.touchAngularSensibility:0}set touchAngularSensibility(p){const _=this.inputs.attached.touch;_&&(_.touchAngularSensibility=p)}get touchMoveSensibility(){const p=this.inputs.attached.touch;return p?p.touchMoveSensibility:0}set touchMoveSensibility(p){const _=this.inputs.attached.touch;_&&(_.touchMoveSensibility=p)}constructor(p,_,E){super(p,_,E),this.inputs.addTouch(),this._setupInputs()}getClassName(){return"TouchCamera"}_setupInputs(){const p=this.inputs.attached.touch,_=this.inputs.attached.mouse;_?_.touchEnabled=!1:p.allowMouse=!0}}class jL{constructor(p,_){this.x=p,this.y=_}}class rx{get isConnected(){return this._isConnected}constructor(p,_,E,I=0,Z=1,re=2,ae=3){this.id=p,this.index=_,this.browserGamepad=E,this._leftStick={x:0,y:0},this._rightStick={x:0,y:0},this._isConnected=!0,this._invertLeftStickY=!1,this.type=rx.GAMEPAD,this._leftStickAxisX=I,this._leftStickAxisY=Z,this._rightStickAxisX=re,this._rightStickAxisY=ae,this.browserGamepad.axes.length>=2&&(this._leftStick={x:this.browserGamepad.axes[this._leftStickAxisX],y:this.browserGamepad.axes[this._leftStickAxisY]}),this.browserGamepad.axes.length>=4&&(this._rightStick={x:this.browserGamepad.axes[this._rightStickAxisX],y:this.browserGamepad.axes[this._rightStickAxisY]})}onleftstickchanged(p){this._onleftstickchanged=p}onrightstickchanged(p){this._onrightstickchanged=p}get leftStick(){return this._leftStick}set leftStick(p){this._onleftstickchanged&&(this._leftStick.x!==p.x||this._leftStick.y!==p.y)&&this._onleftstickchanged(p),this._leftStick=p}get rightStick(){return this._rightStick}set rightStick(p){this._onrightstickchanged&&(this._rightStick.x!==p.x||this._rightStick.y!==p.y)&&this._onrightstickchanged(p),this._rightStick=p}update(){this._leftStick&&(this.leftStick={x:this.browserGamepad.axes[this._leftStickAxisX],y:this.browserGamepad.axes[this._leftStickAxisY]},this._invertLeftStickY&&(this.leftStick.y*=-1)),this._rightStick&&(this.rightStick={x:this.browserGamepad.axes[this._rightStickAxisX],y:this.browserGamepad.axes[this._rightStickAxisY]})}dispose(){}}rx.GAMEPAD=0,rx.GENERIC=1,rx.XBOX=2,rx.POSE_ENABLED=3,rx.DUALSHOCK=4;class qM extends rx{onbuttondown(p){this._onbuttondown=p}onbuttonup(p){this._onbuttonup=p}constructor(p,_,E){super(p,_,E),this.onButtonDownObservable=new Ri,this.onButtonUpObservable=new Ri,this.type=rx.GENERIC,this._buttons=new Array(E.buttons.length)}_setButtonValue(p,_,E){return p!==_&&(p===1&&(this._onbuttondown&&this._onbuttondown(E),this.onButtonDownObservable.notifyObservers(E)),p===0&&(this._onbuttonup&&this._onbuttonup(E),this.onButtonUpObservable.notifyObservers(E))),p}update(){super.update();for(let p=0;p<this._buttons.length;p++)this._buttons[p]=this._setButtonValue(this.browserGamepad.buttons[p].value,this._buttons[p],p)}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear()}}var a2;(function(pe){pe[pe.A=0]="A",pe[pe.B=1]="B",pe[pe.X=2]="X",pe[pe.Y=3]="Y",pe[pe.LB=4]="LB",pe[pe.RB=5]="RB",pe[pe.Back=8]="Back",pe[pe.Start=9]="Start",pe[pe.LeftStick=10]="LeftStick",pe[pe.RightStick=11]="RightStick"})(a2||(a2={}));var uu;(function(pe){pe[pe.Up=12]="Up",pe[pe.Down=13]="Down",pe[pe.Left=14]="Left",pe[pe.Right=15]="Right"})(uu||(uu={}));class $M extends rx{constructor(p,_,E,I=!1){super(p,_,E,0,1,2,3),this._leftTrigger=0,this._rightTrigger=0,this.onButtonDownObservable=new Ri,this.onButtonUpObservable=new Ri,this.onPadDownObservable=new Ri,this.onPadUpObservable=new Ri,this._buttonA=0,this._buttonB=0,this._buttonX=0,this._buttonY=0,this._buttonBack=0,this._buttonStart=0,this._buttonLB=0,this._buttonRB=0,this._buttonLeftStick=0,this._buttonRightStick=0,this._dPadUp=0,this._dPadDown=0,this._dPadLeft=0,this._dPadRight=0,this._isXboxOnePad=!1,this.type=rx.XBOX,this._isXboxOnePad=I}onlefttriggerchanged(p){this._onlefttriggerchanged=p}onrighttriggerchanged(p){this._onrighttriggerchanged=p}get leftTrigger(){return this._leftTrigger}set leftTrigger(p){this._onlefttriggerchanged&&this._leftTrigger!==p&&this._onlefttriggerchanged(p),this._leftTrigger=p}get rightTrigger(){return this._rightTrigger}set rightTrigger(p){this._onrighttriggerchanged&&this._rightTrigger!==p&&this._onrighttriggerchanged(p),this._rightTrigger=p}onbuttondown(p){this._onbuttondown=p}onbuttonup(p){this._onbuttonup=p}ondpaddown(p){this._ondpaddown=p}ondpadup(p){this._ondpadup=p}_setButtonValue(p,_,E){return p!==_&&(p===1&&(this._onbuttondown&&this._onbuttondown(E),this.onButtonDownObservable.notifyObservers(E)),p===0&&(this._onbuttonup&&this._onbuttonup(E),this.onButtonUpObservable.notifyObservers(E))),p}_setDPadValue(p,_,E){return p!==_&&(p===1&&(this._ondpaddown&&this._ondpaddown(E),this.onPadDownObservable.notifyObservers(E)),p===0&&(this._ondpadup&&this._ondpadup(E),this.onPadUpObservable.notifyObservers(E))),p}get buttonA(){return this._buttonA}set buttonA(p){this._buttonA=this._setButtonValue(p,this._buttonA,a2.A)}get buttonB(){return this._buttonB}set buttonB(p){this._buttonB=this._setButtonValue(p,this._buttonB,a2.B)}get buttonX(){return this._buttonX}set buttonX(p){this._buttonX=this._setButtonValue(p,this._buttonX,a2.X)}get buttonY(){return this._buttonY}set buttonY(p){this._buttonY=this._setButtonValue(p,this._buttonY,a2.Y)}get buttonStart(){return this._buttonStart}set buttonStart(p){this._buttonStart=this._setButtonValue(p,this._buttonStart,a2.Start)}get buttonBack(){return this._buttonBack}set buttonBack(p){this._buttonBack=this._setButtonValue(p,this._buttonBack,a2.Back)}get buttonLB(){return this._buttonLB}set buttonLB(p){this._buttonLB=this._setButtonValue(p,this._buttonLB,a2.LB)}get buttonRB(){return this._buttonRB}set buttonRB(p){this._buttonRB=this._setButtonValue(p,this._buttonRB,a2.RB)}get buttonLeftStick(){return this._buttonLeftStick}set buttonLeftStick(p){this._buttonLeftStick=this._setButtonValue(p,this._buttonLeftStick,a2.LeftStick)}get buttonRightStick(){return this._buttonRightStick}set buttonRightStick(p){this._buttonRightStick=this._setButtonValue(p,this._buttonRightStick,a2.RightStick)}get dPadUp(){return this._dPadUp}set dPadUp(p){this._dPadUp=this._setDPadValue(p,this._dPadUp,uu.Up)}get dPadDown(){return this._dPadDown}set dPadDown(p){this._dPadDown=this._setDPadValue(p,this._dPadDown,uu.Down)}get dPadLeft(){return this._dPadLeft}set dPadLeft(p){this._dPadLeft=this._setDPadValue(p,this._dPadLeft,uu.Left)}get dPadRight(){return this._dPadRight}set dPadRight(p){this._dPadRight=this._setDPadValue(p,this._dPadRight,uu.Right)}update(){super.update(),this._isXboxOnePad?(this.buttonA=this.browserGamepad.buttons[0].value,this.buttonB=this.browserGamepad.buttons[1].value,this.buttonX=this.browserGamepad.buttons[2].value,this.buttonY=this.browserGamepad.buttons[3].value,this.buttonLB=this.browserGamepad.buttons[4].value,this.buttonRB=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonBack=this.browserGamepad.buttons[8].value,this.buttonStart=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value):(this.buttonA=this.browserGamepad.buttons[0].value,this.buttonB=this.browserGamepad.buttons[1].value,this.buttonX=this.browserGamepad.buttons[2].value,this.buttonY=this.browserGamepad.buttons[3].value,this.buttonLB=this.browserGamepad.buttons[4].value,this.buttonRB=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonBack=this.browserGamepad.buttons[8].value,this.buttonStart=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value)}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear(),this.onPadDownObservable.clear(),this.onPadUpObservable.clear()}}var x2;(function(pe){pe[pe.Cross=0]="Cross",pe[pe.Circle=1]="Circle",pe[pe.Square=2]="Square",pe[pe.Triangle=3]="Triangle",pe[pe.L1=4]="L1",pe[pe.R1=5]="R1",pe[pe.Share=8]="Share",pe[pe.Options=9]="Options",pe[pe.LeftStick=10]="LeftStick",pe[pe.RightStick=11]="RightStick"})(x2||(x2={}));var pu;(function(pe){pe[pe.Up=12]="Up",pe[pe.Down=13]="Down",pe[pe.Left=14]="Left",pe[pe.Right=15]="Right"})(pu||(pu={}));class rO extends rx{constructor(p,_,E){super(p.replace("STANDARD GAMEPAD","SONY PLAYSTATION DUALSHOCK"),_,E,0,1,2,3),this._leftTrigger=0,this._rightTrigger=0,this.onButtonDownObservable=new Ri,this.onButtonUpObservable=new Ri,this.onPadDownObservable=new Ri,this.onPadUpObservable=new Ri,this._buttonCross=0,this._buttonCircle=0,this._buttonSquare=0,this._buttonTriangle=0,this._buttonShare=0,this._buttonOptions=0,this._buttonL1=0,this._buttonR1=0,this._buttonLeftStick=0,this._buttonRightStick=0,this._dPadUp=0,this._dPadDown=0,this._dPadLeft=0,this._dPadRight=0,this.type=rx.DUALSHOCK}onlefttriggerchanged(p){this._onlefttriggerchanged=p}onrighttriggerchanged(p){this._onrighttriggerchanged=p}get leftTrigger(){return this._leftTrigger}set leftTrigger(p){this._onlefttriggerchanged&&this._leftTrigger!==p&&this._onlefttriggerchanged(p),this._leftTrigger=p}get rightTrigger(){return this._rightTrigger}set rightTrigger(p){this._onrighttriggerchanged&&this._rightTrigger!==p&&this._onrighttriggerchanged(p),this._rightTrigger=p}onbuttondown(p){this._onbuttondown=p}onbuttonup(p){this._onbuttonup=p}ondpaddown(p){this._ondpaddown=p}ondpadup(p){this._ondpadup=p}_setButtonValue(p,_,E){return p!==_&&(p===1&&(this._onbuttondown&&this._onbuttondown(E),this.onButtonDownObservable.notifyObservers(E)),p===0&&(this._onbuttonup&&this._onbuttonup(E),this.onButtonUpObservable.notifyObservers(E))),p}_setDPadValue(p,_,E){return p!==_&&(p===1&&(this._ondpaddown&&this._ondpaddown(E),this.onPadDownObservable.notifyObservers(E)),p===0&&(this._ondpadup&&this._ondpadup(E),this.onPadUpObservable.notifyObservers(E))),p}get buttonCross(){return this._buttonCross}set buttonCross(p){this._buttonCross=this._setButtonValue(p,this._buttonCross,x2.Cross)}get buttonCircle(){return this._buttonCircle}set buttonCircle(p){this._buttonCircle=this._setButtonValue(p,this._buttonCircle,x2.Circle)}get buttonSquare(){return this._buttonSquare}set buttonSquare(p){this._buttonSquare=this._setButtonValue(p,this._buttonSquare,x2.Square)}get buttonTriangle(){return this._buttonTriangle}set buttonTriangle(p){this._buttonTriangle=this._setButtonValue(p,this._buttonTriangle,x2.Triangle)}get buttonOptions(){return this._buttonOptions}set buttonOptions(p){this._buttonOptions=this._setButtonValue(p,this._buttonOptions,x2.Options)}get buttonShare(){return this._buttonShare}set buttonShare(p){this._buttonShare=this._setButtonValue(p,this._buttonShare,x2.Share)}get buttonL1(){return this._buttonL1}set buttonL1(p){this._buttonL1=this._setButtonValue(p,this._buttonL1,x2.L1)}get buttonR1(){return this._buttonR1}set buttonR1(p){this._buttonR1=this._setButtonValue(p,this._buttonR1,x2.R1)}get buttonLeftStick(){return this._buttonLeftStick}set buttonLeftStick(p){this._buttonLeftStick=this._setButtonValue(p,this._buttonLeftStick,x2.LeftStick)}get buttonRightStick(){return this._buttonRightStick}set buttonRightStick(p){this._buttonRightStick=this._setButtonValue(p,this._buttonRightStick,x2.RightStick)}get dPadUp(){return this._dPadUp}set dPadUp(p){this._dPadUp=this._setDPadValue(p,this._dPadUp,pu.Up)}get dPadDown(){return this._dPadDown}set dPadDown(p){this._dPadDown=this._setDPadValue(p,this._dPadDown,pu.Down)}get dPadLeft(){return this._dPadLeft}set dPadLeft(p){this._dPadLeft=this._setDPadValue(p,this._dPadLeft,pu.Left)}get dPadRight(){return this._dPadRight}set dPadRight(p){this._dPadRight=this._setDPadValue(p,this._dPadRight,pu.Right)}update(){super.update(),this.buttonCross=this.browserGamepad.buttons[0].value,this.buttonCircle=this.browserGamepad.buttons[1].value,this.buttonSquare=this.browserGamepad.buttons[2].value,this.buttonTriangle=this.browserGamepad.buttons[3].value,this.buttonL1=this.browserGamepad.buttons[4].value,this.buttonR1=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonShare=this.browserGamepad.buttons[8].value,this.buttonOptions=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear(),this.onPadDownObservable.clear(),this.onPadUpObservable.clear()}}class nO{constructor(p){if(this._scene=p,this._babylonGamepads=[],this._oneGamepadConnected=!1,this._isMonitoring=!1,this.onGamepadDisconnectedObservable=new Ri,va()?(this._gamepadEventSupported="GamepadEvent"in window,this._gamepadSupport=navigator&&navigator.getGamepads):this._gamepadEventSupported=!1,this.onGamepadConnectedObservable=new Ri(_=>{for(const E in this._babylonGamepads){const I=this._babylonGamepads[E];I&&I._isConnected&&this.onGamepadConnectedObservable.notifyObserver(_,I)}}),this._onGamepadConnectedEvent=_=>{const E=_.gamepad;if(E.index in this._babylonGamepads&&this._babylonGamepads[E.index].isConnected)return;let I;this._babylonGamepads[E.index]?(I=this._babylonGamepads[E.index],I.browserGamepad=E,I._isConnected=!0):I=this._addNewGamepad(E),this.onGamepadConnectedObservable.notifyObservers(I),this._startMonitoringGamepads()},this._onGamepadDisconnectedEvent=_=>{const E=_.gamepad;for(const I in this._babylonGamepads)if(this._babylonGamepads[I].index===E.index){const Z=this._babylonGamepads[I];Z._isConnected=!1,this.onGamepadDisconnectedObservable.notifyObservers(Z),Z.dispose&&Z.dispose();break}},this._gamepadSupport)if(this._updateGamepadObjects(),this._babylonGamepads.length&&this._startMonitoringGamepads(),this._gamepadEventSupported){const _=this._scene?this._scene.getEngine().getHostWindow():window;_&&(_.addEventListener("gamepadconnected",this._onGamepadConnectedEvent,!1),_.addEventListener("gamepaddisconnected",this._onGamepadDisconnectedEvent,!1))}else this._startMonitoringGamepads()}get gamepads(){return this._babylonGamepads}getGamepadByType(p=rx.XBOX){for(const _ of this._babylonGamepads)if(_&&_.type===p)return _;return null}dispose(){this._gamepadEventSupported&&(this._onGamepadConnectedEvent&&window.removeEventListener("gamepadconnected",this._onGamepadConnectedEvent),this._onGamepadDisconnectedEvent&&window.removeEventListener("gamepaddisconnected",this._onGamepadDisconnectedEvent),this._onGamepadConnectedEvent=null,this._onGamepadDisconnectedEvent=null),this._babylonGamepads.forEach(p=>{p.dispose()}),this.onGamepadConnectedObservable.clear(),this.onGamepadDisconnectedObservable.clear(),this._oneGamepadConnected=!1,this._stopMonitoringGamepads(),this._babylonGamepads=[]}_addNewGamepad(p){this._oneGamepadConnected||(this._oneGamepadConnected=!0);let _;const E=p.id.search("054c")!==-1&&p.id.search("0ce6")===-1,I=p.id.search("Xbox One")!==-1;return I||p.id.search("Xbox 360")!==-1||p.id.search("xinput")!==-1||p.id.search("045e")!==-1&&p.id.search("Surface Dock")===-1?_=new $M(p.id,p.index,p,I):E?_=new rO(p.id,p.index,p):_=new qM(p.id,p.index,p),this._babylonGamepads[_.index]=_,_}_startMonitoringGamepads(){this._isMonitoring||(this._isMonitoring=!0,this._checkGamepadsStatus())}_stopMonitoringGamepads(){this._isMonitoring=!1}_checkGamepadsStatus(){this._updateGamepadObjects();for(const p in this._babylonGamepads){const _=this._babylonGamepads[p];if(!(!_||!_.isConnected))try{_.update()}catch{this._loggedErrors.indexOf(_.index)===-1&&(lt.Warn(`Error updating gamepad ${_.id}`),this._loggedErrors.push(_.index))}}this._isMonitoring&&ci.QueueNewFrame(()=>{this._checkGamepadsStatus()})}_updateGamepadObjects(){const p=navigator.getGamepads?navigator.getGamepads():[];for(let _=0;_<p.length;_++){const E=p[_];if(E)if(this._babylonGamepads[E.index])this._babylonGamepads[_].browserGamepad=E,this._babylonGamepads[_].isConnected||(this._babylonGamepads[_]._isConnected=!0,this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[_]));else{const I=this._addNewGamepad(E);this.onGamepadConnectedObservable.notifyObservers(I)}}}}class Hm{constructor(){this.gamepadAngularSensibility=200,this.gamepadMoveSensibility=40,this.deadzoneDelta=.1,this._yAxisScale=1,this._cameraTransform=jt.Identity(),this._deltaTransform=at.Zero(),this._vector3=at.Zero(),this._vector2=xr.Zero()}get invertYAxis(){return this._yAxisScale!==1}set invertYAxis(p){this._yAxisScale=p?-1:1}attachControl(){const p=this.camera.getScene().gamepadManager;this._onGamepadConnectedObserver=p.onGamepadConnectedObservable.add(_=>{_.type!==rx.POSE_ENABLED&&(!this.gamepad||_.type===rx.XBOX)&&(this.gamepad=_)}),this._onGamepadDisconnectedObserver=p.onGamepadDisconnectedObservable.add(_=>{this.gamepad===_&&(this.gamepad=null)}),this.gamepad=p.getGamepadByType(rx.XBOX),!this.gamepad&&p.gamepads.length&&(this.gamepad=p.gamepads[0])}detachControl(){this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver),this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver),this.gamepad=null}checkInputs(){if(this.gamepad&&this.gamepad.leftStick){const p=this.camera,_=this.gamepad.leftStick;this.gamepadMoveSensibility!==0&&(_.x=Math.abs(_.x)>this.deadzoneDelta?_.x/this.gamepadMoveSensibility:0,_.y=Math.abs(_.y)>this.deadzoneDelta?_.y/this.gamepadMoveSensibility:0);let E=this.gamepad.rightStick;E&&this.gamepadAngularSensibility!==0?(E.x=Math.abs(E.x)>this.deadzoneDelta?E.x/this.gamepadAngularSensibility:0,E.y=(Math.abs(E.y)>this.deadzoneDelta?E.y/this.gamepadAngularSensibility:0)*this._yAxisScale):E={x:0,y:0},p.rotationQuaternion?p.rotationQuaternion.toRotationMatrix(this._cameraTransform):jt.RotationYawPitchRollToRef(p.rotation.y,p.rotation.x,0,this._cameraTransform);const I=p._computeLocalCameraSpeed()*50;this._vector3.copyFromFloats(_.x*I,0,-_.y*I),at.TransformCoordinatesToRef(this._vector3,this._cameraTransform,this._deltaTransform),p.cameraDirection.addInPlace(this._deltaTransform),this._vector2.copyFromFloats(E.y,E.x),p.cameraRotation.addInPlace(this._vector2)}}getClassName(){return"FreeCameraGamepadInput"}getSimpleName(){return"gamepad"}}Rt([Ut()],Hm.prototype,"gamepadAngularSensibility",void 0),Rt([Ut()],Hm.prototype,"gamepadMoveSensibility",void 0),k2.FreeCameraGamepadInput=Hm;class hb{constructor(){this._currentActiveButton=-1,this.buttons=[0,1,2]}attachControl(p){p=lt.BackCompatCameraNoPreventDefault(arguments);const _=this.camera.getEngine(),E=_.getInputElement();let I=0,Z=null;this._pointA=null,this._pointB=null,this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._pointerInput=ae=>{const he=ae.event,_e=he.pointerType==="touch";if(ae.type!==zr.POINTERMOVE&&this.buttons.indexOf(he.button)===-1)return;const ve=he.target;if(this._altKey=he.altKey,this._ctrlKey=he.ctrlKey,this._metaKey=he.metaKey,this._shiftKey=he.shiftKey,this._buttonsPressed=he.buttons,_.isPointerLock){const Le=he.movementX,ze=he.movementY;this.onTouch(null,Le,ze),this._pointA=null,this._pointB=null}else{if(ae.type!==zr.POINTERDOWN&&_e&&this._pointA?.pointerId!==he.pointerId&&this._pointB?.pointerId!==he.pointerId)return;if(ae.type===zr.POINTERDOWN&&(this._currentActiveButton===-1||_e)){try{ve?.setPointerCapture(he.pointerId)}catch{}if(this._pointA===null)this._pointA={x:he.clientX,y:he.clientY,pointerId:he.pointerId,type:he.pointerType};else if(this._pointB===null)this._pointB={x:he.clientX,y:he.clientY,pointerId:he.pointerId,type:he.pointerType};else return;this._currentActiveButton===-1&&!_e&&(this._currentActiveButton=he.button),this.onButtonDown(he),p||(he.preventDefault(),E&&E.focus())}else if(ae.type===zr.POINTERDOUBLETAP)this.onDoubleTap(he.pointerType);else if(ae.type===zr.POINTERUP&&(this._currentActiveButton===he.button||_e)){try{ve?.releasePointerCapture(he.pointerId)}catch{}_e||(this._pointB=null),_._badOS?this._pointA=this._pointB=null:this._pointB&&this._pointA&&this._pointA.pointerId==he.pointerId?(this._pointA=this._pointB,this._pointB=null):this._pointA&&this._pointB&&this._pointB.pointerId==he.pointerId?this._pointB=null:this._pointA=this._pointB=null,(I!==0||Z)&&(this.onMultiTouch(this._pointA,this._pointB,I,0,Z,null),I=0,Z=null),this._currentActiveButton=-1,this.onButtonUp(he),p||he.preventDefault()}else if(ae.type===zr.POINTERMOVE){if(p||he.preventDefault(),this._pointA&&this._pointB===null){const Le=he.clientX-this._pointA.x,ze=he.clientY-this._pointA.y;this.onTouch(this._pointA,Le,ze),this._pointA.x=he.clientX,this._pointA.y=he.clientY}else if(this._pointA&&this._pointB){const Le=this._pointA.pointerId===he.pointerId?this._pointA:this._pointB;Le.x=he.clientX,Le.y=he.clientY;const ze=this._pointA.x-this._pointB.x,He=this._pointA.y-this._pointB.y,xt=ze*ze+He*He,rt={x:(this._pointA.x+this._pointB.x)/2,y:(this._pointA.y+this._pointB.y)/2,pointerId:he.pointerId,type:ae.type};this.onMultiTouch(this._pointA,this._pointB,I,xt,Z,rt),Z=rt,I=xt}}}},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,zr.POINTERDOWN|zr.POINTERUP|zr.POINTERMOVE|zr.POINTERDOUBLETAP),this._onLostFocus=()=>{this._pointA=this._pointB=null,I=0,Z=null,this.onLostFocus()},this._contextMenuBind=ae=>this.onContextMenu(ae),E&&E.addEventListener("contextmenu",this._contextMenuBind,!1);const re=this.camera.getScene().getEngine().getHostWindow();re&&lt.RegisterTopRootEvents(re,[{name:"blur",handler:this._onLostFocus}])}detachControl(){if(this._onLostFocus){const p=this.camera.getScene().getEngine().getHostWindow();p&&lt.UnregisterTopRootEvents(p,[{name:"blur",handler:this._onLostFocus}])}if(this._observer){if(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._contextMenuBind){const p=this.camera.getScene().getEngine().getInputElement();p&&p.removeEventListener("contextmenu",this._contextMenuBind)}this._onLostFocus=null}this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._currentActiveButton=-1}getClassName(){return"BaseCameraPointersInput"}getSimpleName(){return"pointers"}onDoubleTap(p){}onTouch(p,_,E){}onMultiTouch(p,_,E,I,Z,re){}onContextMenu(p){p.preventDefault()}onButtonDown(p){}onButtonUp(p){}onLostFocus(){}}Rt([Ut()],hb.prototype,"buttons",void 0);class jx extends hb{constructor(){super(...arguments),this.buttons=[0,1,2],this.angularSensibilityX=1e3,this.angularSensibilityY=1e3,this.pinchPrecision=12,this.pinchDeltaPercentage=0,this.useNaturalPinchZoom=!1,this.pinchZoom=!0,this.panningSensibility=1e3,this.multiTouchPanning=!0,this.multiTouchPanAndZoom=!0,this.pinchInwards=!0,this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}getClassName(){return"ArcRotateCameraPointersInput"}_computeMultiTouchPanning(p,_){if(this.panningSensibility!==0&&p&&_){const E=_.x-p.x,I=_.y-p.y;this.camera.inertialPanningX+=-E/this.panningSensibility,this.camera.inertialPanningY+=I/this.panningSensibility}}_computePinchZoom(p,_){const E=this.camera.radius||jx.MinimumRadiusForPinch;this.useNaturalPinchZoom?this.camera.radius=E*Math.sqrt(p)/Math.sqrt(_):this.pinchDeltaPercentage?this.camera.inertialRadiusOffset+=(_-p)*.001*E*this.pinchDeltaPercentage:this.camera.inertialRadiusOffset+=(_-p)/(this.pinchPrecision*(this.pinchInwards?1:-1)*(this.angularSensibilityX+this.angularSensibilityY)/2)}onTouch(p,_,E){this.panningSensibility!==0&&(this._ctrlKey&&this.camera._useCtrlForPanning||this._isPanClick)?(this.camera.inertialPanningX+=-_/this.panningSensibility,this.camera.inertialPanningY+=E/this.panningSensibility):(this.camera.inertialAlphaOffset-=_/this.angularSensibilityX,this.camera.inertialBetaOffset-=E/this.angularSensibilityY)}onDoubleTap(){this.camera.useInputToRestoreState&&this.camera.restoreState()}onMultiTouch(p,_,E,I,Z,re){E===0&&Z===null||I===0&&re===null||(this.multiTouchPanAndZoom?(this._computePinchZoom(E,I),this._computeMultiTouchPanning(Z,re)):this.multiTouchPanning&&this.pinchZoom?(this._twoFingerActivityCount++,this._isPinching||this._twoFingerActivityCount<20&&Math.abs(Math.sqrt(I)-Math.sqrt(E))>this.camera.pinchToPanMaxDistance?(this._computePinchZoom(E,I),this._isPinching=!0):this._computeMultiTouchPanning(Z,re)):this.multiTouchPanning?this._computeMultiTouchPanning(Z,re):this.pinchZoom&&this._computePinchZoom(E,I))}onButtonDown(p){this._isPanClick=p.button===this.camera._panningMouseButton}onButtonUp(p){this._twoFingerActivityCount=0,this._isPinching=!1}onLostFocus(){this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}}jx.MinimumRadiusForPinch=.001,Rt([Ut()],jx.prototype,"buttons",void 0),Rt([Ut()],jx.prototype,"angularSensibilityX",void 0),Rt([Ut()],jx.prototype,"angularSensibilityY",void 0),Rt([Ut()],jx.prototype,"pinchPrecision",void 0),Rt([Ut()],jx.prototype,"pinchDeltaPercentage",void 0),Rt([Ut()],jx.prototype,"useNaturalPinchZoom",void 0),Rt([Ut()],jx.prototype,"pinchZoom",void 0),Rt([Ut()],jx.prototype,"panningSensibility",void 0),Rt([Ut()],jx.prototype,"multiTouchPanning",void 0),Rt([Ut()],jx.prototype,"multiTouchPanAndZoom",void 0),k2.ArcRotateCameraPointersInput=jx;class G2{constructor(){this.keysUp=[38],this.keysDown=[40],this.keysLeft=[37],this.keysRight=[39],this.keysReset=[220],this.panningSensibility=50,this.zoomingSensibility=25,this.useAltToZoom=!0,this.angularSpeed=.01,this._keys=new Array}attachControl(p){p=lt.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(_=>{const E=_.event;if(!E.metaKey){if(_.type===lu.KEYDOWN)this._ctrlPressed=E.ctrlKey,this._altPressed=E.altKey,(this.keysUp.indexOf(E.keyCode)!==-1||this.keysDown.indexOf(E.keyCode)!==-1||this.keysLeft.indexOf(E.keyCode)!==-1||this.keysRight.indexOf(E.keyCode)!==-1||this.keysReset.indexOf(E.keyCode)!==-1)&&(this._keys.indexOf(E.keyCode)===-1&&this._keys.push(E.keyCode),E.preventDefault&&(p||E.preventDefault()));else if(this.keysUp.indexOf(E.keyCode)!==-1||this.keysDown.indexOf(E.keyCode)!==-1||this.keysLeft.indexOf(E.keyCode)!==-1||this.keysRight.indexOf(E.keyCode)!==-1||this.keysReset.indexOf(E.keyCode)!==-1){const I=this._keys.indexOf(E.keyCode);I>=0&&this._keys.splice(I,1),E.preventDefault&&(p||E.preventDefault())}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){if(this._onKeyboardObserver){const p=this.camera;for(let _=0;_<this._keys.length;_++){const E=this._keys[_];this.keysLeft.indexOf(E)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?p.inertialPanningX-=1/this.panningSensibility:p.inertialAlphaOffset-=this.angularSpeed:this.keysUp.indexOf(E)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?p.inertialPanningY+=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?p.inertialRadiusOffset+=1/this.zoomingSensibility:p.inertialBetaOffset-=this.angularSpeed:this.keysRight.indexOf(E)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?p.inertialPanningX+=1/this.panningSensibility:p.inertialAlphaOffset+=this.angularSpeed:this.keysDown.indexOf(E)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?p.inertialPanningY-=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?p.inertialRadiusOffset-=1/this.zoomingSensibility:p.inertialBetaOffset+=this.angularSpeed:this.keysReset.indexOf(E)!==-1&&p.useInputToRestoreState&&p.restoreState()}}}getClassName(){return"ArcRotateCameraKeyboardMoveInput"}getSimpleName(){return"keyboard"}}Rt([Ut()],G2.prototype,"keysUp",void 0),Rt([Ut()],G2.prototype,"keysDown",void 0),Rt([Ut()],G2.prototype,"keysLeft",void 0),Rt([Ut()],G2.prototype,"keysRight",void 0),Rt([Ut()],G2.prototype,"keysReset",void 0),Rt([Ut()],G2.prototype,"panningSensibility",void 0),Rt([Ut()],G2.prototype,"zoomingSensibility",void 0),Rt([Ut()],G2.prototype,"useAltToZoom",void 0),Rt([Ut()],G2.prototype,"angularSpeed",void 0),k2.ArcRotateCameraKeyboardMoveInput=G2;const aO=40;class Xp{constructor(){this.wheelPrecision=3,this.zoomToMouseLocation=!1,this.wheelDeltaPercentage=0,this.customComputeDeltaFromMouseWheel=null,this._viewOffset=new at(0,0,0),this._globalOffset=new at(0,0,0),this._inertialPanning=at.Zero()}_computeDeltaFromMouseWheelLegacyEvent(p,_){let E=0;const I=p*.01*this.wheelDeltaPercentage*_;return p>0?E=I/(1+this.wheelDeltaPercentage):E=I*(1+this.wheelDeltaPercentage),E}attachControl(p){p=lt.BackCompatCameraNoPreventDefault(arguments),this._wheel=_=>{if(_.type!==zr.POINTERWHEEL)return;const E=_.event;let I=0;const Z=E.deltaMode===hu.DOM_DELTA_LINE?aO:1,re=-(E.deltaY*Z);if(this.customComputeDeltaFromMouseWheel)I=this.customComputeDeltaFromMouseWheel(re,this,E);else if(this.wheelDeltaPercentage){if(I=this._computeDeltaFromMouseWheelLegacyEvent(re,this.camera.radius),I>0){let ae=this.camera.radius,he=this.camera.inertialRadiusOffset+I;for(let _e=0;_e<20&&Math.abs(he)>.001;_e++)ae-=he,he*=this.camera.inertia;ae=$t.Clamp(ae,0,Number.MAX_VALUE),I=this._computeDeltaFromMouseWheelLegacyEvent(re,ae)}}else I=re/(this.wheelPrecision*40);I&&(this.zoomToMouseLocation?(this._hitPlane||this._updateHitPlane(),this._zoomToMouse(I)):this.camera.inertialRadiusOffset+=I),E.preventDefault&&(p||E.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,zr.POINTERWHEEL),this.zoomToMouseLocation&&this._inertialPanning.setAll(0)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null)}checkInputs(){if(!this.zoomToMouseLocation)return;const p=this.camera;0+p.inertialAlphaOffset+p.inertialBetaOffset+p.inertialRadiusOffset&&(this._updateHitPlane(),p.target.addInPlace(this._inertialPanning),this._inertialPanning.scaleInPlace(p.inertia),this._zeroIfClose(this._inertialPanning))}getClassName(){return"ArcRotateCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}_updateHitPlane(){const p=this.camera,_=p.target.subtract(p.position);this._hitPlane=r2.FromPositionAndNormal(p.target,_)}_getPosition(){const p=this.camera,_=p.getScene(),E=_.createPickingRay(_.pointerX,_.pointerY,jt.Identity(),p,!1);(p.targetScreenOffset.x!==0||p.targetScreenOffset.y!==0)&&(this._viewOffset.set(p.targetScreenOffset.x,p.targetScreenOffset.y,0),p.getViewMatrix().invertToRef(p._cameraTransformMatrix),this._globalOffset=at.TransformNormal(this._viewOffset,p._cameraTransformMatrix),E.origin.addInPlace(this._globalOffset));let I=0;return this._hitPlane&&(I=E.intersectsPlane(this._hitPlane)??0),E.origin.addInPlace(E.direction.scaleInPlace(I))}_zoomToMouse(p){const _=this.camera,E=1-_.inertia;if(_.lowerRadiusLimit){const he=_.lowerRadiusLimit??0;_.radius-(_.inertialRadiusOffset+p)/E<he&&(p=(_.radius-he)*E-_.inertialRadiusOffset)}if(_.upperRadiusLimit){const he=_.upperRadiusLimit??0;_.radius-(_.inertialRadiusOffset+p)/E>he&&(p=(_.radius-he)*E-_.inertialRadiusOffset)}const Z=p/E/_.radius,re=this._getPosition(),ae=ui.Vector3[6];re.subtractToRef(_.target,ae),ae.scaleInPlace(Z),ae.scaleInPlace(E),this._inertialPanning.addInPlace(ae),_.inertialRadiusOffset+=p}_zeroIfClose(p){Math.abs(p.x)<ns&&(p.x=0),Math.abs(p.y)<ns&&(p.y=0),Math.abs(p.z)<ns&&(p.z=0)}}Rt([Ut()],Xp.prototype,"wheelPrecision",void 0),Rt([Ut()],Xp.prototype,"zoomToMouseLocation",void 0),Rt([Ut()],Xp.prototype,"wheelDeltaPercentage",void 0),k2.ArcRotateCameraMouseWheelInput=Xp;class xO extends ab{constructor(p){super(p)}addMouseWheel(){return this.add(new Xp),this}addPointers(){return this.add(new jx),this}addKeyboard(){return this.add(new G2),this}}class Xm{constructor(){this.gamepadRotationSensibility=80,this.gamepadMoveSensibility=40,this._yAxisScale=1}get invertYAxis(){return this._yAxisScale!==1}set invertYAxis(p){this._yAxisScale=p?-1:1}attachControl(){const p=this.camera.getScene().gamepadManager;this._onGamepadConnectedObserver=p.onGamepadConnectedObservable.add(_=>{_.type!==rx.POSE_ENABLED&&(!this.gamepad||_.type===rx.XBOX)&&(this.gamepad=_)}),this._onGamepadDisconnectedObserver=p.onGamepadDisconnectedObservable.add(_=>{this.gamepad===_&&(this.gamepad=null)}),this.gamepad=p.getGamepadByType(rx.XBOX),!this.gamepad&&p.gamepads.length&&(this.gamepad=p.gamepads[0])}detachControl(){this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver),this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver),this.gamepad=null}checkInputs(){if(this.gamepad){const p=this.camera,_=this.gamepad.rightStick;if(_){if(_.x!=0){const I=_.x/this.gamepadRotationSensibility;I!=0&&Math.abs(I)>.005&&(p.inertialAlphaOffset+=I)}if(_.y!=0){const I=_.y/this.gamepadRotationSensibility*this._yAxisScale;I!=0&&Math.abs(I)>.005&&(p.inertialBetaOffset+=I)}}const E=this.gamepad.leftStick;if(E&&E.y!=0){const I=E.y/this.gamepadMoveSensibility;I!=0&&Math.abs(I)>.005&&(this.camera.inertialRadiusOffset-=I)}}}getClassName(){return"ArcRotateCameraGamepadInput"}getSimpleName(){return"gamepad"}}Rt([Ut()],Xm.prototype,"gamepadRotationSensibility",void 0),Rt([Ut()],Xm.prototype,"gamepadMoveSensibility",void 0),k2.ArcRotateCameraGamepadInput=Xm,Object.defineProperty(U0.prototype,"gamepadManager",{get:function(){if(!this._gamepadManager){this._gamepadManager=new nO(this);let pe=this._getComponent(_r.NAME_GAMEPAD);pe||(pe=new lO(this),this._addComponent(pe))}return this._gamepadManager},enumerable:!0,configurable:!0}),xb.prototype.addGamepad=function(){return this.add(new Hm),this},xO.prototype.addGamepad=function(){return this.add(new Xm),this};class lO{constructor(p){this.name=_r.NAME_GAMEPAD,this.scene=p}register(){this.scene._beforeCameraUpdateStage.registerStep(_r.STEP_BEFORECAMERAUPDATE_GAMEPAD,this,this._beforeCameraUpdate)}rebuild(){}dispose(){const p=this.scene._gamepadManager;p&&(p.dispose(),this.scene._gamepadManager=null)}_beforeCameraUpdate(){const p=this.scene._gamepadManager;p&&p._isMonitoring&&p._checkGamepadsStatus()}}Ha.AddNodeConstructor("FreeCamera",(pe,p)=>()=>new Hg(pe,at.Zero(),p));class Hg extends lb{get gamepadAngularSensibility(){const p=this.inputs.attached.gamepad;return p?p.gamepadAngularSensibility:0}set gamepadAngularSensibility(p){const _=this.inputs.attached.gamepad;_&&(_.gamepadAngularSensibility=p)}get gamepadMoveSensibility(){const p=this.inputs.attached.gamepad;return p?p.gamepadMoveSensibility:0}set gamepadMoveSensibility(p){const _=this.inputs.attached.gamepad;_&&(_.gamepadMoveSensibility=p)}constructor(p,_,E){super(p,_,E),this.inputs.addGamepad()}getClassName(){return"UniversalCamera"}}Wr._CreateDefaultParsedCamera=(pe,p)=>new Hg(pe,at.Zero(),p);class cb{constructor(p,_,E){this.bu=p,this.bv=_,this.distance=E,this.faceId=0,this.subMeshId=0}}class ql{constructor(p,_,E){this.vectors=Ts.BuildArray(8,at.Zero),this.center=at.Zero(),this.centerWorld=at.Zero(),this.extendSize=at.Zero(),this.extendSizeWorld=at.Zero(),this.directions=Ts.BuildArray(3,at.Zero),this.vectorsWorld=Ts.BuildArray(8,at.Zero),this.minimumWorld=at.Zero(),this.maximumWorld=at.Zero(),this.minimum=at.Zero(),this.maximum=at.Zero(),this._drawWrapperFront=null,this._drawWrapperBack=null,this.reConstruct(p,_,E)}reConstruct(p,_,E){const I=p.x,Z=p.y,re=p.z,ae=_.x,he=_.y,_e=_.z,ve=this.vectors;this.minimum.copyFromFloats(I,Z,re),this.maximum.copyFromFloats(ae,he,_e),ve[0].copyFromFloats(I,Z,re),ve[1].copyFromFloats(ae,he,_e),ve[2].copyFromFloats(ae,Z,re),ve[3].copyFromFloats(I,he,re),ve[4].copyFromFloats(I,Z,_e),ve[5].copyFromFloats(ae,he,re),ve[6].copyFromFloats(I,he,_e),ve[7].copyFromFloats(ae,Z,_e),_.addToRef(p,this.center).scaleInPlace(.5),_.subtractToRef(p,this.extendSize).scaleInPlace(.5),this._worldMatrix=E||jt.IdentityReadOnly,this._update(this._worldMatrix)}scale(p){const _=ql._TmpVector3,E=this.maximum.subtractToRef(this.minimum,_[0]),I=E.length();E.normalizeFromLength(I);const Z=I*p,re=E.scaleInPlace(Z*.5),ae=this.center.subtractToRef(re,_[1]),he=this.center.addToRef(re,_[2]);return this.reConstruct(ae,he,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(p){const _=this.minimumWorld,E=this.maximumWorld,I=this.directions,Z=this.vectorsWorld,re=this.vectors;if(p.isIdentity()){_.copyFrom(this.minimum),E.copyFrom(this.maximum);for(let ae=0;ae<8;++ae)Z[ae].copyFrom(re[ae]);this.extendSizeWorld.copyFrom(this.extendSize),this.centerWorld.copyFrom(this.center)}else{_.setAll(Number.MAX_VALUE),E.setAll(-Number.MAX_VALUE);for(let ae=0;ae<8;++ae){const he=Z[ae];at.TransformCoordinatesToRef(re[ae],p,he),_.minimizeInPlace(he),E.maximizeInPlace(he)}E.subtractToRef(_,this.extendSizeWorld).scaleInPlace(.5),E.addToRef(_,this.centerWorld).scaleInPlace(.5)}at.FromArrayToRef(p.m,0,I[0]),at.FromArrayToRef(p.m,4,I[1]),at.FromArrayToRef(p.m,8,I[2]),this._worldMatrix=p}isInFrustum(p){return ql.IsInFrustum(this.vectorsWorld,p)}isCompletelyInFrustum(p){return ql.IsCompletelyInFrustum(this.vectorsWorld,p)}intersectsPoint(p){const _=this.minimumWorld,E=this.maximumWorld,I=_.x,Z=_.y,re=_.z,ae=E.x,he=E.y,_e=E.z,ve=p.x,Le=p.y,ze=p.z,He=-ns;return!(ae-ve<He||He>ve-I||he-Le<He||He>Le-Z||_e-ze<He||He>ze-re)}intersectsSphere(p){return ql.IntersectsSphere(this.minimumWorld,this.maximumWorld,p.centerWorld,p.radiusWorld)}intersectsMinMax(p,_){const E=this.minimumWorld,I=this.maximumWorld,Z=E.x,re=E.y,ae=E.z,he=I.x,_e=I.y,ve=I.z,Le=p.x,ze=p.y,He=p.z,xt=_.x,rt=_.y,Tt=_.z;return!(he<Le||Z>xt||_e<ze||re>rt||ve<He||ae>Tt)}dispose(){this._drawWrapperFront?.dispose(),this._drawWrapperBack?.dispose()}static Intersects(p,_){return p.intersectsMinMax(_.minimumWorld,_.maximumWorld)}static IntersectsSphere(p,_,E,I){const Z=ql._TmpVector3[0];return at.ClampToRef(E,p,_,Z),at.DistanceSquared(E,Z)<=I*I}static IsCompletelyInFrustum(p,_){for(let E=0;E<6;++E){const I=_[E];for(let Z=0;Z<8;++Z)if(I.dotCoordinate(p[Z])<0)return!1}return!0}static IsInFrustum(p,_){for(let E=0;E<6;++E){let I=!0;const Z=_[E];for(let re=0;re<8;++re)if(Z.dotCoordinate(p[re])>=0){I=!1;break}if(I)return!1}return!0}}ql._TmpVector3=Ts.BuildArray(3,at.Zero);class Wc{constructor(p,_,E){this.center=at.Zero(),this.centerWorld=at.Zero(),this.minimum=at.Zero(),this.maximum=at.Zero(),this.reConstruct(p,_,E)}reConstruct(p,_,E){this.minimum.copyFrom(p),this.maximum.copyFrom(_);const I=at.Distance(p,_);_.addToRef(p,this.center).scaleInPlace(.5),this.radius=I*.5,this._update(E||jt.IdentityReadOnly)}scale(p){const _=this.radius*p,E=Wc._TmpVector3,I=E[0].setAll(_),Z=this.center.subtractToRef(I,E[1]),re=this.center.addToRef(I,E[2]);return this.reConstruct(Z,re,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(p){if(p.isIdentity())this.centerWorld.copyFrom(this.center),this.radiusWorld=this.radius;else{at.TransformCoordinatesToRef(this.center,p,this.centerWorld);const _=Wc._TmpVector3[0];at.TransformNormalFromFloatsToRef(1,1,1,p,_),this.radiusWorld=Math.max(Math.abs(_.x),Math.abs(_.y),Math.abs(_.z))*this.radius}}isInFrustum(p){const _=this.centerWorld,E=this.radiusWorld;for(let I=0;I<6;I++)if(p[I].dotCoordinate(_)<=-E)return!1;return!0}isCenterInFrustum(p){const _=this.centerWorld;for(let E=0;E<6;E++)if(p[E].dotCoordinate(_)<0)return!1;return!0}intersectsPoint(p){const _=at.DistanceSquared(this.centerWorld,p);return!(this.radiusWorld*this.radiusWorld<_)}static Intersects(p,_){const E=at.DistanceSquared(p.centerWorld,_.centerWorld),I=p.radiusWorld+_.radiusWorld;return!(I*I<E)}static CreateFromCenterAndRadius(p,_,E){this._TmpVector3[0].copyFrom(p),this._TmpVector3[1].copyFromFloats(0,0,_),this._TmpVector3[2].copyFrom(p),this._TmpVector3[0].addInPlace(this._TmpVector3[1]),this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);const I=new Wc(this._TmpVector3[0],this._TmpVector3[2]);return E?I._worldMatrix=E:I._worldMatrix=jt.Identity(),I}}Wc._TmpVector3=Ts.BuildArray(3,at.Zero);const Xg={min:0,max:0},Yg={min:0,max:0},ub=(pe,p,_)=>{const E=at.Dot(p.centerWorld,pe),I=Math.abs(at.Dot(p.directions[0],pe))*p.extendSize.x,Z=Math.abs(at.Dot(p.directions[1],pe))*p.extendSize.y,re=Math.abs(at.Dot(p.directions[2],pe))*p.extendSize.z,ae=I+Z+re;_.min=E-ae,_.max=E+ae},qx=(pe,p,_)=>(ub(pe,p,Xg),ub(pe,_,Yg),!(Xg.min>Yg.max||Yg.min>Xg.max));class uo{constructor(p,_,E){this._isLocked=!1,this.boundingBox=new ql(p,_,E),this.boundingSphere=new Wc(p,_,E)}reConstruct(p,_,E){this.boundingBox.reConstruct(p,_,E),this.boundingSphere.reConstruct(p,_,E)}get minimum(){return this.boundingBox.minimum}get maximum(){return this.boundingBox.maximum}get isLocked(){return this._isLocked}set isLocked(p){this._isLocked=p}update(p){this._isLocked||(this.boundingBox._update(p),this.boundingSphere._update(p))}centerOn(p,_){const E=uo._TmpVector3[0].copyFrom(p).subtractInPlace(_),I=uo._TmpVector3[1].copyFrom(p).addInPlace(_);return this.boundingBox.reConstruct(E,I,this.boundingBox.getWorldMatrix()),this.boundingSphere.reConstruct(E,I,this.boundingBox.getWorldMatrix()),this}encapsulate(p){const _=at.Minimize(this.minimum,p),E=at.Maximize(this.maximum,p);return this.reConstruct(_,E,this.boundingBox.getWorldMatrix()),this}encapsulateBoundingInfo(p){const _=ui.Matrix[0];this.boundingBox.getWorldMatrix().invertToRef(_);const E=ui.Vector3[0];return at.TransformCoordinatesToRef(p.boundingBox.minimumWorld,_,E),this.encapsulate(E),at.TransformCoordinatesToRef(p.boundingBox.maximumWorld,_,E),this.encapsulate(E),this}scale(p){return this.boundingBox.scale(p),this.boundingSphere.scale(p),this}isInFrustum(p,_=0){return(_===2||_===3)&&this.boundingSphere.isCenterInFrustum(p)?!0:this.boundingSphere.isInFrustum(p)?_===1||_===3?!0:this.boundingBox.isInFrustum(p):!1}get diagonalLength(){const p=this.boundingBox;return p.maximumWorld.subtractToRef(p.minimumWorld,uo._TmpVector3[0]).length()}isCompletelyInFrustum(p){return this.boundingBox.isCompletelyInFrustum(p)}_checkCollision(p){return p._canDoCollision(this.boundingSphere.centerWorld,this.boundingSphere.radiusWorld,this.boundingBox.minimumWorld,this.boundingBox.maximumWorld)}intersectsPoint(p){return!(!this.boundingSphere.centerWorld||!this.boundingSphere.intersectsPoint(p)||!this.boundingBox.intersectsPoint(p))}intersects(p,_){if(!Wc.Intersects(this.boundingSphere,p.boundingSphere)||!ql.Intersects(this.boundingBox,p.boundingBox))return!1;if(!_)return!0;const E=this.boundingBox,I=p.boundingBox;return!(!qx(E.directions[0],E,I)||!qx(E.directions[1],E,I)||!qx(E.directions[2],E,I)||!qx(I.directions[0],E,I)||!qx(I.directions[1],E,I)||!qx(I.directions[2],E,I)||!qx(at.Cross(E.directions[0],I.directions[0]),E,I)||!qx(at.Cross(E.directions[0],I.directions[1]),E,I)||!qx(at.Cross(E.directions[0],I.directions[2]),E,I)||!qx(at.Cross(E.directions[1],I.directions[0]),E,I)||!qx(at.Cross(E.directions[1],I.directions[1]),E,I)||!qx(at.Cross(E.directions[1],I.directions[2]),E,I)||!qx(at.Cross(E.directions[2],I.directions[0]),E,I)||!qx(at.Cross(E.directions[2],I.directions[1]),E,I)||!qx(at.Cross(E.directions[2],I.directions[2]),E,I))}}uo._TmpVector3=Ts.BuildArray(2,at.Zero);class Ym{static extractMinAndMaxIndexed(p,_,E,I,Z,re){for(let ae=E;ae<E+I;ae++){const he=_[ae]*3,_e=p[he],ve=p[he+1],Le=p[he+2];Z.minimizeInPlaceFromFloats(_e,ve,Le),re.maximizeInPlaceFromFloats(_e,ve,Le)}}static extractMinAndMax(p,_,E,I,Z,re){for(let ae=_,he=_*I;ae<_+E;ae++,he+=I){const _e=p[he],ve=p[he+1],Le=p[he+2];Z.minimizeInPlaceFromFloats(_e,ve,Le),re.maximizeInPlaceFromFloats(_e,ve,Le)}}}Rt([Wh.filter((...[pe,p])=>!Array.isArray(pe)&&!Array.isArray(p))],Ym,"extractMinAndMaxIndexed",null),Rt([Wh.filter((...[pe])=>!Array.isArray(pe))],Ym,"extractMinAndMax",null);function hO(pe,p,_,E,I=null){const Z=new at(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),re=new at(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return Ym.extractMinAndMaxIndexed(pe,p,_,E,Z,re),I&&(Z.x-=Z.x*I.x+I.y,Z.y-=Z.y*I.x+I.y,Z.z-=Z.z*I.x+I.y,re.x+=re.x*I.x+I.y,re.y+=re.y*I.x+I.y,re.z+=re.z*I.x+I.y),{minimum:Z,maximum:re}}function pb(pe,p,_,E=null,I){const Z=new at(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),re=new at(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return I||(I=3),Ym.extractMinAndMax(pe,p,_,I,Z,re),E&&(Z.x-=Z.x*E.x+E.y,Z.y-=Z.y*E.x+E.y,Z.z-=Z.z*E.x+E.y,re.x+=re.x*E.x+E.y,re.y+=re.y*E.x+E.y,re.z+=re.z*E.x+E.y),{minimum:Z,maximum:re}}class l2{get materialDefines(){return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.defines:this._getDrawWrapper()?.defines}set materialDefines(p){const _=this._mainDrawWrapperOverride??this._getDrawWrapper(void 0,!0);_.defines=p}_getDrawWrapper(p,_=!1){p=p??this._engine.currentRenderPassId;let E=this._drawWrappers[p];return!E&&_&&(this._drawWrappers[p]=E=new xo(this._mesh.getScene().getEngine())),E}_removeDrawWrapper(p,_=!0){_&&this._drawWrappers[p]?.dispose(),this._drawWrappers[p]=void 0}get effect(){return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.effect:this._getDrawWrapper()?.effect??null}get _drawWrapper(){return this._mainDrawWrapperOverride??this._getDrawWrapper(void 0,!0)}get _drawWrapperOverride(){return this._mainDrawWrapperOverride}_setMainDrawWrapperOverride(p){this._mainDrawWrapperOverride=p}setEffect(p,_=null,E,I=!0){const Z=this._drawWrapper;Z.setEffect(p,_,I),E!==void 0&&(Z.materialContext=E),p||(Z.defines=null,Z.materialContext=void 0)}resetDrawCache(p){if(this._drawWrappers)if(p!==void 0){this._removeDrawWrapper(p);return}else for(const _ of this._drawWrappers)_?.dispose();this._drawWrappers=[]}static AddToMesh(p,_,E,I,Z,re,ae,he=!0){return new l2(p,_,E,I,Z,re,ae,he)}constructor(p,_,E,I,Z,re,ae,he=!0,_e=!0){this.materialIndex=p,this.verticesStart=_,this.verticesCount=E,this.indexStart=I,this.indexCount=Z,this._mainDrawWrapperOverride=null,this._linesIndexCount=0,this._linesIndexBuffer=null,this._lastColliderWorldVertices=null,this._lastColliderTransformMatrix=null,this._wasDispatched=!1,this._renderId=0,this._alphaIndex=0,this._distanceToCamera=0,this._currentMaterial=null,this._mesh=re,this._renderingMesh=ae||re,_e&&re.subMeshes.push(this),this._engine=this._mesh.getScene().getEngine(),this.resetDrawCache(),this._trianglePlanes=[],this._id=re.subMeshes.length-1,he&&(this.refreshBoundingInfo(),re.computeWorldMatrix(!0))}get IsGlobal(){return this.verticesStart===0&&this.verticesCount===this._mesh.getTotalVertices()&&this.indexStart===0&&this.indexCount===this._mesh.getTotalIndices()}getBoundingInfo(){return this.IsGlobal||this._mesh.hasThinInstances?this._mesh.getBoundingInfo():this._boundingInfo}setBoundingInfo(p){return this._boundingInfo=p,this}getMesh(){return this._mesh}getRenderingMesh(){return this._renderingMesh}getReplacementMesh(){return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null}getEffectiveMesh(){const p=this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null;return p||this._renderingMesh}getMaterial(p=!0){const _=this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)??this._renderingMesh.material;if(_){if(this._isMultiMaterial(_)){const E=_.getSubMaterial(this.materialIndex);return this._currentMaterial!==E&&(this._currentMaterial=E,this.resetDrawCache()),E}}else return p?this._mesh.getScene().defaultMaterial:null;return _}_isMultiMaterial(p){return p.getSubMaterial!==void 0}refreshBoundingInfo(p=null){if(this._lastColliderWorldVertices=null,this.IsGlobal||!this._renderingMesh||!this._renderingMesh.geometry)return this;if(p||(p=this._renderingMesh.getVerticesData(ut.PositionKind)),!p)return this._boundingInfo=this._mesh.getBoundingInfo(),this;const _=this._renderingMesh.getIndices();let E;if(this.indexStart===0&&this.indexCount===_.length){const I=this._renderingMesh.getBoundingInfo();E={minimum:I.minimum.clone(),maximum:I.maximum.clone()}}else E=hO(p,_,this.indexStart,this.indexCount,this._renderingMesh.geometry.boundingBias);return this._boundingInfo?this._boundingInfo.reConstruct(E.minimum,E.maximum):this._boundingInfo=new uo(E.minimum,E.maximum),this}_checkCollision(p){return this.getBoundingInfo()._checkCollision(p)}updateBoundingInfo(p){let _=this.getBoundingInfo();return _||(this.refreshBoundingInfo(),_=this.getBoundingInfo()),_&&_.update(p),this}isInFrustum(p){const _=this.getBoundingInfo();return _?_.isInFrustum(p,this._mesh.cullingStrategy):!1}isCompletelyInFrustum(p){const _=this.getBoundingInfo();return _?_.isCompletelyInFrustum(p):!1}render(p){return this._renderingMesh.render(this,p,this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:void 0),this}_getLinesIndexBuffer(p,_){if(!this._linesIndexBuffer){const E=[];for(let I=this.indexStart;I<this.indexStart+this.indexCount;I+=3)E.push(p[I],p[I+1],p[I+1],p[I+2],p[I+2],p[I]);this._linesIndexBuffer=_.createIndexBuffer(E),this._linesIndexCount=E.length}return this._linesIndexBuffer}canIntersects(p){const _=this.getBoundingInfo();return _?p.intersectsBox(_.boundingBox):!1}intersects(p,_,E,I,Z){const re=this.getMaterial();if(!re)return null;let ae=3,he=!1;switch(re.fillMode){case 3:case 5:case 6:case 8:return null;case 7:ae=1,he=!0;break;default:break}return re.fillMode===4?E.length?this._intersectLines(p,_,E,this._mesh.intersectionThreshold,I):this._intersectUnIndexedLines(p,_,E,this._mesh.intersectionThreshold,I):!E.length&&this._mesh._unIndexed?this._intersectUnIndexedTriangles(p,_,E,I,Z):this._intersectTriangles(p,_,E,ae,he,I,Z)}_intersectLines(p,_,E,I,Z){let re=null;for(let ae=this.indexStart;ae<this.indexStart+this.indexCount;ae+=2){const he=_[E[ae]],_e=_[E[ae+1]],ve=p.intersectionSegment(he,_e,I);if(!(ve<0)&&(Z||!re||ve<re.distance)&&(re=new cb(null,null,ve),re.faceId=ae/2,Z))break}return re}_intersectUnIndexedLines(p,_,E,I,Z){let re=null;for(let ae=this.verticesStart;ae<this.verticesStart+this.verticesCount;ae+=2){const he=_[ae],_e=_[ae+1],ve=p.intersectionSegment(he,_e,I);if(!(ve<0)&&(Z||!re||ve<re.distance)&&(re=new cb(null,null,ve),re.faceId=ae/2,Z))break}return re}_intersectTriangles(p,_,E,I,Z,re,ae){let he=null,_e=-1;for(let ve=this.indexStart;ve<this.indexStart+this.indexCount-(3-I);ve+=I){_e++;const Le=E[ve],ze=E[ve+1],He=E[ve+2];if(Z&&He===4294967295){ve+=2;continue}const xt=_[Le],rt=_[ze],Tt=_[He];if(!xt||!rt||!Tt||ae&&!ae(xt,rt,Tt,p,Le,ze,He))continue;const Lt=p.intersectsTriangle(xt,rt,Tt);if(Lt){if(Lt.distance<0)continue;if((re||!he||Lt.distance<he.distance)&&(he=Lt,he.faceId=_e,re))break}}return he}_intersectUnIndexedTriangles(p,_,E,I,Z){let re=null;for(let ae=this.verticesStart;ae<this.verticesStart+this.verticesCount;ae+=3){const he=_[ae],_e=_[ae+1],ve=_[ae+2];if(Z&&!Z(he,_e,ve,p,-1,-1,-1))continue;const Le=p.intersectsTriangle(he,_e,ve);if(Le){if(Le.distance<0)continue;if((I||!re||Le.distance<re.distance)&&(re=Le,re.faceId=ae/3,I))break}}return re}_rebuild(){this._linesIndexBuffer&&(this._linesIndexBuffer=null)}clone(p,_){const E=new l2(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,p,_,!1);if(!this.IsGlobal){const I=this.getBoundingInfo();if(!I)return E;E._boundingInfo=new uo(I.minimum,I.maximum)}return E}dispose(){this._linesIndexBuffer&&(this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=null);const p=this._mesh.subMeshes.indexOf(this);this._mesh.subMeshes.splice(p,1),this.resetDrawCache()}getClassName(){return"SubMesh"}static CreateFromIndices(p,_,E,I,Z,re=!0){let ae=Number.MAX_VALUE,he=-Number.MAX_VALUE;const ve=(Z||I).getIndices();for(let Le=_;Le<_+E;Le++){const ze=ve[Le];ze<ae&&(ae=ze),ze>he&&(he=ze)}return new l2(p,ae,he-ae+1,_,E,I,Z,re)}}function _b(pe){pe.indexOf("vClipPlane")===-1&&pe.push("vClipPlane"),pe.indexOf("vClipPlane2")===-1&&pe.push("vClipPlane2"),pe.indexOf("vClipPlane3")===-1&&pe.push("vClipPlane3"),pe.indexOf("vClipPlane4")===-1&&pe.push("vClipPlane4"),pe.indexOf("vClipPlane5")===-1&&pe.push("vClipPlane5"),pe.indexOf("vClipPlane6")===-1&&pe.push("vClipPlane6")}function cO(pe,p,_){const E=!!(pe.clipPlane??p.clipPlane),I=!!(pe.clipPlane2??p.clipPlane2),Z=!!(pe.clipPlane3??p.clipPlane3),re=!!(pe.clipPlane4??p.clipPlane4),ae=!!(pe.clipPlane5??p.clipPlane5),he=!!(pe.clipPlane6??p.clipPlane6);E&&_.push("#define CLIPPLANE"),I&&_.push("#define CLIPPLANE2"),Z&&_.push("#define CLIPPLANE3"),re&&_.push("#define CLIPPLANE4"),ae&&_.push("#define CLIPPLANE5"),he&&_.push("#define CLIPPLANE6")}function uO(pe,p,_){let E=!1;const I=!!(pe.clipPlane??p.clipPlane),Z=!!(pe.clipPlane2??p.clipPlane2),re=!!(pe.clipPlane3??p.clipPlane3),ae=!!(pe.clipPlane4??p.clipPlane4),he=!!(pe.clipPlane5??p.clipPlane5),_e=!!(pe.clipPlane6??p.clipPlane6);return _.CLIPPLANE!==I&&(_.CLIPPLANE=I,E=!0),_.CLIPPLANE2!==Z&&(_.CLIPPLANE2=Z,E=!0),_.CLIPPLANE3!==re&&(_.CLIPPLANE3=re,E=!0),_.CLIPPLANE4!==ae&&(_.CLIPPLANE4=ae,E=!0),_.CLIPPLANE5!==he&&(_.CLIPPLANE5=he,E=!0),_.CLIPPLANE6!==_e&&(_.CLIPPLANE6=_e,E=!0),E}function Tb(pe,p,_){let E=p.clipPlane??_.clipPlane;_u(pe,"vClipPlane",E),E=p.clipPlane2??_.clipPlane2,_u(pe,"vClipPlane2",E),E=p.clipPlane3??_.clipPlane3,_u(pe,"vClipPlane3",E),E=p.clipPlane4??_.clipPlane4,_u(pe,"vClipPlane4",E),E=p.clipPlane5??_.clipPlane5,_u(pe,"vClipPlane5",E),E=p.clipPlane6??_.clipPlane6,_u(pe,"vClipPlane6",E)}function _u(pe,p,_){_&&pe.setFloat4(p,_.normal.x,_.normal.y,_.normal.z,_.d)}class lr{static BindSceneUniformBuffer(p,_){_.bindToEffect(p,"Scene")}static PrepareDefinesForMergedUV(p,_,E){_._needUVs=!0,_[E]=!0,p.optimizeUVAllocation&&p.getTextureMatrix().isIdentityAs3x2()?(_[E+"DIRECTUV"]=p.coordinatesIndex+1,_["MAINUV"+(p.coordinatesIndex+1)]=!0):_[E+"DIRECTUV"]=0}static BindTextureMatrix(p,_,E){const I=p.getTextureMatrix();_.updateMatrix(E+"Matrix",I)}static GetFogState(p,_){return _.fogEnabled&&p.applyFog&&_.fogMode!==U0.FOGMODE_NONE}static PrepareDefinesForMisc(p,_,E,I,Z,re,ae,he=!1){ae._areMiscDirty&&(ae.LOGARITHMICDEPTH=E,ae.POINTSIZE=I,ae.FOG=Z&&this.GetFogState(p,_),ae.NONUNIFORMSCALING=p.nonUniformScaling,ae.ALPHATEST=re,ae.DECAL_AFTER_DETAIL=he)}static PrepareDefinesForCamera(p,_){let E=!1;if(p.activeCamera){const I=_.CAMERA_ORTHOGRAPHIC?1:0,Z=_.CAMERA_PERSPECTIVE?1:0,re=p.activeCamera.mode===Wr.ORTHOGRAPHIC_CAMERA?1:0,ae=p.activeCamera.mode===Wr.PERSPECTIVE_CAMERA?1:0;(I^re||Z^ae)&&(_.CAMERA_ORTHOGRAPHIC=re===1,_.CAMERA_PERSPECTIVE=ae===1,E=!0)}return E}static PrepareDefinesForFrameBoundValues(p,_,E,I,Z,re=null,ae=!1){let he=lr.PrepareDefinesForCamera(p,I);re!==!1&&(he=uO(E,p,I)),I.DEPTHPREPASS!==!_.getColorWrite()&&(I.DEPTHPREPASS=!I.DEPTHPREPASS,he=!0),I.INSTANCES!==Z&&(I.INSTANCES=Z,he=!0),I.THIN_INSTANCES!==ae&&(I.THIN_INSTANCES=ae,he=!0),he&&I.markAsUnprocessed()}static PrepareDefinesForBones(p,_){if(p.useBones&&p.computeBonesUsingShaders&&p.skeleton){_.NUM_BONE_INFLUENCERS=p.numBoneInfluencers;const E=_.BONETEXTURE!==void 0;if(p.skeleton.isUsingTextureForMatrices&&E)_.BONETEXTURE=!0;else{_.BonesPerMesh=p.skeleton.bones.length+1,_.BONETEXTURE=E?!1:void 0;const I=p.getScene().prePassRenderer;if(I&&I.enabled){const Z=I.excludedSkinnedMesh.indexOf(p)===-1;_.BONES_VELOCITY_ENABLED=Z}}}else _.NUM_BONE_INFLUENCERS=0,_.BonesPerMesh=0,_.BONETEXTURE!==void 0&&(_.BONETEXTURE=!1)}static PrepareDefinesForMorphTargets(p,_){const E=p.morphTargetManager;E?(_.MORPHTARGETS_UV=E.supportsUVs&&_.UV1,_.MORPHTARGETS_TANGENT=E.supportsTangents&&_.TANGENT,_.MORPHTARGETS_NORMAL=E.supportsNormals&&_.NORMAL,_.NUM_MORPH_INFLUENCERS=E.numMaxInfluencers||E.numInfluencers,_.MORPHTARGETS=_.NUM_MORPH_INFLUENCERS>0,_.MORPHTARGETS_TEXTURE=E.isUsingTextureForTargets):(_.MORPHTARGETS_UV=!1,_.MORPHTARGETS_TANGENT=!1,_.MORPHTARGETS_NORMAL=!1,_.MORPHTARGETS=!1,_.NUM_MORPH_INFLUENCERS=0)}static PrepareDefinesForBakedVertexAnimation(p,_){const E=p.bakedVertexAnimationManager;_.BAKED_VERTEX_ANIMATION_TEXTURE=!!(E&&E.isEnabled)}static PrepareDefinesForAttributes(p,_,E,I,Z=!1,re=!0,ae=!0){if(!_._areAttributesDirty&&_._needNormals===_._normals&&_._needUVs===_._uvs)return!1;_._normals=_._needNormals,_._uvs=_._needUVs,_.NORMAL=_._needNormals&&p.isVerticesDataPresent(ut.NormalKind),_._needNormals&&p.isVerticesDataPresent(ut.TangentKind)&&(_.TANGENT=!0);for(let he=1;he<=6;++he)_["UV"+he]=_._needUVs?p.isVerticesDataPresent(`uv${he===1?"":he}`):!1;if(E){const he=p.useVertexColors&&p.isVerticesDataPresent(ut.ColorKind);_.VERTEXCOLOR=he,_.VERTEXALPHA=p.hasVertexAlpha&&he&&re}return p.isVerticesDataPresent(ut.ColorInstanceKind)&&(p.hasInstances||p.hasThinInstances)&&(_.INSTANCESCOLOR=!0),I&&this.PrepareDefinesForBones(p,_),Z&&this.PrepareDefinesForMorphTargets(p,_),ae&&this.PrepareDefinesForBakedVertexAnimation(p,_),!0}static PrepareDefinesForMultiview(p,_){if(p.activeCamera){const E=_.MULTIVIEW;_.MULTIVIEW=p.activeCamera.outputRenderTarget!==null&&p.activeCamera.outputRenderTarget.getViewCount()>1,_.MULTIVIEW!=E&&_.markAsUnprocessed()}}static PrepareDefinesForOIT(p,_,E){const I=_.ORDER_INDEPENDENT_TRANSPARENCY,Z=_.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;_.ORDER_INDEPENDENT_TRANSPARENCY=p.useOrderIndependentTransparency&&E,_.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!p.getEngine().getCaps().textureFloatLinearFiltering,(I!==_.ORDER_INDEPENDENT_TRANSPARENCY||Z!==_.ORDER_INDEPENDENT_TRANSPARENCY_16BITS)&&_.markAsUnprocessed()}static PrepareDefinesForPrePass(p,_,E){const I=_.PREPASS;if(!_._arePrePassDirty)return;const Z=[{type:1,define:"PREPASS_POSITION",index:"PREPASS_POSITION_INDEX"},{type:2,define:"PREPASS_VELOCITY",index:"PREPASS_VELOCITY_INDEX"},{type:3,define:"PREPASS_REFLECTIVITY",index:"PREPASS_REFLECTIVITY_INDEX"},{type:0,define:"PREPASS_IRRADIANCE",index:"PREPASS_IRRADIANCE_INDEX"},{type:7,define:"PREPASS_ALBEDO_SQRT",index:"PREPASS_ALBEDO_SQRT_INDEX"},{type:5,define:"PREPASS_DEPTH",index:"PREPASS_DEPTH_INDEX"},{type:6,define:"PREPASS_NORMAL",index:"PREPASS_NORMAL_INDEX"}];if(p.prePassRenderer&&p.prePassRenderer.enabled&&E){_.PREPASS=!0,_.SCENE_MRT_COUNT=p.prePassRenderer.mrtCount,_.PREPASS_NORMAL_WORLDSPACE=p.prePassRenderer.generateNormalsInWorldSpace;for(let re=0;re<Z.length;re++){const ae=p.prePassRenderer.getIndex(Z[re].type);ae!==-1?(_[Z[re].define]=!0,_[Z[re].index]=ae):_[Z[re].define]=!1}}else{_.PREPASS=!1;for(let re=0;re<Z.length;re++)_[Z[re].define]=!1}_.PREPASS!=I&&(_.markAsUnprocessed(),_.markAsImageProcessingDirty())}static PrepareDefinesForLight(p,_,E,I,Z,re,ae){switch(ae.needNormals=!0,Z["LIGHT"+I]===void 0&&(ae.needRebuild=!0),Z["LIGHT"+I]=!0,Z["SPOTLIGHT"+I]=!1,Z["HEMILIGHT"+I]=!1,Z["POINTLIGHT"+I]=!1,Z["DIRLIGHT"+I]=!1,E.prepareLightSpecificDefines(Z,I),Z["LIGHT_FALLOFF_PHYSICAL"+I]=!1,Z["LIGHT_FALLOFF_GLTF"+I]=!1,Z["LIGHT_FALLOFF_STANDARD"+I]=!1,E.falloffType){case Kn.FALLOFF_GLTF:Z["LIGHT_FALLOFF_GLTF"+I]=!0;break;case Kn.FALLOFF_PHYSICAL:Z["LIGHT_FALLOFF_PHYSICAL"+I]=!0;break;case Kn.FALLOFF_STANDARD:Z["LIGHT_FALLOFF_STANDARD"+I]=!0;break}if(re&&!E.specular.equalsFloats(0,0,0)&&(ae.specularEnabled=!0),Z["SHADOW"+I]=!1,Z["SHADOWCSM"+I]=!1,Z["SHADOWCSMDEBUG"+I]=!1,Z["SHADOWCSMNUM_CASCADES"+I]=!1,Z["SHADOWCSMUSESHADOWMAXZ"+I]=!1,Z["SHADOWCSMNOBLEND"+I]=!1,Z["SHADOWCSM_RIGHTHANDED"+I]=!1,Z["SHADOWPCF"+I]=!1,Z["SHADOWPCSS"+I]=!1,Z["SHADOWPOISSON"+I]=!1,Z["SHADOWESM"+I]=!1,Z["SHADOWCLOSEESM"+I]=!1,Z["SHADOWCUBE"+I]=!1,Z["SHADOWLOWQUALITY"+I]=!1,Z["SHADOWMEDIUMQUALITY"+I]=!1,_&&_.receiveShadows&&p.shadowsEnabled&&E.shadowEnabled){const he=E.getShadowGenerator(p.activeCamera)??E.getShadowGenerator();if(he){const _e=he.getShadowMap();_e&&_e.renderList&&_e.renderList.length>0&&(ae.shadowEnabled=!0,he.prepareDefines(Z,I))}}E.lightmapMode!=Kn.LIGHTMAP_DEFAULT?(ae.lightmapMode=!0,Z["LIGHTMAPEXCLUDED"+I]=!0,Z["LIGHTMAPNOSPECULAR"+I]=E.lightmapMode==Kn.LIGHTMAP_SHADOWSONLY):(Z["LIGHTMAPEXCLUDED"+I]=!1,Z["LIGHTMAPNOSPECULAR"+I]=!1)}static PrepareDefinesForLights(p,_,E,I,Z=4,re=!1){if(!E._areLightsDirty)return E._needNormals;let ae=0;const he={needNormals:E._needNormals,needRebuild:!1,lightmapMode:!1,shadowEnabled:!1,specularEnabled:!1};if(p.lightsEnabled&&!re){for(const ve of _.lightSources)if(this.PrepareDefinesForLight(p,_,ve,ae,E,I,he),ae++,ae===Z)break}E.SPECULARTERM=he.specularEnabled,E.SHADOWS=he.shadowEnabled;for(let ve=ae;ve<Z;ve++)E["LIGHT"+ve]!==void 0&&(E["LIGHT"+ve]=!1,E["HEMILIGHT"+ve]=!1,E["POINTLIGHT"+ve]=!1,E["DIRLIGHT"+ve]=!1,E["SPOTLIGHT"+ve]=!1,E["SHADOW"+ve]=!1,E["SHADOWCSM"+ve]=!1,E["SHADOWCSMDEBUG"+ve]=!1,E["SHADOWCSMNUM_CASCADES"+ve]=!1,E["SHADOWCSMUSESHADOWMAXZ"+ve]=!1,E["SHADOWCSMNOBLEND"+ve]=!1,E["SHADOWCSM_RIGHTHANDED"+ve]=!1,E["SHADOWPCF"+ve]=!1,E["SHADOWPCSS"+ve]=!1,E["SHADOWPOISSON"+ve]=!1,E["SHADOWESM"+ve]=!1,E["SHADOWCLOSEESM"+ve]=!1,E["SHADOWCUBE"+ve]=!1,E["SHADOWLOWQUALITY"+ve]=!1,E["SHADOWMEDIUMQUALITY"+ve]=!1);const _e=p.getEngine().getCaps();return E.SHADOWFLOAT===void 0&&(he.needRebuild=!0),E.SHADOWFLOAT=he.shadowEnabled&&(_e.textureFloatRender&&_e.textureFloatLinearFiltering||_e.textureHalfFloatRender&&_e.textureHalfFloatLinearFiltering),E.LIGHTMAPEXCLUDED=he.lightmapMode,he.needRebuild&&E.rebuild(),he.needNormals}static PrepareUniformsAndSamplersForLight(p,_,E,I,Z=null,re=!1){Z&&Z.push("Light"+p),!re&&(_.push("vLightData"+p,"vLightDiffuse"+p,"vLightSpecular"+p,"vLightDirection"+p,"vLightFalloff"+p,"vLightGround"+p,"lightMatrix"+p,"shadowsInfo"+p,"depthValues"+p),E.push("shadowSampler"+p),E.push("depthSampler"+p),_.push("viewFrustumZ"+p,"cascadeBlendFactor"+p,"lightSizeUVCorrection"+p,"depthCorrection"+p,"penumbraDarkness"+p,"frustumLengths"+p),I&&(E.push("projectionLightSampler"+p),_.push("textureProjectionMatrix"+p)))}static PrepareUniformsAndSamplersList(p,_,E,I=4){let Z,re=null;if(p.uniformsNames){const ae=p;Z=ae.uniformsNames,re=ae.uniformBuffersNames,_=ae.samplers,E=ae.defines,I=ae.maxSimultaneousLights||0}else Z=p,_||(_=[]);for(let ae=0;ae<I&&E["LIGHT"+ae];ae++)this.PrepareUniformsAndSamplersForLight(ae,Z,_,E["PROJECTEDLIGHTTEXTURE"+ae],re);E.NUM_MORPH_INFLUENCERS&&(Z.push("morphTargetInfluences"),Z.push("morphTargetCount")),E.BAKED_VERTEX_ANIMATION_TEXTURE&&(Z.push("bakedVertexAnimationSettings"),Z.push("bakedVertexAnimationTextureSizeInverted"),Z.push("bakedVertexAnimationTime"),_.push("bakedVertexAnimationTexture"))}static HandleFallbacksForShadows(p,_,E=4,I=0){let Z=0;for(let re=0;re<E&&p["LIGHT"+re];re++)re>0&&(Z=I+re,_.addFallback(Z,"LIGHT"+re)),p.SHADOWS||(p["SHADOW"+re]&&_.addFallback(I,"SHADOW"+re),p["SHADOWPCF"+re]&&_.addFallback(I,"SHADOWPCF"+re),p["SHADOWPCSS"+re]&&_.addFallback(I,"SHADOWPCSS"+re),p["SHADOWPOISSON"+re]&&_.addFallback(I,"SHADOWPOISSON"+re),p["SHADOWESM"+re]&&_.addFallback(I,"SHADOWESM"+re),p["SHADOWCLOSEESM"+re]&&_.addFallback(I,"SHADOWCLOSEESM"+re));return Z++}static PrepareAttributesForMorphTargetsInfluencers(p,_,E){this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS=E,this.PrepareAttributesForMorphTargets(p,_,this._TmpMorphInfluencers)}static PrepareAttributesForMorphTargets(p,_,E){const I=E.NUM_MORPH_INFLUENCERS;if(I>0&&Mr.LastCreatedEngine){const Z=Mr.LastCreatedEngine.getCaps().maxVertexAttribs,re=_.morphTargetManager;if(re?.isUsingTextureForTargets)return;const ae=re&&re.supportsNormals&&E.NORMAL,he=re&&re.supportsTangents&&E.TANGENT,_e=re&&re.supportsUVs&&E.UV1;for(let ve=0;ve<I;ve++)p.push(ut.PositionKind+ve),ae&&p.push(ut.NormalKind+ve),he&&p.push(ut.TangentKind+ve),_e&&p.push(ut.UVKind+"_"+ve),p.length>Z&&Ti.Error("Cannot add more vertex attributes for mesh "+_.name)}}static PrepareAttributesForBakedVertexAnimation(p,_,E){E.BAKED_VERTEX_ANIMATION_TEXTURE&&E.INSTANCES&&p.push("bakedVertexAnimationSettingsInstanced")}static PrepareAttributesForBones(p,_,E,I){E.NUM_BONE_INFLUENCERS>0&&(I.addCPUSkinningFallback(0,_),p.push(ut.MatricesIndicesKind),p.push(ut.MatricesWeightsKind),E.NUM_BONE_INFLUENCERS>4&&(p.push(ut.MatricesIndicesExtraKind),p.push(ut.MatricesWeightsExtraKind)))}static PrepareAttributesForInstances(p,_){(_.INSTANCES||_.THIN_INSTANCES)&&this.PushAttributesForInstances(p,!!_.PREPASS_VELOCITY),_.INSTANCESCOLOR&&p.push(ut.ColorInstanceKind)}static PushAttributesForInstances(p,_=!1){p.push("world0"),p.push("world1"),p.push("world2"),p.push("world3"),_&&(p.push("previousWorld0"),p.push("previousWorld1"),p.push("previousWorld2"),p.push("previousWorld3"))}static BindLightProperties(p,_,E){p.transferToEffect(_,E+"")}static BindLight(p,_,E,I,Z,re=!0){p._bindLight(_,E,I,Z,re)}static BindLights(p,_,E,I,Z=4){const re=Math.min(_.lightSources.length,Z);for(let ae=0;ae<re;ae++){const he=_.lightSources[ae];this.BindLight(he,ae,p,E,typeof I=="boolean"?I:I.SPECULARTERM,_.receiveShadows)}}static BindFogParameters(p,_,E,I=!1){E&&p.fogEnabled&&(!_||_.applyFog)&&p.fogMode!==U0.FOGMODE_NONE&&(E.setFloat4("vFogInfos",p.fogMode,p.fogStart,p.fogEnd,p.fogDensity),I?(p.fogColor.toLinearSpaceToRef(this._TempFogColor,p.getEngine().useExactSrgbConversions),E.setColor3("vFogColor",this._TempFogColor)):E.setColor3("vFogColor",p.fogColor))}static BindBonesParameters(p,_,E){if(!(!_||!p)&&(p.computeBonesUsingShaders&&_._bonesComputationForcedToCPU&&(p.computeBonesUsingShaders=!1),p.useBones&&p.computeBonesUsingShaders&&p.skeleton)){const I=p.skeleton;if(I.isUsingTextureForMatrices&&_.getUniformIndex("boneTextureWidth")>-1){const Z=I.getTransformMatrixTexture(p);_.setTexture("boneSampler",Z),_.setFloat("boneTextureWidth",4*(I.bones.length+1))}else{const Z=I.getTransformMatrices(p);Z&&(_.setMatrices("mBones",Z),E&&p.getScene().prePassRenderer&&p.getScene().prePassRenderer.getIndex(2)&&(E.previousBones[p.uniqueId]||(E.previousBones[p.uniqueId]=Z.slice()),_.setMatrices("mPreviousBones",E.previousBones[p.uniqueId]),lr._CopyBonesTransformationMatrices(Z,E.previousBones[p.uniqueId])))}}}static _CopyBonesTransformationMatrices(p,_){return _.set(p),_}static BindMorphTargetParameters(p,_){const E=p.morphTargetManager;!p||!E||_.setFloatArray("morphTargetInfluences",E.influences)}static BindLogDepth(p,_,E){if(!p||p.LOGARITHMICDEPTH||p.indexOf&&p.indexOf("LOGARITHMICDEPTH")>=0){const I=E.activeCamera;I.mode===Wr.ORTHOGRAPHIC_CAMERA&&Ti.Error("Logarithmic depth is not compatible with orthographic cameras!",20),_.setFloat("logarithmicDepthConstant",2/(Math.log(I.maxZ+1)/Math.LN2))}}}lr._TmpMorphInfluencers={NUM_MORPH_INFLUENCERS:0},lr._TempFogColor=Rs.Black();class $l{constructor(){this.reset()}reset(){this.enabled=!1,this.mask=255,this.func=519,this.funcRef=1,this.funcMask=255,this.opStencilFail=7680,this.opDepthFail=7680,this.opStencilDepthPass=7681}get func(){return this._func}set func(p){this._func=p}get funcRef(){return this._funcRef}set funcRef(p){this._funcRef=p}get funcMask(){return this._funcMask}set funcMask(p){this._funcMask=p}get opStencilFail(){return this._opStencilFail}set opStencilFail(p){this._opStencilFail=p}get opDepthFail(){return this._opDepthFail}set opDepthFail(p){this._opDepthFail=p}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(p){this._opStencilDepthPass=p}get mask(){return this._mask}set mask(p){this._mask=p}get enabled(){return this._enabled}set enabled(p){this._enabled=p}getClassName(){return"MaterialStencilState"}copyTo(p){Hr.Clone(()=>p,this)}serialize(){return Hr.Serialize(this)}parse(p,_,E){Hr.Parse(()=>this,p,_,E)}}Rt([Ut()],$l.prototype,"func",null),Rt([Ut()],$l.prototype,"funcRef",null),Rt([Ut()],$l.prototype,"funcMask",null),Rt([Ut()],$l.prototype,"opStencilFail",null),Rt([Ut()],$l.prototype,"opDepthFail",null),Rt([Ut()],$l.prototype,"opStencilDepthPass",null),Rt([Ut()],$l.prototype,"mask",null),Rt([Ut()],$l.prototype,"enabled",null);var vx;(function(pe){pe[pe.Created=1]="Created",pe[pe.Disposed=2]="Disposed",pe[pe.GetDefineNames=4]="GetDefineNames",pe[pe.PrepareUniformBuffer=8]="PrepareUniformBuffer",pe[pe.IsReadyForSubMesh=16]="IsReadyForSubMesh",pe[pe.PrepareDefines=32]="PrepareDefines",pe[pe.BindForSubMesh=64]="BindForSubMesh",pe[pe.PrepareEffect=128]="PrepareEffect",pe[pe.GetAnimatables=256]="GetAnimatables",pe[pe.GetActiveTextures=512]="GetActiveTextures",pe[pe.HasTexture=1024]="HasTexture",pe[pe.FillRenderTargetTextures=2048]="FillRenderTargetTextures",pe[pe.HasRenderTargetTextures=4096]="HasRenderTargetTextures",pe[pe.HardBindForSubMesh=8192]="HardBindForSubMesh"})(vx||(vx={}));class zi{get canRenderToMRT(){return!1}set alpha(p){if(this._alpha===p)return;const _=this._alpha;this._alpha=p,(_===1||p===1)&&this.markAsDirty(zi.MiscDirtyFlag+zi.PrePassDirtyFlag)}get alpha(){return this._alpha}set backFaceCulling(p){this._backFaceCulling!==p&&(this._backFaceCulling=p,this.markAsDirty(zi.TextureDirtyFlag))}get backFaceCulling(){return this._backFaceCulling}set cullBackFaces(p){this._cullBackFaces!==p&&(this._cullBackFaces=p,this.markAsDirty(zi.TextureDirtyFlag))}get cullBackFaces(){return this._cullBackFaces}get blockDirtyMechanism(){return this._blockDirtyMechanism}set blockDirtyMechanism(p){this._blockDirtyMechanism!==p&&(this._blockDirtyMechanism=p,p||this.markDirty())}atomicMaterialsUpdate(p){this.blockDirtyMechanism=!0;try{p(this)}finally{this.blockDirtyMechanism=!1}}get hasRenderTargetTextures(){return this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._eventInfo.hasRenderTargetTextures}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new Ri),this._onBindObservable}set onBind(p){this._onBindObserver&&this.onBindObservable.remove(this._onBindObserver),this._onBindObserver=this.onBindObservable.add(p)}get onUnBindObservable(){return this._onUnBindObservable||(this._onUnBindObservable=new Ri),this._onUnBindObservable}get onEffectCreatedObservable(){return this._onEffectCreatedObservable||(this._onEffectCreatedObservable=new Ri),this._onEffectCreatedObservable}set alphaMode(p){this._alphaMode!==p&&(this._alphaMode=p,this.markAsDirty(zi.TextureDirtyFlag))}get alphaMode(){return this._alphaMode}set needDepthPrePass(p){this._needDepthPrePass!==p&&(this._needDepthPrePass=p,this._needDepthPrePass&&(this.checkReadyOnEveryCall=!0))}get needDepthPrePass(){return this._needDepthPrePass}get isPrePassCapable(){return!1}set fogEnabled(p){this._fogEnabled!==p&&(this._fogEnabled=p,this.markAsDirty(zi.MiscDirtyFlag))}get fogEnabled(){return this._fogEnabled}get wireframe(){switch(this._fillMode){case zi.WireFrameFillMode:case zi.LineListDrawMode:case zi.LineLoopDrawMode:case zi.LineStripDrawMode:return!0}return this._scene.forceWireframe}set wireframe(p){this.fillMode=p?zi.WireFrameFillMode:zi.TriangleFillMode}get pointsCloud(){switch(this._fillMode){case zi.PointFillMode:case zi.PointListDrawMode:return!0}return this._scene.forcePointsCloud}set pointsCloud(p){this.fillMode=p?zi.PointFillMode:zi.TriangleFillMode}get fillMode(){return this._fillMode}set fillMode(p){this._fillMode!==p&&(this._fillMode=p,this.markAsDirty(zi.MiscDirtyFlag))}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(p){const _=this.getScene().getEngine().getCaps().fragmentDepthSupported;p&&!_&&Ti.Warn("Logarithmic depth has been requested for a material on a device that doesn't support it."),this._useLogarithmicDepth=p&&_,this._markAllSubMeshesAsMiscDirty()}_getDrawWrapper(){return this._drawWrapper}_setDrawWrapper(p){this._drawWrapper=p}constructor(p,_,E){this.shadowDepthWrapper=null,this.allowShaderHotSwapping=!0,this.metadata=null,this.reservedDataStore=null,this.checkReadyOnEveryCall=!1,this.checkReadyOnlyOnce=!1,this.state="",this._alpha=1,this._backFaceCulling=!0,this._cullBackFaces=!0,this._blockDirtyMechanism=!1,this.onCompiled=null,this.onError=null,this.getRenderTargetTextures=null,this.doNotSerialize=!1,this._storeEffectOnSubMeshes=!1,this.animations=null,this.onDisposeObservable=new Ri,this._onDisposeObserver=null,this._onUnBindObservable=null,this._onBindObserver=null,this._alphaMode=2,this._needDepthPrePass=!1,this.disableDepthWrite=!1,this.disableColorWrite=!1,this.forceDepthWrite=!1,this.depthFunction=0,this.separateCullingPass=!1,this._fogEnabled=!0,this.pointSize=1,this.zOffset=0,this.zOffsetUnits=0,this.stencil=new $l,this._useUBO=!1,this._fillMode=zi.TriangleFillMode,this._cachedDepthWriteState=!1,this._cachedColorWriteState=!1,this._cachedDepthFunctionState=0,this._indexInSceneMaterialArray=-1,this.meshMap=null,this._parentContainer=null,this._uniformBufferLayoutBuilt=!1,this._eventInfo={},this._callbackPluginEventGeneric=()=>{},this._callbackPluginEventIsReadyForSubMesh=()=>{},this._callbackPluginEventPrepareDefines=()=>{},this._callbackPluginEventPrepareDefinesBeforeAttributes=()=>{},this._callbackPluginEventHardBindForSubMesh=()=>{},this._callbackPluginEventBindForSubMesh=()=>{},this._callbackPluginEventHasRenderTargetTextures=()=>{},this._callbackPluginEventFillRenderTargetTextures=()=>{},this._forceAlphaTest=!1,this._transparencyMode=null,this.name=p;const I=_||Mr.LastCreatedScene;I&&(this._scene=I,this._dirtyCallbacks={},this._dirtyCallbacks[1]=this._markAllSubMeshesAsTexturesDirty.bind(this),this._dirtyCallbacks[2]=this._markAllSubMeshesAsLightsDirty.bind(this),this._dirtyCallbacks[4]=this._markAllSubMeshesAsFresnelDirty.bind(this),this._dirtyCallbacks[8]=this._markAllSubMeshesAsAttributesDirty.bind(this),this._dirtyCallbacks[16]=this._markAllSubMeshesAsMiscDirty.bind(this),this._dirtyCallbacks[32]=this._markAllSubMeshesAsPrePassDirty.bind(this),this._dirtyCallbacks[63]=this._markAllSubMeshesAsAllDirty.bind(this),this.id=p||lt.RandomId(),this.uniqueId=this._scene.getUniqueId(),this._materialContext=this._scene.getEngine().createMaterialContext(),this._drawWrapper=new xo(this._scene.getEngine(),!1),this._drawWrapper.materialContext=this._materialContext,this._scene.useRightHandedSystem?this.sideOrientation=zi.ClockWiseSideOrientation:this.sideOrientation=zi.CounterClockWiseSideOrientation,this._uniformBuffer=new qs(this._scene.getEngine(),void 0,void 0,p),this._useUBO=this.getScene().getEngine().supportsUniformBuffers,E||this._scene.addMaterial(this),this._scene.useMaterialMeshMap&&(this.meshMap={}),zi.OnEventObservable.notifyObservers(this,vx.Created))}toString(p){return"Name: "+this.name}getClassName(){return"Material"}get _isMaterial(){return!0}get isFrozen(){return this.checkReadyOnlyOnce}freeze(){this.markDirty(),this.checkReadyOnlyOnce=!0}unfreeze(){this.markDirty(),this.checkReadyOnlyOnce=!1}isReady(p,_){return!0}isReadyForSubMesh(p,_,E){const I=_.materialDefines;return I?(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=I,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),this._eventInfo.isReadyForSubMesh):!1}getEffect(){return this._drawWrapper.effect}getScene(){return this._scene}get transparencyMode(){return this._transparencyMode}set transparencyMode(p){this._transparencyMode!==p&&(this._transparencyMode=p,this._forceAlphaTest=p===zi.MATERIAL_ALPHATESTANDBLEND,this._markAllSubMeshesAsTexturesAndMiscDirty())}get _disableAlphaBlending(){return this._transparencyMode===zi.MATERIAL_OPAQUE||this._transparencyMode===zi.MATERIAL_ALPHATEST}needAlphaBlending(){return this._disableAlphaBlending?!1:this.alpha<1}needAlphaBlendingForMesh(p){return p.visibility<1?!0:this._disableAlphaBlending?!1:p.hasVertexAlpha||this.needAlphaBlending()}needAlphaTesting(){return!!this._forceAlphaTest}_shouldTurnAlphaTestOn(p){return!this.needAlphaBlendingForMesh(p)&&this.needAlphaTesting()}getAlphaTestTexture(){return null}markDirty(p=!1){const _=this.getScene().meshes;for(const E of _)if(E.subMeshes){for(const I of E.subMeshes)if(I.getMaterial()===this)for(const Z of I._drawWrappers)Z&&this._materialContext===Z.materialContext&&(Z._wasPreviouslyReady=!1,Z._wasPreviouslyUsingInstances=null,Z._forceRebindOnNextCall=p)}p&&this.markAsDirty(zi.AllDirtyFlag)}_preBind(p,_=null){const E=this._scene.getEngine(),Z=(_??this.sideOrientation)===zi.ClockWiseSideOrientation;return E.enableEffect(p||this._getDrawWrapper()),E.setState(this.backFaceCulling,this.zOffset,!1,Z,this._scene._mirroredCameraPosition?!this.cullBackFaces:this.cullBackFaces,this.stencil,this.zOffsetUnits),Z}bind(p,_){}buildUniformLayout(){const p=this._uniformBuffer;this._eventInfo.ubo=p,this._callbackPluginEventGeneric(vx.PrepareUniformBuffer,this._eventInfo),p.create(),this._uniformBufferLayoutBuilt=!0}bindForSubMesh(p,_,E){const I=E._drawWrapper;this._eventInfo.subMesh=E,this._callbackPluginEventBindForSubMesh(this._eventInfo),I._forceRebindOnNextCall=!1}bindOnlyWorldMatrix(p){}bindView(p){this._useUBO?this._needToBindSceneUbo=!0:p.setMatrix("view",this.getScene().getViewMatrix())}bindViewProjection(p){this._useUBO?this._needToBindSceneUbo=!0:(p.setMatrix("viewProjection",this.getScene().getTransformMatrix()),p.setMatrix("projection",this.getScene().getProjectionMatrix()))}bindEyePosition(p,_){this._useUBO?this._needToBindSceneUbo=!0:this._scene.bindEyePosition(p,_)}_afterBind(p,_=null,E){if(this._scene._cachedMaterial=this,this._needToBindSceneUbo&&_&&(this._needToBindSceneUbo=!1,lr.BindSceneUniformBuffer(_,this.getScene().getSceneUniformBuffer()),this._scene.finalizeSceneUbo()),p?this._scene._cachedVisibility=p.visibility:this._scene._cachedVisibility=1,this._onBindObservable&&p&&this._onBindObservable.notifyObservers(p),this.disableDepthWrite){const I=this._scene.getEngine();this._cachedDepthWriteState=I.getDepthWrite(),I.setDepthWrite(!1)}if(this.disableColorWrite){const I=this._scene.getEngine();this._cachedColorWriteState=I.getColorWrite(),I.setColorWrite(!1)}if(this.depthFunction!==0){const I=this._scene.getEngine();this._cachedDepthFunctionState=I.getDepthFunction()||0,I.setDepthFunction(this.depthFunction)}}unbind(){this._onUnBindObservable&&this._onUnBindObservable.notifyObservers(this),this.depthFunction!==0&&this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState),this.disableDepthWrite&&this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState),this.disableColorWrite&&this._scene.getEngine().setColorWrite(this._cachedColorWriteState)}getAnimatables(){return this._eventInfo.animatables=[],this._callbackPluginEventGeneric(vx.GetAnimatables,this._eventInfo),this._eventInfo.animatables}getActiveTextures(){return this._eventInfo.activeTextures=[],this._callbackPluginEventGeneric(vx.GetActiveTextures,this._eventInfo),this._eventInfo.activeTextures}hasTexture(p){return this._eventInfo.hasTexture=!1,this._eventInfo.texture=p,this._callbackPluginEventGeneric(vx.HasTexture,this._eventInfo),this._eventInfo.hasTexture}clone(p){return null}_clonePlugins(p,_){const E={};if(this._serializePlugins(E),zi._ParsePlugins(E,p,this._scene,_),this.pluginManager)for(const I of this.pluginManager._plugins){const Z=p.pluginManager.getPlugin(I.name);Z&&I.copyTo(Z)}}getBindedMeshes(){if(this.meshMap){const p=[];for(const _ in this.meshMap){const E=this.meshMap[_];E&&p.push(E)}return p}else return this._scene.meshes.filter(_=>_.material===this)}forceCompilation(p,_,E,I){const Z={clipPlane:!1,useInstances:!1,...E},re=this.getScene(),ae=this.allowShaderHotSwapping;this.allowShaderHotSwapping=!1;const he=()=>{if(!this._scene||!this._scene.getEngine())return;const _e=re.clipPlane;if(Z.clipPlane&&(re.clipPlane=new r2(0,0,0,1)),this._storeEffectOnSubMeshes){let ve=!0,Le=null;if(p.subMeshes){const ze=new l2(0,0,0,0,0,p,void 0,!1,!1);ze.materialDefines&&(ze.materialDefines._renderId=-1),this.isReadyForSubMesh(p,ze,Z.useInstances)||(ze.effect&&ze.effect.getCompilationError()&&ze.effect.allFallbacksProcessed()?Le=ze.effect.getCompilationError():(ve=!1,setTimeout(he,16)))}ve&&(this.allowShaderHotSwapping=ae,Le&&I&&I(Le),_&&_(this))}else this.isReady()?(this.allowShaderHotSwapping=ae,_&&_(this)):setTimeout(he,16);Z.clipPlane&&(re.clipPlane=_e)};he()}forceCompilationAsync(p,_){return new Promise((E,I)=>{this.forceCompilation(p,()=>{E()},_,Z=>{I(Z)})})}markAsDirty(p){this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism||(zi._DirtyCallbackArray.length=0,p&zi.TextureDirtyFlag&&zi._DirtyCallbackArray.push(zi._TextureDirtyCallBack),p&zi.LightDirtyFlag&&zi._DirtyCallbackArray.push(zi._LightsDirtyCallBack),p&zi.FresnelDirtyFlag&&zi._DirtyCallbackArray.push(zi._FresnelDirtyCallBack),p&zi.AttributesDirtyFlag&&zi._DirtyCallbackArray.push(zi._AttributeDirtyCallBack),p&zi.MiscDirtyFlag&&zi._DirtyCallbackArray.push(zi._MiscDirtyCallBack),p&zi.PrePassDirtyFlag&&zi._DirtyCallbackArray.push(zi._PrePassDirtyCallBack),zi._DirtyCallbackArray.length&&this._markAllSubMeshesAsDirty(zi._RunDirtyCallBacks),this.getScene().resetCachedMaterial())}resetDrawCache(){const p=this.getScene().meshes;for(const _ of p)if(_.subMeshes)for(const E of _.subMeshes)E.getMaterial()===this&&E.resetDrawCache()}_markAllSubMeshesAsDirty(p){if(this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const _=this.getScene().meshes;for(const E of _)if(E.subMeshes){for(const I of E.subMeshes)if(I.getMaterial(!1)===this)for(const Z of I._drawWrappers)!Z||!Z.defines||!Z.defines.markAllAsDirty||this._materialContext===Z.materialContext&&p(Z.defines)}}_markScenePrePassDirty(){if(this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const p=this.getScene().enablePrePassRenderer();p&&p.markAsDirty()}_markAllSubMeshesAsAllDirty(){this._markAllSubMeshesAsDirty(zi._AllDirtyCallBack)}_markAllSubMeshesAsImageProcessingDirty(){this._markAllSubMeshesAsDirty(zi._ImageProcessingDirtyCallBack)}_markAllSubMeshesAsTexturesDirty(){this._markAllSubMeshesAsDirty(zi._TextureDirtyCallBack)}_markAllSubMeshesAsFresnelDirty(){this._markAllSubMeshesAsDirty(zi._FresnelDirtyCallBack)}_markAllSubMeshesAsFresnelAndMiscDirty(){this._markAllSubMeshesAsDirty(zi._FresnelAndMiscDirtyCallBack)}_markAllSubMeshesAsLightsDirty(){this._markAllSubMeshesAsDirty(zi._LightsDirtyCallBack)}_markAllSubMeshesAsAttributesDirty(){this._markAllSubMeshesAsDirty(zi._AttributeDirtyCallBack)}_markAllSubMeshesAsMiscDirty(){this._markAllSubMeshesAsDirty(zi._MiscDirtyCallBack)}_markAllSubMeshesAsPrePassDirty(){this._markAllSubMeshesAsDirty(zi._MiscDirtyCallBack)}_markAllSubMeshesAsTexturesAndMiscDirty(){this._markAllSubMeshesAsDirty(zi._TextureAndMiscDirtyCallBack)}_checkScenePerformancePriority(){if(this._scene.performancePriority!==_l.BackwardCompatible){this.checkReadyOnlyOnce=!0;const p=this._scene.onScenePerformancePriorityChangedObservable.addOnce(()=>{this.checkReadyOnlyOnce=!1});this.onDisposeObservable.add(()=>{this._scene.onScenePerformancePriorityChangedObservable.remove(p)})}}setPrePassRenderer(p){return!1}dispose(p,_,E){const I=this.getScene();if(I.stopAnimation(this),I.freeProcessedMaterials(),I.removeMaterial(this),this._eventInfo.forceDisposeTextures=_,this._callbackPluginEventGeneric(vx.Disposed,this._eventInfo),this._parentContainer){const Z=this._parentContainer.materials.indexOf(this);Z>-1&&this._parentContainer.materials.splice(Z,1),this._parentContainer=null}if(E!==!0)if(this.meshMap)for(const Z in this.meshMap){const re=this.meshMap[Z];re&&(re.material=null,this.releaseVertexArrayObject(re,p))}else{const Z=I.meshes;for(const re of Z)re.material===this&&!re.sourceMesh&&(re.material=null,this.releaseVertexArrayObject(re,p))}this._uniformBuffer.dispose(),p&&this._drawWrapper.effect&&(this._storeEffectOnSubMeshes||this._drawWrapper.effect.dispose(),this._drawWrapper.effect=null),this.metadata=null,this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this._onBindObservable&&this._onBindObservable.clear(),this._onUnBindObservable&&this._onUnBindObservable.clear(),this._onEffectCreatedObservable&&this._onEffectCreatedObservable.clear(),this._eventInfo&&(this._eventInfo={})}releaseVertexArrayObject(p,_){const E=p.geometry;if(E)if(this._storeEffectOnSubMeshes){if(p.subMeshes)for(const I of p.subMeshes)E._releaseVertexArrayObject(I.effect),_&&I.effect&&I.effect.dispose()}else E._releaseVertexArrayObject(this._drawWrapper.effect)}serialize(){const p=Hr.Serialize(this);return p.stencil=this.stencil.serialize(),p.uniqueId=this.uniqueId,this._serializePlugins(p),p}_serializePlugins(p){if(p.plugins={},this.pluginManager)for(const _ of this.pluginManager._plugins)p.plugins[_.getClassName()]=_.serialize()}static Parse(p,_,E){if(!p.customType)p.customType="BABYLON.StandardMaterial";else if(p.customType==="BABYLON.PBRMaterial"&&p.overloadedAlbedo&&(p.customType="BABYLON.LegacyPBRMaterial",!BABYLON.LegacyPBRMaterial))return Ti.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."),null;const Z=lt.Instantiate(p.customType).Parse(p,_,E);return Z._loadedUniqueId=p.uniqueId,Z}static _ParsePlugins(p,_,E,I){if(p.plugins)for(const Z in p.plugins){const re=p.plugins[Z];let ae=_.pluginManager?.getPlugin(re.name);if(!ae){const he=lt.Instantiate("BABYLON."+Z);he&&(ae=new he(_))}ae?.parse(re,E,I)}}}zi.TriangleFillMode=0,zi.WireFrameFillMode=1,zi.PointFillMode=2,zi.PointListDrawMode=3,zi.LineListDrawMode=4,zi.LineLoopDrawMode=5,zi.LineStripDrawMode=6,zi.TriangleStripDrawMode=7,zi.TriangleFanDrawMode=8,zi.ClockWiseSideOrientation=0,zi.CounterClockWiseSideOrientation=1,zi.TextureDirtyFlag=1,zi.LightDirtyFlag=2,zi.FresnelDirtyFlag=4,zi.AttributesDirtyFlag=8,zi.MiscDirtyFlag=16,zi.PrePassDirtyFlag=32,zi.AllDirtyFlag=63,zi.MATERIAL_OPAQUE=0,zi.MATERIAL_ALPHATEST=1,zi.MATERIAL_ALPHABLEND=2,zi.MATERIAL_ALPHATESTANDBLEND=3,zi.MATERIAL_NORMALBLENDMETHOD_WHITEOUT=0,zi.MATERIAL_NORMALBLENDMETHOD_RNM=1,zi.OnEventObservable=new Ri,zi._AllDirtyCallBack=pe=>pe.markAllAsDirty(),zi._ImageProcessingDirtyCallBack=pe=>pe.markAsImageProcessingDirty(),zi._TextureDirtyCallBack=pe=>pe.markAsTexturesDirty(),zi._FresnelDirtyCallBack=pe=>pe.markAsFresnelDirty(),zi._MiscDirtyCallBack=pe=>pe.markAsMiscDirty(),zi._PrePassDirtyCallBack=pe=>pe.markAsPrePassDirty(),zi._LightsDirtyCallBack=pe=>pe.markAsLightDirty(),zi._AttributeDirtyCallBack=pe=>pe.markAsAttributesDirty(),zi._FresnelAndMiscDirtyCallBack=pe=>{zi._FresnelDirtyCallBack(pe),zi._MiscDirtyCallBack(pe)},zi._TextureAndMiscDirtyCallBack=pe=>{zi._TextureDirtyCallBack(pe),zi._MiscDirtyCallBack(pe)},zi._DirtyCallbackArray=[],zi._RunDirtyCallBacks=pe=>{for(const p of zi._DirtyCallbackArray)p(pe)},Rt([Ut()],zi.prototype,"id",void 0),Rt([Ut()],zi.prototype,"uniqueId",void 0),Rt([Ut()],zi.prototype,"name",void 0),Rt([Ut()],zi.prototype,"metadata",void 0),Rt([Ut()],zi.prototype,"checkReadyOnEveryCall",void 0),Rt([Ut()],zi.prototype,"checkReadyOnlyOnce",void 0),Rt([Ut()],zi.prototype,"state",void 0),Rt([Ut("alpha")],zi.prototype,"_alpha",void 0),Rt([Ut("backFaceCulling")],zi.prototype,"_backFaceCulling",void 0),Rt([Ut("cullBackFaces")],zi.prototype,"_cullBackFaces",void 0),Rt([Ut()],zi.prototype,"sideOrientation",void 0),Rt([Ut("alphaMode")],zi.prototype,"_alphaMode",void 0),Rt([Ut()],zi.prototype,"_needDepthPrePass",void 0),Rt([Ut()],zi.prototype,"disableDepthWrite",void 0),Rt([Ut()],zi.prototype,"disableColorWrite",void 0),Rt([Ut()],zi.prototype,"forceDepthWrite",void 0),Rt([Ut()],zi.prototype,"depthFunction",void 0),Rt([Ut()],zi.prototype,"separateCullingPass",void 0),Rt([Ut("fogEnabled")],zi.prototype,"_fogEnabled",void 0),Rt([Ut()],zi.prototype,"pointSize",void 0),Rt([Ut()],zi.prototype,"zOffset",void 0),Rt([Ut()],zi.prototype,"zOffsetUnits",void 0),Rt([Ut()],zi.prototype,"pointsCloud",null),Rt([Ut()],zi.prototype,"fillMode",null),Rt([Ut()],zi.prototype,"useLogarithmicDepth",null),Rt([Ut()],zi.prototype,"transparencyMode",null);class zo{constructor(p,_){this.width=p,this.height=_}toString(){return`{W: ${this.width}, H: ${this.height}}`}getClassName(){return"Size"}getHashCode(){let p=this.width|0;return p=p*397^(this.height|0),p}copyFrom(p){this.width=p.width,this.height=p.height}copyFromFloats(p,_){return this.width=p,this.height=_,this}set(p,_){return this.copyFromFloats(p,_)}multiplyByFloats(p,_){return new zo(this.width*p,this.height*_)}clone(){return new zo(this.width,this.height)}equals(p){return p?this.width===p.width&&this.height===p.height:!1}get surface(){return this.width*this.height}static Zero(){return new zo(0,0)}add(p){return new zo(this.width+p.width,this.height+p.height)}subtract(p){return new zo(this.width-p.width,this.height-p.height)}scale(p){return new zo(this.width*p,this.height*p)}static Lerp(p,_,E){const I=p.width+(_.width-p.width)*E,Z=p.height+(_.height-p.height)*E;return new zo(I,Z)}}class Kg{get wrapU(){return this._wrapU}set wrapU(p){this._wrapU=p}get wrapV(){return this._wrapV}set wrapV(p){this._wrapV=p}get coordinatesMode(){return 0}get isCube(){return this._texture?this._texture.isCube:!1}set isCube(p){this._texture&&(this._texture.isCube=p)}get is3D(){return this._texture?this._texture.is3D:!1}set is3D(p){this._texture&&(this._texture.is3D=p)}get is2DArray(){return this._texture?this._texture.is2DArray:!1}set is2DArray(p){this._texture&&(this._texture.is2DArray=p)}getClassName(){return"ThinTexture"}static _IsRenderTargetWrapper(p){return p?._shareDepth!==void 0}constructor(p){this._wrapU=1,this._wrapV=1,this.wrapR=1,this.anisotropicFilteringLevel=4,this.delayLoadState=0,this._texture=null,this._engine=null,this._cachedSize=zo.Zero(),this._cachedBaseSize=zo.Zero(),this._initialSamplingMode=2,this._texture=Kg._IsRenderTargetWrapper(p)?p.texture:p,this._texture&&(this._engine=this._texture.getEngine())}isReady(){return this.delayLoadState===4?(this.delayLoad(),!1):this._texture?this._texture.isReady:!1}delayLoad(){}getInternalTexture(){return this._texture}getSize(){if(this._texture){if(this._texture.width)return this._cachedSize.width=this._texture.width,this._cachedSize.height=this._texture.height,this._cachedSize;if(this._texture._size)return this._cachedSize.width=this._texture._size,this._cachedSize.height=this._texture._size,this._cachedSize}return this._cachedSize}getBaseSize(){return!this.isReady()||!this._texture?(this._cachedBaseSize.width=0,this._cachedBaseSize.height=0,this._cachedBaseSize):this._texture._size?(this._cachedBaseSize.width=this._texture._size,this._cachedBaseSize.height=this._texture._size,this._cachedBaseSize):(this._cachedBaseSize.width=this._texture.baseWidth,this._cachedBaseSize.height=this._texture.baseHeight,this._cachedBaseSize)}get samplingMode(){return this._texture?this._texture.samplingMode:this._initialSamplingMode}updateSamplingMode(p){this._texture&&this._engine&&this._engine.updateTextureSamplingMode(p,this._texture)}releaseInternalTexture(){this._texture&&(this._texture.dispose(),this._texture=null)}dispose(){this._texture&&(this.releaseInternalTexture(),this._engine=null)}}class na extends Kg{set hasAlpha(p){this._hasAlpha!==p&&(this._hasAlpha=p,this._scene&&this._scene.markAllMaterialsAsDirty(1,_=>_.hasTexture(this)))}get hasAlpha(){return this._hasAlpha}set getAlphaFromRGB(p){this._getAlphaFromRGB!==p&&(this._getAlphaFromRGB=p,this._scene&&this._scene.markAllMaterialsAsDirty(1,_=>_.hasTexture(this)))}get getAlphaFromRGB(){return this._getAlphaFromRGB}set coordinatesIndex(p){this._coordinatesIndex!==p&&(this._coordinatesIndex=p,this._scene&&this._scene.markAllMaterialsAsDirty(1,_=>_.hasTexture(this)))}get coordinatesIndex(){return this._coordinatesIndex}set coordinatesMode(p){this._coordinatesMode!==p&&(this._coordinatesMode=p,this._scene&&this._scene.markAllMaterialsAsDirty(1,_=>_.hasTexture(this)))}get coordinatesMode(){return this._coordinatesMode}get wrapU(){return this._wrapU}set wrapU(p){this._wrapU=p}get wrapV(){return this._wrapV}set wrapV(p){this._wrapV=p}get isCube(){return this._texture?this._texture.isCube:this._isCube}set isCube(p){this._texture?this._texture.isCube=p:this._isCube=p}get is3D(){return this._texture?this._texture.is3D:!1}set is3D(p){this._texture&&(this._texture.is3D=p)}get is2DArray(){return this._texture?this._texture.is2DArray:!1}set is2DArray(p){this._texture&&(this._texture.is2DArray=p)}get gammaSpace(){if(this._texture)this._texture._gammaSpace===null&&(this._texture._gammaSpace=this._gammaSpace);else return this._gammaSpace;return this._texture._gammaSpace&&!this._texture._useSRGBBuffer}set gammaSpace(p){if(this._texture){if(this._texture._gammaSpace===p)return;this._texture._gammaSpace=p}else{if(this._gammaSpace===p)return;this._gammaSpace=p}this.getScene()?.markAllMaterialsAsDirty(1,_=>_.hasTexture(this))}get isRGBD(){return this._texture!=null&&this._texture._isRGBD}set isRGBD(p){p!==this.isRGBD&&(this._texture&&(this._texture._isRGBD=p),this.getScene()?.markAllMaterialsAsDirty(1,_=>_.hasTexture(this)))}get noMipmap(){return!1}get lodGenerationOffset(){return this._texture?this._texture._lodGenerationOffset:0}set lodGenerationOffset(p){this._texture&&(this._texture._lodGenerationOffset=p)}get lodGenerationScale(){return this._texture?this._texture._lodGenerationScale:0}set lodGenerationScale(p){this._texture&&(this._texture._lodGenerationScale=p)}get linearSpecularLOD(){return this._texture?this._texture._linearSpecularLOD:!1}set linearSpecularLOD(p){this._texture&&(this._texture._linearSpecularLOD=p)}get irradianceTexture(){return this._texture?this._texture._irradianceTexture:null}set irradianceTexture(p){this._texture&&(this._texture._irradianceTexture=p)}get uid(){return this._uid||(this._uid=Y0()),this._uid}toString(){return this.name}getClassName(){return"BaseTexture"}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}get isBlocking(){return!0}get loadingError(){return this._loadingError}get errorObject(){return this._errorObject}constructor(p,_=null){super(null),this.metadata=null,this.reservedDataStore=null,this._hasAlpha=!1,this._getAlphaFromRGB=!1,this.level=1,this._coordinatesIndex=0,this.optimizeUVAllocation=!0,this._coordinatesMode=0,this.wrapR=1,this.anisotropicFilteringLevel=na.DEFAULT_ANISOTROPIC_FILTERING_LEVEL,this._isCube=!1,this._gammaSpace=!0,this.invertZ=!1,this.lodLevelInAlpha=!1,this.isRenderTarget=!1,this._prefiltered=!1,this._forceSerialize=!1,this.animations=[],this.onDisposeObservable=new Ri,this._onDisposeObserver=null,this._scene=null,this._uid=null,this._parentContainer=null,this._loadingError=!1,p?na._IsScene(p)?this._scene=p:this._engine=p:this._scene=Mr.LastCreatedScene,this._scene&&(this.uniqueId=this._scene.getUniqueId(),this._scene.addTexture(this),this._engine=this._scene.getEngine()),this._texture=_,this._uid=null}getScene(){return this._scene}_getEngine(){return this._engine}checkTransformsAreIdentical(p){return p!==null}getTextureMatrix(){return jt.IdentityReadOnly}getReflectionTextureMatrix(){return jt.IdentityReadOnly}getRefractionTextureMatrix(){return this.getReflectionTextureMatrix()}isReadyOrNotBlocking(){return!this.isBlocking||this.isReady()||this.loadingError}scale(p){}get canRescale(){return!1}_getFromCache(p,_,E,I,Z,re){const ae=this._getEngine();if(!ae)return null;const he=ae._getUseSRGBBuffer(!!Z,_),_e=ae.getLoadedTexturesCache();for(let ve=0;ve<_e.length;ve++){const Le=_e[ve];if((Z===void 0||he===Le._useSRGBBuffer)&&(I===void 0||I===Le.invertY)&&Le.url===p&&Le.generateMipMaps===!_&&(!E||E===Le.samplingMode)&&(re===void 0||re===Le.isCube))return Le.incrementReferences(),Le}return null}_rebuild(p=!1){}clone(){return null}get textureType(){return this._texture&&this._texture.type!==void 0?this._texture.type:0}get textureFormat(){return this._texture&&this._texture.format!==void 0?this._texture.format:5}_markAllSubMeshesAsTexturesDirty(){const p=this.getScene();p&&p.markAllMaterialsAsDirty(1)}readPixels(p=0,_=0,E=null,I=!0,Z=!1,re=0,ae=0,he=Number.MAX_VALUE,_e=Number.MAX_VALUE){if(!this._texture)return null;const ve=this._getEngine();if(!ve)return null;const Le=this.getSize();let ze=Le.width,He=Le.height;_!==0&&(ze=ze/Math.pow(2,_),He=He/Math.pow(2,_),ze=Math.round(ze),He=Math.round(He)),he=Math.min(ze,he),_e=Math.min(He,_e);try{return this._texture.isCube?ve._readTexturePixels(this._texture,he,_e,p,_,E,I,Z,re,ae):ve._readTexturePixels(this._texture,he,_e,-1,_,E,I,Z,re,ae)}catch{return null}}_readPixelsSync(p=0,_=0,E=null,I=!0,Z=!1){if(!this._texture)return null;const re=this.getSize();let ae=re.width,he=re.height;const _e=this._getEngine();if(!_e)return null;_!=0&&(ae=ae/Math.pow(2,_),he=he/Math.pow(2,_),ae=Math.round(ae),he=Math.round(he));try{return this._texture.isCube?_e._readTexturePixelsSync(this._texture,ae,he,p,_,E,I,Z):_e._readTexturePixelsSync(this._texture,ae,he,-1,_,E,I,Z)}catch{return null}}get _lodTextureHigh(){return this._texture?this._texture._lodTextureHigh:null}get _lodTextureMid(){return this._texture?this._texture._lodTextureMid:null}get _lodTextureLow(){return this._texture?this._texture._lodTextureLow:null}dispose(){if(this._scene){this._scene.stopAnimation&&this._scene.stopAnimation(this),this._scene.removePendingData(this);const p=this._scene.textures.indexOf(this);if(p>=0&&this._scene.textures.splice(p,1),this._scene.onTextureRemovedObservable.notifyObservers(this),this._scene=null,this._parentContainer){const _=this._parentContainer.textures.indexOf(this);_>-1&&this._parentContainer.textures.splice(_,1),this._parentContainer=null}}this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.metadata=null,super.dispose()}serialize(p=!1){if(!this.name&&!p)return null;const _=Hr.Serialize(this);return Hr.AppendSerializedAnimations(this,_),_}static WhenAllReady(p,_){let E=p.length;if(E===0){_();return}for(let I=0;I<p.length;I++){const Z=p[I];if(Z.isReady())--E===0&&_();else{const re=Z.onLoadObservable;re?re.addOnce(()=>{--E===0&&_()}):--E===0&&_()}}}static _IsScene(p){return p.getClassName()==="Scene"}}na.DEFAULT_ANISOTROPIC_FILTERING_LEVEL=4,Rt([Ut()],na.prototype,"uniqueId",void 0),Rt([Ut()],na.prototype,"name",void 0),Rt([Ut()],na.prototype,"metadata",void 0),Rt([Ut("hasAlpha")],na.prototype,"_hasAlpha",void 0),Rt([Ut("getAlphaFromRGB")],na.prototype,"_getAlphaFromRGB",void 0),Rt([Ut()],na.prototype,"level",void 0),Rt([Ut("coordinatesIndex")],na.prototype,"_coordinatesIndex",void 0),Rt([Ut()],na.prototype,"optimizeUVAllocation",void 0),Rt([Ut("coordinatesMode")],na.prototype,"_coordinatesMode",void 0),Rt([Ut()],na.prototype,"wrapU",null),Rt([Ut()],na.prototype,"wrapV",null),Rt([Ut()],na.prototype,"wrapR",void 0),Rt([Ut()],na.prototype,"anisotropicFilteringLevel",void 0),Rt([Ut()],na.prototype,"isCube",null),Rt([Ut()],na.prototype,"is3D",null),Rt([Ut()],na.prototype,"is2DArray",null),Rt([Ut()],na.prototype,"gammaSpace",null),Rt([Ut()],na.prototype,"invertZ",void 0),Rt([Ut()],na.prototype,"lodLevelInAlpha",void 0),Rt([Ut()],na.prototype,"lodGenerationOffset",null),Rt([Ut()],na.prototype,"lodGenerationScale",null),Rt([Ut()],na.prototype,"linearSpecularLOD",null),Rt([Hn()],na.prototype,"irradianceTexture",null),Rt([Ut()],na.prototype,"isRenderTarget",void 0);function jg(pe,p,_=!1){const E=p.width,I=p.height;if(pe instanceof Float32Array){let _e=pe.byteLength/pe.BYTES_PER_ELEMENT;const ve=new Uint8Array(_e);for(;--_e>=0;){let Le=pe[_e];Le<0?Le=0:Le>1&&(Le=1),ve[_e]=Le*255}pe=ve}const Z=document.createElement("canvas");Z.width=E,Z.height=I;const re=Z.getContext("2d");if(!re)return null;const ae=re.createImageData(E,I);if(ae.data.set(pe),re.putImageData(ae,0,0),_){const _e=document.createElement("canvas");_e.width=E,_e.height=I;const ve=_e.getContext("2d");return ve?(ve.translate(0,I),ve.scale(1,-1),ve.drawImage(Z,0,0),_e.toDataURL("image/png")):null}return Z.toDataURL("image/png")}function vb(pe,p=0,_=0){const E=pe.getInternalTexture();if(!E)return null;const I=pe._readPixelsSync(p,_);return I?jg(I,pe.getSize(),E.invertY):null}async function Rb(pe,p=0,_=0){const E=pe.getInternalTexture();if(!E)return null;const I=await pe.readPixels(p,_);return I?jg(I,pe.getSize(),E.invertY):null}const qL={GenerateBase64StringFromPixelData:jg,GenerateBase64StringFromTexture:vb,GenerateBase64StringFromTextureAsync:Rb};class rh{}rh.UseOpenGLOrientationForUV=!1;class Ki extends na{static _CreateVideoTexture(p,_,E,I=!1,Z=!1,re=Ki.TRILINEAR_SAMPLINGMODE,ae={},he,_e=5){throw ur("VideoTexture")}get noMipmap(){return this._noMipmap}get mimeType(){return this._mimeType}set isBlocking(p){this._isBlocking=p}get isBlocking(){return this._isBlocking}get invertY(){return this._invertY}constructor(p,_,E,I,Z=Ki.TRILINEAR_SAMPLINGMODE,re=null,ae=null,he=null,_e=!1,ve,Le,ze,He,xt){super(_),this.url=null,this.uOffset=0,this.vOffset=0,this.uScale=1,this.vScale=1,this.uAng=0,this.vAng=0,this.wAng=0,this.uRotationCenter=.5,this.vRotationCenter=.5,this.wRotationCenter=.5,this.homogeneousRotationInUVTransform=!1,this.inspectableCustomProperties=null,this._noMipmap=!1,this._invertY=!1,this._rowGenerationMatrix=null,this._cachedTextureMatrix=null,this._projectionModeMatrix=null,this._t0=null,this._t1=null,this._t2=null,this._cachedUOffset=-1,this._cachedVOffset=-1,this._cachedUScale=0,this._cachedVScale=0,this._cachedUAng=-1,this._cachedVAng=-1,this._cachedWAng=-1,this._cachedReflectionProjectionMatrixId=-1,this._cachedURotationCenter=-1,this._cachedVRotationCenter=-1,this._cachedWRotationCenter=-1,this._cachedHomogeneousRotationInUVTransform=!1,this._cachedReflectionTextureMatrix=null,this._cachedReflectionUOffset=-1,this._cachedReflectionVOffset=-1,this._cachedReflectionUScale=0,this._cachedReflectionVScale=0,this._cachedReflectionCoordinatesMode=-1,this._buffer=null,this._deleteBuffer=!1,this._format=null,this._delayedOnLoad=null,this._delayedOnError=null,this.onLoadObservable=new Ri,this._isBlocking=!0,this.name=p||"",this.url=p;let rt,Tt=!1,Lt=null,Nt=!0;typeof E=="object"&&E!==null?(rt=E.noMipmap??!1,I=E.invertY??!rh.UseOpenGLOrientationForUV,Z=E.samplingMode??Ki.TRILINEAR_SAMPLINGMODE,re=E.onLoad??null,ae=E.onError??null,he=E.buffer??null,_e=E.deleteBuffer??!1,ve=E.format,Le=E.mimeType,ze=E.loaderOptions,He=E.creationFlags,Tt=E.useSRGBBuffer??!1,Lt=E.internalTexture??null,Nt=E.gammaSpace??Nt):rt=!!E,this._gammaSpace=Nt,this._noMipmap=rt,this._invertY=I===void 0?!rh.UseOpenGLOrientationForUV:I,this._initialSamplingMode=Z,this._buffer=he,this._deleteBuffer=_e,this._mimeType=Le,this._loaderOptions=ze,this._creationFlags=He,this._useSRGBBuffer=Tt,this._forcedExtension=xt,ve&&(this._format=ve);const qt=this.getScene(),Xt=this._getEngine();if(!Xt)return;Xt.onBeforeTextureInitObservable.notifyObservers(this);const zt=()=>{this._texture&&(this._texture._invertVScale&&(this.vScale*=-1,this.vOffset+=1),this._texture._cachedWrapU!==null&&(this.wrapU=this._texture._cachedWrapU,this._texture._cachedWrapU=null),this._texture._cachedWrapV!==null&&(this.wrapV=this._texture._cachedWrapV,this._texture._cachedWrapV=null),this._texture._cachedWrapR!==null&&(this.wrapR=this._texture._cachedWrapR,this._texture._cachedWrapR=null)),this.onLoadObservable.hasObservers()&&this.onLoadObservable.notifyObservers(this),re&&re(),!this.isBlocking&&qt&&qt.resetCachedMaterial()},Gt=(xi,Gi)=>{this._loadingError=!0,this._errorObject={message:xi,exception:Gi},ae&&ae(xi,Gi),Ki.OnTextureLoadErrorObservable.notifyObservers(this)};if(!this.url&&!Lt){this._delayedOnLoad=zt,this._delayedOnError=Gt;return}if(this._texture=Lt??this._getFromCache(this.url,rt,Z,this._invertY,Tt,this.isCube),this._texture)if(this._texture.isReady)cl.SetImmediate(()=>zt());else{const xi=this._texture.onLoadedObservable.add(zt);this._texture.onErrorObservable.add(Gi=>{Gt(Gi.message,Gi.exception),this._texture?.onLoadedObservable.remove(xi)})}else if(!qt||!qt.useDelayedTextureLoading){try{this._texture=Xt.createTexture(this.url,rt,this._invertY,qt,Z,zt,Gt,this._buffer,void 0,this._format,this._forcedExtension,Le,ze,He,Tt)}catch(xi){throw Gt("error loading",xi),xi}_e&&(this._buffer=null)}else this.delayLoadState=4,this._delayedOnLoad=zt,this._delayedOnError=Gt}updateURL(p,_=null,E,I){this.url&&(this.releaseInternalTexture(),this.getScene().markAllMaterialsAsDirty(1,Z=>Z.hasTexture(this))),(!this.name||this.name.startsWith("data:"))&&(this.name=p),this.url=p,this._buffer=_,this._forcedExtension=I,this.delayLoadState=4,E&&(this._delayedOnLoad=E),this.delayLoad()}delayLoad(){if(this.delayLoadState!==4)return;const p=this.getScene();p&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,this._noMipmap,this.samplingMode,this._invertY,this._useSRGBBuffer,this.isCube),this._texture?this._delayedOnLoad&&(this._texture.isReady?cl.SetImmediate(this._delayedOnLoad):this._texture.onLoadedObservable.add(this._delayedOnLoad)):(this._texture=p.getEngine().createTexture(this.url,this._noMipmap,this._invertY,p,this.samplingMode,this._delayedOnLoad,this._delayedOnError,this._buffer,null,this._format,this._forcedExtension,this._mimeType,this._loaderOptions,this._creationFlags,this._useSRGBBuffer),this._deleteBuffer&&(this._buffer=null)),this._delayedOnLoad=null,this._delayedOnError=null)}_prepareRowForTextureGeneration(p,_,E,I){p*=this._cachedUScale,_*=this._cachedVScale,p-=this.uRotationCenter*this._cachedUScale,_-=this.vRotationCenter*this._cachedVScale,E-=this.wRotationCenter,at.TransformCoordinatesFromFloatsToRef(p,_,E,this._rowGenerationMatrix,I),I.x+=this.uRotationCenter*this._cachedUScale+this._cachedUOffset,I.y+=this.vRotationCenter*this._cachedVScale+this._cachedVOffset,I.z+=this.wRotationCenter}checkTransformsAreIdentical(p){return p!==null&&this.uOffset===p.uOffset&&this.vOffset===p.vOffset&&this.uScale===p.uScale&&this.vScale===p.vScale&&this.uAng===p.uAng&&this.vAng===p.vAng&&this.wAng===p.wAng}getTextureMatrix(p=1){if(this.uOffset===this._cachedUOffset&&this.vOffset===this._cachedVOffset&&this.uScale*p===this._cachedUScale&&this.vScale===this._cachedVScale&&this.uAng===this._cachedUAng&&this.vAng===this._cachedVAng&&this.wAng===this._cachedWAng&&this.uRotationCenter===this._cachedURotationCenter&&this.vRotationCenter===this._cachedVRotationCenter&&this.wRotationCenter===this._cachedWRotationCenter&&this.homogeneousRotationInUVTransform===this._cachedHomogeneousRotationInUVTransform)return this._cachedTextureMatrix;this._cachedUOffset=this.uOffset,this._cachedVOffset=this.vOffset,this._cachedUScale=this.uScale*p,this._cachedVScale=this.vScale,this._cachedUAng=this.uAng,this._cachedVAng=this.vAng,this._cachedWAng=this.wAng,this._cachedURotationCenter=this.uRotationCenter,this._cachedVRotationCenter=this.vRotationCenter,this._cachedWRotationCenter=this.wRotationCenter,this._cachedHomogeneousRotationInUVTransform=this.homogeneousRotationInUVTransform,(!this._cachedTextureMatrix||!this._rowGenerationMatrix)&&(this._cachedTextureMatrix=jt.Zero(),this._rowGenerationMatrix=new jt,this._t0=at.Zero(),this._t1=at.Zero(),this._t2=at.Zero()),jt.RotationYawPitchRollToRef(this.vAng,this.uAng,this.wAng,this._rowGenerationMatrix),this.homogeneousRotationInUVTransform?(jt.TranslationToRef(-this._cachedURotationCenter,-this._cachedVRotationCenter,-this._cachedWRotationCenter,ui.Matrix[0]),jt.TranslationToRef(this._cachedURotationCenter,this._cachedVRotationCenter,this._cachedWRotationCenter,ui.Matrix[1]),jt.ScalingToRef(this._cachedUScale,this._cachedVScale,0,ui.Matrix[2]),jt.TranslationToRef(this._cachedUOffset,this._cachedVOffset,0,ui.Matrix[3]),ui.Matrix[0].multiplyToRef(this._rowGenerationMatrix,this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(ui.Matrix[1],this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(ui.Matrix[2],this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(ui.Matrix[3],this._cachedTextureMatrix),this._cachedTextureMatrix.setRowFromFloats(2,this._cachedTextureMatrix.m[12],this._cachedTextureMatrix.m[13],this._cachedTextureMatrix.m[14],1)):(this._prepareRowForTextureGeneration(0,0,0,this._t0),this._prepareRowForTextureGeneration(1,0,0,this._t1),this._prepareRowForTextureGeneration(0,1,0,this._t2),this._t1.subtractInPlace(this._t0),this._t2.subtractInPlace(this._t0),jt.FromValuesToRef(this._t1.x,this._t1.y,this._t1.z,0,this._t2.x,this._t2.y,this._t2.z,0,this._t0.x,this._t0.y,this._t0.z,0,0,0,0,1,this._cachedTextureMatrix));const _=this.getScene();return _?(this.optimizeUVAllocation&&_.markAllMaterialsAsDirty(1,E=>E.hasTexture(this)),this._cachedTextureMatrix):this._cachedTextureMatrix}getReflectionTextureMatrix(){const p=this.getScene();if(!p)return this._cachedReflectionTextureMatrix;if(this.uOffset===this._cachedReflectionUOffset&&this.vOffset===this._cachedReflectionVOffset&&this.uScale===this._cachedReflectionUScale&&this.vScale===this._cachedReflectionVScale&&this.coordinatesMode===this._cachedReflectionCoordinatesMode)if(this.coordinatesMode===Ki.PROJECTION_MODE){if(this._cachedReflectionProjectionMatrixId===p.getProjectionMatrix().updateFlag)return this._cachedReflectionTextureMatrix}else return this._cachedReflectionTextureMatrix;this._cachedReflectionTextureMatrix||(this._cachedReflectionTextureMatrix=jt.Zero()),this._projectionModeMatrix||(this._projectionModeMatrix=jt.Zero());const _=this._cachedReflectionCoordinatesMode!==this.coordinatesMode;switch(this._cachedReflectionUOffset=this.uOffset,this._cachedReflectionVOffset=this.vOffset,this._cachedReflectionUScale=this.uScale,this._cachedReflectionVScale=this.vScale,this._cachedReflectionCoordinatesMode=this.coordinatesMode,this.coordinatesMode){case Ki.PLANAR_MODE:{jt.IdentityToRef(this._cachedReflectionTextureMatrix),this._cachedReflectionTextureMatrix[0]=this.uScale,this._cachedReflectionTextureMatrix[5]=this.vScale,this._cachedReflectionTextureMatrix[12]=this.uOffset,this._cachedReflectionTextureMatrix[13]=this.vOffset;break}case Ki.PROJECTION_MODE:{jt.FromValuesToRef(.5,0,0,0,0,-.5,0,0,0,0,0,0,.5,.5,1,1,this._projectionModeMatrix);const E=p.getProjectionMatrix();this._cachedReflectionProjectionMatrixId=E.updateFlag,E.multiplyToRef(this._projectionModeMatrix,this._cachedReflectionTextureMatrix);break}default:jt.IdentityToRef(this._cachedReflectionTextureMatrix);break}return _&&p.markAllMaterialsAsDirty(1,E=>E.hasTexture(this)),this._cachedReflectionTextureMatrix}clone(){const p={noMipmap:this._noMipmap,invertY:this._invertY,samplingMode:this.samplingMode,onLoad:void 0,onError:void 0,buffer:this._texture?this._texture._buffer:void 0,deleteBuffer:this._deleteBuffer,format:this.textureFormat,mimeType:this.mimeType,loaderOptions:this._loaderOptions,creationFlags:this._creationFlags,useSRGBBuffer:this._useSRGBBuffer};return Hr.Clone(()=>new Ki(this._texture?this._texture.url:null,this.getScene(),p),this)}serialize(){const p=this.name;Ki.SerializeBuffers||this.name.startsWith("data:")&&(this.name=""),this.name.startsWith("data:")&&this.url===this.name&&(this.url="");const _=super.serialize(Ki._SerializeInternalTextureUniqueId);return _?((Ki.SerializeBuffers||Ki.ForceSerializeBuffers)&&(typeof this._buffer=="string"&&this._buffer.substr(0,5)==="data:"?(_.base64String=this._buffer,_.name=_.name.replace("data:","")):this.url&&this.url.startsWith("data:")&&this._buffer instanceof Uint8Array?_.base64String="data:image/png;base64,"+ll(this._buffer):(Ki.ForceSerializeBuffers||this.url&&this.url.startsWith("blob:")||this._forceSerialize)&&(_.base64String=!this._engine||this._engine._features.supportSyncTextureRead?vb(this):Rb(this))),_.invertY=this._invertY,_.samplingMode=this.samplingMode,_._creationFlags=this._creationFlags,_._useSRGBBuffer=this._useSRGBBuffer,Ki._SerializeInternalTextureUniqueId&&(_.internalTextureUniqueId=this._texture?.uniqueId??void 0),_.noMipmap=this._noMipmap,this.name=p,_):null}getClassName(){return"Texture"}dispose(){super.dispose(),this.onLoadObservable.clear(),this._delayedOnLoad=null,this._delayedOnError=null,this._buffer=null}static Parse(p,_,E){if(p.customType){const _e=k0.Instantiate(p.customType).Parse(p,_,E);return p.samplingMode&&_e.updateSamplingMode&&_e._samplingMode&&_e._samplingMode!==p.samplingMode&&_e.updateSamplingMode(p.samplingMode),_e}if(p.isCube&&!p.isRenderTarget)return Ki._CubeTextureParser(p,_,E);const I=p.internalTextureUniqueId!==void 0;if(!p.name&&!p.isRenderTarget&&!I)return null;let Z;if(I){const he=_.getEngine().getLoadedTexturesCache();for(const _e of he)if(_e.uniqueId===p.internalTextureUniqueId){Z=_e;break}}const re=he=>{if(he&&he._texture&&(he._texture._cachedWrapU=null,he._texture._cachedWrapV=null,he._texture._cachedWrapR=null),p.samplingMode){const _e=p.samplingMode;he&&he.samplingMode!==_e&&he.updateSamplingMode(_e)}if(he&&p.animations)for(let _e=0;_e<p.animations.length;_e++){const ve=p.animations[_e],Le=r0("BABYLON.Animation");Le&&he.animations.push(Le.Parse(ve))}I&&!Z&&he?._texture?._setUniqueId(p.internalTextureUniqueId)};return Hr.Parse(()=>{let he=!0;if(p.noMipmap&&(he=!1),p.mirrorPlane){const _e=Ki._CreateMirror(p.name,p.renderTargetSize,_,he);return _e._waitingRenderList=p.renderList,_e.mirrorPlane=r2.FromArray(p.mirrorPlane),re(_e),_e}else if(p.isRenderTarget){let _e=null;if(p.isCube){if(_.reflectionProbes)for(let ve=0;ve<_.reflectionProbes.length;ve++){const Le=_.reflectionProbes[ve];if(Le.name===p.name)return Le.cubeTexture}}else _e=Ki._CreateRenderTargetTexture(p.name,p.renderTargetSize,_,he,p._creationFlags??0),_e._waitingRenderList=p.renderList;return re(_e),_e}else if(p.isVideo){const _e=Ki._CreateVideoTexture(E+(p.url||p.name),E+(p.src||p.url),_,he,p.invertY,p.samplingMode,p.settings||{});return re(_e),_e}else{let _e;if(p.base64String&&!Z)_e=Ki.CreateFromBase64String(p.base64String,p.base64String,_,!he,p.invertY,p.samplingMode,()=>{re(_e)},p._creationFlags??0,p._useSRGBBuffer??!1),_e.name=p.name;else{let ve;p.name&&(p.name.indexOf("://")>0||p.name.startsWith("data:"))?ve=p.name:ve=E+p.name,p.url&&(p.url.startsWith("data:")||Ki.UseSerializedUrlIfAny)&&(ve=p.url);const Le={noMipmap:!he,invertY:p.invertY,samplingMode:p.samplingMode,onLoad:()=>{re(_e)},internalTexture:Z};_e=new Ki(ve,_,Le)}return _e}},p,_)}static CreateFromBase64String(p,_,E,I,Z,re=Ki.TRILINEAR_SAMPLINGMODE,ae=null,he=null,_e=5,ve){return new Ki("data:"+_,E,I,Z,re,ae,he,p,!1,_e,void 0,void 0,ve)}static LoadFromDataString(p,_,E,I=!1,Z,re=!0,ae=Ki.TRILINEAR_SAMPLINGMODE,he=null,_e=null,ve=5,Le){return p.substr(0,5)!=="data:"&&(p="data:"+p),new Ki(p,E,Z,re,ae,he,_e,_,I,ve,void 0,void 0,Le)}}Ki.SerializeBuffers=!0,Ki.ForceSerializeBuffers=!1,Ki.OnTextureLoadErrorObservable=new Ri,Ki._SerializeInternalTextureUniqueId=!1,Ki._CubeTextureParser=(pe,p,_)=>{throw ur("CubeTexture")},Ki._CreateMirror=(pe,p,_,E)=>{throw ur("MirrorTexture")},Ki._CreateRenderTargetTexture=(pe,p,_,E,I)=>{throw ur("RenderTargetTexture")},Ki.NEAREST_SAMPLINGMODE=1,Ki.NEAREST_NEAREST_MIPLINEAR=8,Ki.BILINEAR_SAMPLINGMODE=2,Ki.LINEAR_LINEAR_MIPNEAREST=11,Ki.TRILINEAR_SAMPLINGMODE=3,Ki.LINEAR_LINEAR_MIPLINEAR=3,Ki.NEAREST_NEAREST_MIPNEAREST=4,Ki.NEAREST_LINEAR_MIPNEAREST=5,Ki.NEAREST_LINEAR_MIPLINEAR=6,Ki.NEAREST_LINEAR=7,Ki.NEAREST_NEAREST=1,Ki.LINEAR_NEAREST_MIPNEAREST=9,Ki.LINEAR_NEAREST_MIPLINEAR=10,Ki.LINEAR_LINEAR=2,Ki.LINEAR_NEAREST=12,Ki.EXPLICIT_MODE=0,Ki.SPHERICAL_MODE=1,Ki.PLANAR_MODE=2,Ki.CUBIC_MODE=3,Ki.PROJECTION_MODE=4,Ki.SKYBOX_MODE=5,Ki.INVCUBIC_MODE=6,Ki.EQUIRECTANGULAR_MODE=7,Ki.FIXED_EQUIRECTANGULAR_MODE=8,Ki.FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9,Ki.CLAMP_ADDRESSMODE=0,Ki.WRAP_ADDRESSMODE=1,Ki.MIRROR_ADDRESSMODE=2,Ki.UseSerializedUrlIfAny=!1,Rt([Ut()],Ki.prototype,"url",void 0),Rt([Ut()],Ki.prototype,"uOffset",void 0),Rt([Ut()],Ki.prototype,"vOffset",void 0),Rt([Ut()],Ki.prototype,"uScale",void 0),Rt([Ut()],Ki.prototype,"vScale",void 0),Rt([Ut()],Ki.prototype,"uAng",void 0),Rt([Ut()],Ki.prototype,"vAng",void 0),Rt([Ut()],Ki.prototype,"wAng",void 0),Rt([Ut()],Ki.prototype,"uRotationCenter",void 0),Rt([Ut()],Ki.prototype,"vRotationCenter",void 0),Rt([Ut()],Ki.prototype,"wRotationCenter",void 0),Rt([Ut()],Ki.prototype,"homogeneousRotationInUVTransform",void 0),Rt([Ut()],Ki.prototype,"isBlocking",null),Gs("BABYLON.Texture",Ki),Hr._TextureParser=Ki.Parse;class pO{constructor(p){this.name=_r.NAME_LAYER,this.scene=p||Mr.LastCreatedScene,this.scene&&(this._engine=this.scene.getEngine(),this.scene.layers=[])}register(){this.scene._beforeCameraDrawStage.registerStep(_r.STEP_BEFORECAMERADRAW_LAYER,this,this._drawCameraBackground),this.scene._afterCameraDrawStage.registerStep(_r.STEP_AFTERCAMERADRAW_LAYER,this,this._drawCameraForegroundWithPostProcessing),this.scene._afterCameraPostProcessStage.registerStep(_r.STEP_AFTERCAMERAPOSTPROCESS_LAYER,this,this._drawCameraForegroundWithoutPostProcessing),this.scene._beforeRenderTargetDrawStage.registerStep(_r.STEP_BEFORERENDERTARGETDRAW_LAYER,this,this._drawRenderTargetBackground),this.scene._afterRenderTargetDrawStage.registerStep(_r.STEP_AFTERRENDERTARGETDRAW_LAYER,this,this._drawRenderTargetForegroundWithPostProcessing),this.scene._afterRenderTargetPostProcessStage.registerStep(_r.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER,this,this._drawRenderTargetForegroundWithoutPostProcessing)}rebuild(){const p=this.scene.layers;for(const _ of p)_._rebuild()}dispose(){const p=this.scene.layers;for(;p.length;)p[0].dispose()}_draw(p){const _=this.scene.layers;if(_.length){this._engine.setDepthBuffer(!1);for(const E of _)p(E)&&E.render();this._engine.setDepthBuffer(!0)}}_drawCameraPredicate(p,_,E,I){return!p.renderOnlyInRenderTargetTextures&&p.isBackground===_&&p.applyPostProcess===E&&(p.layerMask&I)!==0}_drawCameraBackground(p){this._draw(_=>this._drawCameraPredicate(_,!0,!0,p.layerMask))}_drawCameraForegroundWithPostProcessing(p){this._draw(_=>this._drawCameraPredicate(_,!1,!0,p.layerMask))}_drawCameraForegroundWithoutPostProcessing(p){this._draw(_=>this._drawCameraPredicate(_,!1,!1,p.layerMask))}_drawRenderTargetPredicate(p,_,E,I,Z){return p.renderTargetTextures.length>0&&p.isBackground===_&&p.applyPostProcess===E&&p.renderTargetTextures.indexOf(Z)>-1&&(p.layerMask&I)!==0}_drawRenderTargetBackground(p){this._draw(_=>this._drawRenderTargetPredicate(_,!0,!0,this.scene.activeCamera.layerMask,p))}_drawRenderTargetForegroundWithPostProcessing(p){this._draw(_=>this._drawRenderTargetPredicate(_,!1,!0,this.scene.activeCamera.layerMask,p))}_drawRenderTargetForegroundWithoutPostProcessing(p){this._draw(_=>this._drawRenderTargetPredicate(_,!1,!1,this.scene.activeCamera.layerMask,p))}addFromContainer(p){p.layers&&p.layers.forEach(_=>{this.scene.layers.push(_)})}removeFromContainer(p,_=!1){p.layers&&p.layers.forEach(E=>{const I=this.scene.layers.indexOf(E);I!==-1&&this.scene.layers.splice(I,1),_&&E.dispose()})}}const Mb="helperFunctions",wb=`const float PI=3.1415926535897932384626433832795;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
mat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{return value*value;}
vec3 square(vec3 value)
{return value*value;}
float pow5(float value) {float sq=value*value;return sq*sq*value;}
float getLuminance(vec3 color)
{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}
float getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}
float dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}
const float rgbdMaxRange=255.0;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(clamp(rgb,0.,1.),D); }
vec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
`;ji.IncludesShadersStore[Mb]=wb;const $L={name:Mb,shader:wb},Lb="layerPixelShader",kb=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec4 color;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);
#ifdef LINEAR
baseColor.rgb=toGammaSpace(baseColor.rgb);
#endif
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
gl_FragColor=baseColor*color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;ji.ShadersStore[Lb]=kb;const rB={name:Lb,shader:kb},Ub="layerVertexShader",Gb=`attribute vec2 position;uniform vec2 scale;uniform vec2 offset;uniform mat4 textureMatrix;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec2 shiftedPosition=position*scale+offset;vUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));gl_Position=vec4(shiftedPosition,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;ji.ShadersStore[Ub]=Gb;const nB={name:Ub,shader:Gb};class _O{set applyPostProcess(p){this._applyPostProcess=p}get applyPostProcess(){return this.isBackground||this._applyPostProcess}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}set onBeforeRender(p){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(p)}set onAfterRender(p){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(p)}constructor(p,_,E,I,Z){this.name=p,this._applyPostProcess=!0,this.scale=new xr(1,1),this.offset=new xr(0,0),this.alphaBlendingMode=2,this.layerMask=268435455,this.renderTargetTextures=[],this.renderOnlyInRenderTargetTextures=!1,this.isEnabled=!0,this._vertexBuffers={},this.onDisposeObservable=new Ri,this.onBeforeRenderObservable=new Ri,this.onAfterRenderObservable=new Ri,this.texture=_?new Ki(_,E,!0):null,this.isBackground=I===void 0?!0:I,this.color=Z===void 0?new Tr(1,1,1,1):Z,this._scene=E||Mr.LastCreatedScene;let re=this._scene._getComponent(_r.NAME_LAYER);re||(re=new pO(this._scene),this._scene._addComponent(re)),this._scene.layers.push(this);const ae=this._scene.getEngine();this._drawWrapper=new xo(ae);const he=[];he.push(1,1),he.push(-1,1),he.push(-1,-1),he.push(1,-1);const _e=new ut(ae,he,ut.PositionKind,!1,!1,2);this._vertexBuffers[ut.PositionKind]=_e,this._createIndexBuffer()}_createIndexBuffer(){const p=this._scene.getEngine(),_=[];_.push(0),_.push(1),_.push(2),_.push(0),_.push(2),_.push(3),this._indexBuffer=p.createIndexBuffer(_)}_rebuild(){const p=this._vertexBuffers[ut.PositionKind];p&&p._rebuild(),this._createIndexBuffer()}isReady(){const p=this._scene.getEngine();let _="";return this.alphaTest&&(_="#define ALPHATEST"),this.texture&&!this.texture.gammaSpace&&(_+=`
#define LINEAR`),this._previousDefines!==_&&(this._previousDefines=_,this._drawWrapper.effect=p.createEffect("layer",[ut.PositionKind],["textureMatrix","color","scale","offset"],["textureSampler"],_)),this._drawWrapper.effect?.isReady()&&this.texture?.isReady()}render(){if(!this.isEnabled)return;const p=this._scene.getEngine();if(!this.isReady())return;const _=this._drawWrapper.effect;this.onBeforeRenderObservable.notifyObservers(this),p.enableEffect(this._drawWrapper),p.setState(!1),_.setTexture("textureSampler",this.texture),_.setMatrix("textureMatrix",this.texture.getTextureMatrix()),_.setFloat4("color",this.color.r,this.color.g,this.color.b,this.color.a),_.setVector2("offset",this.offset),_.setVector2("scale",this.scale),p.bindBuffers(this._vertexBuffers,this._indexBuffer,_),this.alphaTest?p.drawElementsType(zi.TriangleFillMode,0,6):(p.setAlphaMode(this.alphaBlendingMode),p.drawElementsType(zi.TriangleFillMode,0,6),p.setAlphaMode(0)),this.onAfterRenderObservable.notifyObservers(this)}dispose(){const p=this._vertexBuffers[ut.PositionKind];p&&(p.dispose(),this._vertexBuffers[ut.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this.texture&&(this.texture.dispose(),this.texture=null),this.renderTargetTextures=[];const _=this._scene.layers.indexOf(this);this._scene.layers.splice(_,1),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onAfterRenderObservable.clear(),this.onBeforeRenderObservable.clear()}}function qg(pe,p,_){try{const E=pe.next();E.done?p(E):E.value?E.value.then(()=>{E.value=void 0,p(E)},_):p(E)}catch(E){_(E)}}function TO(pe=25){let p;return(_,E,I)=>{const Z=performance.now();p===void 0||Z-p>pe?(p=Z,setTimeout(()=>{qg(_,E,I)},0)):qg(_,E,I)}}function zb(pe,p,_,E,I){const Z=()=>{let re;const ae=he=>{he.done?_(he.value):re===void 0?re=!0:Z()};do re=void 0,!I||!I.aborted?p(pe,ae,E):E(new Error("Aborted")),re===void 0&&(re=!1);while(re)};Z()}function $g(pe,p){let _;return zb(pe,qg,E=>_=E,E=>{throw E},p),_}function Wb(pe,p,_){return new Promise((E,I)=>{zb(pe,p,E,I,_)})}function vO(pe,p){return(..._)=>$g(pe(..._),p)}function aB(pe,p,_){return(...E)=>Wb(pe(...E),p,_)}class e_{}class Xr{constructor(){this.uniqueId=0,this.metadata={},this._applyTo=vO(this._applyToCoroutine.bind(this)),this.uniqueId=Xr._UniqueIDGenerator,Xr._UniqueIDGenerator++}set(p,_){switch(p.length||Ti.Warn(`Setting vertex data kind '${_}' with an empty array`),_){case ut.PositionKind:this.positions=p;break;case ut.NormalKind:this.normals=p;break;case ut.TangentKind:this.tangents=p;break;case ut.UVKind:this.uvs=p;break;case ut.UV2Kind:this.uvs2=p;break;case ut.UV3Kind:this.uvs3=p;break;case ut.UV4Kind:this.uvs4=p;break;case ut.UV5Kind:this.uvs5=p;break;case ut.UV6Kind:this.uvs6=p;break;case ut.ColorKind:this.colors=p;break;case ut.MatricesIndicesKind:this.matricesIndices=p;break;case ut.MatricesWeightsKind:this.matricesWeights=p;break;case ut.MatricesIndicesExtraKind:this.matricesIndicesExtra=p;break;case ut.MatricesWeightsExtraKind:this.matricesWeightsExtra=p;break}}applyToMesh(p,_){return this._applyTo(p,_,!1),this}applyToGeometry(p,_){return this._applyTo(p,_,!1),this}updateMesh(p){return this._update(p),this}updateGeometry(p){return this._update(p),this}*_applyToCoroutine(p,_=!1,E){if(this.positions&&(p.setVerticesData(ut.PositionKind,this.positions,_),E&&(yield)),this.normals&&(p.setVerticesData(ut.NormalKind,this.normals,_),E&&(yield)),this.tangents&&(p.setVerticesData(ut.TangentKind,this.tangents,_),E&&(yield)),this.uvs&&(p.setVerticesData(ut.UVKind,this.uvs,_),E&&(yield)),this.uvs2&&(p.setVerticesData(ut.UV2Kind,this.uvs2,_),E&&(yield)),this.uvs3&&(p.setVerticesData(ut.UV3Kind,this.uvs3,_),E&&(yield)),this.uvs4&&(p.setVerticesData(ut.UV4Kind,this.uvs4,_),E&&(yield)),this.uvs5&&(p.setVerticesData(ut.UV5Kind,this.uvs5,_),E&&(yield)),this.uvs6&&(p.setVerticesData(ut.UV6Kind,this.uvs6,_),E&&(yield)),this.colors&&(p.setVerticesData(ut.ColorKind,this.colors,_),E&&(yield)),this.matricesIndices&&(p.setVerticesData(ut.MatricesIndicesKind,this.matricesIndices,_),E&&(yield)),this.matricesWeights&&(p.setVerticesData(ut.MatricesWeightsKind,this.matricesWeights,_),E&&(yield)),this.matricesIndicesExtra&&(p.setVerticesData(ut.MatricesIndicesExtraKind,this.matricesIndicesExtra,_),E&&(yield)),this.matricesWeightsExtra&&(p.setVerticesData(ut.MatricesWeightsExtraKind,this.matricesWeightsExtra,_),E&&(yield)),this.indices?(p.setIndices(this.indices,null,_),E&&(yield)):p.setIndices([],null),p.subMeshes&&this.materialInfos&&this.materialInfos.length>1){const I=p;I.subMeshes=[];for(const Z of this.materialInfos)new l2(Z.materialIndex,Z.verticesStart,Z.verticesCount,Z.indexStart,Z.indexCount,I)}return this}_update(p,_,E){return this.positions&&p.updateVerticesData(ut.PositionKind,this.positions,_,E),this.normals&&p.updateVerticesData(ut.NormalKind,this.normals,_,E),this.tangents&&p.updateVerticesData(ut.TangentKind,this.tangents,_,E),this.uvs&&p.updateVerticesData(ut.UVKind,this.uvs,_,E),this.uvs2&&p.updateVerticesData(ut.UV2Kind,this.uvs2,_,E),this.uvs3&&p.updateVerticesData(ut.UV3Kind,this.uvs3,_,E),this.uvs4&&p.updateVerticesData(ut.UV4Kind,this.uvs4,_,E),this.uvs5&&p.updateVerticesData(ut.UV5Kind,this.uvs5,_,E),this.uvs6&&p.updateVerticesData(ut.UV6Kind,this.uvs6,_,E),this.colors&&p.updateVerticesData(ut.ColorKind,this.colors,_,E),this.matricesIndices&&p.updateVerticesData(ut.MatricesIndicesKind,this.matricesIndices,_,E),this.matricesWeights&&p.updateVerticesData(ut.MatricesWeightsKind,this.matricesWeights,_,E),this.matricesIndicesExtra&&p.updateVerticesData(ut.MatricesIndicesExtraKind,this.matricesIndicesExtra,_,E),this.matricesWeightsExtra&&p.updateVerticesData(ut.MatricesWeightsExtraKind,this.matricesWeightsExtra,_,E),this.indices&&p.setIndices(this.indices,null),this}static _TransformVector3Coordinates(p,_,E=0,I=p.length){const Z=ui.Vector3[0],re=ui.Vector3[1];for(let ae=E;ae<E+I;ae+=3)at.FromArrayToRef(p,ae,Z),at.TransformCoordinatesToRef(Z,_,re),p[ae]=re.x,p[ae+1]=re.y,p[ae+2]=re.z}static _TransformVector3Normals(p,_,E=0,I=p.length){const Z=ui.Vector3[0],re=ui.Vector3[1];for(let ae=E;ae<E+I;ae+=3)at.FromArrayToRef(p,ae,Z),at.TransformNormalToRef(Z,_,re),p[ae]=re.x,p[ae+1]=re.y,p[ae+2]=re.z}static _TransformVector4Normals(p,_,E=0,I=p.length){const Z=ui.Vector4[0],re=ui.Vector4[1];for(let ae=E;ae<E+I;ae+=4)Lr.FromArrayToRef(p,ae,Z),Lr.TransformNormalToRef(Z,_,re),p[ae]=re.x,p[ae+1]=re.y,p[ae+2]=re.z,p[ae+3]=re.w}static _FlipFaces(p,_=0,E=p.length){for(let I=_;I<_+E;I+=3){const Z=p[I+1];p[I+1]=p[I+2],p[I+2]=Z}}transform(p){const _=p.determinant()<0;return this.positions&&Xr._TransformVector3Coordinates(this.positions,p),this.normals&&Xr._TransformVector3Normals(this.normals,p),this.tangents&&Xr._TransformVector4Normals(this.tangents,p),_&&this.indices&&Xr._FlipFaces(this.indices),this}splitBasedOnMaterialID(){if(!this.materialInfos||this.materialInfos.length<2)return[this];const p=[];for(const _ of this.materialInfos){const E=new Xr;if(this.positions&&(E.positions=this.positions.slice(_.verticesStart*3,(_.verticesCount+_.verticesStart)*3)),this.normals&&(E.normals=this.normals.slice(_.verticesStart*3,(_.verticesCount+_.verticesStart)*3)),this.tangents&&(E.tangents=this.tangents.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.colors&&(E.colors=this.colors.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.uvs&&(E.uvs=this.uvs.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.uvs2&&(E.uvs2=this.uvs2.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.uvs3&&(E.uvs3=this.uvs3.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.uvs4&&(E.uvs4=this.uvs4.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.uvs5&&(E.uvs5=this.uvs5.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.uvs6&&(E.uvs6=this.uvs6.slice(_.verticesStart*2,(_.verticesCount+_.verticesStart)*2)),this.matricesIndices&&(E.matricesIndices=this.matricesIndices.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.matricesIndicesExtra&&(E.matricesIndicesExtra=this.matricesIndicesExtra.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.matricesWeights&&(E.matricesWeights=this.matricesWeights.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.matricesWeightsExtra&&(E.matricesWeightsExtra=this.matricesWeightsExtra.slice(_.verticesStart*4,(_.verticesCount+_.verticesStart)*4)),this.indices){E.indices=[];for(let Z=_.indexStart;Z<_.indexStart+_.indexCount;Z++)E.indices.push(this.indices[Z]-_.verticesStart)}const I=new e_;I.indexStart=0,I.indexCount=E.indices?E.indices.length:0,I.materialIndex=_.materialIndex,I.verticesStart=0,I.verticesCount=(E.positions?E.positions.length:0)/3,E.materialInfos=[I],p.push(E)}return p}merge(p,_=!1,E=!1,I=!1,Z=!1){const re=Array.isArray(p)?p.map(ae=>({vertexData:ae})):[{vertexData:p}];return $g(this._mergeCoroutine(void 0,re,_,!1,E,I,Z))}*_mergeCoroutine(p,_,E=!1,I,Z,re=!1,ae=!1){this._validate();let he=_.map(He=>He.vertexData),_e=this;if(ae)for(const He of he)He&&(He._validate(),!this.normals&&He.normals&&(this.normals=new Float32Array(this.positions.length)),!this.tangents&&He.tangents&&(this.tangents=new Float32Array(this.positions.length/3*4)),!this.uvs&&He.uvs&&(this.uvs=new Float32Array(this.positions.length/3*2)),!this.uvs2&&He.uvs2&&(this.uvs2=new Float32Array(this.positions.length/3*2)),!this.uvs3&&He.uvs3&&(this.uvs3=new Float32Array(this.positions.length/3*2)),!this.uvs4&&He.uvs4&&(this.uvs4=new Float32Array(this.positions.length/3*2)),!this.uvs5&&He.uvs5&&(this.uvs5=new Float32Array(this.positions.length/3*2)),!this.uvs6&&He.uvs6&&(this.uvs6=new Float32Array(this.positions.length/3*2)),!this.colors&&He.colors&&(this.colors=new Float32Array(this.positions.length/3*4),this.colors.fill(1)),!this.matricesIndices&&He.matricesIndices&&(this.matricesIndices=new Float32Array(this.positions.length/3*4)),!this.matricesWeights&&He.matricesWeights&&(this.matricesWeights=new Float32Array(this.positions.length/3*4)),!this.matricesIndicesExtra&&He.matricesIndicesExtra&&(this.matricesIndicesExtra=new Float32Array(this.positions.length/3*4)),!this.matricesWeightsExtra&&He.matricesWeightsExtra&&(this.matricesWeightsExtra=new Float32Array(this.positions.length/3*4)));for(const He of he)if(He){if(ae)this.normals&&!He.normals&&(He.normals=new Float32Array(He.positions.length)),this.tangents&&!He.tangents&&(He.tangents=new Float32Array(He.positions.length/3*4)),this.uvs&&!He.uvs&&(He.uvs=new Float32Array(He.positions.length/3*2)),this.uvs2&&!He.uvs2&&(He.uvs2=new Float32Array(He.positions.length/3*2)),this.uvs3&&!He.uvs3&&(He.uvs3=new Float32Array(He.positions.length/3*2)),this.uvs4&&!He.uvs4&&(He.uvs4=new Float32Array(He.positions.length/3*2)),this.uvs5&&!He.uvs5&&(He.uvs5=new Float32Array(He.positions.length/3*2)),this.uvs6&&!He.uvs6&&(He.uvs6=new Float32Array(He.positions.length/3*2)),this.colors&&!He.colors&&(He.colors=new Float32Array(He.positions.length/3*4),He.colors.fill(1)),this.matricesIndices&&!He.matricesIndices&&(He.matricesIndices=new Float32Array(He.positions.length/3*4)),this.matricesWeights&&!He.matricesWeights&&(He.matricesWeights=new Float32Array(He.positions.length/3*4)),this.matricesIndicesExtra&&!He.matricesIndicesExtra&&(He.matricesIndicesExtra=new Float32Array(He.positions.length/3*4)),this.matricesWeightsExtra&&!He.matricesWeightsExtra&&(He.matricesWeightsExtra=new Float32Array(He.positions.length/3*4));else if(He._validate(),!this.normals!=!He.normals||!this.tangents!=!He.tangents||!this.uvs!=!He.uvs||!this.uvs2!=!He.uvs2||!this.uvs3!=!He.uvs3||!this.uvs4!=!He.uvs4||!this.uvs5!=!He.uvs5||!this.uvs6!=!He.uvs6||!this.colors!=!He.colors||!this.matricesIndices!=!He.matricesIndices||!this.matricesWeights!=!He.matricesWeights||!this.matricesIndicesExtra!=!He.matricesIndicesExtra||!this.matricesWeightsExtra!=!He.matricesWeightsExtra)throw new Error("Cannot merge vertex data that do not have the same set of attributes")}if(re){let He=0,xt=0,rt=0;const Tt=[];let Lt=null;const Nt=[];for(const Xt of this.splitBasedOnMaterialID())Nt.push({vertexData:Xt,transform:p});for(const Xt of _)if(Xt.vertexData)for(const zt of Xt.vertexData.splitBasedOnMaterialID())Nt.push({vertexData:zt,transform:Xt.transform});Nt.sort((Xt,zt)=>{const Gt=Xt.vertexData.materialInfos?Xt.vertexData.materialInfos[0].materialIndex:0,xi=zt.vertexData.materialInfos?zt.vertexData.materialInfos[0].materialIndex:0;return Gt>xi?1:Gt===xi?0:-1});for(const Xt of Nt){const zt=Xt.vertexData;if(zt.materialInfos?He=zt.materialInfos[0].materialIndex:He=0,Lt&&Lt.materialIndex===He)Lt.indexCount+=zt.indices.length,Lt.verticesCount+=zt.positions.length/3;else{const Gt=new e_;Gt.materialIndex=He,Gt.indexStart=xt,Gt.indexCount=zt.indices.length,Gt.verticesStart=rt,Gt.verticesCount=zt.positions.length/3,Tt.push(Gt),Lt=Gt}xt+=zt.indices.length,rt+=zt.positions.length/3}const qt=Nt.splice(0,1)[0];_e=qt.vertexData,p=qt.transform,he=Nt.map(Xt=>Xt.vertexData),_=Nt,this.materialInfos=Tt}const ve=he.reduce((He,xt)=>He+(xt.indices?.length??0),_e.indices?.length??0);let ze=Z||he.some(He=>He.indices===_e.indices)?_e.indices?.slice():_e.indices;if(ve>0){let He=ze?.length??0;if(ze||(ze=new Array(ve)),ze.length!==ve){if(Array.isArray(ze))ze.length=ve;else{const rt=E||ze instanceof Uint32Array?new Uint32Array(ve):new Uint16Array(ve);rt.set(ze),ze=rt}p&&p.determinant()<0&&Xr._FlipFaces(ze,0,He)}let xt=_e.positions?_e.positions.length/3:0;for(const{vertexData:rt,transform:Tt}of _)if(rt.indices){for(let Lt=0;Lt<rt.indices.length;Lt++)ze[He+Lt]=rt.indices[Lt]+xt;Tt&&Tt.determinant()<0&&Xr._FlipFaces(ze,He,rt.indices.length),xt+=rt.positions.length/3,He+=rt.indices.length,I&&(yield)}}return this.indices=ze,this.positions=Xr._MergeElement(ut.PositionKind,_e.positions,p,_.map(He=>[He.vertexData.positions,He.transform])),I&&(yield),_e.normals&&(this.normals=Xr._MergeElement(ut.NormalKind,_e.normals,p,_.map(He=>[He.vertexData.normals,He.transform])),I&&(yield)),_e.tangents&&(this.tangents=Xr._MergeElement(ut.TangentKind,_e.tangents,p,_.map(He=>[He.vertexData.tangents,He.transform])),I&&(yield)),_e.uvs&&(this.uvs=Xr._MergeElement(ut.UVKind,_e.uvs,p,_.map(He=>[He.vertexData.uvs,He.transform])),I&&(yield)),_e.uvs2&&(this.uvs2=Xr._MergeElement(ut.UV2Kind,_e.uvs2,p,_.map(He=>[He.vertexData.uvs2,He.transform])),I&&(yield)),_e.uvs3&&(this.uvs3=Xr._MergeElement(ut.UV3Kind,_e.uvs3,p,_.map(He=>[He.vertexData.uvs3,He.transform])),I&&(yield)),_e.uvs4&&(this.uvs4=Xr._MergeElement(ut.UV4Kind,_e.uvs4,p,_.map(He=>[He.vertexData.uvs4,He.transform])),I&&(yield)),_e.uvs5&&(this.uvs5=Xr._MergeElement(ut.UV5Kind,_e.uvs5,p,_.map(He=>[He.vertexData.uvs5,He.transform])),I&&(yield)),_e.uvs6&&(this.uvs6=Xr._MergeElement(ut.UV6Kind,_e.uvs6,p,_.map(He=>[He.vertexData.uvs6,He.transform])),I&&(yield)),_e.colors&&(this.colors=Xr._MergeElement(ut.ColorKind,_e.colors,p,_.map(He=>[He.vertexData.colors,He.transform])),I&&(yield)),_e.matricesIndices&&(this.matricesIndices=Xr._MergeElement(ut.MatricesIndicesKind,_e.matricesIndices,p,_.map(He=>[He.vertexData.matricesIndices,He.transform])),I&&(yield)),_e.matricesWeights&&(this.matricesWeights=Xr._MergeElement(ut.MatricesWeightsKind,_e.matricesWeights,p,_.map(He=>[He.vertexData.matricesWeights,He.transform])),I&&(yield)),_e.matricesIndicesExtra&&(this.matricesIndicesExtra=Xr._MergeElement(ut.MatricesIndicesExtraKind,_e.matricesIndicesExtra,p,_.map(He=>[He.vertexData.matricesIndicesExtra,He.transform])),I&&(yield)),_e.matricesWeightsExtra&&(this.matricesWeightsExtra=Xr._MergeElement(ut.MatricesWeightsExtraKind,_e.matricesWeightsExtra,p,_.map(He=>[He.vertexData.matricesWeightsExtra,He.transform]))),this}static _MergeElement(p,_,E,I){const Z=I.filter(he=>he[0]!==null&&he[0]!==void 0);if(!_&&Z.length==0)return _;if(!_)return this._MergeElement(p,Z[0][0],Z[0][1],Z.slice(1));const re=Z.reduce((he,_e)=>he+_e[0].length,_.length),ae=p===ut.PositionKind?Xr._TransformVector3Coordinates:p===ut.NormalKind?Xr._TransformVector3Normals:p===ut.TangentKind?Xr._TransformVector4Normals:()=>{};if(_ instanceof Float32Array){const he=new Float32Array(re);he.set(_),E&&ae(he,E,0,_.length);let _e=_.length;for(const[ve,Le]of Z)he.set(ve,_e),Le&&ae(he,Le,_e,ve.length),_e+=ve.length;return he}else{const he=new Array(re);for(let ve=0;ve<_.length;ve++)he[ve]=_[ve];E&&ae(he,E,0,_.length);let _e=_.length;for(const[ve,Le]of Z){for(let ze=0;ze<ve.length;ze++)he[_e+ze]=ve[ze];Le&&ae(he,Le,_e,ve.length),_e+=ve.length}return he}}_validate(){if(!this.positions)throw new Hx("Positions are required",Wx.MeshInvalidPositionsError);const p=(I,Z)=>{const re=ut.DeduceStride(I);if(Z.length%re!==0)throw new Error("The "+I+"s array count must be a multiple of "+re);return Z.length/re},_=p(ut.PositionKind,this.positions),E=(I,Z)=>{const re=p(I,Z);if(re!==_)throw new Error("The "+I+"s element count ("+re+") does not match the positions count ("+_+")")};this.normals&&E(ut.NormalKind,this.normals),this.tangents&&E(ut.TangentKind,this.tangents),this.uvs&&E(ut.UVKind,this.uvs),this.uvs2&&E(ut.UV2Kind,this.uvs2),this.uvs3&&E(ut.UV3Kind,this.uvs3),this.uvs4&&E(ut.UV4Kind,this.uvs4),this.uvs5&&E(ut.UV5Kind,this.uvs5),this.uvs6&&E(ut.UV6Kind,this.uvs6),this.colors&&E(ut.ColorKind,this.colors),this.matricesIndices&&E(ut.MatricesIndicesKind,this.matricesIndices),this.matricesWeights&&E(ut.MatricesWeightsKind,this.matricesWeights),this.matricesIndicesExtra&&E(ut.MatricesIndicesExtraKind,this.matricesIndicesExtra),this.matricesWeightsExtra&&E(ut.MatricesWeightsExtraKind,this.matricesWeightsExtra)}clone(){const p=this.serialize();return Xr.Parse(p)}serialize(){const p={};if(this.positions&&(p.positions=Array.from(this.positions)),this.normals&&(p.normals=Array.from(this.normals)),this.tangents&&(p.tangents=Array.from(this.tangents)),this.uvs&&(p.uvs=Array.from(this.uvs)),this.uvs2&&(p.uvs2=Array.from(this.uvs2)),this.uvs3&&(p.uvs3=Array.from(this.uvs3)),this.uvs4&&(p.uvs4=Array.from(this.uvs4)),this.uvs5&&(p.uvs5=Array.from(this.uvs5)),this.uvs6&&(p.uvs6=Array.from(this.uvs6)),this.colors&&(p.colors=Array.from(this.colors)),this.matricesIndices&&(p.matricesIndices=Array.from(this.matricesIndices),p.matricesIndices._isExpanded=!0),this.matricesWeights&&(p.matricesWeights=Array.from(this.matricesWeights)),this.matricesIndicesExtra&&(p.matricesIndicesExtra=Array.from(this.matricesIndicesExtra),p.matricesIndicesExtra._isExpanded=!0),this.matricesWeightsExtra&&(p.matricesWeightsExtra=Array.from(this.matricesWeightsExtra)),p.indices=Array.from(this.indices),this.materialInfos){p.materialInfos=[];for(const _ of this.materialInfos){const E={indexStart:_.indexStart,indexCount:_.indexCount,materialIndex:_.materialIndex,verticesStart:_.verticesStart,verticesCount:_.verticesCount};p.materialInfos.push(E)}}return p}static ExtractFromMesh(p,_,E){return Xr._ExtractFrom(p,_,E)}static ExtractFromGeometry(p,_,E){return Xr._ExtractFrom(p,_,E)}static _ExtractFrom(p,_,E){const I=new Xr;return p.isVerticesDataPresent(ut.PositionKind)&&(I.positions=p.getVerticesData(ut.PositionKind,_,E)),p.isVerticesDataPresent(ut.NormalKind)&&(I.normals=p.getVerticesData(ut.NormalKind,_,E)),p.isVerticesDataPresent(ut.TangentKind)&&(I.tangents=p.getVerticesData(ut.TangentKind,_,E)),p.isVerticesDataPresent(ut.UVKind)&&(I.uvs=p.getVerticesData(ut.UVKind,_,E)),p.isVerticesDataPresent(ut.UV2Kind)&&(I.uvs2=p.getVerticesData(ut.UV2Kind,_,E)),p.isVerticesDataPresent(ut.UV3Kind)&&(I.uvs3=p.getVerticesData(ut.UV3Kind,_,E)),p.isVerticesDataPresent(ut.UV4Kind)&&(I.uvs4=p.getVerticesData(ut.UV4Kind,_,E)),p.isVerticesDataPresent(ut.UV5Kind)&&(I.uvs5=p.getVerticesData(ut.UV5Kind,_,E)),p.isVerticesDataPresent(ut.UV6Kind)&&(I.uvs6=p.getVerticesData(ut.UV6Kind,_,E)),p.isVerticesDataPresent(ut.ColorKind)&&(I.colors=p.getVerticesData(ut.ColorKind,_,E)),p.isVerticesDataPresent(ut.MatricesIndicesKind)&&(I.matricesIndices=p.getVerticesData(ut.MatricesIndicesKind,_,E)),p.isVerticesDataPresent(ut.MatricesWeightsKind)&&(I.matricesWeights=p.getVerticesData(ut.MatricesWeightsKind,_,E)),p.isVerticesDataPresent(ut.MatricesIndicesExtraKind)&&(I.matricesIndicesExtra=p.getVerticesData(ut.MatricesIndicesExtraKind,_,E)),p.isVerticesDataPresent(ut.MatricesWeightsExtraKind)&&(I.matricesWeightsExtra=p.getVerticesData(ut.MatricesWeightsExtraKind,_,E)),I.indices=p.getIndices(_,E),I}static CreateRibbon(p){throw ur("ribbonBuilder")}static CreateBox(p){throw ur("boxBuilder")}static CreateTiledBox(p){throw ur("tiledBoxBuilder")}static CreateTiledPlane(p){throw ur("tiledPlaneBuilder")}static CreateSphere(p){throw ur("sphereBuilder")}static CreateCylinder(p){throw ur("cylinderBuilder")}static CreateTorus(p){throw ur("torusBuilder")}static CreateLineSystem(p){throw ur("linesBuilder")}static CreateDashedLines(p){throw ur("linesBuilder")}static CreateGround(p){throw ur("groundBuilder")}static CreateTiledGround(p){throw ur("groundBuilder")}static CreateGroundFromHeightMap(p){throw ur("groundBuilder")}static CreatePlane(p){throw ur("planeBuilder")}static CreateDisc(p){throw ur("discBuilder")}static CreatePolygon(p,_,E,I,Z,re,ae){throw ur("polygonBuilder")}static CreateIcoSphere(p){throw ur("icoSphereBuilder")}static CreatePolyhedron(p){throw ur("polyhedronBuilder")}static CreateCapsule(p={orientation:at.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){throw ur("capsuleBuilder")}static CreateTorusKnot(p){throw ur("torusKnotBuilder")}static ComputeNormals(p,_,E,I){let Z=0,re=0,ae=0,he=0,_e=0,ve=0,Le=0,ze=0,He=0,xt=0,rt=0,Tt=0,Lt=0,Nt=0,qt=0,Xt=0,zt=0,Gt=0,xi=0,Gi=0,vs=!1,ks=!1,Ur=!1,hn=!1,pn=1,_n=0,x0=null;I&&(vs=!!I.facetNormals,ks=!!I.facetPositions,Ur=!!I.facetPartitioning,pn=I.useRightHandedSystem===!0?-1:1,_n=I.ratio||0,hn=!!I.depthSort,x0=I.distanceTo,hn&&x0===void 0&&(x0=at.Zero()));let Ta=0,n0=0,z0=0,W0=0;for(Ur&&I&&I.bbSize&&(Ta=I.subDiv.X*_n/I.bbSize.x,n0=I.subDiv.Y*_n/I.bbSize.y,z0=I.subDiv.Z*_n/I.bbSize.z,W0=I.subDiv.max*I.subDiv.max,I.facetPartitioning.length=0),Z=0;Z<p.length;Z++)E[Z]=0;const Ho=_.length/3|0;for(Z=0;Z<Ho;Z++){if(Tt=_[Z*3]*3,Lt=Tt+1,Nt=Tt+2,qt=_[Z*3+1]*3,Xt=qt+1,zt=qt+2,Gt=_[Z*3+2]*3,xi=Gt+1,Gi=Gt+2,re=p[Tt]-p[qt],ae=p[Lt]-p[Xt],he=p[Nt]-p[zt],_e=p[Gt]-p[qt],ve=p[xi]-p[Xt],Le=p[Gi]-p[zt],ze=pn*(ae*Le-he*ve),He=pn*(he*_e-re*Le),xt=pn*(re*ve-ae*_e),rt=Math.sqrt(ze*ze+He*He+xt*xt),rt=rt===0?1:rt,ze/=rt,He/=rt,xt/=rt,vs&&I&&(I.facetNormals[Z].x=ze,I.facetNormals[Z].y=He,I.facetNormals[Z].z=xt),ks&&I&&(I.facetPositions[Z].x=(p[Tt]+p[qt]+p[Gt])/3,I.facetPositions[Z].y=(p[Lt]+p[Xt]+p[xi])/3,I.facetPositions[Z].z=(p[Nt]+p[zt]+p[Gi])/3),Ur&&I){const vo=Math.floor((I.facetPositions[Z].x-I.bInfo.minimum.x*_n)*Ta),Ml=Math.floor((I.facetPositions[Z].y-I.bInfo.minimum.y*_n)*n0),ac=Math.floor((I.facetPositions[Z].z-I.bInfo.minimum.z*_n)*z0),wg=Math.floor((p[Tt]-I.bInfo.minimum.x*_n)*Ta),Lg=Math.floor((p[Lt]-I.bInfo.minimum.y*_n)*n0),kg=Math.floor((p[Nt]-I.bInfo.minimum.z*_n)*z0),hy=Math.floor((p[qt]-I.bInfo.minimum.x*_n)*Ta),cy=Math.floor((p[Xt]-I.bInfo.minimum.y*_n)*n0),uy=Math.floor((p[zt]-I.bInfo.minimum.z*_n)*z0),py=Math.floor((p[Gt]-I.bInfo.minimum.x*_n)*Ta),_y=Math.floor((p[xi]-I.bInfo.minimum.y*_n)*n0),Ty=Math.floor((p[Gi]-I.bInfo.minimum.z*_n)*z0),uh=wg+I.subDiv.max*Lg+W0*kg,ph=hy+I.subDiv.max*cy+W0*uy,_h=py+I.subDiv.max*_y+W0*Ty,Th=vo+I.subDiv.max*Ml+W0*ac;I.facetPartitioning[Th]=I.facetPartitioning[Th]?I.facetPartitioning[Th]:new Array,I.facetPartitioning[uh]=I.facetPartitioning[uh]?I.facetPartitioning[uh]:new Array,I.facetPartitioning[ph]=I.facetPartitioning[ph]?I.facetPartitioning[ph]:new Array,I.facetPartitioning[_h]=I.facetPartitioning[_h]?I.facetPartitioning[_h]:new Array,I.facetPartitioning[uh].push(Z),ph!=uh&&I.facetPartitioning[ph].push(Z),_h==ph||_h==uh||I.facetPartitioning[_h].push(Z),Th==uh||Th==ph||Th==_h||I.facetPartitioning[Th].push(Z)}if(hn&&I&&I.facetPositions){const vo=I.depthSortedFacets[Z];vo.ind=Z*3,vo.sqDistance=at.DistanceSquared(I.facetPositions[Z],x0)}E[Tt]+=ze,E[Lt]+=He,E[Nt]+=xt,E[qt]+=ze,E[Xt]+=He,E[zt]+=xt,E[Gt]+=ze,E[xi]+=He,E[Gi]+=xt}for(Z=0;Z<E.length/3;Z++)ze=E[Z*3],He=E[Z*3+1],xt=E[Z*3+2],rt=Math.sqrt(ze*ze+He*He+xt*xt),rt=rt===0?1:rt,ze/=rt,He/=rt,xt/=rt,E[Z*3]=ze,E[Z*3+1]=He,E[Z*3+2]=xt}static _ComputeSides(p,_,E,I,Z,re,ae){const he=E.length,_e=I.length;let ve,Le;switch(p=p||Xr.DEFAULTSIDE,p){case Xr.FRONTSIDE:break;case Xr.BACKSIDE:for(ve=0;ve<he;ve+=3){const ze=E[ve];E[ve]=E[ve+2],E[ve+2]=ze}for(Le=0;Le<_e;Le++)I[Le]=-I[Le];break;case Xr.DOUBLESIDE:{const ze=_.length,He=ze/3;for(let Tt=0;Tt<ze;Tt++)_[ze+Tt]=_[Tt];for(ve=0;ve<he;ve+=3)E[ve+he]=E[ve+2]+He,E[ve+1+he]=E[ve+1]+He,E[ve+2+he]=E[ve]+He;for(Le=0;Le<_e;Le++)I[_e+Le]=-I[Le];const xt=Z.length;let rt=0;for(rt=0;rt<xt;rt++)Z[rt+xt]=Z[rt];for(re=re||new Lr(0,0,1,1),ae=ae||new Lr(0,0,1,1),rt=0,ve=0;ve<xt/2;ve++)Z[rt]=re.x+(re.z-re.x)*Z[rt],Z[rt+1]=re.y+(re.w-re.y)*Z[rt+1],Z[rt+xt]=ae.x+(ae.z-ae.x)*Z[rt+xt],Z[rt+xt+1]=ae.y+(ae.w-ae.y)*Z[rt+xt+1],rt+=2;break}}}static Parse(p){const _=new Xr,E=p.positions;E&&_.set(E,ut.PositionKind);const I=p.normals;I&&_.set(I,ut.NormalKind);const Z=p.tangents;Z&&_.set(Z,ut.TangentKind);const re=p.uvs;re&&_.set(re,ut.UVKind);const ae=p.uvs2;ae&&_.set(ae,ut.UV2Kind);const he=p.uvs3;he&&_.set(he,ut.UV3Kind);const _e=p.uvs4;_e&&_.set(_e,ut.UV4Kind);const ve=p.uvs5;ve&&_.set(ve,ut.UV5Kind);const Le=p.uvs6;Le&&_.set(Le,ut.UV6Kind);const ze=p.colors;ze&&_.set(Tr.CheckColors4(ze,E.length/3),ut.ColorKind);const He=p.matricesIndices;He&&_.set(He,ut.MatricesIndicesKind);const xt=p.matricesWeights;xt&&_.set(xt,ut.MatricesWeightsKind);const rt=p.indices;rt&&(_.indices=rt);const Tt=p.materialInfos;if(Tt){_.materialInfos=[];for(const Lt of Tt){const Nt=new e_;Nt.indexCount=Lt.indexCount,Nt.indexStart=Lt.indexStart,Nt.verticesCount=Lt.verticesCount,Nt.verticesStart=Lt.verticesStart,Nt.materialIndex=Lt.materialIndex,_.materialInfos.push(Nt)}}return _}static ImportVertexData(p,_){const E=Xr.Parse(p);_.setAllVerticesData(E,p.updatable)}}Xr.FRONTSIDE=0,Xr.BACKSIDE=1,Xr.DOUBLESIDE=2,Xr.DEFAULTSIDE=0,Xr._UniqueIDGenerator=0,Rt([Wh.filter((...[pe])=>!Array.isArray(pe))],Xr,"_TransformVector3Coordinates",null),Rt([Wh.filter((...[pe])=>!Array.isArray(pe))],Xr,"_TransformVector3Normals",null),Rt([Wh.filter((...[pe])=>!Array.isArray(pe))],Xr,"_TransformVector4Normals",null),Rt([Wh.filter((...[pe])=>!Array.isArray(pe))],Xr,"_FlipFaces",null);const RO=jt.Compose(at.One(),us.FromEulerAngles(0,Math.PI,0),at.Zero());class Gr extends Ha{get billboardMode(){return this._billboardMode}set billboardMode(p){this._billboardMode!==p&&(this._billboardMode=p,this._cache.useBillboardPosition=(this._billboardMode&Gr.BILLBOARDMODE_USE_POSITION)!==0,this._computeUseBillboardPath())}get preserveParentRotationForBillboard(){return this._preserveParentRotationForBillboard}set preserveParentRotationForBillboard(p){p!==this._preserveParentRotationForBillboard&&(this._preserveParentRotationForBillboard=p,this._computeUseBillboardPath())}_computeUseBillboardPath(){this._cache.useBillboardPath=this._billboardMode!==Gr.BILLBOARDMODE_NONE&&!this.preserveParentRotationForBillboard}get infiniteDistance(){return this._infiniteDistance}set infiniteDistance(p){this._infiniteDistance!==p&&(this._infiniteDistance=p)}constructor(p,_=null,E=!0){super(p,_),this._forward=new at(0,0,1),this._up=new at(0,1,0),this._right=new at(1,0,0),this._position=at.Zero(),this._rotation=at.Zero(),this._rotationQuaternion=null,this._scaling=at.One(),this._transformToBoneReferal=null,this._isAbsoluteSynced=!1,this._billboardMode=Gr.BILLBOARDMODE_NONE,this._preserveParentRotationForBillboard=!1,this.scalingDeterminant=1,this._infiniteDistance=!1,this.ignoreNonUniformScaling=!1,this.reIntegrateRotationIntoRotationQuaternion=!1,this._poseMatrix=null,this._localMatrix=jt.Zero(),this._usePivotMatrix=!1,this._absolutePosition=at.Zero(),this._absoluteScaling=at.Zero(),this._absoluteRotationQuaternion=us.Identity(),this._pivotMatrix=jt.Identity(),this._postMultiplyPivotMatrix=!1,this._isWorldMatrixFrozen=!1,this._indexInSceneTransformNodesArray=-1,this.onAfterWorldMatrixUpdateObservable=new Ri,this._nonUniformScaling=!1,E&&this.getScene().addTransformNode(this)}getClassName(){return"TransformNode"}get position(){return this._position}set position(p){this._position=p,this._isDirty=!0}isUsingPivotMatrix(){return this._usePivotMatrix}isUsingPostMultiplyPivotMatrix(){return this._postMultiplyPivotMatrix}get rotation(){return this._rotation}set rotation(p){this._rotation=p,this._rotationQuaternion=null,this._isDirty=!0}get scaling(){return this._scaling}set scaling(p){this._scaling=p,this._isDirty=!0}get rotationQuaternion(){return this._rotationQuaternion}set rotationQuaternion(p){this._rotationQuaternion=p,p&&this._rotation.setAll(0),this._isDirty=!0}get forward(){return at.TransformNormalFromFloatsToRef(0,0,this.getScene().useRightHandedSystem?-1:1,this.getWorldMatrix(),this._forward),this._forward.normalize()}get up(){return at.TransformNormalFromFloatsToRef(0,1,0,this.getWorldMatrix(),this._up),this._up.normalize()}get right(){return at.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem?-1:1,0,0,this.getWorldMatrix(),this._right),this._right.normalize()}updatePoseMatrix(p){return this._poseMatrix?(this._poseMatrix.copyFrom(p),this):(this._poseMatrix=p.clone(),this)}getPoseMatrix(){return this._poseMatrix||(this._poseMatrix=jt.Identity()),this._poseMatrix}_isSynchronized(){const p=this._cache;return!(this._billboardMode!==p.billboardMode||this._billboardMode!==Gr.BILLBOARDMODE_NONE||p.pivotMatrixUpdated||this._infiniteDistance||this._position._isDirty||this._scaling._isDirty||this._rotationQuaternion&&this._rotationQuaternion._isDirty||this._rotation._isDirty)}_initCache(){super._initCache();const p=this._cache;p.localMatrixUpdated=!1,p.billboardMode=-1,p.infiniteDistance=!1,p.useBillboardPosition=!1,p.useBillboardPath=!1}get absolutePosition(){return this.getAbsolutePosition()}get absoluteScaling(){return this._syncAbsoluteScalingAndRotation(),this._absoluteScaling}get absoluteRotationQuaternion(){return this._syncAbsoluteScalingAndRotation(),this._absoluteRotationQuaternion}setPreTransformMatrix(p){return this.setPivotMatrix(p,!1)}setPivotMatrix(p,_=!0){return this._pivotMatrix.copyFrom(p),this._usePivotMatrix=!this._pivotMatrix.isIdentity(),this._cache.pivotMatrixUpdated=!0,this._postMultiplyPivotMatrix=_,this._postMultiplyPivotMatrix&&(this._pivotMatrixInverse?this._pivotMatrix.invertToRef(this._pivotMatrixInverse):this._pivotMatrixInverse=jt.Invert(this._pivotMatrix)),this}getPivotMatrix(){return this._pivotMatrix}instantiateHierarchy(p=null,_,E){const I=this.clone("Clone of "+(this.name||this.id),p||this.parent,!0);I&&E&&E(this,I);for(const Z of this.getChildTransformNodes(!0))Z.instantiateHierarchy(I,_,E);return I}freezeWorldMatrix(p=null,_=!1){return p?_?(this._rotation.setAll(0),this._rotationQuaternion=this._rotationQuaternion||us.Identity(),p.decompose(this._scaling,this._rotationQuaternion,this._position),this.computeWorldMatrix(!0)):(this._worldMatrix=p,this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._afterComputeWorldMatrix()):(this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0)),this._isDirty=!1,this._isWorldMatrixFrozen=!0,this}unfreezeWorldMatrix(){return this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0),this}get isWorldMatrixFrozen(){return this._isWorldMatrixFrozen}getAbsolutePosition(){return this.computeWorldMatrix(),this._absolutePosition}setAbsolutePosition(p){if(!p)return this;let _,E,I;if(p.x===void 0){if(arguments.length<3)return this;_=arguments[0],E=arguments[1],I=arguments[2]}else _=p.x,E=p.y,I=p.z;if(this.parent){const Z=ui.Matrix[0];this.parent.getWorldMatrix().invertToRef(Z),at.TransformCoordinatesFromFloatsToRef(_,E,I,Z,this.position)}else this.position.x=_,this.position.y=E,this.position.z=I;return this._absolutePosition.copyFrom(p),this}setPositionWithLocalVector(p){return this.computeWorldMatrix(),this.position=at.TransformNormal(p,this._localMatrix),this}getPositionExpressedInLocalSpace(){this.computeWorldMatrix();const p=ui.Matrix[0];return this._localMatrix.invertToRef(p),at.TransformNormal(this.position,p)}locallyTranslate(p){return this.computeWorldMatrix(!0),this.position=at.TransformCoordinates(p,this._localMatrix),this}lookAt(p,_=0,E=0,I=0,Z=Wn.LOCAL){const re=Gr._LookAtVectorCache,ae=Z===Wn.LOCAL?this.position:this.getAbsolutePosition();if(p.subtractToRef(ae,re),this.setDirection(re,_,E,I),Z===Wn.WORLD&&this.parent)if(this.rotationQuaternion){const he=ui.Matrix[0];this.rotationQuaternion.toRotationMatrix(he);const _e=ui.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(_e),_e.invert(),he.multiplyToRef(_e,he),this.rotationQuaternion.fromRotationMatrix(he)}else{const he=ui.Quaternion[0];us.FromEulerVectorToRef(this.rotation,he);const _e=ui.Matrix[0];he.toRotationMatrix(_e);const ve=ui.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(ve),ve.invert(),_e.multiplyToRef(ve,_e),he.fromRotationMatrix(_e),he.toEulerAnglesToRef(this.rotation)}return this}getDirection(p){const _=at.Zero();return this.getDirectionToRef(p,_),_}getDirectionToRef(p,_){return at.TransformNormalToRef(p,this.getWorldMatrix(),_),this}setDirection(p,_=0,E=0,I=0){const Z=-Math.atan2(p.z,p.x)+Math.PI/2,re=Math.sqrt(p.x*p.x+p.z*p.z),ae=-Math.atan2(p.y,re);return this.rotationQuaternion?us.RotationYawPitchRollToRef(Z+_,ae+E,I,this.rotationQuaternion):(this.rotation.x=ae+E,this.rotation.y=Z+_,this.rotation.z=I),this}setPivotPoint(p,_=Wn.LOCAL){this.getScene().getRenderId()==0&&this.computeWorldMatrix(!0);const E=this.getWorldMatrix();if(_==Wn.WORLD){const I=ui.Matrix[0];E.invertToRef(I),p=at.TransformCoordinates(p,I)}return this.setPivotMatrix(jt.Translation(-p.x,-p.y,-p.z),!0)}getPivotPoint(){const p=at.Zero();return this.getPivotPointToRef(p),p}getPivotPointToRef(p){return p.x=-this._pivotMatrix.m[12],p.y=-this._pivotMatrix.m[13],p.z=-this._pivotMatrix.m[14],this}getAbsolutePivotPoint(){const p=at.Zero();return this.getAbsolutePivotPointToRef(p),p}getAbsolutePivotPointToRef(p){return this.getPivotPointToRef(p),at.TransformCoordinatesToRef(p,this.getWorldMatrix(),p),this}markAsDirty(p){if(this._isDirty)return this;if(this._children)for(const _ of this._children)_.markAsDirty(p);return super.markAsDirty(p)}setParent(p,_=!1,E=!1){if(!p&&!this.parent)return this;const I=ui.Quaternion[0],Z=ui.Vector3[0],re=ui.Vector3[1],ae=ui.Matrix[1];jt.IdentityToRef(ae);const he=ui.Matrix[0];this.computeWorldMatrix(!0);let _e=this.rotationQuaternion;return _e||(_e=Gr._TmpRotation,us.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,_e)),jt.ComposeToRef(this.scaling,_e,this.position,he),this.parent&&he.multiplyToRef(this.parent.computeWorldMatrix(!0),he),p&&(p.computeWorldMatrix(!0).invertToRef(ae),he.multiplyToRef(ae,he)),he.decompose(re,I,Z,_?this:void 0),this.rotationQuaternion?this.rotationQuaternion.copyFrom(I):I.toEulerAnglesToRef(this.rotation),this.scaling.copyFrom(re),this.position.copyFrom(Z),this.parent=p,E&&this.setPivotMatrix(jt.Identity()),this}get nonUniformScaling(){return this._nonUniformScaling}_updateNonUniformScalingState(p){return this._nonUniformScaling===p?!1:(this._nonUniformScaling=p,!0)}attachToBone(p,_){return this._currentParentWhenAttachingToBone=this.parent,this._transformToBoneReferal=_,this.parent=p,p.getSkeleton().prepare(!0),p.getFinalMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this}detachFromBone(p=!1){return this.parent?(this.parent.getWorldMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this._transformToBoneReferal=null,p?this.parent=this._currentParentWhenAttachingToBone:this.parent=null,this):(p&&(this.parent=this._currentParentWhenAttachingToBone),this)}rotate(p,_,E){p.normalize(),this.rotationQuaternion||(this.rotationQuaternion=this.rotation.toQuaternion(),this.rotation.setAll(0));let I;if(!E||E===Wn.LOCAL)I=us.RotationAxisToRef(p,_,Gr._RotationAxisCache),this.rotationQuaternion.multiplyToRef(I,this.rotationQuaternion);else{if(this.parent){const Z=this.parent.getWorldMatrix(),re=ui.Matrix[0];Z.invertToRef(re),p=at.TransformNormal(p,re),Z.determinant()<0&&(_*=-1)}I=us.RotationAxisToRef(p,_,Gr._RotationAxisCache),I.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion)}return this}rotateAround(p,_,E){_.normalize(),this.rotationQuaternion||(this.rotationQuaternion=us.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z),this.rotation.setAll(0));const I=ui.Vector3[0],Z=ui.Vector3[1],re=ui.Vector3[2],ae=ui.Quaternion[0],he=ui.Matrix[0],_e=ui.Matrix[1],ve=ui.Matrix[2],Le=ui.Matrix[3];return p.subtractToRef(this.position,I),jt.TranslationToRef(I.x,I.y,I.z,he),jt.TranslationToRef(-I.x,-I.y,-I.z,_e),jt.RotationAxisToRef(_,E,ve),_e.multiplyToRef(ve,Le),Le.multiplyToRef(he,Le),Le.decompose(Z,ae,re),this.position.addInPlace(re),ae.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion),this}translate(p,_,E){const I=p.scale(_);if(!E||E===Wn.LOCAL){const Z=this.getPositionExpressedInLocalSpace().add(I);this.setPositionWithLocalVector(Z)}else this.setAbsolutePosition(this.getAbsolutePosition().add(I));return this}addRotation(p,_,E){let I;this.rotationQuaternion?I=this.rotationQuaternion:(I=ui.Quaternion[1],us.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,I));const Z=ui.Quaternion[0];return us.RotationYawPitchRollToRef(_,p,E,Z),I.multiplyInPlace(Z),this.rotationQuaternion||I.toEulerAnglesToRef(this.rotation),this}_getEffectiveParent(){return this.parent}isWorldMatrixCameraDependent(){return this._infiniteDistance&&!this.parent||this._billboardMode!==Gr.BILLBOARDMODE_NONE&&!this.preserveParentRotationForBillboard}computeWorldMatrix(p=!1,_=null){if(this._isWorldMatrixFrozen&&!this._isDirty)return this._worldMatrix;const E=this.getScene().getRenderId();if(!this._isDirty&&!p&&(this._currentRenderId===E||this.isSynchronized()))return this._currentRenderId=E,this._worldMatrix;_=_||this.getScene().activeCamera,this._updateCache();const I=this._cache;I.pivotMatrixUpdated=!1,I.billboardMode=this.billboardMode,I.infiniteDistance=this.infiniteDistance,I.parent=this._parentNode,this._currentRenderId=E,this._childUpdateId+=1,this._isDirty=!1,this._position._isDirty=!1,this._rotation._isDirty=!1,this._scaling._isDirty=!1;const Z=this._getEffectiveParent(),re=Gr._TmpScaling;let ae=this._position;if(this._infiniteDistance&&!this.parent&&_){const _e=_.getWorldMatrix(),ve=new at(_e.m[12],_e.m[13],_e.m[14]);ae=Gr._TmpTranslation,ae.copyFromFloats(this._position.x+ve.x,this._position.y+ve.y,this._position.z+ve.z)}re.copyFromFloats(this._scaling.x*this.scalingDeterminant,this._scaling.y*this.scalingDeterminant,this._scaling.z*this.scalingDeterminant);let he;if(this._rotationQuaternion?(this._rotationQuaternion._isDirty=!1,he=this._rotationQuaternion,this.reIntegrateRotationIntoRotationQuaternion&&this.rotation.lengthSquared()&&(this._rotationQuaternion.multiplyInPlace(us.RotationYawPitchRoll(this._rotation.y,this._rotation.x,this._rotation.z)),this._rotation.copyFromFloats(0,0,0))):(he=Gr._TmpRotation,us.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,he)),this._usePivotMatrix){const _e=ui.Matrix[1];jt.ScalingToRef(re.x,re.y,re.z,_e);const ve=ui.Matrix[0];he.toRotationMatrix(ve),this._pivotMatrix.multiplyToRef(_e,ui.Matrix[4]),ui.Matrix[4].multiplyToRef(ve,this._localMatrix),this._postMultiplyPivotMatrix&&this._localMatrix.multiplyToRef(this._pivotMatrixInverse,this._localMatrix),this._localMatrix.addTranslationFromFloats(ae.x,ae.y,ae.z)}else jt.ComposeToRef(re,he,ae,this._localMatrix);if(Z&&Z.getWorldMatrix){if(p&&Z.computeWorldMatrix(p),I.useBillboardPath){if(this._transformToBoneReferal){const ze=this.parent;ze.getSkeleton().prepare(),ze.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),ui.Matrix[7])}else ui.Matrix[7].copyFrom(Z.getWorldMatrix());const _e=ui.Vector3[5],ve=ui.Vector3[6],Le=ui.Quaternion[0];ui.Matrix[7].decompose(ve,Le,_e),jt.ScalingToRef(ve.x,ve.y,ve.z,ui.Matrix[7]),ui.Matrix[7].setTranslation(_e),Gr.BillboardUseParentOrientation&&(this._position.applyRotationQuaternionToRef(Le,_e),this._localMatrix.setTranslation(_e)),this._localMatrix.multiplyToRef(ui.Matrix[7],this._worldMatrix)}else if(this._transformToBoneReferal){const _e=this.parent;_e.getSkeleton().prepare(),this._localMatrix.multiplyToRef(_e.getFinalMatrix(),ui.Matrix[6]),ui.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),this._worldMatrix)}else this._localMatrix.multiplyToRef(Z.getWorldMatrix(),this._worldMatrix);this._markSyncedWithParent()}else this._worldMatrix.copyFrom(this._localMatrix);if(I.useBillboardPath&&_&&this.billboardMode&&!I.useBillboardPosition){const _e=ui.Vector3[0];if(this._worldMatrix.getTranslationToRef(_e),ui.Matrix[1].copyFrom(_.getViewMatrix()),this._scene.useRightHandedSystem&&ui.Matrix[1].multiplyToRef(RO,ui.Matrix[1]),ui.Matrix[1].setTranslationFromFloats(0,0,0),ui.Matrix[1].invertToRef(ui.Matrix[0]),(this.billboardMode&Gr.BILLBOARDMODE_ALL)!==Gr.BILLBOARDMODE_ALL){ui.Matrix[0].decompose(void 0,ui.Quaternion[0],void 0);const ve=ui.Vector3[1];ui.Quaternion[0].toEulerAnglesToRef(ve),(this.billboardMode&Gr.BILLBOARDMODE_X)!==Gr.BILLBOARDMODE_X&&(ve.x=0),(this.billboardMode&Gr.BILLBOARDMODE_Y)!==Gr.BILLBOARDMODE_Y&&(ve.y=0),(this.billboardMode&Gr.BILLBOARDMODE_Z)!==Gr.BILLBOARDMODE_Z&&(ve.z=0),jt.RotationYawPitchRollToRef(ve.y,ve.x,ve.z,ui.Matrix[0])}this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(ui.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(ui.Vector3[0])}else if(I.useBillboardPath&&_&&I.useBillboardPosition){const _e=ui.Vector3[0];this._worldMatrix.getTranslationToRef(_e);const ve=_.globalPosition;this._worldMatrix.invertToRef(ui.Matrix[1]);const Le=ui.Vector3[1];at.TransformCoordinatesToRef(ve,ui.Matrix[1],Le),Le.normalize();const ze=-Math.atan2(Le.z,Le.x)+Math.PI/2,He=Math.sqrt(Le.x*Le.x+Le.z*Le.z),xt=-Math.atan2(Le.y,He);if(us.RotationYawPitchRollToRef(ze,xt,0,ui.Quaternion[0]),(this.billboardMode&Gr.BILLBOARDMODE_ALL)!==Gr.BILLBOARDMODE_ALL){const rt=ui.Vector3[1];ui.Quaternion[0].toEulerAnglesToRef(rt),(this.billboardMode&Gr.BILLBOARDMODE_X)!==Gr.BILLBOARDMODE_X&&(rt.x=0),(this.billboardMode&Gr.BILLBOARDMODE_Y)!==Gr.BILLBOARDMODE_Y&&(rt.y=0),(this.billboardMode&Gr.BILLBOARDMODE_Z)!==Gr.BILLBOARDMODE_Z&&(rt.z=0),jt.RotationYawPitchRollToRef(rt.y,rt.x,rt.z,ui.Matrix[0])}else jt.FromQuaternionToRef(ui.Quaternion[0],ui.Matrix[0]);this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(ui.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(ui.Vector3[0])}return this.ignoreNonUniformScaling?this._updateNonUniformScalingState(!1):this._scaling.isNonUniformWithinEpsilon(1e-6)?this._updateNonUniformScalingState(!0):Z&&Z._nonUniformScaling?this._updateNonUniformScalingState(Z._nonUniformScaling):this._updateNonUniformScalingState(!1),this._afterComputeWorldMatrix(),this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._isAbsoluteSynced=!1,this.onAfterWorldMatrixUpdateObservable.notifyObservers(this),this._poseMatrix||(this._poseMatrix=jt.Invert(this._worldMatrix)),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix}resetLocalMatrix(p=!0){if(this.computeWorldMatrix(),p){const _=this.getChildren();for(let E=0;E<_.length;++E){const I=_[E];if(I){I.computeWorldMatrix();const Z=ui.Matrix[0];I._localMatrix.multiplyToRef(this._localMatrix,Z);const re=ui.Quaternion[0];Z.decompose(I.scaling,re,I.position),I.rotationQuaternion?I.rotationQuaternion.copyFrom(re):re.toEulerAnglesToRef(I.rotation)}}}this.scaling.copyFromFloats(1,1,1),this.position.copyFromFloats(0,0,0),this.rotation.copyFromFloats(0,0,0),this.rotationQuaternion&&(this.rotationQuaternion=us.Identity()),this._worldMatrix=jt.Identity()}_afterComputeWorldMatrix(){}registerAfterWorldMatrixUpdate(p){return this.onAfterWorldMatrixUpdateObservable.add(p),this}unregisterAfterWorldMatrixUpdate(p){return this.onAfterWorldMatrixUpdateObservable.removeCallback(p),this}getPositionInCameraSpace(p=null){return p||(p=this.getScene().activeCamera),at.TransformCoordinates(this.getAbsolutePosition(),p.getViewMatrix())}getDistanceToCamera(p=null){return p||(p=this.getScene().activeCamera),this.getAbsolutePosition().subtract(p.globalPosition).length()}clone(p,_,E){const I=Hr.Clone(()=>new Gr(p,this.getScene()),this);if(I.name=p,I.id=p,_&&(I.parent=_),!E){const Z=this.getDescendants(!0);for(let re=0;re<Z.length;re++){const ae=Z[re];ae.clone&&ae.clone(p+"."+ae.name,I)}}return I}serialize(p){const _=Hr.Serialize(this,p);return _.type=this.getClassName(),_.uniqueId=this.uniqueId,this.parent&&this.parent._serializeAsParent(_),_.localMatrix=this.getPivotMatrix().asArray(),_.isEnabled=this.isEnabled(),Hr.AppendSerializedAnimations(this,_),_.ranges=this.serializeAnimationRanges(),_}static Parse(p,_,E){const I=Hr.Parse(()=>new Gr(p.name,_),p,_,E);if(p.localMatrix?I.setPreTransformMatrix(jt.FromArray(p.localMatrix)):p.pivotMatrix&&I.setPivotMatrix(jt.FromArray(p.pivotMatrix)),I.setEnabled(p.isEnabled),I._waitingParsedUniqueId=p.uniqueId,p.parentId!==void 0&&(I._waitingParentId=p.parentId),p.parentInstanceIndex!==void 0&&(I._waitingParentInstanceIndex=p.parentInstanceIndex),p.animations){for(let Z=0;Z<p.animations.length;Z++){const re=p.animations[Z],ae=r0("BABYLON.Animation");ae&&I.animations.push(ae.Parse(re))}Ha.ParseAnimationRanges(I,p,_)}return p.autoAnimate&&_.beginAnimation(I,p.autoAnimateFrom,p.autoAnimateTo,p.autoAnimateLoop,p.autoAnimateSpeed||1),I}getChildTransformNodes(p,_){const E=[];return this._getDescendants(E,p,I=>(!_||_(I))&&I instanceof Gr),E}dispose(p,_=!1){if(this.getScene().stopAnimation(this),this.getScene().removeTransformNode(this),this._parentContainer){const E=this._parentContainer.transformNodes.indexOf(this);E>-1&&this._parentContainer.transformNodes.splice(E,1),this._parentContainer=null}if(this.onAfterWorldMatrixUpdateObservable.clear(),p){const E=this.getChildTransformNodes(!0);for(const I of E)I.parent=null,I.computeWorldMatrix(!0)}super.dispose(p,_)}normalizeToUnitCube(p=!0,_=!1,E){let I=null,Z=null;_&&(this.rotationQuaternion?(Z=this.rotationQuaternion.clone(),this.rotationQuaternion.copyFromFloats(0,0,0,1)):this.rotation&&(I=this.rotation.clone(),this.rotation.copyFromFloats(0,0,0)));const re=this.getHierarchyBoundingVectors(p,E),ae=re.max.subtract(re.min),he=Math.max(ae.x,ae.y,ae.z);if(he===0)return this;const _e=1/he;return this.scaling.scaleInPlace(_e),_&&(this.rotationQuaternion&&Z?this.rotationQuaternion.copyFrom(Z):this.rotation&&I&&this.rotation.copyFrom(I)),this}_syncAbsoluteScalingAndRotation(){this._isAbsoluteSynced||(this._worldMatrix.decompose(this._absoluteScaling,this._absoluteRotationQuaternion),this._isAbsoluteSynced=!0)}}Gr.BILLBOARDMODE_NONE=0,Gr.BILLBOARDMODE_X=1,Gr.BILLBOARDMODE_Y=2,Gr.BILLBOARDMODE_Z=4,Gr.BILLBOARDMODE_ALL=7,Gr.BILLBOARDMODE_USE_POSITION=128,Gr.BillboardUseParentOrientation=!1,Gr._TmpRotation=us.Zero(),Gr._TmpScaling=at.Zero(),Gr._TmpTranslation=at.Zero(),Gr._LookAtVectorCache=new at(0,0,0),Gr._RotationAxisCache=new us,Rt([Yn("position")],Gr.prototype,"_position",void 0),Rt([Yn("rotation")],Gr.prototype,"_rotation",void 0),Rt([UM("rotationQuaternion")],Gr.prototype,"_rotationQuaternion",void 0),Rt([Yn("scaling")],Gr.prototype,"_scaling",void 0),Rt([Ut("billboardMode")],Gr.prototype,"_billboardMode",void 0),Rt([Ut()],Gr.prototype,"scalingDeterminant",void 0),Rt([Ut("infiniteDistance")],Gr.prototype,"_infiniteDistance",void 0),Rt([Ut()],Gr.prototype,"ignoreNonUniformScaling",void 0),Rt([Ut()],Gr.prototype,"reIntegrateRotationIntoRotationQuaternion",void 0);class Hb{constructor(){this._defines={},this._currentRank=32,this._maxRank=-1,this._mesh=null}unBindMesh(){this._mesh=null}addFallback(p,_){this._defines[p]||(p<this._currentRank&&(this._currentRank=p),p>this._maxRank&&(this._maxRank=p),this._defines[p]=new Array),this._defines[p].push(_)}addCPUSkinningFallback(p,_){this._mesh=_,p<this._currentRank&&(this._currentRank=p),p>this._maxRank&&(this._maxRank=p)}get hasMoreFallbacks(){return this._currentRank<=this._maxRank}reduce(p,_){if(this._mesh&&this._mesh.computeBonesUsingShaders&&this._mesh.numBoneInfluencers>0){this._mesh.computeBonesUsingShaders=!1,p=p.replace("#define NUM_BONE_INFLUENCERS "+this._mesh.numBoneInfluencers,"#define NUM_BONE_INFLUENCERS 0"),_._bonesComputationForcedToCPU=!0;const E=this._mesh.getScene();for(let I=0;I<E.meshes.length;I++){const Z=E.meshes[I];if(!Z.material){!this._mesh.material&&Z.computeBonesUsingShaders&&Z.numBoneInfluencers>0&&(Z.computeBonesUsingShaders=!1);continue}if(!(!Z.computeBonesUsingShaders||Z.numBoneInfluencers===0)){if(Z.material.getEffect()===_)Z.computeBonesUsingShaders=!1;else if(Z.subMeshes){for(const re of Z.subMeshes)if(re.effect===_){Z.computeBonesUsingShaders=!1;break}}}}}else{const E=this._defines[this._currentRank];if(E)for(let I=0;I<E.length;I++)p=p.replace("#define "+E[I],"");this._currentRank++}return p}}class Xb extends zi{constructor(p,_,E=!0){super(p,_),this._normalMatrix=new jt,this._storeEffectOnSubMeshes=E}getEffect(){return this._storeEffectOnSubMeshes?this._activeEffect:super.getEffect()}isReady(p,_){return p?!this._storeEffectOnSubMeshes||!p.subMeshes||p.subMeshes.length===0?!0:this.isReadyForSubMesh(p,p.subMeshes[0],_):!1}_isReadyForSubMesh(p){const _=p.materialDefines;return!!(!this.checkReadyOnEveryCall&&p.effect&&_&&_._renderId===this.getScene().getRenderId())}bindOnlyWorldMatrix(p){this._activeEffect.setMatrix("world",p)}bindOnlyNormalMatrix(p){this._activeEffect.setMatrix("normalMatrix",p)}bind(p,_){_&&this.bindForSubMesh(p,_,_.subMeshes[0])}_afterBind(p,_=null,E){super._afterBind(p,_,E),this.getScene()._cachedEffect=_,E?E._drawWrapper._forceRebindOnNextCall=!1:this._drawWrapper._forceRebindOnNextCall=!1}_mustRebind(p,_,E,I=1){return E._drawWrapper._forceRebindOnNextCall||p.isCachedMaterialInvalid(this,_,I)}dispose(p,_,E){this._activeEffect=void 0,super.dispose(p,_,E)}}const t_={effect:null,subMesh:null};class Xh extends Xb{constructor(p,_,E,I={},Z=!0){super(p,_,Z),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new jt,this._cachedWorldViewProjectionMatrix=new jt,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=E,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...I}}get shaderPath(){return this._shaderPath}set shaderPath(p){this._shaderPath=p}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(p){this._options.uniforms.indexOf(p)===-1&&this._options.uniforms.push(p)}setTexture(p,_){return this._options.samplers.indexOf(p)===-1&&this._options.samplers.push(p),this._textures[p]=_,this}setTextureArray(p,_){return this._options.samplers.indexOf(p)===-1&&this._options.samplers.push(p),this._checkUniform(p),this._textureArrays[p]=_,this}setExternalTexture(p,_){return this._options.externalTextures.indexOf(p)===-1&&this._options.externalTextures.push(p),this._externalTextures[p]=_,this}setFloat(p,_){return this._checkUniform(p),this._floats[p]=_,this}setInt(p,_){return this._checkUniform(p),this._ints[p]=_,this}setUInt(p,_){return this._checkUniform(p),this._uints[p]=_,this}setFloats(p,_){return this._checkUniform(p),this._floatsArrays[p]=_,this}setColor3(p,_){return this._checkUniform(p),this._colors3[p]=_,this}setColor3Array(p,_){return this._checkUniform(p),this._colors3Arrays[p]=_.reduce((E,I)=>(I.toArray(E,E.length),E),[]),this}setColor4(p,_){return this._checkUniform(p),this._colors4[p]=_,this}setColor4Array(p,_){return this._checkUniform(p),this._colors4Arrays[p]=_.reduce((E,I)=>(I.toArray(E,E.length),E),[]),this}setVector2(p,_){return this._checkUniform(p),this._vectors2[p]=_,this}setVector3(p,_){return this._checkUniform(p),this._vectors3[p]=_,this}setVector4(p,_){return this._checkUniform(p),this._vectors4[p]=_,this}setQuaternion(p,_){return this._checkUniform(p),this._quaternions[p]=_,this}setQuaternionArray(p,_){return this._checkUniform(p),this._quaternionsArrays[p]=_.reduce((E,I)=>(I.toArray(E,E.length),E),[]),this}setMatrix(p,_){return this._checkUniform(p),this._matrices[p]=_,this}setMatrices(p,_){this._checkUniform(p);const E=new Float32Array(_.length*16);for(let I=0;I<_.length;I++)_[I].copyToArray(E,I*16);return this._matrixArrays[p]=E,this}setMatrix3x3(p,_){return this._checkUniform(p),this._matrices3x3[p]=_,this}setMatrix2x2(p,_){return this._checkUniform(p),this._matrices2x2[p]=_,this}setArray2(p,_){return this._checkUniform(p),this._vectors2Arrays[p]=_,this}setArray3(p,_){return this._checkUniform(p),this._vectors3Arrays[p]=_,this}setArray4(p,_){return this._checkUniform(p),this._vectors4Arrays[p]=_,this}setUniformBuffer(p,_){return this._options.uniformBuffers.indexOf(p)===-1&&this._options.uniformBuffers.push(p),this._uniformBuffers[p]=_,this}setTextureSampler(p,_){return this._options.samplerObjects.indexOf(p)===-1&&this._options.samplerObjects.push(p),this._textureSamplers[p]=_,this}setStorageBuffer(p,_){return this._options.storageBuffers.indexOf(p)===-1&&this._options.storageBuffers.push(p),this._storageBuffers[p]=_,this}setDefine(p,_){const E=p.trimEnd()+" ",I=this.options.defines.findIndex(Z=>Z===p||Z.startsWith(E));return I>=0&&this.options.defines.splice(I,1),(typeof _!="boolean"||_)&&this.options.defines.push(E+_),this}isReadyForSubMesh(p,_,E){return this.isReady(p,E,_)}isReady(p,_,E){const I=E&&this._storeEffectOnSubMeshes;if(this.isFrozen){const zt=I?E._drawWrapper:this._drawWrapper;if(zt.effect&&zt._wasPreviouslyReady&&zt._wasPreviouslyUsingInstances===_)return!0}const Z=this.getScene(),re=Z.getEngine(),ae=[],he=[],_e=new Hb;let ve=this._shaderPath,Le=this._options.uniforms,ze=this._options.uniformBuffers,He=this._options.samplers;re.getCaps().multiview&&Z.activeCamera&&Z.activeCamera.outputRenderTarget&&Z.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,ae.push("#define MULTIVIEW"),Le.indexOf("viewProjection")!==-1&&Le.indexOf("viewProjectionR")===-1&&Le.push("viewProjectionR"));for(let zt=0;zt<this._options.defines.length;zt++){const Gt=this._options.defines[zt].indexOf("#define")===0?this._options.defines[zt]:`#define ${this._options.defines[zt]}`;ae.push(Gt)}for(let zt=0;zt<this._options.attributes.length;zt++)he.push(this._options.attributes[zt]);if(p&&p.isVerticesDataPresent(ut.ColorKind)&&(he.indexOf(ut.ColorKind)===-1&&he.push(ut.ColorKind),ae.push("#define VERTEXCOLOR")),_&&(ae.push("#define INSTANCES"),lr.PushAttributesForInstances(he,this._materialHelperNeedsPreviousMatrices),p?.hasThinInstances&&(ae.push("#define THIN_INSTANCES"),p&&p.isVerticesDataPresent(ut.ColorInstanceKind)&&(he.push(ut.ColorInstanceKind),ae.push("#define INSTANCESCOLOR")))),p&&p.useBones&&p.computeBonesUsingShaders&&p.skeleton){he.push(ut.MatricesIndicesKind),he.push(ut.MatricesWeightsKind),p.numBoneInfluencers>4&&(he.push(ut.MatricesIndicesExtraKind),he.push(ut.MatricesWeightsExtraKind));const zt=p.skeleton;ae.push("#define NUM_BONE_INFLUENCERS "+p.numBoneInfluencers),_e.addCPUSkinningFallback(0,p),zt.isUsingTextureForMatrices?(ae.push("#define BONETEXTURE"),Le.indexOf("boneTextureWidth")===-1&&Le.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(ae.push("#define BonesPerMesh "+(zt.bones.length+1)),Le.indexOf("mBones")===-1&&Le.push("mBones"))}else ae.push("#define NUM_BONE_INFLUENCERS 0");let xt=0;const rt=p?p.morphTargetManager:null;if(rt){const zt=rt.supportsUVs&&ae.indexOf("#define UV1")!==-1,Gt=rt.supportsTangents&&ae.indexOf("#define TANGENT")!==-1,xi=rt.supportsNormals&&ae.indexOf("#define NORMAL")!==-1;xt=rt.numMaxInfluencers||rt.numInfluencers,zt&&ae.push("#define MORPHTARGETS_UV"),Gt&&ae.push("#define MORPHTARGETS_TANGENT"),xi&&ae.push("#define MORPHTARGETS_NORMAL"),xt>0&&ae.push("#define MORPHTARGETS"),rt.isUsingTextureForTargets&&(ae.push("#define MORPHTARGETS_TEXTURE"),Le.indexOf("morphTargetTextureIndices")===-1&&Le.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),ae.push("#define NUM_MORPH_INFLUENCERS "+xt);for(let Gi=0;Gi<xt;Gi++)he.push(ut.PositionKind+Gi),xi&&he.push(ut.NormalKind+Gi),Gt&&he.push(ut.TangentKind+Gi),zt&&he.push(ut.UVKind+"_"+Gi);xt>0&&(Le=Le.slice(),Le.push("morphTargetInfluences"),Le.push("morphTargetCount"),Le.push("morphTargetTextureInfo"),Le.push("morphTargetTextureIndices"))}else ae.push("#define NUM_MORPH_INFLUENCERS 0");if(p){const zt=p.bakedVertexAnimationManager;zt&&zt.isEnabled&&(ae.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),Le.indexOf("bakedVertexAnimationSettings")===-1&&Le.push("bakedVertexAnimationSettings"),Le.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&Le.push("bakedVertexAnimationTextureSizeInverted"),Le.indexOf("bakedVertexAnimationTime")===-1&&Le.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture")),lr.PrepareAttributesForBakedVertexAnimation(he,p,ae)}for(const zt in this._textures)if(!this._textures[zt].isReady())return!1;p&&this._shouldTurnAlphaTestOn(p)&&ae.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(_b(Le),cO(this,Z,ae)),Z.fogEnabled&&p?.applyFog&&Z.fogMode!==U0.FOGMODE_NONE&&(ae.push("#define FOG"),Le.indexOf("view")===-1&&Le.push("view"),Le.indexOf("vFogInfos")===-1&&Le.push("vFogInfos"),Le.indexOf("vFogColor")===-1&&Le.push("vFogColor")),this._useLogarithmicDepth&&(ae.push("#define LOGARITHMICDEPTH"),Le.indexOf("logarithmicDepthConstant")===-1&&Le.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(Le=Le.slice(),ze=ze.slice(),He=He.slice(),ve=this.customShaderNameResolve(ve,Le,ze,He,ae,he));const Tt=I?E._getDrawWrapper(void 0,!0):this._drawWrapper,Lt=Tt?.effect??null,Nt=Tt?.defines??null,qt=ae.join(`
`);let Xt=Lt;return Nt!==qt&&(Xt=re.createEffect(ve,{attributes:he,uniformsNames:Le,uniformBuffersNames:ze,samplers:He,defines:qt,fallbacks:_e,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:xt},shaderLanguage:this._options.shaderLanguage},re),I?E.setEffect(Xt,qt,this._materialContext):Tt&&Tt.setEffect(Xt,qt),this._onEffectCreatedObservable&&(t_.effect=Xt,t_.subMesh=E??p?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(t_))),Tt._wasPreviouslyUsingInstances=!!_,Xt?.isReady()?(Lt!==Xt&&Z.resetCachedMaterial(),Tt._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(p,_){const E=this.getScene(),I=_??this.getEffect();I&&(this._options.uniforms.indexOf("world")!==-1&&I.setMatrix("world",p),this._options.uniforms.indexOf("worldView")!==-1&&(p.multiplyToRef(E.getViewMatrix(),this._cachedWorldViewMatrix),I.setMatrix("worldView",this._cachedWorldViewMatrix)),this._options.uniforms.indexOf("worldViewProjection")!==-1&&(p.multiplyToRef(E.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),I.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),this._options.uniforms.indexOf("view")!==-1&&I.setMatrix("view",E.getViewMatrix()))}bindForSubMesh(p,_,E){this.bind(p,_,E._drawWrapperOverride?.effect,E)}bind(p,_,E,I){const Z=I&&this._storeEffectOnSubMeshes,re=E??(Z?I.effect:this.getEffect());if(!re)return;const ae=this.getScene();this._activeEffect=re,this.bindOnlyWorldMatrix(p,E);const he=this._options.uniformBuffers;let _e=!1;if(re&&he&&he.length>0&&ae.getEngine().supportsUniformBuffers)for(let Le=0;Le<he.length;++Le)switch(he[Le]){case"Mesh":_&&(_.getMeshUniformBuffer().bindToEffect(re,"Mesh"),_.transferToEffect(p));break;case"Scene":lr.BindSceneUniformBuffer(re,ae.getSceneUniformBuffer()),ae.finalizeSceneUbo(),_e=!0;break}const ve=_&&Z?this._mustRebind(ae,re,I,_.visibility):ae.getCachedMaterial()!==this;if(re&&ve){!_e&&this._options.uniforms.indexOf("view")!==-1&&re.setMatrix("view",ae.getViewMatrix()),!_e&&this._options.uniforms.indexOf("projection")!==-1&&re.setMatrix("projection",ae.getProjectionMatrix()),!_e&&this._options.uniforms.indexOf("viewProjection")!==-1&&(re.setMatrix("viewProjection",ae.getTransformMatrix()),this._multiview&&re.setMatrix("viewProjectionR",ae._transformMatrixR)),ae.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&re.setVector3("cameraPosition",ae.activeCamera.globalPosition),lr.BindBonesParameters(_,re),Tb(re,this,ae),this._useLogarithmicDepth&&lr.BindLogDepth(Z?I.materialDefines:re.defines,re,ae),_&&lr.BindFogParameters(ae,_,re);let Le;for(Le in this._textures)re.setTexture(Le,this._textures[Le]);for(Le in this._textureArrays)re.setTextureArray(Le,this._textureArrays[Le]);for(Le in this._externalTextures)re.setExternalTexture(Le,this._externalTextures[Le]);for(Le in this._ints)re.setInt(Le,this._ints[Le]);for(Le in this._uints)re.setUInt(Le,this._uints[Le]);for(Le in this._floats)re.setFloat(Le,this._floats[Le]);for(Le in this._floatsArrays)re.setArray(Le,this._floatsArrays[Le]);for(Le in this._colors3)re.setColor3(Le,this._colors3[Le]);for(Le in this._colors3Arrays)re.setArray3(Le,this._colors3Arrays[Le]);for(Le in this._colors4){const ze=this._colors4[Le];re.setFloat4(Le,ze.r,ze.g,ze.b,ze.a)}for(Le in this._colors4Arrays)re.setArray4(Le,this._colors4Arrays[Le]);for(Le in this._vectors2)re.setVector2(Le,this._vectors2[Le]);for(Le in this._vectors3)re.setVector3(Le,this._vectors3[Le]);for(Le in this._vectors4)re.setVector4(Le,this._vectors4[Le]);for(Le in this._quaternions)re.setQuaternion(Le,this._quaternions[Le]);for(Le in this._matrices)re.setMatrix(Le,this._matrices[Le]);for(Le in this._matrixArrays)re.setMatrices(Le,this._matrixArrays[Le]);for(Le in this._matrices3x3)re.setMatrix3x3(Le,this._matrices3x3[Le]);for(Le in this._matrices2x2)re.setMatrix2x2(Le,this._matrices2x2[Le]);for(Le in this._vectors2Arrays)re.setArray2(Le,this._vectors2Arrays[Le]);for(Le in this._vectors3Arrays)re.setArray3(Le,this._vectors3Arrays[Le]);for(Le in this._vectors4Arrays)re.setArray4(Le,this._vectors4Arrays[Le]);for(Le in this._quaternionsArrays)re.setArray4(Le,this._quaternionsArrays[Le]);for(Le in this._uniformBuffers){const ze=this._uniformBuffers[Le].getBuffer();ze&&re.bindUniformBuffer(ze,Le)}for(Le in this._textureSamplers)re.setTextureSampler(Le,this._textureSamplers[Le]);for(Le in this._storageBuffers)re.setStorageBuffer(Le,this._storageBuffers[Le])}if(re&&_&&(ve||!this.isFrozen)){const Le=_.morphTargetManager;Le&&Le.numInfluencers>0&&lr.BindMorphTargetParameters(_,re);const ze=_.bakedVertexAnimationManager;if(ze&&ze.isEnabled){const He=Z?I._drawWrapper:this._drawWrapper;_.bakedVertexAnimationManager?.bind(re,!!He._wasPreviouslyUsingInstances)}}this._afterBind(_,re,I)}getActiveTextures(){const p=super.getActiveTextures();for(const _ in this._textures)p.push(this._textures[_]);for(const _ in this._textureArrays){const E=this._textureArrays[_];for(let I=0;I<E.length;I++)p.push(E[I])}return p}hasTexture(p){if(super.hasTexture(p))return!0;for(const _ in this._textures)if(this._textures[_]===p)return!0;for(const _ in this._textureArrays){const E=this._textureArrays[_];for(let I=0;I<E.length;I++)if(E[I]===p)return!0}return!1}clone(p){const _=Hr.Clone(()=>new Xh(p,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);_.name=p,_.id=p,typeof _._shaderPath=="object"&&(_._shaderPath={..._._shaderPath}),this._options={...this._options},Object.keys(this._options).forEach(E=>{const I=this._options[E];Array.isArray(I)&&(this._options[E]=I.slice(0))}),this.stencil.copyTo(_.stencil);for(const E in this._textures)_.setTexture(E,this._textures[E]);for(const E in this._textureArrays)_.setTextureArray(E,this._textureArrays[E]);for(const E in this._externalTextures)_.setExternalTexture(E,this._externalTextures[E]);for(const E in this._ints)_.setInt(E,this._ints[E]);for(const E in this._uints)_.setUInt(E,this._uints[E]);for(const E in this._floats)_.setFloat(E,this._floats[E]);for(const E in this._floatsArrays)_.setFloats(E,this._floatsArrays[E]);for(const E in this._colors3)_.setColor3(E,this._colors3[E]);for(const E in this._colors3Arrays)_._colors3Arrays[E]=this._colors3Arrays[E];for(const E in this._colors4)_.setColor4(E,this._colors4[E]);for(const E in this._colors4Arrays)_._colors4Arrays[E]=this._colors4Arrays[E];for(const E in this._vectors2)_.setVector2(E,this._vectors2[E]);for(const E in this._vectors3)_.setVector3(E,this._vectors3[E]);for(const E in this._vectors4)_.setVector4(E,this._vectors4[E]);for(const E in this._quaternions)_.setQuaternion(E,this._quaternions[E]);for(const E in this._quaternionsArrays)_._quaternionsArrays[E]=this._quaternionsArrays[E];for(const E in this._matrices)_.setMatrix(E,this._matrices[E]);for(const E in this._matrixArrays)_._matrixArrays[E]=this._matrixArrays[E].slice();for(const E in this._matrices3x3)_.setMatrix3x3(E,this._matrices3x3[E]);for(const E in this._matrices2x2)_.setMatrix2x2(E,this._matrices2x2[E]);for(const E in this._vectors2Arrays)_.setArray2(E,this._vectors2Arrays[E]);for(const E in this._vectors3Arrays)_.setArray3(E,this._vectors3Arrays[E]);for(const E in this._vectors4Arrays)_.setArray4(E,this._vectors4Arrays[E]);for(const E in this._uniformBuffers)_.setUniformBuffer(E,this._uniformBuffers[E]);for(const E in this._textureSamplers)_.setTextureSampler(E,this._textureSamplers[E]);for(const E in this._storageBuffers)_.setStorageBuffer(E,this._storageBuffers[E]);return _}dispose(p,_,E){if(_){let I;for(I in this._textures)this._textures[I].dispose();for(I in this._textureArrays){const Z=this._textureArrays[I];for(let re=0;re<Z.length;re++)Z[re].dispose()}}this._textures={},super.dispose(p,_,E)}serialize(){const p=Hr.Serialize(this);p.customType="BABYLON.ShaderMaterial",p.uniqueId=this.uniqueId,p.options=this._options,p.shaderPath=this._shaderPath,p.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let _;p.stencil=this.stencil.serialize(),p.textures={};for(_ in this._textures)p.textures[_]=this._textures[_].serialize();p.textureArrays={};for(_ in this._textureArrays){p.textureArrays[_]=[];const E=this._textureArrays[_];for(let I=0;I<E.length;I++)p.textureArrays[_].push(E[I].serialize())}p.ints={};for(_ in this._ints)p.ints[_]=this._ints[_];p.uints={};for(_ in this._uints)p.uints[_]=this._uints[_];p.floats={};for(_ in this._floats)p.floats[_]=this._floats[_];p.floatsArrays={};for(_ in this._floatsArrays)p.floatsArrays[_]=this._floatsArrays[_];p.colors3={};for(_ in this._colors3)p.colors3[_]=this._colors3[_].asArray();p.colors3Arrays={};for(_ in this._colors3Arrays)p.colors3Arrays[_]=this._colors3Arrays[_];p.colors4={};for(_ in this._colors4)p.colors4[_]=this._colors4[_].asArray();p.colors4Arrays={};for(_ in this._colors4Arrays)p.colors4Arrays[_]=this._colors4Arrays[_];p.vectors2={};for(_ in this._vectors2)p.vectors2[_]=this._vectors2[_].asArray();p.vectors3={};for(_ in this._vectors3)p.vectors3[_]=this._vectors3[_].asArray();p.vectors4={};for(_ in this._vectors4)p.vectors4[_]=this._vectors4[_].asArray();p.quaternions={};for(_ in this._quaternions)p.quaternions[_]=this._quaternions[_].asArray();p.matrices={};for(_ in this._matrices)p.matrices[_]=this._matrices[_].asArray();p.matrixArray={};for(_ in this._matrixArrays)p.matrixArray[_]=this._matrixArrays[_];p.matrices3x3={};for(_ in this._matrices3x3)p.matrices3x3[_]=this._matrices3x3[_];p.matrices2x2={};for(_ in this._matrices2x2)p.matrices2x2[_]=this._matrices2x2[_];p.vectors2Arrays={};for(_ in this._vectors2Arrays)p.vectors2Arrays[_]=this._vectors2Arrays[_];p.vectors3Arrays={};for(_ in this._vectors3Arrays)p.vectors3Arrays[_]=this._vectors3Arrays[_];p.vectors4Arrays={};for(_ in this._vectors4Arrays)p.vectors4Arrays[_]=this._vectors4Arrays[_];p.quaternionsArrays={};for(_ in this._quaternionsArrays)p.quaternionsArrays[_]=this._quaternionsArrays[_];return p}static Parse(p,_,E){const I=Hr.Parse(()=>new Xh(p.name,_,p.shaderPath,p.options,p.storeEffectOnSubMeshes),p,_,E);let Z;p.stencil&&I.stencil.parse(p.stencil,_,E);for(Z in p.textures)I.setTexture(Z,Ki.Parse(p.textures[Z],_,E));for(Z in p.textureArrays){const re=p.textureArrays[Z],ae=[];for(let he=0;he<re.length;he++)ae.push(Ki.Parse(re[he],_,E));I.setTextureArray(Z,ae)}for(Z in p.ints)I.setInt(Z,p.ints[Z]);for(Z in p.uints)I.setUInt(Z,p.uints[Z]);for(Z in p.floats)I.setFloat(Z,p.floats[Z]);for(Z in p.floatsArrays)I.setFloats(Z,p.floatsArrays[Z]);for(Z in p.colors3)I.setColor3(Z,Rs.FromArray(p.colors3[Z]));for(Z in p.colors3Arrays){const re=p.colors3Arrays[Z].reduce((ae,he,_e)=>(_e%3===0?ae.push([he]):ae[ae.length-1].push(he),ae),[]).map(ae=>Rs.FromArray(ae));I.setColor3Array(Z,re)}for(Z in p.colors4)I.setColor4(Z,Tr.FromArray(p.colors4[Z]));for(Z in p.colors4Arrays){const re=p.colors4Arrays[Z].reduce((ae,he,_e)=>(_e%4===0?ae.push([he]):ae[ae.length-1].push(he),ae),[]).map(ae=>Tr.FromArray(ae));I.setColor4Array(Z,re)}for(Z in p.vectors2)I.setVector2(Z,xr.FromArray(p.vectors2[Z]));for(Z in p.vectors3)I.setVector3(Z,at.FromArray(p.vectors3[Z]));for(Z in p.vectors4)I.setVector4(Z,Lr.FromArray(p.vectors4[Z]));for(Z in p.quaternions)I.setQuaternion(Z,us.FromArray(p.quaternions[Z]));for(Z in p.matrices)I.setMatrix(Z,jt.FromArray(p.matrices[Z]));for(Z in p.matrixArray)I._matrixArrays[Z]=new Float32Array(p.matrixArray[Z]);for(Z in p.matrices3x3)I.setMatrix3x3(Z,p.matrices3x3[Z]);for(Z in p.matrices2x2)I.setMatrix2x2(Z,p.matrices2x2[Z]);for(Z in p.vectors2Arrays)I.setArray2(Z,p.vectors2Arrays[Z]);for(Z in p.vectors3Arrays)I.setArray3(Z,p.vectors3Arrays[Z]);for(Z in p.vectors4Arrays)I.setArray4(Z,p.vectors4Arrays[Z]);for(Z in p.quaternionsArrays)I.setArray4(Z,p.quaternionsArrays[Z]);return I}static ParseFromFileAsync(p,_,E,I=""){return new Promise((Z,re)=>{const ae=new Ua;ae.addEventListener("readystatechange",()=>{if(ae.readyState==4)if(ae.status==200){const he=JSON.parse(ae.responseText),_e=this.Parse(he,E||Mr.LastCreatedScene,I);p&&(_e.name=p),Z(_e)}else re("Unable to load the ShaderMaterial")}),ae.open("GET",_),ae.send()})}static ParseFromSnippetAsync(p,_,E=""){return new Promise((I,Z)=>{const re=new Ua;re.addEventListener("readystatechange",()=>{if(re.readyState==4)if(re.status==200){const ae=JSON.parse(JSON.parse(re.responseText).jsonPayload),he=JSON.parse(ae.shaderMaterial),_e=this.Parse(he,_||Mr.LastCreatedScene,E);_e.snippetId=p,I(_e)}else Z("Unable to load the snippet "+p)}),re.open("GET",this.SnippetUrl+"/"+p.replace(/#/g,"/")),re.send()})}}Xh.SnippetUrl="https://snippet.babylonjs.com",Xh.CreateFromSnippetAsync=Xh.ParseFromSnippetAsync,Gs("BABYLON.ShaderMaterial",Xh);const Yb="bonesDeclaration",Kb=`#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform highp sampler2D boneSampler;uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#endif
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}
#endif
#endif
#endif
`;ji.IncludesShadersStore[Yb]=Kb;const xB={name:Yb,shader:Kb},jb="bonesVertex",qb=`#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;ji.IncludesShadersStore[jb]=qb;const lB={name:jb,shader:qb},$b="clipPlaneVertexDeclaration",rE=`#ifdef CLIPPLANE
uniform vec4 vClipPlane;varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;varying float fClipDistance6;
#endif
`;ji.IncludesShadersStore[$b]=rE;const hB={name:$b,shader:rE},nE="clipPlaneVertex",aE=`#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`;ji.IncludesShadersStore[nE]=aE;const cB={name:nE,shader:aE},xE="instancesDeclaration",lE=`#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`;ji.IncludesShadersStore[xE]=lE;const uB={name:xE,shader:lE},hE="instancesVertex",cE=`#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;ji.IncludesShadersStore[hE]=cE;const pB={name:hE,shader:cE},uE="clipPlaneFragmentDeclaration",pE=`#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`;ji.IncludesShadersStore[uE]=pE;const _B={name:uE,shader:pE},_E="clipPlaneFragment",TE=`#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{discard;}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{discard;}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{discard;}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{discard;}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{discard;}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{discard;}
#endif
`;ji.IncludesShadersStore[_E]=TE;const TB={name:_E,shader:TE};class vE extends null{constructor(p,_,E=1){super(p,_,["image"],{},ME("max",E),void 0,!0,!0)}}class RE extends null{constructor(p,_,E=1){super(p,_,["image"],{},ME("min",E),void 0,!0,!0)}}function ME(pe,p=1){return`
        precision mediump float;
        varying vec2 xy;
        uniform vec2 wh;
        uniform sampler2D image;
        void main() {
            float res = texture2D(image, xy).r;
            for (int x = -`+p+"; x <= "+p+`; x++)
                for (int y = -`+p+"; y <= "+p+`; y++)
                    res = `+pe+`(res, texture2D(image, xy + vec2(x, y) / wh).r);
            gl_FragColor = vec4(res, res, res, 1.0);
        }`}var MO=Object.defineProperty,wE=Object.getOwnPropertySymbols,wO=Object.prototype.hasOwnProperty,LO=Object.prototype.propertyIsEnumerable,LE=(pe,p,_)=>p in pe?MO(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,kO=(pe,p)=>{for(var _ in p||(p={}))wO.call(p,_)&&LE(pe,_,p[_]);if(wE)for(var _ of wE(p))LO.call(p,_)&&LE(pe,_,p[_]);return pe};class vB extends null{constructor(p={width:256,height:256}){super(),this.size=p,this.ordinal=o.PreProcess}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.maskTexture=new d(_,this.size,!0,!0),super.load(p)}unload(){var p;this.loaded&&((p=this.maskTexture)==null||p.dispose(),delete this.maskTexture,super.unload())}async update(p,_){const{maskTexture:E}=this;if(!this.loaded||!E)return;const I=jm(p);if(!I||!I.mask)return;this.size=kO({},I.mask.size),E.resize(I.mask.size),E.update(I.mask.buffer);const Z=E.texture();Z&&(I.maskTex={texture:Z,size:I.mask.size,box:I.mask.box})}}function Km(pe){return[pe[0][0],pe[0][1],pe[1][0]-pe[0][0],pe[1][1]-pe[0][1]]}function jm(pe){return"poses"in pe&&pe.poses[0]||"faces"in pe&&pe.faces[0]||"masks"in pe&&pe.masks[0]||void 0}function RB(pe){var p;return(p=jm(pe))==null?void 0:p.mask}function Hc(pe){var p;return(p=jm(pe))==null?void 0:p.maskTex}var UO=Object.defineProperty,kE=Object.getOwnPropertySymbols,GO=Object.prototype.hasOwnProperty,zO=Object.prototype.propertyIsEnumerable,UE=(pe,p,_)=>p in pe?UO(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,GE=(pe,p)=>{for(var _ in p||(p={}))GO.call(p,_)&&UE(pe,_,p[_]);if(kE)for(var _ of kE(p))zO.call(p,_)&&UE(pe,_,p[_]);return pe};class WO{constructor(){this.upscalers=[],this.upscaleSize={width:1024,height:1024}}load(p,_,E=.55,I=2){const Z=GE({},_);for(let re=0;re<I;re++){Z.width*=2,Z.height*=2;const ae=new x(p,Z,["image","mask"],{rect:"4f"},HO(E),void 0,!0,!0),he=new x(p,Z,["mask"],{},XO(E),void 0,!0,!0);this.upscalers.push({edge:ae,fill:he})}this.upscaleSize=Z}unload(){this.upscalers.forEach(p=>{p.edge.dispose(),p.fill.dispose()}),this.upscalers=[]}upscale(p,_){const{upscalers:E}=this;if(E.length<1)return!1;const I=Km(p.box);let Z=p.texture;for(let re=0;re<E.length;re++){const ae=E[re];ae.edge.process([_,Z],{rect:I}),ae.fill.process([ae.edge.output()]),Z=ae.fill.output()}return!0}mask(){var p;return((p=this.upscalers[this.upscalers.length-1])==null?void 0:p.fill.output())||null}size(){return this.upscaleSize}resize(p){const{upscalers:_}=this,E=GE({},p);for(let I=0;I<_.length;I++)E.width*=2,E.height*=2,_[I].edge.resize(E),_[I].fill.resize(E);this.upscaleSize=E}}const HO=(pe=.55)=>`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform vec4 rect;
    uniform sampler2D image;
    uniform sampler2D mask;

    vec4 avgColor(vec2 xyMask, vec2 whPix) {
        vec2 xy = xyMask * rect.zw + rect.xy;
        vec2 dxy = whPix * rect.zw / 3.0;
        vec4 color = vec4(0.0);
        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                color += texture2D(image, xy + vec2(i, j) * dxy);
        return color / 9.0;
    }

    float minDiff(vec2 xyI, vec4 color) {
        // vec4 c = avgColor(xyI / wh, 1.0 / wh);
        // vec3 diff = color.rgb - c.rgb;
        // float ra = 0.5 * (color.r + c.r);
        // diff = diff * diff;
        // return (2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b;
        vec2 xyMask = xyI / wh;
        vec2 whPix = 1.0 / (2.0 * wh);
        float dist = 100.0;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                vec4 c = avgColor(xyMask + vec2(i, j) * whPix, whPix);
                vec3 diff = color.rgb - c.rgb;
                float ra = 0.5 * (color.r + c.r);
                diff = diff * diff;
                dist = min((2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b, dist);
            }
        }
        return dist;
    }

    float minDist(vec2 xyI, vec2 dxy, vec4 color) {
        vec2 dxyI = 0.25 * dxy;
        float dist = 100.0;
        for (int i = 0; i < 8; i++) {
            vec4 c = texture2D(image, (xyI + float(i) * dxyI) / wh * rect.zw + rect.xy);
            vec3 diff = color.rgb - c.rgb;
            float ra = 0.5 * (color.r + c.r);
            diff = diff * diff;
            dist = min((2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b, dist);
        }
        return dist;
    }

    void main() {
        vec2 xyI = floor(xy * wh);
        float val[9];
        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                val[j * 3 + i] = texture2D(mask,
                    (xyI + vec2(i, j) - 1.0) / wh).r;
        bool fg[9];
        int fgCount = 0;
        for (int i = 0; i < 9; i++) {
            fg[i] = val[i] > `+pe+`;
            fgCount += int(fg[i]);
        }
        if (fgCount <= 0) {
            float valMin = min(val[0], min(
                min(min(val[1], val[2]), min(val[3], val[4])),
                min(min(val[5], val[6]), min(val[7], val[8]))));
            gl_FragColor = vec4(valMin, 0, 0, 1);
            return;
        }
        if (fgCount >= 9) {
            float valMax = max(val[0], max(
                max(max(val[1], val[2]), max(val[3], val[4])),
                max(max(val[5], val[6]), max(val[7], val[8]))));
            gl_FragColor = vec4(valMax, 0, 0, 1);
            return;
        }
        vec2 dxy = normalize(vec2(
            val[2] + 2.0 * val[5] + val[8] - val[0] - 2.0 * val[3] - val[6],
            val[6] + 2.0 * val[7] + val[8] - val[0] - 2.0 * val[1] - val[2]));
        vec4 color = avgColor(xyI / wh, 1.0 / wh);
        vec2 xyFg = xyI + (fg[4] ? 2.0 : 3.0) * dxy;
        vec2 xyBg = xyI - (fg[4] ? 3.0 : 2.0) * dxy;
        vec2 diffFgBg = sqrt(vec2(
            minDist(xyFg,  dxy, color),
            minDist(xyBg, -dxy, color)));
        diffFgBg /= diffFgBg.x + diffFgBg.y;
        vec2 valBgFg = vec2(texture2D(mask, xyBg / wh).r,
                            texture2D(mask, xyFg / wh).r);
        float valInter = dot(valBgFg, diffFgBg);
        gl_FragColor = vec4(valInter, 1, 0, 1);
    }
`,XO=(pe=.55)=>`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform sampler2D mask;

    void main() {
        vec2 xyI = floor(xy * wh);
        vec4 val0 = texture2D(mask, xyI / wh);
        if (val0.r > `+pe+`) {
            gl_FragColor = val0;
            return;
        }
        float val[9];
        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                val[j * 3 + i] = texture2D(mask,
                    (xyI + vec2(i, j) - 1.0) / wh).r;
        bool fg[9];
        int fgCount = 0;
        for (int i = 0; i < 9; i++) {
            fg[i] = val[i] > `+pe+`;
            fgCount += int(fg[i]);
        }
        float valMax = max(val[0], max(
            max(max(val[1], val[2]), max(val[3], val[4])),
            max(max(val[5], val[6]), max(val[7], val[8]))));
        if (fg[0] && fg[8] || fg[1] && fg[7] ||
            fg[2] && fg[6] || fg[3] && fg[5] || fgCount >= 4) {
            gl_FragColor = vec4(valMax, 1, 0, 1);
            return;
        }
        gl_FragColor = val0;
    }
`;var YO=Object.defineProperty,zE=Object.getOwnPropertySymbols,KO=Object.prototype.hasOwnProperty,jO=Object.prototype.propertyIsEnumerable,WE=(pe,p,_)=>p in pe?YO(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,HE=(pe,p)=>{for(var _ in p||(p={}))KO.call(p,_)&&WE(pe,_,p[_]);if(zE)for(var _ of zE(p))jO.call(p,_)&&WE(pe,_,p[_]);return pe};class MB extends null{constructor(p=.55,_=2,E={width:256,height:256}){super(),this.thresh=p,this.steps=_,this.size=E,this.upscaler=new WO,this.ordinal=o.Process}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.upscaler.load(_,this.size,this.thresh,this.steps),super.load(p)}unload(){this.loaded&&(this.upscaler.unload(),super.unload())}async update(p,_){var E;const{renderer:I}=this;if(!this.loaded||!(I instanceof i))return;const Z=(E=I.input)==null?void 0:E.texture(),re=jm(p);if(!re||!re.maskTex||!Z)return;this.size=HE({},re.maskTex.size),this.upscaler.resize(re.maskTex.size);const ae=this.upscaler.upscale(re.maskTex,Z)&&this.upscaler.mask();ae&&(re.maskTex.texture=ae,re.maskTex={texture:ae,size:HE({},this.upscaler.size()),box:re.maskTex.box})}}var qO=Object.defineProperty,XE=Object.getOwnPropertySymbols,$O=Object.prototype.hasOwnProperty,rP=Object.prototype.propertyIsEnumerable,YE=(pe,p,_)=>p in pe?qO(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,nP=(pe,p)=>{for(var _ in p||(p={}))$O.call(p,_)&&YE(pe,_,p[_]);if(XE)for(var _ of XE(p))rP.call(p,_)&&YE(pe,_,p[_]);return pe};class wB extends null{constructor(p=2,_={width:256,height:256}){super(),this.smooth=p,this.size=_,this.gaussian=[],this.ordinal=o.Process;const E=-.5/p**2,I=Math.floor(2*p);this.gaussian.push(1);let Z=1;for(let re=1;re<=I;re++){const ae=Math.exp(E*re**2);this.gaussian.push(ae),this.gaussian.unshift(ae),Z+=2*ae}for(let re=0;re<this.gaussian.length;re++)this.gaussian[re]/=Z}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.xpass=new x(_,this.size,["image"],{kernel:"1fv"},KE("x",this.smooth),void 0,!0,!0),this.xpass.setUniform("kernel",this.gaussian),this.ypass=new x(_,this.size,["image"],{kernel:"1fv"},KE("y",this.smooth),void 0,!0,!0),this.ypass.setUniform("kernel",this.gaussian),super.load(p)}unload(){var p,_;this.loaded&&((p=this.xpass)==null||p.dispose(),delete this.xpass,(_=this.ypass)==null||_.dispose(),delete this.ypass,super.unload())}async update(p,_){const E=Hc(p);if(!E)return;const{xpass:I,ypass:Z}=this;if(!I||!Z)return;this.size=nP({},E.size),I.resize(E.size),Z.resize(E.size);const re=I.process([E.texture]),ae=re&&Z.process([re]);ae&&(E.texture=ae)}}function KE(pe,p){const _=pe==="x"?["x","x","0"]:["y","0","y"],E=Math.floor(2*p);return`
            precision mediump float;
            varying vec2 xy;
            uniform vec2 wh;
            uniform float kernel[`+(2*E+1)+`];
            uniform sampler2D image;

            void main() {
                float result = 0.0;
                for (int `+_[0]+" = "+-E+"; "+_[0]+" <= "+E+"; "+_[0]+`++)
                    result += kernel[`+_[0]+" + "+E+`] *
                        texture2D(image, xy + vec2(`+_[1]+", "+_[2]+`) / wh).r;
                gl_FragColor = vec4(result, result, result, 1.0);
            }`}var aP=Object.defineProperty,jE=Object.getOwnPropertySymbols,xP=Object.prototype.hasOwnProperty,lP=Object.prototype.propertyIsEnumerable,qE=(pe,p,_)=>p in pe?aP(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,hP=(pe,p)=>{for(var _ in p||(p={}))xP.call(p,_)&&qE(pe,_,p[_]);if(jE)for(var _ of jE(p))lP.call(p,_)&&qE(pe,_,p[_]);return pe};class LB extends null{constructor(p=1,_={width:256,height:256}){super(),this.radius=p,this.size=_,this.ordinal=o.Process}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.shader=new vE(_,this.size,this.radius),super.load(p)}unload(){var p;this.loaded&&((p=this.shader)==null||p.dispose(),delete this.shader,super.unload())}async update(p,_){const{shader:E}=this;if(!this.loaded||!E)return;const I=Hc(p);if(!I)return;this.size=hP({},I.size),E.resize(I.size);const Z=E.process([I.texture]);Z&&(I.texture=Z)}}var cP=Object.defineProperty,$E=Object.getOwnPropertySymbols,uP=Object.prototype.hasOwnProperty,pP=Object.prototype.propertyIsEnumerable,rT=(pe,p,_)=>p in pe?cP(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,_P=(pe,p)=>{for(var _ in p||(p={}))uP.call(p,_)&&rT(pe,_,p[_]);if($E)for(var _ of $E(p))pP.call(p,_)&&rT(pe,_,p[_]);return pe};class kB extends null{constructor(p=1,_={width:256,height:256}){super(),this.radius=p,this.size=_,this.ordinal=o.Process}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.shader=new RE(_,this.size,this.radius),super.load(p)}unload(){var p;this.loaded&&((p=this.shader)==null||p.dispose(),delete this.shader,super.unload())}async update(p,_){const{shader:E}=this;if(!this.loaded||!E)return;const I=Hc(p);if(!I)return;this.size=_P({},I.size),E.resize(I.size);const Z=E.process([I.texture]);Z&&(I.texture=Z)}}var TP=Object.defineProperty,nT=Object.getOwnPropertySymbols,vP=Object.prototype.hasOwnProperty,RP=Object.prototype.propertyIsEnumerable,aT=(pe,p,_)=>p in pe?TP(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,MP=(pe,p)=>{for(var _ in p||(p={}))vP.call(p,_)&&aT(pe,_,p[_]);if(nT)for(var _ of nT(p))RP.call(p,_)&&aT(pe,_,p[_]);return pe};class UB extends null{constructor(p=1,_={width:256,height:256}){super(),this.radius=p,this.size=_,this.ordinal=o.Process}async load(p){const _=p instanceof i&&p.shaderCtx;if(!(this.loaded||!_))return this.shader=this.radius>0?new vE(_,this.size,this.radius):new RE(_,this.size,-this.radius),super.load(p)}unload(){var p;this.loaded&&((p=this.shader)==null||p.dispose(),delete this.shader,super.unload())}async update(p,_){const{shader:E}=this;if(!this.loaded||!E)return;const I=Hc(p);if(!I)return;this.size=MP({},I.size),E.resize(I.size);const Z=E.process([I.texture]);Z&&(I.texture=Z)}}class GB extends null{constructor(p=11,_=.55){super(["image","smooth","mask"],{rect:"4f",kernel:"1fv"},LP(p,_)),this.smooth=p,this.gaussian=[];const E=-.5/p**2,I=Math.floor(2*p);this.gaussian.push(1);let Z=1;for(let re=1;re<=I;re++){const ae=Math.exp(E*re**2);this.gaussian.push(ae),this.gaussian.unshift(ae),Z+=2*ae}for(let re=0;re<this.gaussian.length;re++)this.gaussian[re]/=Z}async load(p){var _;const E=p instanceof i&&p.shaderCtx;this.loaded||!E||(this.xpass=new x(E,this.size,["image"],{kernel:"1fv"},wP(this.smooth)),await super.load(p),this.xpass.setUniform("kernel",this.gaussian),(_=this.shader)==null||_.setUniform("kernel",this.gaussian))}unload(){var p;this.loaded&&((p=this.xpass)==null||p.dispose(),delete this.xpass,super.unload())}async process(p,_){const E=Hc(p);if(!E)return!1;const{xpass:I,shader:Z}=this;if(!I||!Z)return!1;const re=Km(E.box);return I.process([_]),Z.process([_,I.output(),E.texture],{rect:re}),!0}setupVideo(p){var _;super.setupVideo(p),(_=this.xpass)==null||_.resize(p)}}function wP(pe){const p=Math.floor(2*pe);return`
            precision mediump float;
            varying vec2 xy;
            uniform vec2 wh;
            uniform float kernel[`+(2*p+1)+`];
            uniform sampler2D image;

            void main() {
                vec3 result = vec3(0.0);
                for (int x = `+-p+"; x <= "+p+`; x++)
                    result += kernel[x + `+p+`] *
                        texture2D(image, xy + vec2(x, 0) / wh).rgb;
                gl_FragColor = vec4(result, 1.0);
            }`}function LP(pe,p=.55){const _=Math.floor(2*pe);return`
            precision mediump float;
            varying vec2 xy;
            uniform vec2 wh;
            uniform vec4 rect;
            uniform float kernel[`+(2*_+1)+`];
            uniform sampler2D image;
            uniform sampler2D smooth;
            uniform sampler2D mask;

            void main() {
                vec2 xyMask = (xy - rect.xy) / rect.zw;
                bool fg = texture2D(mask, xyMask).r > `+p+` &&
                          min(xyMask.x, xyMask.y) >= 0.0 &&
                          max(xyMask.x, xyMask.y) <= 1.0;
                if (fg) {
                    gl_FragColor = texture2D(image, xy);
                    return;
                }
                vec3 result = vec3(0.0);
                for (int y = `+-_+"; y <= "+_+`; y++)
                    result += kernel[y + `+_+`] *
                        texture2D(smooth, xy + vec2(0, y) / wh).rgb;
                gl_FragColor = vec4(result, 1.0);
            }`}class zB extends null{constructor(p=7,_=.05){super(["image"],{kernel:"1fv"},xT("y",p,_)),this.smooth=p,this.sense=_,this.gaussian=[];const E=-.5/p**2,I=Math.floor(2*p);this.gaussian.push(1);let Z=1;for(let re=1;re<=I;re++){const ae=Math.exp(E*re**2);this.gaussian.push(ae),this.gaussian.unshift(ae),Z+=2*ae}for(let re=0;re<2*I+1;re++)this.gaussian[re]/=Z}async load(p){var _;const E=p instanceof i&&p.shaderCtx;this.loaded||!E||(this.xpass=new x(E,this.size,["image"],{kernel:"1fv"},xT("x",this.smooth,this.sense)),await super.load(p),this.xpass.setUniform("kernel",this.gaussian),(_=this.shader)==null||_.setUniform("kernel",this.gaussian))}unload(){var p;this.loaded&&((p=this.xpass)==null||p.dispose(),delete this.xpass,super.unload())}async process(p,_){const{xpass:E,shader:I}=this;return!E||!I?!1:(E.process([_]),I.process([E.output()]),!0)}setupVideo(p){var _;super.setupVideo(p),(_=this.xpass)==null||_.resize(p)}}function xT(pe,p,_){const E=pe==="x"?["x","x","0"]:["y","0","y"],I=Math.floor(2*p);return`
            precision mediump float;
            varying vec2 xy;
            uniform sampler2D image;
            uniform vec2 wh;
            uniform float kernel[`+(2*I+1)+`];

            void main() {
                vec3 center = texture2D(image, xy).rgb;
                vec3 result = vec3(0.0);
                float norm = 0.0;
                for (int `+E[0]+" = "+-I+"; "+E[0]+" <= "+I+"; "+E[0]+`++) {
                    vec3 pixel = texture2D(image, xy + vec2(`+E[1]+", "+E[2]+`) / wh).rgb;
                    vec3 diff = center - pixel;
                    float kc = `+1/(_*Math.sqrt(2*Math.PI))+` *
                        exp(-0.5 * dot(diff, diff) / `+_*_+`);
                    float k = kernel[`+E[0]+" + "+I+`] * kc;
                    result += k * pixel;
                    norm += k;
                }
                gl_FragColor = vec4(result / norm, 1.0);
            }`}class WB extends null{constructor(p=.55,_=512){super(["image","mask"],{rect:"4f"},kP(p,_)),this.ordinal=o.PostRender}async process(p,_){const E=Hc(p),{shader:I}=this;if(!E||!I)return!1;const Z=Km(E.box);return I.process([_,E.texture],{rect:Z}),!0}}const kP=(pe=.55,p=512)=>{const _=Math.ceil(p/8);return`
        precision mediump float;
        varying vec2 xy;
        uniform vec2 wh;
        uniform vec4 rect;
        uniform sampler2D image;
        uniform sampler2D mask;

        float readMask(vec2 xy0, vec2 dxyI) {
            return texture2D(mask, (xy0 + dxyI / wh - rect.xy) / rect.zw).r;
        }

        vec4 readProp(vec2 xy0, vec2 dxyI, vec2 ddxyI) {
            return abs(dxyI.x) + abs(dxyI.y) < `+80 .toFixed(1)+` &&
                readMask(xy0, ddxyI) < `+pe+` ?
                texture2D(image, xy0 + ddxyI / wh) :
                texture2D(image, xy0 + dxyI / wh);
        }

        float traverse(vec2 xy0, vec2 dxyI) {
            bool bg = false;
            float d = 1.0;
            for (int di = 1; di < `+_+`; di++) {
                d = bg ? d : float(di * 8);
                bg = bg || readMask(xy0, d * dxyI) < `+pe+`;
            }
            bool bg1 = bg;
            for (int di = 1; di < 8; di++) {
                float d1 = d - 1.0;
                bg1 = bg1 && readMask(xy0, d1 * dxyI) < `+pe+`;
                d = bg1 ? d1 : d;
            }
            return bg ? d : -1.0;
        }

        void main() {
            bool bg = texture2D(mask, (xy - rect.xy) / (rect.zw)).r < `+pe+`;
            bool bg1;
            vec4 color = texture2D(image, xy);
            if (bg) {
                gl_FragColor = color;
                return;
            }

            float x0 = traverse(xy, vec2(-1.0, 0.0));
            bg = x0 > 0.0;
            vec4 cx0 = bg ? readProp(xy, vec2(-x0, 0.0),
                vec2(-2.0 * x0 + 1.0, 0.0)) : color;
            x0 = bg ? 1.0 / x0 : 0.0;

            float x1 = traverse(xy, vec2(1.0, 0.0));
            bg = x1 > 0.0;
            vec4 cx1 = bg ? readProp(xy, vec2(x1, 0.0),
                vec2(2.0 * x1 - 1.0, 0.0)) : color;
            x1 = bg ? 1.0 / x1 : 0.0;

            float y0 = traverse(xy, vec2(0.0, -1.0));
            bg = y0 > 0.0;
            vec4 cy0 = bg ? readProp(xy, vec2(0.0, -y0),
                vec2(0.0, -2.0 * y0 + 1.0)) : color;
            y0 = bg ? 1.0 / y0 : 0.0;

            float y1 = traverse(xy, vec2(0.0, 1.0));
            bg = y1 > 0.0;
            vec4 cy1 = bg ? readProp(xy, vec2(0.0, y1),
                vec2(0.0, 2.0 * y1 - 1.0)) : color;
            y1 = bg ? 1.0 / y1 : 0.0;

            float s = 1.0 / (x0 + x1 + y0 + y1);
            color = cx0 * x0 * s + cx1 * x1 * s + cy0 * y0 * s + cy1 * y1 * s;
            gl_FragColor = color;
        }`};class HB extends null{constructor(p,_=.5,E=.1,I={minCutOff:.05,minCutOffD:.1,beta:.05}){super(),this.callback=p,this.rangeMax=_,this.rangeMin=E,this.filterParams=I,this.gl=null,this.texture=null,this.frameBuffer=null,this.size={width:0,height:0},this.levels=1,this.ordinal=o.PreRender,this.rangeRatio=(1-E)/(_-E)}async load(p){if(this.loaded||!(p instanceof i)||!p.shaderCtx)return;const{shaderCtx:_}=p;if(this.frameBuffer=_.createFramebuffer(),!!this.frameBuffer)return this.gl=_,this.setupVideo(this.size),super.load(p)}unload(){if(!this.loaded)return;const{gl:p}=this;p?.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,p?.deleteTexture(this.texture),this.texture=null,this.gl=null,super.unload()}async update(p,_){const{gl:E,texture:I,size:{width:Z,height:re},levels:ae}=this;if(!this.loaded||!E||!I)return;const he=E.getParameter(E.TEXTURE_BINDING_2D),_e=E.getParameter(E.FRAMEBUFFER_BINDING);E.bindTexture(E.TEXTURE_2D,I),E.texSubImage2D(E.TEXTURE_2D,0,0,0,Z,re,E.RGBA,E.UNSIGNED_BYTE,_),E.generateMipmap(E.TEXTURE_2D),E.bindFramebuffer(E.FRAMEBUFFER,this.frameBuffer),E.framebufferTexture2D(E.FRAMEBUFFER,E.COLOR_ATTACHMENT0,E.TEXTURE_2D,I,ae-1);const ve=new Uint8Array(4);E.readPixels(0,0,1,1,E.RGBA,E.UNSIGNED_BYTE,ve);let Le=(.299*ve[0]+.587*ve[1]+.114*ve[2])/255;Le=this.filter(Le),Le=Math.min(Math.max(Le,this.rangeMin),this.rangeMax),Le=(Le-this.rangeMin)*this.rangeRatio+this.rangeMin,this.callback&&this.callback(Le),E.bindTexture(E.TEXTURE_2D,he),E.bindFramebuffer(E.FRAMEBUFFER,_e)}setupVideo(p){const{width:_,height:E}=p;if(_===this.size.width&&E===this.size.height&&this.texture)return!0;const{gl:I}=this;if(!I||(I.deleteTexture(this.texture),this.texture=null,(_>0||E>0)&&(this.texture=I.createTexture()),!this.texture))return!1;const Z=I.getParameter(I.TEXTURE_BINDING_2D);return I.bindTexture(I.TEXTURE_2D,this.texture),this.size={width:_,height:E},this.levels=1+Math.floor(Math.log2(Math.max(_,E))),I.texStorage2D(I.TEXTURE_2D,this.levels,I.RGBA8,_,E),I.bindTexture(I.TEXTURE_2D,Z),!0}setCallback(p){this.callback=p}filter(p){if(!this.smooth)return this.smooth={val:p,der:0,time:Date.now()/1e3},p;const{smooth:_,filterParams:E}=this,I=Date.now()/1e3;if(I<=_.time)return p;const Z=1/(I-_.time);_.time=I;const re=(p-_.val)*Z,ae=ve=>1/(1+Z/(2*Math.PI*ve)),he=ae(E.minCutOffD);_.der=_.der+he*(re-_.der);const _e=ae(E.minCutOff+E.beta*Math.abs(_.der));return _.val=_.val+_e*(p-_.val),_.val}}class XB extends null{constructor(p){super(),this.callback=p,this.ordinal=o.PostProcess}async update(p,_){if(this.loaded)return this.callback(p),super.update(p,_)}}class YB extends null{}class KB extends null{}class jB extends null{constructor(p){super(),this.predicate=p,this.ordinal=o.PreProcess}async update(p,_){this.loaded&&(p.poses=p.poses.filter(this.predicate))}}class qB extends null{constructor(p){super(),this.predicate=p,this.ordinal=o.PreProcess}async update(p,_){if(this.loaded)return p.faces=p.faces.filter(this.predicate),super.update(p,_)}}class $B extends null{constructor(p){super(),this.callback=p,this.fpsStart=Date.now(),this.fpsCount=0,this.ordinal=o.PostRender}async load(p){return this.fpsStart=Date.now(),this.fpsCount=0,super.load(p)}async update(p,_){if(this.loaded){if(this.fpsCount++,this.fpsCount>=30){const E=Date.now(),I=this.fpsCount*1e3/(E-this.fpsStart);this.fpsCount=0,this.fpsStart=E,this.callback(I)}return super.update(p,_)}}}class r3 extends null{constructor(p=.55){super(["image","mask"],{rect:"4f"},UP(p))}async process(p,_){var E;const I=Hc(p);if(!I)return!1;const Z=Km(I.box);return(E=this.shader)==null||E.process([_,I.texture],{rect:Z}),!0}}const UP=(pe=.55)=>`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform vec4 rect;
    uniform sampler2D image;
    uniform sampler2D mask;

    void main() {
        // vec2 xyMask = floor((xy - rect.xy) / rect.zw * 256.0 + 0.5) / 256.0;
        vec2 xyMask = (xy - rect.xy) / rect.zw;
        bool fg = texture2D(mask, xyMask).r > `+pe+` &&
                  min(xyMask.x, xyMask.y) >= 0.0 && max(xyMask.x, xyMask.y) <= 1.0;
        vec4 color = texture2D(image, xy);
        if (!fg) {
            gl_FragColor = color;
            return;
        }
        gl_FragColor = mix(color, vec4(1.0, 0.0, 0.0, 1.0), 0.5);
    }
`;class GP{get depthStencilTexture(){return this._depthStencilTexture}get depthStencilTextureWithStencil(){return this._depthStencilTextureWithStencil}get isCube(){return this._isCube}get isMulti(){return this._isMulti}get is2DArray(){return this.layers>0}get size(){return this.width}get width(){return this._size.width||this._size}get height(){return this._size.height||this._size}get layers(){return this._size.layers||0}get texture(){return this._textures?.[0]??null}get textures(){return this._textures}get faceIndices(){return this._faceIndices}get layerIndices(){return this._layerIndices}get samples(){return this._samples}setSamples(p,_=!0,E=!1){if(this.samples===p&&!E)return p;const I=this._isMulti?this._engine.updateMultipleRenderTargetTextureSampleCount(this,p,_):this._engine.updateRenderTargetTextureSampleCount(this,p);return this._samples=p,I}constructor(p,_,E,I,Z){this._textures=null,this._faceIndices=null,this._layerIndices=null,this._samples=1,this._attachments=null,this._generateStencilBuffer=!1,this._generateDepthBuffer=!1,this._depthStencilTextureWithStencil=!1,this._isMulti=p,this._isCube=_,this._size=E,this._engine=I,this._depthStencilTexture=null,this.label=Z}setTextures(p){Array.isArray(p)?this._textures=p:p?this._textures=[p]:this._textures=null}setTexture(p,_=0,E=!0){this._textures||(this._textures=[]),this._textures[_]!==p&&(this._textures[_]&&E&&this._textures[_].dispose(),this._textures[_]=p)}setLayerAndFaceIndices(p,_){this._layerIndices=p,this._faceIndices=_}setLayerAndFaceIndex(p=0,_,E){this._layerIndices||(this._layerIndices=[]),this._faceIndices||(this._faceIndices=[]),_!==void 0&&_>=0&&(this._layerIndices[p]=_),E!==void 0&&E>=0&&(this._faceIndices[p]=E)}createDepthStencilTexture(p=0,_=!0,E=!1,I=1,Z=14,re){return this._depthStencilTexture?.dispose(),this._depthStencilTextureWithStencil=E,this._depthStencilTextureLabel=re,this._depthStencilTexture=this._engine.createDepthStencilTexture(this._size,{bilinearFiltering:_,comparisonFunction:p,generateStencil:E,isCube:this._isCube,samples:I,depthTextureFormat:Z,label:re},this),this._depthStencilTexture}_shareDepth(p){this._depthStencilTexture&&(p._depthStencilTexture&&p._depthStencilTexture.dispose(),p._depthStencilTexture=this._depthStencilTexture,this._depthStencilTexture.incrementReferences())}_swapAndDie(p){this.texture&&this.texture._swapAndDie(p),this._textures=null,this.dispose(!0)}_cloneRenderTargetWrapper(){let p=null;if(this._isMulti){const _=this.textures;if(_&&_.length>0){let E=!1,I=_.length,Z=-1;const re=_[_.length-1]._source;(re===kn.Depth||re===kn.DepthStencil)&&(E=!0,Z=_[_.length-1].format,I--);const ae=[],he=[],_e=[],ve=[],Le=[],ze=[],He=[],xt={};for(let Lt=0;Lt<I;++Lt){const Nt=_[Lt];ae.push(Nt.samplingMode),he.push(Nt.type),_e.push(Nt.format),xt[Nt.uniqueId]!==void 0?(ve.push(-1),He.push(0)):(xt[Nt.uniqueId]=Lt,Nt.is2DArray?(ve.push(35866),He.push(Nt.depth)):Nt.isCube?(ve.push(34067),He.push(0)):Nt.is3D?(ve.push(32879),He.push(Nt.depth)):(ve.push(3553),He.push(0))),this._faceIndices&&Le.push(this._faceIndices[Lt]??0),this._layerIndices&&ze.push(this._layerIndices[Lt]??0)}const rt={samplingModes:ae,generateMipMaps:_[0].generateMipMaps,generateDepthBuffer:this._generateDepthBuffer,generateStencilBuffer:this._generateStencilBuffer,generateDepthTexture:E,depthTextureFormat:Z,types:he,formats:_e,textureCount:I,targetTypes:ve,faceIndex:Le,layerIndex:ze,layerCounts:He,label:this.label},Tt={width:this.width,height:this.height};p=this._engine.createMultipleRenderTarget(Tt,rt);for(let Lt=0;Lt<I;++Lt){if(ve[Lt]!==-1)continue;const Nt=xt[_[Lt].uniqueId];p.setTexture(p.textures[Nt],Lt)}}}else{const _={};if(_.generateDepthBuffer=this._generateDepthBuffer,_.generateMipMaps=this.texture?.generateMipMaps??!1,_.generateStencilBuffer=this._generateStencilBuffer,_.samplingMode=this.texture?.samplingMode,_.type=this.texture?.type,_.format=this.texture?.format,_.noColorAttachment=!this._textures,_.label=this.label,this.isCube)p=this._engine.createRenderTargetCubeTexture(this.width,_);else{const E={width:this.width,height:this.height,layers:this.is2DArray?this.texture?.depth:void 0};p=this._engine.createRenderTargetTexture(E,_)}p.texture&&(p.texture.isReady=!0)}return p}_swapRenderTargetWrapper(p){if(this._textures&&p._textures)for(let _=0;_<this._textures.length;++_)this._textures[_]._swapAndDie(p._textures[_],!1),p._textures[_].isReady=!0;this._depthStencilTexture&&p._depthStencilTexture&&(this._depthStencilTexture._swapAndDie(p._depthStencilTexture),p._depthStencilTexture.isReady=!0),this._textures=null,this._depthStencilTexture=null}_rebuild(){const p=this._cloneRenderTargetWrapper();if(p){if(this._depthStencilTexture){const _=this._depthStencilTexture.samplingMode,E=this._depthStencilTexture.format,I=_===2||_===3||_===11;p.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction,I,this._depthStencilTextureWithStencil,this._depthStencilTexture.samples,E,this._depthStencilTextureLabel)}this.samples>1&&p.setSamples(this.samples),p._swapRenderTargetWrapper(this),p.dispose()}}releaseTextures(){if(this._textures)for(let p=0;p<this._textures?.length;++p)this._textures[p].dispose();this._textures=null}dispose(p=!1){p||(this._depthStencilTexture?.dispose(),this._depthStencilTexture=null,this.releaseTextures()),this._engine._releaseRenderTargetWrapper(this)}}class zP extends GP{constructor(p,_,E,I,Z){super(p,_,E,I),this._framebuffer=null,this._depthStencilBuffer=null,this._MSAAFramebuffer=null,this._colorTextureArray=null,this._depthStencilTextureArray=null,this._disposeOnlyFramebuffers=!1,this._currentLOD=0,this._context=Z}_cloneRenderTargetWrapper(){let p=null;return this._colorTextureArray&&this._depthStencilTextureArray?(p=this._engine.createMultiviewRenderTargetTexture(this.width,this.height),p.texture.isReady=!0):p=super._cloneRenderTargetWrapper(),p}_swapRenderTargetWrapper(p){super._swapRenderTargetWrapper(p),p._framebuffer=this._framebuffer,p._depthStencilBuffer=this._depthStencilBuffer,p._MSAAFramebuffer=this._MSAAFramebuffer,p._colorTextureArray=this._colorTextureArray,p._depthStencilTextureArray=this._depthStencilTextureArray,this._framebuffer=this._depthStencilBuffer=this._MSAAFramebuffer=this._colorTextureArray=this._depthStencilTextureArray=null}createDepthStencilTexture(p=0,_=!0,E=!1,I=1,Z=14,re){if(this._depthStencilBuffer){const ae=this._engine._currentFramebuffer,he=this._context;this._engine._bindUnboundFramebuffer(this._framebuffer),he.framebufferRenderbuffer(he.FRAMEBUFFER,he.DEPTH_STENCIL_ATTACHMENT,he.RENDERBUFFER,null),he.framebufferRenderbuffer(he.FRAMEBUFFER,he.DEPTH_ATTACHMENT,he.RENDERBUFFER,null),he.framebufferRenderbuffer(he.FRAMEBUFFER,he.STENCIL_ATTACHMENT,he.RENDERBUFFER,null),this._engine._bindUnboundFramebuffer(ae),he.deleteRenderbuffer(this._depthStencilBuffer),this._depthStencilBuffer=null}return super.createDepthStencilTexture(p,_,E,I,Z,re)}_shareDepth(p){super._shareDepth(p);const _=this._context,E=this._depthStencilBuffer,I=p._MSAAFramebuffer||p._framebuffer;p._depthStencilBuffer&&p._depthStencilBuffer!==E&&_.deleteRenderbuffer(p._depthStencilBuffer),p._depthStencilBuffer=E;const Z=p._generateStencilBuffer?_.DEPTH_STENCIL_ATTACHMENT:_.DEPTH_ATTACHMENT;this._engine._bindUnboundFramebuffer(I),_.framebufferRenderbuffer(_.FRAMEBUFFER,Z,_.RENDERBUFFER,E),this._engine._bindUnboundFramebuffer(null)}_bindTextureRenderTarget(p,_=0,E,I=0){if(!p._hardwareTexture)return;const Z=this._framebuffer,re=this._engine._currentFramebuffer;if(this._engine._bindUnboundFramebuffer(Z),this._engine.webGLVersion>1){const ae=this._context,he=ae["COLOR_ATTACHMENT"+_];p.is2DArray||p.is3D?(E=E??this.layerIndices?.[_]??0,ae.framebufferTextureLayer(ae.FRAMEBUFFER,he,p._hardwareTexture.underlyingResource,I,E)):p.isCube?(E=E??this.faceIndices?.[_]??0,ae.framebufferTexture2D(ae.FRAMEBUFFER,he,ae.TEXTURE_CUBE_MAP_POSITIVE_X+E,p._hardwareTexture.underlyingResource,I)):ae.framebufferTexture2D(ae.FRAMEBUFFER,he,ae.TEXTURE_2D,p._hardwareTexture.underlyingResource,I)}else{const ae=this._context,he=ae["COLOR_ATTACHMENT"+_+"_WEBGL"],_e=E!==void 0?ae.TEXTURE_CUBE_MAP_POSITIVE_X+E:ae.TEXTURE_2D;ae.framebufferTexture2D(ae.FRAMEBUFFER,he,_e,p._hardwareTexture.underlyingResource,I)}this._engine._bindUnboundFramebuffer(re)}setTexture(p,_=0,E=!0){super.setTexture(p,_,E),this._bindTextureRenderTarget(p,_)}setLayerAndFaceIndices(p,_){if(super.setLayerAndFaceIndices(p,_),!this.textures||!this.layerIndices||!this.faceIndices)return;const E=this._attachments?.length??this.textures.length;for(let I=0;I<E;I++){const Z=this.textures[I];Z&&(Z.is2DArray||Z.is3D?this._bindTextureRenderTarget(Z,I,this.layerIndices[I]):Z.isCube?this._bindTextureRenderTarget(Z,I,this.faceIndices[I]):this._bindTextureRenderTarget(Z,I))}}setLayerAndFaceIndex(p=0,_,E){if(super.setLayerAndFaceIndex(p,_,E),!this.textures||!this.layerIndices||!this.faceIndices)return;const I=this.textures[p];I.is2DArray||I.is3D?this._bindTextureRenderTarget(this.textures[p],p,this.layerIndices[p]):I.isCube&&this._bindTextureRenderTarget(this.textures[p],p,this.faceIndices[p])}dispose(p=this._disposeOnlyFramebuffers){const _=this._context;p||(this._colorTextureArray&&(this._context.deleteTexture(this._colorTextureArray),this._colorTextureArray=null),this._depthStencilTextureArray&&(this._context.deleteTexture(this._depthStencilTextureArray),this._depthStencilTextureArray=null)),this._framebuffer&&(_.deleteFramebuffer(this._framebuffer),this._framebuffer=null),this._depthStencilBuffer&&(_.deleteRenderbuffer(this._depthStencilBuffer),this._depthStencilBuffer=null),this._MSAAFramebuffer&&(_.deleteFramebuffer(this._MSAAFramebuffer),this._MSAAFramebuffer=null),super.dispose(p)}}sr.prototype._createHardwareRenderTargetWrapper=function(pe,p,_){const E=new zP(pe,p,_,this,this._gl);return this._renderTargetWrapperCache.push(E),E},sr.prototype.createRenderTargetTexture=function(pe,p){const _=this._createHardwareRenderTargetWrapper(!1,!1,pe);let E=!0,I=!1,Z=!1,re,ae=1,he;p!==void 0&&typeof p=="object"&&(E=p.generateDepthBuffer??!0,I=!!p.generateStencilBuffer,Z=!!p.noColorAttachment,re=p.colorAttachment,ae=p.samples??1,he=p.label);const _e=re||(Z?null:this._createInternalTexture(pe,p,!0,kn.RenderTarget)),ve=pe.width||pe,Le=pe.height||pe,ze=this._currentFramebuffer,He=this._gl,xt=He.createFramebuffer();return this._bindUnboundFramebuffer(xt),_._depthStencilBuffer=this._setupFramebufferDepthAttachments(I,E,ve,Le),_e&&!_e.is2DArray&&He.framebufferTexture2D(He.FRAMEBUFFER,He.COLOR_ATTACHMENT0,He.TEXTURE_2D,_e._hardwareTexture.underlyingResource,0),this._bindUnboundFramebuffer(ze),_.label=he??"RenderTargetWrapper",_._framebuffer=xt,_._generateDepthBuffer=E,_._generateStencilBuffer=I,_.setTextures(_e),this.updateRenderTargetTextureSampleCount(_,ae),_},sr.prototype.createDepthStencilTexture=function(pe,p,_){if(p.isCube){const E=pe.width||pe;return this._createDepthStencilCubeTexture(E,p)}else return this._createDepthStencilTexture(pe,p,_)},sr.prototype._createDepthStencilTexture=function(pe,p){const _=this._gl,E=pe.layers||0,I=E!==0?_.TEXTURE_2D_ARRAY:_.TEXTURE_2D,Z=new c0(this,kn.DepthStencil);if(Z.label=p.label,!this._caps.depthTextureExtension)return Ti.Error("Depth texture is not supported by your browser or hardware."),Z;const re={bilinearFiltering:!1,comparisonFunction:0,generateStencil:!1,...p};if(this._bindTextureDirectly(I,Z,!0),this._setupDepthStencilTexture(Z,pe,re.generateStencil,re.comparisonFunction===0?!1:re.bilinearFiltering,re.comparisonFunction,re.samples),re.depthTextureFormat!==void 0){if(re.depthTextureFormat!==15&&re.depthTextureFormat!==16&&re.depthTextureFormat!==17&&re.depthTextureFormat!==13&&re.depthTextureFormat!==14&&re.depthTextureFormat!==18)return Ti.Error("Depth texture format is not supported."),Z;Z.format=re.depthTextureFormat}else Z.format=re.generateStencil?13:16;const ae=Z.format===17||Z.format===13||Z.format===18;let he=_.UNSIGNED_INT;Z.format===15?he=_.UNSIGNED_SHORT:Z.format===17||Z.format===13?he=_.UNSIGNED_INT_24_8:Z.format===14?he=_.FLOAT:Z.format===18&&(he=_.FLOAT_32_UNSIGNED_INT_24_8_REV);const _e=ae?_.DEPTH_STENCIL:_.DEPTH_COMPONENT;let ve=_e;return this.webGLVersion>1&&(Z.format===15?ve=_.DEPTH_COMPONENT16:Z.format===16?ve=_.DEPTH_COMPONENT24:Z.format===17||Z.format===13?ve=_.DEPTH24_STENCIL8:Z.format===14?ve=_.DEPTH_COMPONENT32F:Z.format===18&&(ve=_.DEPTH32F_STENCIL8)),Z.is2DArray?_.texImage3D(I,0,ve,Z.width,Z.height,E,0,_e,he,null):_.texImage2D(I,0,ve,Z.width,Z.height,0,_e,he,null),this._bindTextureDirectly(I,null),this._internalTexturesCache.push(Z),Z},sr.prototype.updateRenderTargetTextureSampleCount=function(pe,p){if(this.webGLVersion<2||!pe||!pe.texture)return 1;if(pe.samples===p)return p;const _=this._gl;p=Math.min(p,this.getCaps().maxMSAASamples),pe._depthStencilBuffer&&(_.deleteRenderbuffer(pe._depthStencilBuffer),pe._depthStencilBuffer=null),pe._MSAAFramebuffer&&(_.deleteFramebuffer(pe._MSAAFramebuffer),pe._MSAAFramebuffer=null);const E=pe.texture._hardwareTexture;if(E.releaseMSAARenderBuffers(),p>1&&typeof _.renderbufferStorageMultisample=="function"){const I=_.createFramebuffer();if(!I)throw new Error("Unable to create multi sampled framebuffer");pe._MSAAFramebuffer=I,this._bindUnboundFramebuffer(pe._MSAAFramebuffer);const Z=this._createRenderBuffer(pe.texture.width,pe.texture.height,p,-1,this._getRGBABufferInternalSizedFormat(pe.texture.type,pe.texture.format,pe.texture._useSRGBBuffer),_.COLOR_ATTACHMENT0,!1);if(!Z)throw new Error("Unable to create multi sampled framebuffer");E.addMSAARenderBuffer(Z)}else this._bindUnboundFramebuffer(pe._framebuffer);return pe.texture.samples=p,pe._samples=p,pe._depthStencilBuffer=this._setupFramebufferDepthAttachments(pe._generateStencilBuffer,pe._generateDepthBuffer,pe.texture.width,pe.texture.height,p),this._bindUnboundFramebuffer(null),p},sr.prototype.createRenderTargetCubeTexture=function(pe,p){const _=this._createHardwareRenderTargetWrapper(!1,!0,pe),E={generateMipMaps:!0,generateDepthBuffer:!0,generateStencilBuffer:!1,type:0,samplingMode:3,format:5,...p};E.generateStencilBuffer=E.generateDepthBuffer&&E.generateStencilBuffer,(E.type===1&&!this._caps.textureFloatLinearFiltering||E.type===2&&!this._caps.textureHalfFloatLinearFiltering)&&(E.samplingMode=1);const I=this._gl,Z=new c0(this,kn.RenderTarget);this._bindTextureDirectly(I.TEXTURE_CUBE_MAP,Z,!0);const re=this._getSamplingParameters(E.samplingMode,E.generateMipMaps);E.type===1&&!this._caps.textureFloat&&(E.type=0,Ti.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type")),I.texParameteri(I.TEXTURE_CUBE_MAP,I.TEXTURE_MAG_FILTER,re.mag),I.texParameteri(I.TEXTURE_CUBE_MAP,I.TEXTURE_MIN_FILTER,re.min),I.texParameteri(I.TEXTURE_CUBE_MAP,I.TEXTURE_WRAP_S,I.CLAMP_TO_EDGE),I.texParameteri(I.TEXTURE_CUBE_MAP,I.TEXTURE_WRAP_T,I.CLAMP_TO_EDGE);for(let he=0;he<6;he++)I.texImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+he,0,this._getRGBABufferInternalSizedFormat(E.type,E.format),pe,pe,0,this._getInternalFormat(E.format),this._getWebGLTextureType(E.type),null);const ae=I.createFramebuffer();return this._bindUnboundFramebuffer(ae),_._depthStencilBuffer=this._setupFramebufferDepthAttachments(E.generateStencilBuffer,E.generateDepthBuffer,pe,pe),E.generateMipMaps&&I.generateMipmap(I.TEXTURE_CUBE_MAP),this._bindTextureDirectly(I.TEXTURE_CUBE_MAP,null),this._bindUnboundFramebuffer(null),_._framebuffer=ae,_._generateDepthBuffer=E.generateDepthBuffer,_._generateStencilBuffer=E.generateStencilBuffer,Z.width=pe,Z.height=pe,Z.isReady=!0,Z.isCube=!0,Z.samples=1,Z.generateMipMaps=E.generateMipMaps,Z.samplingMode=E.samplingMode,Z.type=E.type,Z.format=E.format,this._internalTexturesCache.push(Z),_.setTextures(Z),_};const lT="postprocessVertexShader",hT=`attribute vec2 position;uniform vec2 scale;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd)*scale;gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;ji.ShadersStore[lT]=hT;const n3={name:lT,shader:hT},i_={positions:[1,1,-1,1,-1,-1,1,-1],indices:[0,1,2,0,2,3]};class WP{constructor(p,_=i_){this._fullscreenViewport=new Hp(0,0,1,1);const E=_.positions??i_.positions,I=_.indices??i_.indices;this.engine=p,this._vertexBuffers={[ut.PositionKind]:new ut(p,E,ut.PositionKind,!1,!1,2)},this._indexBuffer=p.createIndexBuffer(I),this._onContextRestoredObserver=p.onContextRestoredObservable.add(()=>{this._indexBuffer=p.createIndexBuffer(I);for(const Z in this._vertexBuffers)this._vertexBuffers[Z]._rebuild()})}setViewport(p=this._fullscreenViewport){this.engine.setViewport(p)}bindBuffers(p){this.engine.bindBuffers(this._vertexBuffers,this._indexBuffer,p)}applyEffectWrapper(p){this.engine.setState(!0),this.engine.depthCullingState.depthTest=!1,this.engine.stencilState.stencilTest=!1,this.engine.enableEffect(p._drawWrapper),this.bindBuffers(p.effect),p.onApplyObservable.notifyObservers({})}saveStates(){this._savedStateDepthTest=this.engine.depthCullingState.depthTest,this._savedStateStencilTest=this.engine.stencilState.stencilTest}restoreStates(){this.engine.depthCullingState.depthTest=this._savedStateDepthTest,this.engine.stencilState.stencilTest=this._savedStateStencilTest}draw(){this.engine.drawElementsType(0,0,6)}_isRenderTargetTexture(p){return p.renderTarget!==void 0}render(p,_=null){if(!p.effect.isReady())return;this.saveStates(),this.setViewport();const E=_===null?null:this._isRenderTargetTexture(_)?_.renderTarget:_;E&&this.engine.bindFramebuffer(E),this.applyEffectWrapper(p),this.draw(),E&&this.engine.unBindFramebuffer(E),this.restoreStates()}dispose(){const p=this._vertexBuffers[ut.PositionKind];p&&(p.dispose(),delete this._vertexBuffers[ut.PositionKind]),this._indexBuffer&&this.engine._releaseBuffer(this._indexBuffer),this._onContextRestoredObserver&&(this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)}}class HP{get effect(){return this._drawWrapper.effect}set effect(p){this._drawWrapper.effect=p}constructor(p){this.onApplyObservable=new Ri;let _;const E=p.uniformNames||[];p.vertexShader?_={fragmentSource:p.fragmentShader,vertexSource:p.vertexShader,spectorName:p.name||"effectWrapper"}:(E.push("scale"),_={fragmentSource:p.fragmentShader,vertex:"postprocess",spectorName:p.name||"effectWrapper"},this.onApplyObservable.add(()=>{this.effect.setFloat2("scale",1,1)}));const I=p.defines?p.defines.join(`
`):"";this._drawWrapper=new xo(p.engine),p.useShaderStore?(_.fragment=_.fragmentSource,_.vertex||(_.vertex=_.vertexSource),delete _.fragmentSource,delete _.vertexSource,this.effect=p.engine.createEffect(_,p.attributeNames||["position"],E,p.samplerNames,I,void 0,p.onCompiled,void 0,void 0,p.shaderLanguage)):(this.effect=new _a(_,p.attributeNames||["position"],E,p.samplerNames,p.engine,I,void 0,p.onCompiled,void 0,void 0,void 0,p.shaderLanguage),this._onContextRestoredObserver=p.engine.onContextRestoredObservable.add(()=>{this.effect._pipelineContext=null,this.effect._prepareEffect()}))}dispose(){this._onContextRestoredObserver&&(this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null),this.effect.dispose()}}const cT="passPixelShader",uT=`varying vec2 vUV;uniform sampler2D textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=texture2D(textureSampler,vUV);}`;ji.ShadersStore[cT]=uT;const pT={name:cT,shader:uT};class Lx{static _CreateDumpRenderer(){if(!Lx._DumpToolsEngine){let p,_=null;const E={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};try{p=new OffscreenCanvas(100,100),_=new sr(p,!1,E)}catch{p=document.createElement("canvas"),_=new sr(p,!1,E)}_.getCaps().parallelShaderCompile=void 0;const I=new WP(_),Z=new HP({engine:_,name:pT.name,fragmentShader:pT.shader,samplerNames:["textureSampler"]});Lx._DumpToolsEngine={canvas:p,engine:_,renderer:I,wrapper:Z}}return Lx._DumpToolsEngine}static async DumpFramebuffer(p,_,E,I,Z="image/png",re,ae){const he=await E.readPixels(0,0,p,_),_e=new Uint8Array(he.buffer);Lx.DumpData(p,_,_e,I,Z,re,!0,void 0,ae)}static DumpDataAsync(p,_,E,I="image/png",Z,re=!1,ae=!1,he){return new Promise(_e=>{Lx.DumpData(p,_,E,ve=>_e(ve),I,Z,re,ae,he)})}static DumpData(p,_,E,I,Z="image/png",re,ae=!1,he=!1,_e){const ve=Lx._CreateDumpRenderer();if(ve.engine.setSize(p,_,!0),E instanceof Float32Array){const ze=new Uint8Array(E.length);let He=E.length;for(;He--;){const xt=E[He];ze[He]=Math.round($t.Clamp(xt)*255)}E=ze}const Le=ve.engine.createRawTexture(E,p,_,5,!1,!ae,1);ve.renderer.setViewport(),ve.renderer.applyEffectWrapper(ve.wrapper),ve.wrapper.effect._bindTexture("textureSampler",Le),ve.renderer.draw(),he?lt.ToBlob(ve.canvas,ze=>{const He=new FileReader;He.onload=xt=>{const rt=xt.target.result;I&&I(rt)},He.readAsArrayBuffer(ze)},Z,_e):lt.EncodeScreenshotCanvasData(ve.canvas,I,Z,re,_e),Le.dispose()}static Dispose(){Lx._DumpToolsEngine&&(Lx._DumpToolsEngine.wrapper.dispose(),Lx._DumpToolsEngine.renderer.dispose(),Lx._DumpToolsEngine.engine.dispose()),Lx._DumpToolsEngine=null}}(()=>{lt.DumpData=Lx.DumpData,lt.DumpDataAsync=Lx.DumpDataAsync,lt.DumpFramebuffer=Lx.DumpFramebuffer})();class z2 extends Ki{get renderList(){return this._renderList}set renderList(p){this._unObserveRenderList&&(this._unObserveRenderList(),this._unObserveRenderList=null),p&&(this._unObserveRenderList=vn(p,this._renderListHasChanged)),this._renderList=p}get postProcesses(){return this._postProcesses}get _prePassEnabled(){return!!this._prePassRenderTarget&&this._prePassRenderTarget.enabled}set onAfterUnbind(p){this._onAfterUnbindObserver&&this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=this.onAfterUnbindObservable.add(p)}set onBeforeRender(p){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(p)}set onAfterRender(p){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(p)}set onClear(p){this._onClearObserver&&this.onClearObservable.remove(this._onClearObserver),this._onClearObserver=this.onClearObservable.add(p)}get renderPassIds(){return this._renderPassIds}get currentRefreshId(){return this._currentRefreshId}setMaterialForRendering(p,_){let E;Array.isArray(p)?E=p:E=[p];for(let I=0;I<E.length;++I)for(let Z=0;Z<this._renderPassIds.length;++Z)E[I].setMaterialForRenderPass(this._renderPassIds[Z],_!==void 0?Array.isArray(_)?_[Z]:_:void 0)}get isMulti(){return this._renderTarget?.isMulti??!1}get renderTargetOptions(){return this._renderTargetOptions}get renderTarget(){return this._renderTarget}_onRatioRescale(){this._sizeRatio&&this.resize(this._initialSizeParameter)}set boundingBoxSize(p){if(this._boundingBoxSize&&this._boundingBoxSize.equals(p))return;this._boundingBoxSize=p;const _=this.getScene();_&&_.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}get depthStencilTexture(){return this._renderTarget?._depthStencilTexture??null}constructor(p,_,E,I=!1,Z=!0,re=0,ae=!1,he=Ki.TRILINEAR_SAMPLINGMODE,_e=!0,ve=!1,Le=!1,ze=5,He=!1,xt,rt,Tt=!1,Lt=!1){let Nt,qt=!0;if(typeof I=="object"){const zt=I;I=!!zt.generateMipMaps,Z=zt.doNotChangeAspectRatio??!0,re=zt.type??0,ae=!!zt.isCube,he=zt.samplingMode??Ki.TRILINEAR_SAMPLINGMODE,_e=zt.generateDepthBuffer??!0,ve=!!zt.generateStencilBuffer,Le=!!zt.isMulti,ze=zt.format??5,He=!!zt.delayAllocation,xt=zt.samples,rt=zt.creationFlags,Tt=!!zt.noColorAttachment,Lt=!!zt.useSRGBBuffer,Nt=zt.colorAttachment,qt=zt.gammaSpace??qt}if(super(null,E,!I,void 0,he,void 0,void 0,void 0,void 0,ze),this._unObserveRenderList=null,this._renderListHasChanged=(zt,Gt)=>{const xi=this._renderList?this._renderList.length:0;(Gt===0&&xi>0||xi===0)&&this.getScene()?.meshes.forEach(Gi=>{Gi._markSubMeshesAsLightDirty()})},this.renderParticles=!0,this.renderSprites=!1,this.forceLayerMaskCheck=!1,this.ignoreCameraViewport=!1,this.onBeforeBindObservable=new Ri,this.onAfterUnbindObservable=new Ri,this.onBeforeRenderObservable=new Ri,this.onAfterRenderObservable=new Ri,this.onClearObservable=new Ri,this.onResizeObservable=new Ri,this._cleared=!1,this.skipInitialClear=!1,this._currentRefreshId=-1,this._refreshRate=1,this._samples=1,this._canRescale=!0,this._renderTarget=null,this.boundingBoxPosition=at.Zero(),E=this.getScene(),!E)return;const Xt=this.getScene().getEngine();this._gammaSpace=qt,this._coordinatesMode=Ki.PROJECTION_MODE,this.renderList=[],this.name=p,this.isRenderTarget=!0,this._initialSizeParameter=_,this._renderPassIds=[],this._isCubeData=ae,this._processSizeParameter(_),this.renderPassId=this._renderPassIds[0],this._resizeObserver=Xt.onResizeObservable.add(()=>{}),this._generateMipMaps=!!I,this._doNotChangeAspectRatio=Z,this._renderingManager=new Tx(E),this._renderingManager._useSceneAutoClearSetup=!0,!Le&&(this._renderTargetOptions={generateMipMaps:I,type:re,format:this._format??void 0,samplingMode:this.samplingMode,generateDepthBuffer:_e,generateStencilBuffer:ve,samples:xt,creationFlags:rt,noColorAttachment:Tt,useSRGBBuffer:Lt,colorAttachment:Nt,label:this.name},this.samplingMode===Ki.NEAREST_SAMPLINGMODE&&(this.wrapU=Ki.CLAMP_ADDRESSMODE,this.wrapV=Ki.CLAMP_ADDRESSMODE),He||(ae?(this._renderTarget=E.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions),this.coordinatesMode=Ki.INVCUBIC_MODE,this._textureMatrix=jt.Identity()):this._renderTarget=E.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,xt!==void 0&&(this.samples=xt)))}createDepthStencilTexture(p=0,_=!0,E=!1,I=1,Z=14){this._renderTarget?.createDepthStencilTexture(p,_,E,I,Z)}_releaseRenderPassId(){if(this._scene){const p=this._scene.getEngine();for(let _=0;_<this._renderPassIds.length;++_)p.releaseRenderPassId(this._renderPassIds[_])}this._renderPassIds=[]}_createRenderPassId(){this._releaseRenderPassId();const p=this._scene.getEngine(),_=this._isCubeData?6:this.getRenderLayers()||1;for(let E=0;E<_;++E)this._renderPassIds[E]=p.createRenderPassId(`RenderTargetTexture - ${this.name}#${E}`)}_processSizeParameter(p,_=!0){if(p.ratio){this._sizeRatio=p.ratio;const E=this._getEngine();this._size={width:this._bestReflectionRenderTargetDimension(E.getRenderWidth(),this._sizeRatio),height:this._bestReflectionRenderTargetDimension(E.getRenderHeight(),this._sizeRatio)}}else this._size=p;_&&this._createRenderPassId()}get samples(){return this._renderTarget?.samples??this._samples}set samples(p){this._renderTarget&&(this._samples=this._renderTarget.setSamples(p))}resetRefreshCounter(){this._currentRefreshId=-1}get refreshRate(){return this._refreshRate}set refreshRate(p){this._refreshRate=p,this.resetRefreshCounter()}addPostProcess(p){if(!this._postProcessManager){const _=this.getScene();if(!_)return;this._postProcessManager=new zg(_),this._postProcesses=new Array}this._postProcesses.push(p),this._postProcesses[0].autoClear=!1}clearPostProcesses(p=!1){if(this._postProcesses){if(p)for(const _ of this._postProcesses)_.dispose();this._postProcesses=[]}}removePostProcess(p){if(!this._postProcesses)return;const _=this._postProcesses.indexOf(p);_!==-1&&(this._postProcesses.splice(_,1),this._postProcesses.length>0&&(this._postProcesses[0].autoClear=!1))}_shouldRender(){return this._currentRefreshId===-1?(this._currentRefreshId=1,!0):this.refreshRate===this._currentRefreshId?(this._currentRefreshId=1,!0):(this._currentRefreshId++,!1)}getRenderSize(){return this.getRenderWidth()}getRenderWidth(){return this._size.width?this._size.width:this._size}getRenderHeight(){return this._size.width?this._size.height:this._size}getRenderLayers(){const p=this._size.layers;return p||0}disableRescaling(){this._canRescale=!1}get canRescale(){return this._canRescale}scale(p){const _=Math.max(1,this.getRenderSize()*p);this.resize(_)}getReflectionTextureMatrix(){return this.isCube?this._textureMatrix:super.getReflectionTextureMatrix()}resize(p){const _=this.isCube;this._renderTarget?.dispose(),this._renderTarget=null;const E=this.getScene();E&&(this._processSizeParameter(p,!1),_?this._renderTarget=E.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions):this._renderTarget=E.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,this._renderTargetOptions.samples!==void 0&&(this.samples=this._renderTargetOptions.samples),this.onResizeObservable.hasObservers()&&this.onResizeObservable.notifyObservers(this))}render(p=!1,_=!1){this._render(p,_)}isReadyForRendering(){return this._render(!1,!1,!0)}_render(p=!1,_=!1,E=!1){const I=this.getScene();if(!I)return E;const Z=I.getEngine();if(this.useCameraPostProcesses!==void 0&&(p=this.useCameraPostProcesses),this._waitingRenderList){if(!this.renderListPredicate){this.renderList=[];for(let ve=0;ve<this._waitingRenderList.length;ve++){const Le=this._waitingRenderList[ve],ze=I.getMeshById(Le);ze&&this.renderList.push(ze)}}this._waitingRenderList=void 0}if(this.renderListPredicate){this.renderList?this.renderList.length=0:this.renderList=[];const ve=this.getScene();if(!ve)return E;const Le=ve.meshes;for(let ze=0;ze<Le.length;ze++){const He=Le[ze];this.renderListPredicate(He)&&this.renderList.push(He)}}const re=Z.currentRenderPassId;this.onBeforeBindObservable.notifyObservers(this);const ae=this.activeCamera??I.activeCamera,he=I.activeCamera;ae&&(ae!==I.activeCamera&&(I.setTransformMatrix(ae.getViewMatrix(),ae.getProjectionMatrix(!0)),I.activeCamera=ae),Z.setViewport(ae.rigParent?ae.rigParent.viewport:ae.viewport,this.getRenderWidth(),this.getRenderHeight())),this._defaultRenderListPrepared=!1;let _e=E;if(E){I.getViewMatrix()||I.updateTransformMatrix();const ve=this.is2DArray?this.getRenderLayers():this.isCube?6:1;for(let Le=0;Le<ve&&_e;Le++){let ze=null;const He=this.renderList?this.renderList:I.getActiveMeshes().data,xt=this.renderList?this.renderList.length:I.getActiveMeshes().length;Z.currentRenderPassId=this._renderPassIds[Le],this.onBeforeRenderObservable.notifyObservers(Le),this.getCustomRenderList&&(ze=this.getCustomRenderList(Le,He,xt)),ze||(ze=He),this._doNotChangeAspectRatio||I.updateTransformMatrix(!0);for(let rt=0;rt<ze.length&&_e;++rt){const Tt=ze[rt];if(!(!Tt.isEnabled()||Tt.isBlocked||!Tt.isVisible||!Tt.subMeshes)){if(this.customIsReadyFunction){if(!this.customIsReadyFunction(Tt,this.refreshRate,E)){_e=!1;continue}}else if(!Tt.isReady(!0)){_e=!1;continue}}}this.onAfterRenderObservable.notifyObservers(Le),(this.is2DArray||this.isCube)&&(I.incrementRenderId(),I.resetCachedMaterial())}}else if(this.is2DArray&&!this.isMulti)for(let ve=0;ve<this.getRenderLayers();ve++)this._renderToTarget(0,p,_,ve,ae),I.incrementRenderId(),I.resetCachedMaterial();else if(this.isCube&&!this.isMulti)for(let ve=0;ve<6;ve++)this._renderToTarget(ve,p,_,void 0,ae),I.incrementRenderId(),I.resetCachedMaterial();else this._renderToTarget(0,p,_,void 0,ae);return this.onAfterUnbindObservable.notifyObservers(this),Z.currentRenderPassId=re,he&&(I.activeCamera=he,this.activeCamera&&this.activeCamera!==I.activeCamera&&I.setTransformMatrix(I.activeCamera.getViewMatrix(),I.activeCamera.getProjectionMatrix(!0)),Z.setViewport(I.activeCamera.viewport)),I.resetCachedMaterial(),_e}_bestReflectionRenderTargetDimension(p,_){const I=p*_,Z=ci.NearestPOT(I+128*128/(128+I));return Math.min(ci.FloorPOT(p),Z)}_prepareRenderingManager(p,_,E,I){const Z=this.getScene();if(!Z)return;this._renderingManager.reset();const re=Z.getRenderId();for(let ae=0;ae<_;ae++){const he=p[ae];if(he&&!he.isBlocked){if(this.customIsReadyFunction){if(!this.customIsReadyFunction(he,this.refreshRate,!1)){this.resetRefreshCounter();continue}}else if(!he.isReady(this.refreshRate===0)){this.resetRefreshCounter();continue}if(!he._internalAbstractMeshDataInfo._currentLODIsUpToDate&&Z.activeCamera&&(he._internalAbstractMeshDataInfo._currentLOD=Z.customLODSelector?Z.customLODSelector(he,this.activeCamera||Z.activeCamera):he.getLOD(this.activeCamera||Z.activeCamera),he._internalAbstractMeshDataInfo._currentLODIsUpToDate=!0),!he._internalAbstractMeshDataInfo._currentLOD)continue;let _e=he._internalAbstractMeshDataInfo._currentLOD;_e._preActivateForIntermediateRendering(re);let ve;if(I&&E?ve=(he.layerMask&E.layerMask)===0:ve=!1,he.isEnabled()&&he.isVisible&&he.subMeshes&&!ve&&(_e!==he&&_e._activate(re,!0),he._activate(re,!0)&&he.subMeshes.length)){he.isAnInstance?he._internalAbstractMeshDataInfo._actAsRegularMesh&&(_e=he):_e._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!1,_e._internalAbstractMeshDataInfo._isActiveIntermediate=!0;for(let Le=0;Le<_e.subMeshes.length;Le++){const ze=_e.subMeshes[Le];this._renderingManager.dispatch(ze,_e)}}}}for(let ae=0;ae<Z.particleSystems.length;ae++){const he=Z.particleSystems[ae],_e=he.emitter;!he.isStarted()||!_e||_e.position&&!_e.isEnabled()||this._renderingManager.dispatchParticles(he)}}_bindFrameBuffer(p=0,_=0){const E=this.getScene();if(!E)return;const I=E.getEngine();this._renderTarget&&I.bindFramebuffer(this._renderTarget,this.isCube?p:void 0,void 0,void 0,this.ignoreCameraViewport,0,_)}_unbindFrameBuffer(p,_){this._renderTarget&&p.unBindFramebuffer(this._renderTarget,this.isCube,()=>{this.onAfterRenderObservable.notifyObservers(_)})}_prepareFrame(p,_,E,I){this._postProcessManager?this._prePassEnabled||this._postProcessManager._prepareFrame(this._texture,this._postProcesses):(!I||!p.postProcessManager._prepareFrame(this._texture))&&this._bindFrameBuffer(_,E)}_renderToTarget(p,_,E,I=0,Z=null){const re=this.getScene();if(!re)return;const ae=re.getEngine();if(ae._debugPushGroup?.(`render to face #${p} layer #${I}`,1),this._prepareFrame(re,p,I,_),this.is2DArray?(ae.currentRenderPassId=this._renderPassIds[I],this.onBeforeRenderObservable.notifyObservers(I)):(ae.currentRenderPassId=this._renderPassIds[p],this.onBeforeRenderObservable.notifyObservers(p)),ae.snapshotRendering&&ae.snapshotRenderingMode===1)this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(ae):this.skipInitialClear||ae.clear(this.clearColor||re.clearColor,!0,!0,!0);else{let _e=null;const ve=this.renderList?this.renderList:re.getActiveMeshes().data,Le=this.renderList?this.renderList.length:re.getActiveMeshes().length;this.getCustomRenderList&&(_e=this.getCustomRenderList(this.is2DArray?I:p,ve,Le)),_e?this._prepareRenderingManager(_e,_e.length,Z,this.forceLayerMaskCheck):(this._defaultRenderListPrepared||(this._prepareRenderingManager(ve,Le,Z,!this.renderList||this.forceLayerMaskCheck),this._defaultRenderListPrepared=!0),_e=ve);for(const He of re._beforeRenderTargetClearStage)He.action(this,p,I);this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(ae):this.skipInitialClear||ae.clear(this.clearColor||re.clearColor,!0,!0,!0),this._doNotChangeAspectRatio||re.updateTransformMatrix(!0);for(const He of re._beforeRenderTargetDrawStage)He.action(this,p,I);this._renderingManager.render(this.customRenderFunction,_e,this.renderParticles,this.renderSprites);for(const He of re._afterRenderTargetDrawStage)He.action(this,p,I);const ze=this._texture?.generateMipMaps??!1;this._texture&&(this._texture.generateMipMaps=!1),this._postProcessManager?this._postProcessManager._finalizeFrame(!1,this._renderTarget??void 0,p,this._postProcesses,this.ignoreCameraViewport):_&&re.postProcessManager._finalizeFrame(!1,this._renderTarget??void 0,p);for(const He of re._afterRenderTargetPostProcessStage)He.action(this,p,I);this._texture&&(this._texture.generateMipMaps=ze),this._doNotChangeAspectRatio||re.updateTransformMatrix(!0),E&&Lx.DumpFramebuffer(this.getRenderWidth(),this.getRenderHeight(),ae)}this._unbindFrameBuffer(ae,p),this._texture&&this.isCube&&p===5&&ae.generateMipMapsForCubemap(this._texture),ae._debugPopGroup?.(1)}setRenderingOrder(p,_=null,E=null,I=null){this._renderingManager.setRenderingOrder(p,_,E,I)}setRenderingAutoClearDepthStencil(p,_){this._renderingManager.setRenderingAutoClearDepthStencil(p,_),this._renderingManager._useSceneAutoClearSetup=!1}clone(){const p=this.getSize(),_=new z2(this.name,p,this.getScene(),this._renderTargetOptions.generateMipMaps,this._doNotChangeAspectRatio,this._renderTargetOptions.type,this.isCube,this._renderTargetOptions.samplingMode,this._renderTargetOptions.generateDepthBuffer,this._renderTargetOptions.generateStencilBuffer,void 0,this._renderTargetOptions.format,void 0,this._renderTargetOptions.samples);return _.hasAlpha=this.hasAlpha,_.level=this.level,_.coordinatesMode=this.coordinatesMode,this.renderList&&(_.renderList=this.renderList.slice(0)),_}serialize(){if(!this.name)return null;const p=super.serialize();if(p.renderTargetSize=this.getRenderSize(),p.renderList=[],this.renderList)for(let _=0;_<this.renderList.length;_++)p.renderList.push(this.renderList[_].id);return p}disposeFramebufferObjects(){this._renderTarget?.dispose(!0)}releaseInternalTexture(){this._renderTarget?.releaseTextures(),this._texture=null}dispose(){this.onResizeObservable.clear(),this.onClearObservable.clear(),this.onAfterRenderObservable.clear(),this.onAfterUnbindObservable.clear(),this.onBeforeBindObservable.clear(),this.onBeforeRenderObservable.clear(),this._postProcessManager&&(this._postProcessManager.dispose(),this._postProcessManager=null),this._prePassRenderTarget&&this._prePassRenderTarget.dispose(),this._releaseRenderPassId(),this.clearPostProcesses(!0),this._resizeObserver&&(this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver),this._resizeObserver=null),this.renderList=null;const p=this.getScene();if(!p)return;let _=p.customRenderTargets.indexOf(this);_>=0&&p.customRenderTargets.splice(_,1);for(const E of p.cameras)_=E.customRenderTargets.indexOf(this),_>=0&&E.customRenderTargets.splice(_,1);this._renderTarget?.dispose(),this._renderTarget=null,this._texture=null,super.dispose()}_rebuild(){this.refreshRate===z2.REFRESHRATE_RENDER_ONCE&&(this.refreshRate=z2.REFRESHRATE_RENDER_ONCE),this._postProcessManager&&this._postProcessManager._rebuild()}freeRenderingGroups(){this._renderingManager&&this._renderingManager.freeRenderingGroups()}getViewCount(){return 1}}z2.REFRESHRATE_RENDER_ONCE=0,z2.REFRESHRATE_RENDER_ONEVERYFRAME=1,z2.REFRESHRATE_RENDER_ONEVERYTWOFRAMES=2,Ki._CreateRenderTargetTexture=(pe,p,_,E,I)=>new z2(pe,p,_,E);class XP{constructor(){this._checkCollisions=!1,this._collisionMask=-1,this._collisionGroup=-1,this._surroundingMeshes=null,this._collider=null,this._oldPositionForCollisions=new at(0,0,0),this._diffPositionForCollisions=new at(0,0,0),this._collisionResponse=!0}}class YP{constructor(){this.facetNb=0,this.partitioningSubdivisions=10,this.partitioningBBoxRatio=1.01,this.facetDataEnabled=!1,this.facetParameters={},this.bbSize=at.Zero(),this.subDiv={max:1,X:1,Y:1,Z:1},this.facetDepthSort=!1,this.facetDepthSortEnabled=!1}}class KP{constructor(){this._hasVertexAlpha=!1,this._useVertexColors=!0,this._numBoneInfluencers=4,this._applyFog=!0,this._receiveShadows=!1,this._facetData=new YP,this._visibility=1,this._skeleton=null,this._layerMask=268435455,this._computeBonesUsingShaders=!0,this._isActive=!1,this._onlyForInstances=!1,this._isActiveIntermediate=!1,this._onlyForInstancesIntermediate=!1,this._actAsRegularMesh=!1,this._currentLOD=null,this._currentLODIsUpToDate=!1,this._collisionRetryCount=3,this._morphTargetManager=null,this._renderingGroupId=0,this._bakedVertexAnimationManager=null,this._material=null,this._positions=null,this._pointerOverDisableMeshTesting=!1,this._meshCollisionData=new XP,this._enableDistantPicking=!1,this._rawBoundingInfo=null}}class kx extends Gr{static get BILLBOARDMODE_NONE(){return Gr.BILLBOARDMODE_NONE}static get BILLBOARDMODE_X(){return Gr.BILLBOARDMODE_X}static get BILLBOARDMODE_Y(){return Gr.BILLBOARDMODE_Y}static get BILLBOARDMODE_Z(){return Gr.BILLBOARDMODE_Z}static get BILLBOARDMODE_ALL(){return Gr.BILLBOARDMODE_ALL}static get BILLBOARDMODE_USE_POSITION(){return Gr.BILLBOARDMODE_USE_POSITION}get facetNb(){return this._internalAbstractMeshDataInfo._facetData.facetNb}get partitioningSubdivisions(){return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions}set partitioningSubdivisions(p){this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions=p}get partitioningBBoxRatio(){return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio}set partitioningBBoxRatio(p){this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio=p}get mustDepthSortFacets(){return this._internalAbstractMeshDataInfo._facetData.facetDepthSort}set mustDepthSortFacets(p){this._internalAbstractMeshDataInfo._facetData.facetDepthSort=p}get facetDepthSortFrom(){return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom}set facetDepthSortFrom(p){this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom=p}get collisionRetryCount(){return this._internalAbstractMeshDataInfo._collisionRetryCount}set collisionRetryCount(p){this._internalAbstractMeshDataInfo._collisionRetryCount=p}get isFacetDataEnabled(){return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled}get morphTargetManager(){return this._internalAbstractMeshDataInfo._morphTargetManager}set morphTargetManager(p){this._internalAbstractMeshDataInfo._morphTargetManager!==p&&(this._internalAbstractMeshDataInfo._morphTargetManager=p,this._syncGeometryWithMorphTargetManager())}get bakedVertexAnimationManager(){return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager}set bakedVertexAnimationManager(p){this._internalAbstractMeshDataInfo._bakedVertexAnimationManager!==p&&(this._internalAbstractMeshDataInfo._bakedVertexAnimationManager=p,this._markSubMeshesAsAttributesDirty())}_syncGeometryWithMorphTargetManager(){}_updateNonUniformScalingState(p){return super._updateNonUniformScalingState(p)?(this._markSubMeshesAsMiscDirty(),!0):!1}get rawBoundingInfo(){return this._internalAbstractMeshDataInfo._rawBoundingInfo}set rawBoundingInfo(p){this._internalAbstractMeshDataInfo._rawBoundingInfo=p}set onCollide(p){this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver&&this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver),this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver=this.onCollideObservable.add(p)}set onCollisionPositionChange(p){this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver&&this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver),this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver=this.onCollisionPositionChangeObservable.add(p)}get visibility(){return this._internalAbstractMeshDataInfo._visibility}set visibility(p){if(this._internalAbstractMeshDataInfo._visibility===p)return;const _=this._internalAbstractMeshDataInfo._visibility;this._internalAbstractMeshDataInfo._visibility=p,(_===1&&p!==1||_!==1&&p===1)&&this._markSubMeshesAsDirty(E=>{E.markAsMiscDirty(),E.markAsPrePassDirty()})}get pointerOverDisableMeshTesting(){return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting}set pointerOverDisableMeshTesting(p){this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting=p}get renderingGroupId(){return this._internalAbstractMeshDataInfo._renderingGroupId}set renderingGroupId(p){this._internalAbstractMeshDataInfo._renderingGroupId=p}get material(){return this._internalAbstractMeshDataInfo._material}set material(p){this._internalAbstractMeshDataInfo._material!==p&&(this._internalAbstractMeshDataInfo._material&&this._internalAbstractMeshDataInfo._material.meshMap&&(this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId]=void 0),this._internalAbstractMeshDataInfo._material=p,p&&p.meshMap&&(p.meshMap[this.uniqueId]=this),this.onMaterialChangedObservable.hasObservers()&&this.onMaterialChangedObservable.notifyObservers(this),this.subMeshes&&(this.resetDrawCache(),this._unBindEffect()))}getMaterialForRenderPass(p){return this._internalAbstractMeshDataInfo._materialForRenderPass?.[p]}setMaterialForRenderPass(p,_){this.resetDrawCache(p),this._internalAbstractMeshDataInfo._materialForRenderPass||(this._internalAbstractMeshDataInfo._materialForRenderPass=[]),this._internalAbstractMeshDataInfo._materialForRenderPass[p]=_}get receiveShadows(){return this._internalAbstractMeshDataInfo._receiveShadows}set receiveShadows(p){this._internalAbstractMeshDataInfo._receiveShadows!==p&&(this._internalAbstractMeshDataInfo._receiveShadows=p,this._markSubMeshesAsLightDirty())}get hasVertexAlpha(){return this._internalAbstractMeshDataInfo._hasVertexAlpha}set hasVertexAlpha(p){this._internalAbstractMeshDataInfo._hasVertexAlpha!==p&&(this._internalAbstractMeshDataInfo._hasVertexAlpha=p,this._markSubMeshesAsAttributesDirty(),this._markSubMeshesAsMiscDirty())}get useVertexColors(){return this._internalAbstractMeshDataInfo._useVertexColors}set useVertexColors(p){this._internalAbstractMeshDataInfo._useVertexColors!==p&&(this._internalAbstractMeshDataInfo._useVertexColors=p,this._markSubMeshesAsAttributesDirty())}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(p){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==p&&(this._internalAbstractMeshDataInfo._computeBonesUsingShaders=p,this._markSubMeshesAsAttributesDirty())}get numBoneInfluencers(){return this._internalAbstractMeshDataInfo._numBoneInfluencers}set numBoneInfluencers(p){this._internalAbstractMeshDataInfo._numBoneInfluencers!==p&&(this._internalAbstractMeshDataInfo._numBoneInfluencers=p,this._markSubMeshesAsAttributesDirty())}get applyFog(){return this._internalAbstractMeshDataInfo._applyFog}set applyFog(p){this._internalAbstractMeshDataInfo._applyFog!==p&&(this._internalAbstractMeshDataInfo._applyFog=p,this._markSubMeshesAsMiscDirty())}get enableDistantPicking(){return this._internalAbstractMeshDataInfo._enableDistantPicking}set enableDistantPicking(p){this._internalAbstractMeshDataInfo._enableDistantPicking=p}get layerMask(){return this._internalAbstractMeshDataInfo._layerMask}set layerMask(p){p!==this._internalAbstractMeshDataInfo._layerMask&&(this._internalAbstractMeshDataInfo._layerMask=p,this._resyncLightSources())}get collisionMask(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask}set collisionMask(p){this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask=isNaN(p)?-1:p}get collisionResponse(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse}set collisionResponse(p){this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse=p}get collisionGroup(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup}set collisionGroup(p){this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup=isNaN(p)?-1:p}get surroundingMeshes(){return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes}set surroundingMeshes(p){this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes=p}get lightSources(){return this._lightSources}get _positions(){return null}set skeleton(p){const _=this._internalAbstractMeshDataInfo._skeleton;_&&_.needInitialSkinMatrix&&_._unregisterMeshWithPoseMatrix(this),p&&p.needInitialSkinMatrix&&p._registerMeshWithPoseMatrix(this),this._internalAbstractMeshDataInfo._skeleton=p,this._internalAbstractMeshDataInfo._skeleton||(this._bonesTransformMatrices=null),this._markSubMeshesAsAttributesDirty()}get skeleton(){return this._internalAbstractMeshDataInfo._skeleton}constructor(p,_=null){switch(super(p,_,!1),this._internalAbstractMeshDataInfo=new KP,this._waitingMaterialId=null,this.cullingStrategy=kx.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY,this.onCollideObservable=new Ri,this.onCollisionPositionChangeObservable=new Ri,this.onMaterialChangedObservable=new Ri,this.definedFacingForward=!0,this._occlusionQuery=null,this._renderingGroup=null,this.alphaIndex=Number.MAX_VALUE,this.isVisible=!0,this.isPickable=!0,this.isNearPickable=!1,this.isNearGrabbable=!1,this.showSubMeshesBoundingBox=!1,this.isBlocker=!1,this.enablePointerMoveEvents=!1,this.outlineColor=Rs.Red(),this.outlineWidth=.02,this.overlayColor=Rs.Red(),this.overlayAlpha=.5,this.useOctreeForRenderingSelection=!0,this.useOctreeForPicking=!0,this.useOctreeForCollisions=!0,this.alwaysSelectAsActiveMesh=!1,this.doNotSyncBoundingInfo=!1,this.actionManager=null,this.ellipsoid=new at(.5,1,.5),this.ellipsoidOffset=new at(0,0,0),this.edgesWidth=1,this.edgesColor=new Tr(1,0,0,1),this._edgesRenderer=null,this._masterMesh=null,this._boundingInfo=null,this._boundingInfoIsDirty=!0,this._renderId=0,this._intersectionsInProgress=new Array,this._unIndexed=!1,this._lightSources=new Array,this._waitingData={lods:null,actions:null,freezeWorldMatrix:null},this._bonesTransformMatrices=null,this._transformMatrixTexture=null,this.onRebuildObservable=new Ri,this._onCollisionPositionChange=(E,I,Z=null)=>{I.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length()>ci.CollisionsEpsilon&&this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),Z&&this.onCollideObservable.notifyObservers(Z),this.onCollisionPositionChangeObservable.notifyObservers(this.position)},_=this.getScene(),_.addMesh(this),this._resyncLightSources(),this._uniformBuffer=new qs(this.getScene().getEngine(),void 0,void 0,p,!this.getScene().getEngine().isWebGPU),this._buildUniformLayout(),_.performancePriority){case _l.Aggressive:this.doNotSyncBoundingInfo=!0;case _l.Intermediate:this.alwaysSelectAsActiveMesh=!0,this.isPickable=!1;break}}_buildUniformLayout(){this._uniformBuffer.addUniform("world",16),this._uniformBuffer.addUniform("visibility",1),this._uniformBuffer.create()}transferToEffect(p){const _=this._uniformBuffer;_.updateMatrix("world",p),_.updateFloat("visibility",this._internalAbstractMeshDataInfo._visibility),_.update()}getMeshUniformBuffer(){return this._uniformBuffer}getClassName(){return"AbstractMesh"}toString(p){let _="Name: "+this.name+", isInstance: "+(this.getClassName()!=="InstancedMesh"?"YES":"NO");_+=", # of submeshes: "+(this.subMeshes?this.subMeshes.length:0);const E=this._internalAbstractMeshDataInfo._skeleton;return E&&(_+=", skeleton: "+E.name),p&&(_+=", billboard mode: "+["NONE","X","Y",null,"Z",null,null,"ALL"][this.billboardMode],_+=", freeze wrld mat: "+(this._isWorldMatrixFrozen||this._waitingData.freezeWorldMatrix?"YES":"NO")),_}_getEffectiveParent(){return this._masterMesh&&this.billboardMode!==Gr.BILLBOARDMODE_NONE?this._masterMesh:super._getEffectiveParent()}_getActionManagerForTrigger(p,_=!0){if(this.actionManager&&(_||this.actionManager.isRecursive))if(p){if(this.actionManager.hasSpecificTrigger(p))return this.actionManager}else return this.actionManager;return this.parent?this.parent._getActionManagerForTrigger(p,!1):null}_rebuild(p=!1){if(this.onRebuildObservable.notifyObservers(this),this._occlusionQuery!==null&&(this._occlusionQuery=null),!!this.subMeshes){for(const _ of this.subMeshes)_._rebuild();this.resetDrawCache()}}_resyncLightSources(){this._lightSources.length=0;for(const p of this.getScene().lights)p.isEnabled()&&p.canAffectMesh(this)&&this._lightSources.push(p);this._markSubMeshesAsLightDirty()}_resyncLightSource(p){const _=p.isEnabled()&&p.canAffectMesh(this),E=this._lightSources.indexOf(p);let I=!1;if(E===-1){if(!_)return;this._lightSources.push(p)}else{if(_)return;I=!0,this._lightSources.splice(E,1)}this._markSubMeshesAsLightDirty(I)}_unBindEffect(){for(const p of this.subMeshes)p.setEffect(null)}_removeLightSource(p,_){const E=this._lightSources.indexOf(p);E!==-1&&(this._lightSources.splice(E,1),this._markSubMeshesAsLightDirty(_))}_markSubMeshesAsDirty(p){if(this.subMeshes)for(const _ of this.subMeshes)for(let E=0;E<_._drawWrappers.length;++E){const I=_._drawWrappers[E];!I||!I.defines||!I.defines.markAllAsDirty||p(I.defines)}}_markSubMeshesAsLightDirty(p=!1){this._markSubMeshesAsDirty(_=>_.markAsLightDirty(p))}_markSubMeshesAsAttributesDirty(){this._markSubMeshesAsDirty(p=>p.markAsAttributesDirty())}_markSubMeshesAsMiscDirty(){this._markSubMeshesAsDirty(p=>p.markAsMiscDirty())}markAsDirty(p){return this._currentRenderId=Number.MAX_VALUE,this._isDirty=!0,this}resetDrawCache(p){if(this.subMeshes)for(const _ of this.subMeshes)_.resetDrawCache(p)}get isBlocked(){return!1}getLOD(p){return this}getTotalVertices(){return 0}getTotalIndices(){return 0}getIndices(){return null}getVerticesData(p){return null}setVerticesData(p,_,E,I){return this}updateVerticesData(p,_,E,I){return this}setIndices(p,_){return this}isVerticesDataPresent(p){return!1}getBoundingInfo(){return this._masterMesh?this._masterMesh.getBoundingInfo():(this._boundingInfoIsDirty&&(this._boundingInfoIsDirty=!1,this._updateBoundingInfo()),this._boundingInfo)}getRawBoundingInfo(){return this.rawBoundingInfo??this.getBoundingInfo()}setBoundingInfo(p){return this._boundingInfo=p,this}get hasBoundingInfo(){return this._boundingInfo!==null}buildBoundingInfo(p,_,E){return this._boundingInfo=new uo(p,_,E),this._boundingInfo}normalizeToUnitCube(p=!0,_=!1,E){return super.normalizeToUnitCube(p,_,E)}get useBones(){return this.skeleton&&this.getScene().skeletonsEnabled&&this.isVerticesDataPresent(ut.MatricesIndicesKind)&&this.isVerticesDataPresent(ut.MatricesWeightsKind)}_preActivate(){}_preActivateForIntermediateRendering(p){}_activate(p,_){return this._renderId=p,!0}_postActivate(){}_freeze(){}_unFreeze(){}getWorldMatrix(){return this._masterMesh&&this.billboardMode===Gr.BILLBOARDMODE_NONE?this._masterMesh.getWorldMatrix():super.getWorldMatrix()}_getWorldMatrixDeterminant(){return this._masterMesh?this._masterMesh._getWorldMatrixDeterminant():super._getWorldMatrixDeterminant()}get isAnInstance(){return!1}get hasInstances(){return!1}get hasThinInstances(){return!1}movePOV(p,_,E){return this.position.addInPlace(this.calcMovePOV(p,_,E)),this}calcMovePOV(p,_,E){const I=new jt;(this.rotationQuaternion?this.rotationQuaternion:us.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z)).toRotationMatrix(I);const re=at.Zero(),ae=this.definedFacingForward?-1:1;return at.TransformCoordinatesFromFloatsToRef(p*ae,_,E*ae,I,re),re}rotatePOV(p,_,E){return this.rotation.addInPlace(this.calcRotatePOV(p,_,E)),this}calcRotatePOV(p,_,E){const I=this.definedFacingForward?1:-1;return new at(p*I,_,E*I)}refreshBoundingInfo(p=!1,_=!1){return this._boundingInfo&&this._boundingInfo.isLocked?this:(this._refreshBoundingInfo(this._getPositionData(p,_),null),this)}_refreshBoundingInfo(p,_){if(p){const E=pb(p,0,this.getTotalVertices(),_);this._boundingInfo?this._boundingInfo.reConstruct(E.minimum,E.maximum):this._boundingInfo=new uo(E.minimum,E.maximum)}if(this.subMeshes)for(let E=0;E<this.subMeshes.length;E++)this.subMeshes[E].refreshBoundingInfo(p);this._updateBoundingInfo()}_getData(p=!1,_=!1,E,I=ut.PositionKind){if(E=E??this.getVerticesData(I).slice(),E&&_&&this.morphTargetManager){let Z=0,re=0;for(let ae=0;ae<E.length;ae++){let he=E[ae];for(let _e=0;_e<this.morphTargetManager.numTargets;_e++){const ve=this.morphTargetManager.getTarget(_e),Le=ve.influence;if(Le!==0){let ze=null;switch(I){case ut.PositionKind:ze=ve.getPositions();break;case ut.NormalKind:ze=ve.getNormals();break;case ut.TangentKind:ze=ve.getTangents();break;case ut.UVKind:ze=ve.getUVs();break}ze&&(he+=(ze[ae]-E[ae])*Le)}}if(E[ae]=he,Z++,I===ut.PositionKind&&this._positions&&Z===3){Z=0;const _e=re*3;this._positions[re++].copyFromFloats(E[_e],E[_e+1],E[_e+2])}}}if(E&&p&&this.skeleton){const Z=this.getVerticesData(ut.MatricesIndicesKind),re=this.getVerticesData(ut.MatricesWeightsKind);if(re&&Z){const ae=this.numBoneInfluencers>4,he=ae?this.getVerticesData(ut.MatricesIndicesExtraKind):null,_e=ae?this.getVerticesData(ut.MatricesWeightsExtraKind):null,ve=this.skeleton.getTransformMatrices(this),Le=ui.Vector3[0],ze=ui.Matrix[0],He=ui.Matrix[1];let xt=0;for(let rt=0;rt<E.length;rt+=3,xt+=4){ze.reset();let Tt,Lt;for(Tt=0;Tt<4;Tt++)Lt=re[xt+Tt],Lt>0&&(jt.FromFloat32ArrayToRefScaled(ve,Math.floor(Z[xt+Tt]*16),Lt,He),ze.addToSelf(He));if(ae)for(Tt=0;Tt<4;Tt++)Lt=_e[xt+Tt],Lt>0&&(jt.FromFloat32ArrayToRefScaled(ve,Math.floor(he[xt+Tt]*16),Lt,He),ze.addToSelf(He));I===ut.NormalKind?at.TransformNormalFromFloatsToRef(E[rt],E[rt+1],E[rt+2],ze,Le):at.TransformCoordinatesFromFloatsToRef(E[rt],E[rt+1],E[rt+2],ze,Le),Le.toArray(E,rt),I===ut.PositionKind&&this._positions&&this._positions[rt/3].copyFrom(Le)}}}return E}getNormalsData(p=!1,_=!1){return this._getData(p,_,null,ut.NormalKind)}getPositionData(p=!1,_=!1,E){return this._getData(p,_,E,ut.PositionKind)}_getPositionData(p,_){let E=this.getVerticesData(ut.PositionKind);if(this._internalAbstractMeshDataInfo._positions&&(this._internalAbstractMeshDataInfo._positions=null),E&&(p&&this.skeleton||_&&this.morphTargetManager)){if(E=E.slice(),this._generatePointsArray(),this._positions){const I=this._positions;this._internalAbstractMeshDataInfo._positions=new Array(I.length);for(let Z=0;Z<I.length;Z++)this._internalAbstractMeshDataInfo._positions[Z]=I[Z]?.clone()||new at}return this.getPositionData(p,_,E)}return E}_updateBoundingInfo(){return this._boundingInfo?this._boundingInfo.update(this.worldMatrixFromCache):this._boundingInfo=new uo(at.Zero(),at.Zero(),this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}_updateSubMeshesBoundingInfo(p){if(!this.subMeshes)return this;const _=this.subMeshes.length;for(let E=0;E<_;E++){const I=this.subMeshes[E];(_>1||!I.IsGlobal)&&I.updateBoundingInfo(p)}return this}_afterComputeWorldMatrix(){this.doNotSyncBoundingInfo||(this._boundingInfoIsDirty=!0)}isInFrustum(p){return this.getBoundingInfo().isInFrustum(p,this.cullingStrategy)}isCompletelyInFrustum(p){return this.getBoundingInfo().isCompletelyInFrustum(p)}intersectsMesh(p,_=!1,E){const I=this.getBoundingInfo(),Z=p.getBoundingInfo();if(I.intersects(Z,_))return!0;if(E){for(const re of this.getChildMeshes())if(re.intersectsMesh(p,_,!0))return!0}return!1}intersectsPoint(p){return this.getBoundingInfo().intersectsPoint(p)}get checkCollisions(){return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions}set checkCollisions(p){this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions=p}get collider(){return this._internalAbstractMeshDataInfo._meshCollisionData._collider}moveWithCollisions(p){this.getAbsolutePosition().addToRef(this.ellipsoidOffset,this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);const E=this.getScene().collisionCoordinator;return this._internalAbstractMeshDataInfo._meshCollisionData._collider||(this._internalAbstractMeshDataInfo._meshCollisionData._collider=E.createCollider()),this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius=this.ellipsoid,E.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,p,this._internalAbstractMeshDataInfo._meshCollisionData._collider,this.collisionRetryCount,this,this._onCollisionPositionChange,this.uniqueId),this}_collideForSubMesh(p,_,E){if(this._generatePointsArray(),!this._positions)return this;if(!p._lastColliderWorldVertices||!p._lastColliderTransformMatrix.equals(_)){p._lastColliderTransformMatrix=_.clone(),p._lastColliderWorldVertices=[],p._trianglePlanes=[];const I=p.verticesStart,Z=p.verticesStart+p.verticesCount;for(let re=I;re<Z;re++)p._lastColliderWorldVertices.push(at.TransformCoordinates(this._positions[re],_))}return E._collide(p._trianglePlanes,p._lastColliderWorldVertices,this.getIndices(),p.indexStart,p.indexStart+p.indexCount,p.verticesStart,!!p.getMaterial(),this,this._shouldConvertRHS(),p.getMaterial()?.fillMode===7),this}_processCollisionsForSubMeshes(p,_){const E=this._scene.getCollidingSubMeshCandidates(this,p),I=E.length;for(let Z=0;Z<I;Z++){const re=E.data[Z];I>1&&!re._checkCollision(p)||this._collideForSubMesh(re,_,p)}return this}_shouldConvertRHS(){return!1}_checkCollision(p){if(!this.getBoundingInfo()._checkCollision(p))return this;const _=ui.Matrix[0],E=ui.Matrix[1];return jt.ScalingToRef(1/p._radius.x,1/p._radius.y,1/p._radius.z,_),this.worldMatrixFromCache.multiplyToRef(_,E),this._processCollisionsForSubMeshes(p,E),this}_generatePointsArray(){return!1}intersects(p,_,E,I=!1,Z,re=!1){const ae=new Wp,he=this.getClassName(),_e=he==="InstancedLinesMesh"||he==="LinesMesh"||he==="GreasedLineMesh"?this.intersectionThreshold:0,ve=this.getBoundingInfo();if(!this.subMeshes||!re&&(!p.intersectsSphere(ve.boundingSphere,_e)||!p.intersectsBox(ve.boundingBox,_e)))return ae;if(I)return ae.hit=!re,ae.pickedMesh=re?null:this,ae.distance=re?0:at.Distance(p.origin,ve.boundingSphere.center),ae.subMeshId=0,ae;if(!this._generatePointsArray())return ae;let Le=null;const ze=this._scene.getIntersectingSubMeshCandidates(this,p),He=ze.length;let xt=!1;for(let rt=0;rt<He;rt++){const Lt=ze.data[rt].getMaterial();if(Lt&&(Lt.fillMode==7||Lt.fillMode==0||Lt.fillMode==1||Lt.fillMode==2||Lt.fillMode==4)){xt=!0;break}}if(!xt)return ae.hit=!0,ae.pickedMesh=this,ae.distance=at.Distance(p.origin,ve.boundingSphere.center),ae.subMeshId=-1,ae;for(let rt=0;rt<He;rt++){const Tt=ze.data[rt];if(He>1&&!re&&!Tt.canIntersects(p))continue;const Lt=Tt.intersects(p,this._positions,this.getIndices(),_,E);if(Lt&&(_||!Le||Lt.distance<Le.distance)&&(Le=Lt,Le.subMeshId=rt,_))break}if(Le){const rt=Z??this.getWorldMatrix(),Tt=ui.Vector3[0],Lt=ui.Vector3[1];at.TransformCoordinatesToRef(p.origin,rt,Tt),p.direction.scaleToRef(Le.distance,Lt);const qt=at.TransformNormal(Lt,rt).addInPlace(Tt);return ae.hit=!0,ae.distance=at.Distance(Tt,qt),ae.pickedPoint=qt,ae.pickedMesh=this,ae.bu=Le.bu||0,ae.bv=Le.bv||0,ae.subMeshFaceId=Le.faceId,ae.faceId=Le.faceId+ze.data[Le.subMeshId].indexStart/(this.getClassName().indexOf("LinesMesh")!==-1?2:3),ae.subMeshId=Le.subMeshId,ae}return ae}clone(p,_,E){return null}releaseSubMeshes(){if(this.subMeshes)for(;this.subMeshes.length;)this.subMeshes[0].dispose();else this.subMeshes=[];return this}dispose(p,_=!1){let E;const I=this.getScene();for(this._scene.useMaterialMeshMap&&this._internalAbstractMeshDataInfo._material&&this._internalAbstractMeshDataInfo._material.meshMap&&(this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId]=void 0),I.freeActiveMeshes(),I.freeRenderingGroups(),I.renderingManager.maintainStateBetweenFrames&&I.renderingManager.restoreDispachedFlags(),this.actionManager!==void 0&&this.actionManager!==null&&(this._scene.meshes.some(ae=>ae!==this&&ae.actionManager===this.actionManager)||this.actionManager.dispose(),this.actionManager=null),this._internalAbstractMeshDataInfo._skeleton=null,this._transformMatrixTexture&&(this._transformMatrixTexture.dispose(),this._transformMatrixTexture=null),E=0;E<this._intersectionsInProgress.length;E++){const ae=this._intersectionsInProgress[E],he=ae._intersectionsInProgress.indexOf(this);ae._intersectionsInProgress.splice(he,1)}this._intersectionsInProgress.length=0,I.lights.forEach(ae=>{let he=ae.includedOnlyMeshes.indexOf(this);he!==-1&&ae.includedOnlyMeshes.splice(he,1),he=ae.excludedMeshes.indexOf(this),he!==-1&&ae.excludedMeshes.splice(he,1);const _e=ae.getShadowGenerators();if(_e){const ve=_e.values();for(let Le=ve.next();Le.done!==!0;Le=ve.next()){const He=Le.value.getShadowMap();He&&He.renderList&&(he=He.renderList.indexOf(this),he!==-1&&He.renderList.splice(he,1))}}}),(this.getClassName()!=="InstancedMesh"||this.getClassName()!=="InstancedLinesMesh")&&this.releaseSubMeshes();const re=I.getEngine();if(this._occlusionQuery!==null&&(this.isOcclusionQueryInProgress=!1,re.deleteQuery(this._occlusionQuery),this._occlusionQuery=null),re.wipeCaches(),I.removeMesh(this),this._parentContainer){const ae=this._parentContainer.meshes.indexOf(this);ae>-1&&this._parentContainer.meshes.splice(ae,1),this._parentContainer=null}if(_&&this.material&&(this.material.getClassName()==="MultiMaterial"?this.material.dispose(!1,!0,!0):this.material.dispose(!1,!0)),!p)for(E=0;E<I.particleSystems.length;E++)I.particleSystems[E].emitter===this&&(I.particleSystems[E].dispose(),E--);this._internalAbstractMeshDataInfo._facetData.facetDataEnabled&&this.disableFacetData(),this._uniformBuffer.dispose(),this.onAfterWorldMatrixUpdateObservable.clear(),this.onCollideObservable.clear(),this.onCollisionPositionChangeObservable.clear(),this.onRebuildObservable.clear(),super.dispose(p,_)}addChild(p,_=!1){return p.setParent(this,_),this}removeChild(p,_=!1){return p.setParent(null,_),this}_initFacetData(){const p=this._internalAbstractMeshDataInfo._facetData;p.facetNormals||(p.facetNormals=[]),p.facetPositions||(p.facetPositions=[]),p.facetPartitioning||(p.facetPartitioning=new Array),p.facetNb=this.getIndices().length/3|0,p.partitioningSubdivisions=p.partitioningSubdivisions?p.partitioningSubdivisions:10,p.partitioningBBoxRatio=p.partitioningBBoxRatio?p.partitioningBBoxRatio:1.01;for(let _=0;_<p.facetNb;_++)p.facetNormals[_]=at.Zero(),p.facetPositions[_]=at.Zero();return p.facetDataEnabled=!0,this}updateFacetData(){const p=this._internalAbstractMeshDataInfo._facetData;p.facetDataEnabled||this._initFacetData();const _=this.getVerticesData(ut.PositionKind),E=this.getIndices(),I=this.getVerticesData(ut.NormalKind),Z=this.getBoundingInfo();if(p.facetDepthSort&&!p.facetDepthSortEnabled){if(p.facetDepthSortEnabled=!0,E instanceof Uint16Array)p.depthSortedIndices=new Uint16Array(E);else if(E instanceof Uint32Array)p.depthSortedIndices=new Uint32Array(E);else{let ae=!1;for(let he=0;he<E.length;he++)if(E[he]>65535){ae=!0;break}ae?p.depthSortedIndices=new Uint32Array(E):p.depthSortedIndices=new Uint16Array(E)}if(p.facetDepthSortFunction=function(ae,he){return he.sqDistance-ae.sqDistance},!p.facetDepthSortFrom){const ae=this.getScene().activeCamera;p.facetDepthSortFrom=ae?ae.position:at.Zero()}p.depthSortedFacets=[];for(let ae=0;ae<p.facetNb;ae++){const he={ind:ae*3,sqDistance:0};p.depthSortedFacets.push(he)}p.invertedMatrix=jt.Identity(),p.facetDepthSortOrigin=at.Zero()}p.bbSize.x=Z.maximum.x-Z.minimum.x>ns?Z.maximum.x-Z.minimum.x:ns,p.bbSize.y=Z.maximum.y-Z.minimum.y>ns?Z.maximum.y-Z.minimum.y:ns,p.bbSize.z=Z.maximum.z-Z.minimum.z>ns?Z.maximum.z-Z.minimum.z:ns;let re=p.bbSize.x>p.bbSize.y?p.bbSize.x:p.bbSize.y;if(re=re>p.bbSize.z?re:p.bbSize.z,p.subDiv.max=p.partitioningSubdivisions,p.subDiv.X=Math.floor(p.subDiv.max*p.bbSize.x/re),p.subDiv.Y=Math.floor(p.subDiv.max*p.bbSize.y/re),p.subDiv.Z=Math.floor(p.subDiv.max*p.bbSize.z/re),p.subDiv.X=p.subDiv.X<1?1:p.subDiv.X,p.subDiv.Y=p.subDiv.Y<1?1:p.subDiv.Y,p.subDiv.Z=p.subDiv.Z<1?1:p.subDiv.Z,p.facetParameters.facetNormals=this.getFacetLocalNormals(),p.facetParameters.facetPositions=this.getFacetLocalPositions(),p.facetParameters.facetPartitioning=this.getFacetLocalPartitioning(),p.facetParameters.bInfo=Z,p.facetParameters.bbSize=p.bbSize,p.facetParameters.subDiv=p.subDiv,p.facetParameters.ratio=this.partitioningBBoxRatio,p.facetParameters.depthSort=p.facetDepthSort,p.facetDepthSort&&p.facetDepthSortEnabled&&(this.computeWorldMatrix(!0),this._worldMatrix.invertToRef(p.invertedMatrix),at.TransformCoordinatesToRef(p.facetDepthSortFrom,p.invertedMatrix,p.facetDepthSortOrigin),p.facetParameters.distanceTo=p.facetDepthSortOrigin),p.facetParameters.depthSortedFacets=p.depthSortedFacets,I&&Xr.ComputeNormals(_,E,I,p.facetParameters),p.facetDepthSort&&p.facetDepthSortEnabled){p.depthSortedFacets.sort(p.facetDepthSortFunction);const ae=p.depthSortedIndices.length/3|0;for(let he=0;he<ae;he++){const _e=p.depthSortedFacets[he].ind;p.depthSortedIndices[he*3]=E[_e],p.depthSortedIndices[he*3+1]=E[_e+1],p.depthSortedIndices[he*3+2]=E[_e+2]}this.updateIndices(p.depthSortedIndices,void 0,!0)}return this}getFacetLocalNormals(){const p=this._internalAbstractMeshDataInfo._facetData;return p.facetNormals||this.updateFacetData(),p.facetNormals}getFacetLocalPositions(){const p=this._internalAbstractMeshDataInfo._facetData;return p.facetPositions||this.updateFacetData(),p.facetPositions}getFacetLocalPartitioning(){const p=this._internalAbstractMeshDataInfo._facetData;return p.facetPartitioning||this.updateFacetData(),p.facetPartitioning}getFacetPosition(p){const _=at.Zero();return this.getFacetPositionToRef(p,_),_}getFacetPositionToRef(p,_){const E=this.getFacetLocalPositions()[p],I=this.getWorldMatrix();return at.TransformCoordinatesToRef(E,I,_),this}getFacetNormal(p){const _=at.Zero();return this.getFacetNormalToRef(p,_),_}getFacetNormalToRef(p,_){const E=this.getFacetLocalNormals()[p];return at.TransformNormalToRef(E,this.getWorldMatrix(),_),this}getFacetsAtLocalCoordinates(p,_,E){const I=this.getBoundingInfo(),Z=this._internalAbstractMeshDataInfo._facetData,re=Math.floor((p-I.minimum.x*Z.partitioningBBoxRatio)*Z.subDiv.X*Z.partitioningBBoxRatio/Z.bbSize.x),ae=Math.floor((_-I.minimum.y*Z.partitioningBBoxRatio)*Z.subDiv.Y*Z.partitioningBBoxRatio/Z.bbSize.y),he=Math.floor((E-I.minimum.z*Z.partitioningBBoxRatio)*Z.subDiv.Z*Z.partitioningBBoxRatio/Z.bbSize.z);return re<0||re>Z.subDiv.max||ae<0||ae>Z.subDiv.max||he<0||he>Z.subDiv.max?null:Z.facetPartitioning[re+Z.subDiv.max*ae+Z.subDiv.max*Z.subDiv.max*he]}getClosestFacetAtCoordinates(p,_,E,I,Z=!1,re=!0){const ae=this.getWorldMatrix(),he=ui.Matrix[5];ae.invertToRef(he);const _e=ui.Vector3[8];at.TransformCoordinatesFromFloatsToRef(p,_,E,he,_e);const ve=this.getClosestFacetAtLocalCoordinates(_e.x,_e.y,_e.z,I,Z,re);return I&&at.TransformCoordinatesFromFloatsToRef(I.x,I.y,I.z,ae,I),ve}getClosestFacetAtLocalCoordinates(p,_,E,I,Z=!1,re=!0){let ae=null,he=0,_e=0,ve=0,Le=0,ze=0,He=0,xt=0,rt=0;const Tt=this.getFacetLocalPositions(),Lt=this.getFacetLocalNormals(),Nt=this.getFacetsAtLocalCoordinates(p,_,E);if(!Nt)return null;let qt=Number.MAX_VALUE,Xt=qt,zt,Gt,xi;for(let Gi=0;Gi<Nt.length;Gi++)zt=Nt[Gi],Gt=Lt[zt],xi=Tt[zt],Le=(p-xi.x)*Gt.x+(_-xi.y)*Gt.y+(E-xi.z)*Gt.z,(!Z||Z&&re&&Le>=0||Z&&!re&&Le<=0)&&(Le=Gt.x*xi.x+Gt.y*xi.y+Gt.z*xi.z,ze=-(Gt.x*p+Gt.y*_+Gt.z*E-Le)/(Gt.x*Gt.x+Gt.y*Gt.y+Gt.z*Gt.z),He=p+Gt.x*ze,xt=_+Gt.y*ze,rt=E+Gt.z*ze,he=He-p,_e=xt-_,ve=rt-E,Xt=he*he+_e*_e+ve*ve,Xt<qt&&(qt=Xt,ae=zt,I&&(I.x=He,I.y=xt,I.z=rt)));return ae}getFacetDataParameters(){return this._internalAbstractMeshDataInfo._facetData.facetParameters}disableFacetData(){const p=this._internalAbstractMeshDataInfo._facetData;return p.facetDataEnabled&&(p.facetDataEnabled=!1,p.facetPositions=[],p.facetNormals=[],p.facetPartitioning=new Array,p.facetParameters=null,p.depthSortedIndices=new Uint32Array(0)),this}updateIndices(p,_,E=!1){return this}createNormals(p){const _=this.getVerticesData(ut.PositionKind),E=this.getIndices();let I;return this.isVerticesDataPresent(ut.NormalKind)?I=this.getVerticesData(ut.NormalKind):I=[],Xr.ComputeNormals(_,E,I,{useRightHandedSystem:this.getScene().useRightHandedSystem}),this.setVerticesData(ut.NormalKind,I,p),this}alignWithNormal(p,_){_||(_=Gc.Y);const E=ui.Vector3[0],I=ui.Vector3[1];return at.CrossToRef(_,p,I),at.CrossToRef(p,I,E),this.rotationQuaternion?us.RotationQuaternionFromAxisToRef(E,p,I,this.rotationQuaternion):at.RotationFromAxisToRef(E,p,I,this.rotation),this}_checkOcclusionQuery(){return!1}disableEdgesRendering(){throw ur("EdgesRenderer")}enableEdgesRendering(p,_,E){throw ur("EdgesRenderer")}getConnectedParticleSystems(){return this._scene.particleSystems.filter(p=>p.emitter===this)}}kx.OCCLUSION_TYPE_NONE=0,kx.OCCLUSION_TYPE_OPTIMISTIC=1,kx.OCCLUSION_TYPE_STRICT=2,kx.OCCLUSION_ALGORITHM_TYPE_ACCURATE=0,kx.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE=1,kx.CULLINGSTRATEGY_STANDARD=0,kx.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY=1,kx.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION=2,kx.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY=3,Gs("BABYLON.AbstractMesh",kx);class x3 extends null{constructor(p,_,E){super({container:p,mode:_,layerCount:2,mirror:E});const I=this.canvas.layers[1];this.renderer=new l(I,!0,{alpha:!0,preserveDrawingBuffer:!0},!0);const Z=window.devicePixelRatio;this.renderer.setSize(I.clientWidth*Z,I.clientHeight*Z),this.canvas.on("resize",()=>{this.renderer.setSize(I.clientWidth*Z,I.clientHeight*Z)}),this.scene=new S(this.renderer),this.scene.useRightHandedSystem=!0,this.scene.clearColor=new L(0,0,0,0),this.camera=new s("camera",new z(0,0,0),this.scene),this.camera.rotationQuaternion=new e(1,0,0,0),this.camera.fov=this.cameraAngle,this.camera.minZ=.02,this.camera.maxZ=20}updateScene(){var p;(p=this.scene)==null||p.render()}dispose(){var p;this.renderer.dispose(),this.camera.dispose(),(p=this.scene)==null||p.dispose(),super.dispose()}setupCamera(p,_){super.setupCamera(p,_),this.camera.fov=this.cameraAngle,this.camera.getProjectionMatrix(!0)}}class jP extends Mn{}class l3 extends null{}class h3 extends null{}class s_ extends Ui{constructor(p,_,E){super({container:p,mode:_,layerCount:1,mirror:E});const I=this.canvas.layers[0];this.renderer=new ci(I,!0,{alpha:!0,preserveDrawingBuffer:!0},!0);const Z=window.devicePixelRatio;this.renderer.setSize(I.clientWidth*Z,I.clientHeight*Z),this.canvas.on("resize",()=>{this.renderer.setSize(I.clientWidth*Z,I.clientHeight*Z)}),this.scene=new U0(this.renderer),this.scene.useRightHandedSystem=!0,this.scene.clearColor=new Tr(0,0,0,0),this.camera=new Hg("camera",new at(0,0,0),this.scene),this.camera.rotationQuaternion=new us(1,0,0,0),this.camera.fov=this.cameraAngle,this.camera.minZ=.02,this.camera.maxZ=20,this.layer=new _O("video",null,this.scene,!0)}updateVideo(p){const{shader:_,shaderCtx:E}=this;if(!(!this.current||!_||!E))return _.process([this.current],{flip:[1]}),hi.prototype.updateVideo.call(this,p)}updateScene(){var p;(p=this.scene)==null||p.render()}dispose(){var p,_,E,I,Z;(E=(_=(p=this.layer.texture)==null?void 0:p.getInternalTexture())==null?void 0:_._hardwareTexture)==null||E.reset(),(I=this.layer.texture)==null||I.dispose(),this.layer.dispose(),this.camera.dispose(),(Z=this.scene)==null||Z.dispose(),this.renderer.dispose(),super.dispose()}setupVideo(p,_){var E,I,Z,re;hi.prototype.setupVideo.call(this,p,_);const{input:ae,shader:he,videoSize:_e}=this;(Z=(I=(E=this.layer.texture)==null?void 0:E.getInternalTexture())==null?void 0:I._hardwareTexture)==null||Z.reset(),(re=this.layer.texture)==null||re.dispose(),this.layer.texture=null,ae?.resize(_e),he?.resize(_e);const ve=he?.output();ve&&(this.layer.texture=new na(this.scene,this.renderer.wrapWebGLTexture(ve)))}setupCamera(p,_){var E;super.setupCamera(p,_),this.camera.fov=this.cameraAngle,(E=this.scene)==null||E.updateTransformMatrix()}}class c3 extends null{}class u3 extends null{}class qP extends s_{}class p3 extends null{}class _3 extends null{constructor(p,_=!1){super(),this.node=p,this.shapeScale=_}async update(p,_){var E;if(!this.loaded||!this.node)return;const I=(E=p.faces[0])==null?void 0:E.transform;if(!I)return this.node.setEnabled(!1),super.update(p,_);const Z=z.FromArray(I.translation),re=new z().setAll(I.scale),ae=z.FromArray(I.shapeScale).scale(I.scale),he=e.FromArray(I.rotation);return this.node.setEnabled(!0),this.node.rotationQuaternion=he,this.node.position=Z,this.node.scaling=this.shapeScale?ae:re,super.update(p,_)}setNode(p){this.node=p}}class T3 extends null{constructor(p,_=0,E=!1){super(),this.node=p,this.facePoint=_,this.shapeScale=E}async update(p,_){if(!this.loaded||!this.node)return;const{transform:E=void 0,metric:I=void 0}=p.faces[0]||{};if(!E||!I)return this.node.setEnabled(!1),super.update(p,_);const Z=z.FromArray(I[this.facePoint]),re=new z().setAll(E.scale),ae=z.FromArray(E.shapeScale).scale(E.scale),he=e.FromArray(E.rotation);return this.node.setEnabled(!0),this.node.rotationQuaternion=he,this.node.position=Z,this.node.scaling=this.shapeScale?ae:re,super.update(p,_)}setNode(p){this.node=p}}class v3 extends null{constructor(p){super(),this.mesh=p,this.pointCont=k.length}async load(p){this.loaded||(await super.load(p),await this.setMesh(this.mesh))}async update(p,_){var E;if(!this.loaded||!this.mesh)return;const I=(E=p.faces[0])==null?void 0:E.metric;return I?(this.mesh.setEnabled(!0),this.mesh.updateVerticesData(u.PositionKind,I.slice(0,this.pointCont).flat()),super.update(p,_)):(this.mesh.setEnabled(!1),super.update(p,_))}async setMesh(p){if(delete this.mesh,this.mesh=p,!(!this.loaded||!p)){var _=new i;_.positions=k.flat(),_.indices=a.flat(),_.uvs=v.flat(),_.normals=[],i.ComputeNormals(_.positions,_.indices,_.normals),_.applyToMesh(p,!0),p.renderingGroupId=1}}}var $P=Object.defineProperty,rw=Object.defineProperties,nw=Object.getOwnPropertyDescriptors,_T=Object.getOwnPropertySymbols,aw=Object.prototype.hasOwnProperty,xw=Object.prototype.propertyIsEnumerable,TT=(pe,p,_)=>p in pe?$P(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,vT=(pe,p)=>{for(var _ in p||(p={}))aw.call(p,_)&&TT(pe,_,p[_]);if(_T)for(var _ of _T(p))xw.call(p,_)&&TT(pe,_,p[_]);return pe},RT=(pe,p)=>rw(pe,nw(p));const MT=null,Yp=(pe,p)=>D(pe,p),lw=pe=>Yp(pe,MT),r_=null,hw=null;class R3 extends null{constructor(p,_={spineCurve:1,pelvisDZ:.01}){super(),this.node=p,this.tune=_,this.nodeOrigin={position:new z(0,0,-1),rotation:new e},this.cameraRatio=1920/1080,this.cameraAngle=10/180*Math.PI,this.alignScore=.9,this.alignVisibility=.9}async load(p){this.loaded||(await super.load(p),this.setNode(this.node))}unload(){this.loaded&&(delete this.node,delete this.skeletonNodes,delete this.skeleton,delete this.spineCurve,super.unload())}setNode(p){var _,E;if(delete this.skeletonNodes,delete this.skeleton,delete this.skeletonSizes,delete this.spineCurve,this.node=p,!this.loaded||!p)return;this.skeleton=((_=p.getChildMeshes(!1).find(vs=>vs.skeleton))==null?void 0:_.skeleton)||void 0;const I=(E=this.skeleton)==null?void 0:E.bones;if(!I)return;const Z={root:"joint",pelvis:"pelvis",spine:"spine",spine1:"spine1",spine2:"spine2",spine3:"spine3",neck:"neck",neck1:"neck1",head:"head",headEnd:"head_tip",shoulderL:"left_shoulder",shoulderR:"right_shoulder",armL:"left_arm",armR:"right_arm",armMidL:"left_arm_middle",armMidR:"right_arm_middle",forearmL:"left_forearm",forearmR:"right_forearm",forearmMidL:"left_forearm_middie",forearmMidR:"right_forearm_middie",handL:"left_hand",handR:"right_hand",uplegL:"left_thigh",uplegR:"right_thigh",uplegMidL:"left_thigh1",uplegMidR:"right_thigh1",legL:"left_shin",legR:"right_shin",footL:"left_ankle",footR:"right_ankle"},re=lw(vs=>{var ks;return(ks=I.find(Ur=>Ur.name.toLowerCase().endsWith(Z[vs])))==null?void 0:ks.getTransformNode()});function ae(vs){return MT.every(ks=>vs[ks])}if(!ae(re))return;this.skeletonNodes=re;const he=Yp(vs=>re[vs].absolutePosition,["shoulderL","shoulderR","neck","neck1","head","armL","armR","armMidL","forearmL","forearmMidL","handL","uplegL","uplegR","uplegMidL","legL","footL"]),_e=z.Lerp(he.uplegL,he.uplegR,.5),ve=z.Lerp(he.shoulderL,he.shoulderR,.5),Le=ve.subtract(_e).length(),ze=he.forearmL.subtract(he.armL).length(),He=he.handL.subtract(he.forearmL).length(),xt=he.legL.subtract(he.uplegL).length(),rt=he.footL.subtract(he.legL).length();this.skeletonSizes={spineLen:Le,hipsWidth:he.uplegL.subtract(he.uplegR).length(),shoulderWidth:he.armL.subtract(he.armR).length(),shoulderRatio:he.shoulderL.subtract(ve).length()/he.armL.subtract(ve).length(),neckRatio:he.neck1.subtract(he.neck).length()/he.head.subtract(he.neck).length(),armLen:ze,armRatio:he.armMidL.subtract(he.armL).length()/ze,forearmLen:He,forearmRatio:he.forearmMidL.subtract(he.forearmL).length()/He,uplegLen:xt,uplegRatio:he.uplegMidL.subtract(he.uplegL).length()/xt,legLen:rt};const Tt=z.Cross(he.shoulderL.subtract(_e),he.shoulderR.subtract(_e)).normalize(),Lt=re.pelvis.absolutePosition.subtract(_e).length(),Nt=RT(vT({},Yp(vs=>re[vs].absolutePosition,["root","spine","spine1","spine2","spine3","neck","pelvis"])),{pelvisEnd:re.pelvis.absolutePosition.add(new z(0,Lt,0).applyRotationQuaternion(re.pelvis.absoluteRotationQuaternion))});this.spineCurve=D(vs=>{const ks=Nt[vs].subtract(_e),Ur=z.Dot(ks,Tt);return[ks.subtract(Tt.scale(Ur)).length()/Le,Ur/Le]},r_),this.nodeOrigin={position:p.absolutePosition.subtract(re.root.absolutePosition).applyRotationQuaternion(re.root.absoluteRotationQuaternion.conjugate()),rotation:p.absoluteRotationQuaternion.multiply(re.root.absoluteRotationQuaternion.conjugate())};let{min:qt,max:Xt}=p.getHierarchyBoundingVectors();const zt=qt.add(Xt).scale(.5),Gt=Xt.subtract(qt),xi=Math.max(Gt.x,Gt.y,Gt.z)*1.1*.5,Gi=new z(xi,xi,xi);qt=zt.subtract(Gi),Xt=zt.add(Gi),p.getChildMeshes(!1).forEach(vs=>vs.buildBoundingInfo(qt,Xt))}async update(p,_){var E,I;if(!this.loaded||!this.node)return;const Z=(E=p.poses[0])==null?void 0:E.points,{node:re,skeletonNodes:ae,skeletonSizes:he,spineCurve:_e}=this;if(!ae||!he||!_e||!Z)return re.setEnabled(!1),super.update(p,_);const ve=r.map(Tt=>Z[Tt]),Le=ve.map(Tt=>Tt.norm);this.equalize(Le);for(let Tt=0;Tt<4;Tt++)this.align(ve);const ze=this.estimateBones(Z,_e,he),He={position:ze.root.position.add(this.nodeOrigin.position.applyRotationQuaternion(ze.root.rotation)),rotation:ze.root.rotation.multiply(this.nodeOrigin.rotation)};(I=this.skeleton)==null||I.returnToRest(),this.alignBone(He,re,!1),this.updateSpine(ze,ae);const xt=Yp(Tt=>({transform:ze[Tt],bone:ae[Tt]}),["armL","armMidL","forearmL","forearmMidL","handL","armR","armMidR","forearmR","forearmMidR","handR"]);this.updateArm({arm:xt.armL,armMid:xt.armMidL,forearm:xt.forearmL,forearmMid:xt.forearmMidL,hand:xt.handL},{shoulder:Z.shoulderL,elbow:Z.elbowL}),this.updateArm({arm:xt.armR,armMid:xt.armMidR,forearm:xt.forearmR,forearmMid:xt.forearmMidR,hand:xt.handR},{shoulder:Z.shoulderR,elbow:Z.elbowR});const rt=Yp(Tt=>({transform:ze[Tt],bone:ae[Tt]}),["uplegL","uplegMidL","legL","footL","uplegR","uplegMidR","legR","footR"]);return this.updateLeg({upleg:rt.uplegL,uplegMid:rt.uplegMidL,leg:rt.legL,foot:rt.footL},{hip:Z.hipL,knee:Z.kneeL}),this.updateLeg({upleg:rt.uplegR,uplegMid:rt.uplegMidR,leg:rt.legR,foot:rt.footR},{hip:Z.hipR,knee:Z.kneeR}),re.setEnabled(!0),super.update(p,_)}updateSpine(p,_){this.alignBone(p.root,_.root,!1),this.alignBone(p.spine,_.spine,!1),this.alignBone(p.spine1,_.spine1),this.alignBone(p.spine2,_.spine2),this.alignBone(p.spine3,_.spine3),this.alignBone(p.neck,_.neck,!1),this.alignBone(p.neck1,_.neck1,!1),this.alignBone(p.head,_.head,!1),_.head.scaling.setAll(1.1),this.alignBone(p.pelvis,_.pelvis,!1),this.alignBone(p.shoulderL,_.shoulderL,!1),this.alignBone(p.shoulderR,_.shoulderR,!1)}updateArm(p,_){this.alignBone(p.arm.transform,p.arm.bone),this.alignBone(p.armMid.transform,p.armMid.bone),this.alignBone(p.forearm.transform,p.forearm.bone),this.alignBone(p.forearmMid.transform,p.forearmMid.bone),this.connectBone(p.hand.transform.position,p.hand.bone),p.hand.bone.scaling.setAll(.95)}updateLeg(p,_){this.alignBone(p.upleg.transform,p.upleg.bone,!1),this.alignBone(p.uplegMid.transform,p.uplegMid.bone),this.alignBone(p.leg.transform,p.leg.bone),this.connectBone(p.foot.transform.position,p.foot.bone)}estimateBones(p,_,E){var I,Z;const re=c(He=>new z(...p[He].metric)),ae=this.estimateTorso(re);if(this.tune.hipsD){const He=ae.hipsZ.scale(this.tune.hipsD[2]),xt=ae.hipsY.scale(this.tune.hipsD[1]).add(ae.torsoN.scale((I=this.tune)==null?void 0:I.hipsD[0]));re.hipL.addInPlace(xt).addInPlace(He),re.hipR.addInPlace(xt).addInPlace(He.negate()),ae.length-=this.tune.hipsD[1]}if(this.tune.shouldersD){const He=ae.shoulderL0.subtract(ae.shoulderR0).normalize().scale(this.tune.shouldersD[2]),xt=ae.hipsY.scale(this.tune.shouldersD[1]).add(ae.torsoN.scale((Z=this.tune)==null?void 0:Z.shouldersD[0]));re.shoulderL.addInPlace(xt).addInPlace(He),re.shoulderR.addInPlace(xt).addInPlace(He.negate()),ae.shoulderL0.addInPlace(xt),ae.shoulderR0.addInPlace(xt),ae.neck.addInPlace(xt),ae.length+=this.tune.shouldersD[1]}const he=this.estimateSpine(re,ae,_,E),_e=this.estimateArm({shoulder0:ae.shoulderL0,shoulder:re.shoulderL,elbow:re.elbowL,wrist:re.wristL},ae,E),ve=this.estimateArm({shoulder0:ae.shoulderR0,shoulder:re.shoulderR,elbow:re.elbowR,wrist:re.wristR},ae,E),Le=this.estimateLeg({hip:re.hipL,knee:re.kneeL,ankle:re.ankleL},ae,E),ze=this.estimateLeg({hip:re.hipR,knee:re.kneeR,ankle:re.ankleR},ae,E);return RT(vT({},he),{shoulderL:_e.shoulder,armL:_e.arm,armMidL:_e.armMid,forearmL:_e.forearm,forearmMidL:_e.forearmMid,handL:_e.hand,shoulderR:ve.shoulder,armR:ve.arm,armMidR:ve.armMid,forearmR:ve.forearm,forearmMidR:ve.forearmMid,handR:ve.hand,uplegL:Le.upleg,uplegMidL:Le.uplegMid,legL:Le.leg,footL:Le.foot,uplegR:ze.upleg,uplegMidR:ze.uplegMid,legR:ze.leg,footR:ze.foot})}estimateTorso(p){const _=z.Lerp(p.hipL,p.hipR,.5),E=z.Lerp(p.shoulderL,p.shoulderR,.5).subtract(_).normalize(),I=p.elbowL.subtract(p.shoulderL).normalize(),Z=p.elbowR.subtract(p.shoulderR).normalize(),re=z.Dot(I,E),ae=z.Dot(Z,E),he=p.shoulderL.add(p.shoulderL.subtract(p.hipL).normalize().scale(((Math.acos(re)/Math.PI)**2*2-1)*(re>0?.04:.02))),_e=p.shoulderR.add(p.shoulderR.subtract(p.hipR).normalize().scale(((Math.acos(ae)/Math.PI)**2*2-1)*(ae>0?.04:.02))),ve=z.Lerp(he,_e,.5),Le=z.Cross(he.subtract(_),_e.subtract(_)).normalize(),ze=ve.subtract(_),He=p.hipL.subtract(p.hipR).normalize(),xt=ze.length();return ze.normalize(),{hipsC:_,hipsY:ze,hipsZ:He,torsoN:Le,length:xt,neck:ve,shoulderL0:he,shoulderR0:_e}}estimateSpine(p,_,E,I){const{shoulderL0:Z,shoulderR0:re,hipsY:ae,torsoN:he,length:_e}=_,ve=D(Gt=>{const xi=z.Lerp(p.hipL,Z,E[Gt][0]),Gi=z.Lerp(p.hipR,re,E[Gt][0]),vs=z.Lerp(xi,Gi,.5),ks=Gi.subtract(xi);return{position:vs,axisZ:ks}},r_);if(this.tune.spineCurve){const Gt=this.tune.spineCurve*_e;r_.forEach(xi=>ve[xi].position.addInPlace(he.scale(E[xi][1]*Gt))),this.tune.pelvisDZ&&ve.pelvisEnd.position.addInPlace(he.scale(this.tune.pelvisDZ))}const Le=z.Lerp(p.earL,p.earR,.5),ze=Le.subtract(p.nose).normalize(),He=p.earR.subtract(p.earL).normalize(),xt=ze.cross(He).normalize().add(ze.scale(.2)).normalize(),rt=Le.add(ze.scale(.02)).add(xt.scale(-.02)),Tt=this.estimateRotationYZ(xt,He),Lt=z.Lerp(ve.neck.axisZ,He,.15).normalize(),Nt=z.Lerp(ve.neck.position,rt,I.neckRatio),qt=z.Lerp(Lt,He,I.neckRatio).normalize(),Xt=ve.pelvisEnd.position.subtract(ve.pelvis.position),zt=this.estimateRotationYX(Xt,ve.pelvis.axisZ.negate());return{root:this.estimateBone(ve.root.position,ve.root.position.add(he.negate()),ae),spine:this.estimateBone(ve.spine.position,ve.spine1.position,ve.spine.axisZ),spine1:this.estimateBone(ve.spine1.position,ve.spine2.position,ve.spine1.axisZ),spine2:this.estimateBone(ve.spine2.position,ve.spine3.position,ve.spine2.axisZ),spine3:this.estimateBone(ve.spine3.position,ve.neck.position,ve.spine3.axisZ),neck:this.estimateBone(ve.neck.position,Nt,Lt),neck1:this.estimateBone(Nt,rt,qt),head:{position:rt,rotation:Tt},pelvis:{position:ve.pelvis.position,rotation:zt}}}estimateArm(p,_,E){const{neck:I,torsoN:Z,hipsY:re}=_,ae=p.elbow.subtract(p.shoulder).normalize(),he=z.Lerp(I,p.shoulder,E.shoulderRatio),_e=p.shoulder.subtract(he),ve=Math.sqrt(.5*(1+Math.sqrt(1-Math.max(z.Dot(ae,re),0)**2))),Le=Math.sign(z.Dot(Z.cross(_e),re)),ze=this.estimateRotationYX(_e,Z).multiply(new e(0,-Math.sqrt(.5*(1-ve))*Le,0,Math.sqrt(.5*(1+ve)))),He=this.estimateRotationYX(p.shoulder0.subtract(I),Z),xt=new z(0,0,1).applyRotationQuaternion(He).applyRotationQuaternion(this.rotationBetween(_e,ae)),rt=p.wrist.subtract(p.elbow).normalize(),Tt=this.rotationBetween(ae,rt),Lt=xt.applyRotationQuaternion(Tt),Nt=z.Lerp(p.shoulder,p.elbow,E.armRatio),qt=z.Lerp(p.elbow,p.wrist,E.forearmRatio);return{shoulder:{position:he,rotation:ze},arm:this.estimateBone(p.shoulder,Nt,xt),armMid:this.estimateBone(Nt,p.elbow,xt),forearm:this.estimateBone(p.elbow,qt,Lt),forearmMid:this.estimateBone(qt,p.wrist,Lt),hand:{position:p.wrist,rotation:new e}}}estimateLeg(p,_,E){const{hipsZ:I,hipsY:Z}=_,re=p.knee.subtract(p.hip).normalize(),ae=this.rotationBetween(Z.negate(),re),he=I.applyRotationQuaternion(ae),_e=z.Lerp(p.hip,p.knee,E.uplegRatio),ve=p.ankle.subtract(p.knee).normalize(),Le=this.rotationBetween(re,ve),ze=he.applyRotationQuaternion(Le);return{upleg:this.estimateBone(p.hip,_e,he),uplegMid:this.estimateBone(_e,p.knee,he),leg:this.estimateBone(p.knee,p.ankle,ze),foot:{position:p.ankle,rotation:new e}}}estimateBone(p,_,E){return{position:p.clone(),rotation:this.estimateRotationYZ(_.subtract(p),E)}}estimateRotationYZ(p,_){const E=p.normalizeToNew(),I=E.cross(_).normalize(),Z=I.cross(E);return e.RotationQuaternionFromAxis(I,E,Z)}estimateRotationYX(p,_){const E=p.normalizeToNew(),I=_.cross(E).normalize(),Z=E.cross(I).normalize();return e.RotationQuaternionFromAxis(Z,E,I)}rotationBetween(p,_){const E=z.Cross(p,_);return new e(E.x,E.y,E.z,Math.sqrt(1+z.Dot(p,_))).normalize()}alignBone(p,_,E=!0){let I=p.position.clone(),Z=p.rotation.clone();_.parent instanceof R&&(I=z.TransformCoordinates(I,_.parent.computeWorldMatrix(!0).clone().invert()),Z=_.parent.absoluteRotationQuaternion.conjugate().multiply(Z),E&&(_.parent.scaling.setAll(I.length()/_.position.length()),I=z.TransformCoordinates(p.position,_.parent.computeWorldMatrix(!0).clone().invert()))),_.position=I,_.rotationQuaternion=Z}connectBone(p,_){let E=p.clone();_.parent instanceof R&&(E=z.TransformCoordinates(E,_.parent.computeWorldMatrix(!0).clone().invert()),_.parent.scaling.setAll(E.length()/_.position.length()),E=z.TransformCoordinates(p,_.parent.computeWorldMatrix(!0).clone().invert())),_.position=E}positionBone(p,_){let E=p.clone();_.parent instanceof R&&(E=z.TransformCoordinates(E,_.parent.computeWorldMatrix(!0).clone().invert())),_.position=E}rotateBone(p,_){let E=p.clone();_.parent instanceof R&&(_.parent.computeWorldMatrix(!0),E=_.parent.absoluteRotationQuaternion.conjugate().multiply(E)),_.rotationQuaternion=E}spineLength(p){const _=m(I=>new z(...p[x[I]]),hw),{length:E}=this.estimateTorso(_);return E}equalize(p){const _=O.lerp(p[11],p[12],.5),E=O.lerp(p[23],p[24],.5),I=O.sub(_,E),Z=O.length(I),re=Math.abs(I[2])/Z,ae=.7;if(re<ae){const he=ae*(re/ae)**7,_e=O.normalizeToLen([I[0]/Z,I[1]/Z,he*Math.sign(I[2])],Z),ve=O.sub(_e,I);for(let Le=0;Le<23;Le++)p[Le][0]+=ve[0],p[Le][1]+=ve[1],p[Le][2]+=ve[2]}}resize(p){const{skeletonSizes:_}=this;if(!_)return;const E=(vs,ks)=>vs.forEach(Ur=>{p[Ur][0]+=ks[0],p[Ur][1]+=ks[1],p[Ur][2]+=ks[2]}),I=O.lerp(p[11],p[12],.5),Z=O.lerp(p[23],p[24],.5),re=this.spineLength(p),ae=O.sub(I,Z),he=O.scale(ae,.5*(_.spineLen/re-1)),_e=O.sub(p[11],p[12]),ve=O.scale(_e,.5*(_.shoulderWidth/O.length(_e)-1));E([11,13,15,17,19,21],O.add(he,ve)),E([12,14,16,18,20,22],O.add(he,O.negate(ve)));const Le=O.sub(p[23],p[24]),ze=O.scale(Le,.5*(_.hipsWidth/O.length(Le)-1));E([23,25,27,29,31],O.add(O.negate(he),ze)),E([24,26,28,30,32],O.add(O.negate(he),O.negate(ze)));const He=O.sub(p[13],p[11]),xt=O.sub(p[15],p[13]),rt=O.scale(He,_.armLen/O.length(He)-1);p[13]=O.add(p[13],rt),E([15,17,19,21],O.add(rt,O.scale(xt,_.forearmLen/O.length(xt)-1)));const Tt=O.sub(p[14],p[12]),Lt=O.sub(p[16],p[14]),Nt=O.scale(Tt,_.armLen/O.length(Tt)-1);p[14]=O.add(p[14],Nt),E([16,18,20,22],O.add(Nt,O.scale(Lt,_.forearmLen/O.length(Lt)-1)));const qt=O.sub(p[25],p[23]),Xt=O.sub(p[27],p[25]),zt=O.scale(qt,_.uplegLen/O.length(qt)-1);p[25]=O.add(p[25],zt),E([27,29,31],O.add(zt,O.scale(Xt,_.legLen/O.length(Xt)-1)));const Gt=O.sub(p[26],p[24]),xi=O.sub(p[28],p[26]),Gi=O.scale(Gt,_.uplegLen/O.length(Gt)-1);p[26]=O.add(p[26],Gi),E([28,30,32],O.add(Gi,O.scale(xi,_.legLen/O.length(xi)-1)))}align(p,_=!0){const E=p.map(ve=>ve.norm);this.resize(E);const{alignScore:I,alignVisibility:Z}=this,re=[];if([11,12,23,24].forEach(ve=>{(p[ve].score>I||p[ve].visibility>Z)&&re.push({world:E[ve],pixel:p[ve].pixel})}),re.length<2)return;const ae=b(re,{angle:this.cameraAngle,ratio:this.cameraRatio});p.forEach((ve,Le)=>{const ze=ve.metric;ze[0]=E[Le][0]+ae[0],ze[1]=E[Le][1]+ae[1],ze[2]=E[Le][2]+ae[2]});const he=2*Math.tan(.5*this.cameraAngle),_e=this.cameraRatio*he;[11,12,23,24].forEach(ve=>{const Le=p[ve],ze=[(Le.pixel[0]-.5)*_e,(Le.pixel[1]-.5)*he],He=[Le.metric[0]/Le.metric[2],Le.metric[1]/Le.metric[2]],xt=[.5*(ze[0]+He[0]),.5*(ze[1]+He[1])];Le.pixel=[xt[0]/_e+.5,xt[1]/he+.5,Le.pixel[2]]}),p.forEach(ve=>{if(_&&(ve.score>I||ve.visibility>Z)){const Le=[(ve.pixel[0]-.5)*_e,(ve.pixel[1]-.5)*he],ze=ve.metric,He=Math.sqrt(ze[0]**2+ze[1]**2+ze[2]**2),xt=Math.sqrt(Le[0]**2+Le[1]**2+1),rt=He/xt;ze[0]=Le[0]*rt,ze[1]=Le[1]*rt,ze[2]=rt}ve.metric[1]=-ve.metric[1],ve.metric[2]=-ve.metric[2]}),p.forEach(ve=>{const Le=ve.metric;ve.norm=[Le[0],-Le[1],-Le[2]]})}setupCamera(p,_){this.cameraRatio=p,this.cameraAngle=_}}const wT=null,cw=(pe,p)=>D(pe,p),uw=pe=>cw(pe,wT);class M3 extends null{setNode(p){var _;delete this.skirtSkeletonNodes,super.setNode(p);const E=(_=this.skeleton)==null?void 0:_.bones;if(!E)return;const I={uplegSkirtL:"left_thigh_skirt",uplegSkirtR:"right_thigh_skirt",uplegMidSkirtL:"left_thigh1_skirt",uplegMidSkirtR:"right_thigh1_skirt",legSkirtL:"left_shin_skirt",legSkirtR:"right_shin_skirt"},Z=uw(ae=>{var he;return(he=E.find(_e=>_e.name.toLowerCase().endsWith(I[ae])))==null?void 0:he.getTransformNode()});function re(ae){return wT.every(he=>ae[he])}re(Z)&&(this.skirtSkeletonNodes=Z)}async update(p,_){var E,I;if(!this.loaded||!this.node)return;await super.update(p,_);const{skeletonNodes:Z,skirtSkeletonNodes:re}=this;if(!Z||!re)return;const{uplegL:ae,uplegR:he,legL:_e,legR:ve}=Z,{uplegSkirtL:Le,uplegSkirtR:ze}=re,He=(E=ae.rotationQuaternion)!=null?E:e.Identity(),xt=_e.position.applyRotationQuaternion(He.invert()).normalize(),rt=xt.clone();rt.z=Math.min(rt.z,0),rt.normalize();const Tt=z.Cross(rt,xt),Lt=new e(Tt.x,Tt.y,Tt.z,Math.sqrt(1+z.Dot(rt,xt))).normalize();Le.position=ae.position,Le.scaling=ae.scaling,Le.rotationQuaternion=He.multiply(Lt);const Nt=(I=he.rotationQuaternion)!=null?I:e.Identity(),qt=ve.position.applyRotationQuaternion(Nt.invert()).normalize(),Xt=qt.clone();Xt.z=Math.max(Xt.z,0),Xt.normalize();const zt=z.Cross(Xt,qt),Gt=new e(zt.x,zt.y,zt.z,Math.sqrt(1+z.Dot(qt,Xt))).normalize();ze.position=he.position,ze.scaling=he.scaling,ze.rotationQuaternion=Nt.multiply(Gt)}}var pw=Object.defineProperty,_w=Object.defineProperties,Tw=Object.getOwnPropertyDescriptors,LT=Object.getOwnPropertySymbols,vw=Object.prototype.hasOwnProperty,Rw=Object.prototype.propertyIsEnumerable,kT=(pe,p,_)=>p in pe?pw(pe,p,{enumerable:!0,configurable:!0,writable:!0,value:_}):pe[p]=_,Mw=(pe,p)=>{for(var _ in p||(p={}))vw.call(p,_)&&kT(pe,_,p[_]);if(LT)for(var _ of LT(p))Rw.call(p,_)&&kT(pe,_,p[_]);return pe},ww=(pe,p)=>_w(pe,Tw(p));const UT=null,Tu=(pe,p)=>D(pe,p),Lw=pe=>Tu(pe,UT),kw=null,Uw=null;class w3 extends null{constructor(p,_={spineCurve:1,neckAdjust:.01,headRatio:.4}){super(),this.node=p,this.tune=_,this.nodeOrigin={position:new z(0,0,-1),rotation:new e},this.cameraRatio=1920/1080,this.cameraAngle=10/180*Math.PI,this.alignScore=.9,this.alignVisibility=.9}async load(p){this.loaded||(await super.load(p),this.setNode(this.node))}unload(){this.loaded&&(delete this.node,delete this.skeletonNodes,delete this.skeleton,delete this.spineCurve,super.unload())}setNode(p){var _,E;if(delete this.skeletonNodes,delete this.skeleton,delete this.skeletonSizes,delete this.spineCurve,this.node=p,!this.loaded||!p)return;this.skeleton=((_=p.getChildMeshes(!1).find(Gi=>Gi.skeleton))==null?void 0:_.skeleton)||void 0;const I=(E=this.skeleton)==null?void 0:E.bones;if(!I)return;const Z={hips:"hips",spine:"spine",spine1:"spine1",spine2:"spine2",neck:"neck",head:"head",headEnd:"headtop_end",shoulderL:"leftshoulder",shoulderR:"rightshoulder",armL:"leftarm",armR:"rightarm",forearmL:"leftforearm",forearmR:"rightforearm",handL:"lefthand",handR:"righthand",uplegL:"leftupleg",uplegR:"rightupleg",legL:"leftleg",legR:"rightleg",footL:"leftfoot",footR:"rightfoot",toeL:"lefttoebase",toeR:"righttoebase"},re=Gi=>{var vs;return((vs=I.find(ks=>ks.name.toLowerCase().endsWith(Z[Gi])))==null?void 0:vs.getTransformNode())||void 0},ae=Lw(Gi=>re(Gi));function he(Gi){return UT.every(vs=>Gi[vs]!==void 0)}if(!he(ae))return;this.skeletonNodes=ae;const _e=Tu(Gi=>ae[Gi].absolutePosition,["hips","shoulderL","shoulderR","neck","head","headEnd","armL","armR","forearmL","handL","uplegL","uplegR","legL","footL"]),ve=_e.hips,Le=z.Lerp(_e.shoulderL,_e.shoulderR,.5),ze=Le.subtract(ve).length(),He=_e.forearmL.subtract(_e.armL).length(),xt=_e.handL.subtract(_e.forearmL).length(),rt=_e.legL.subtract(_e.uplegL).length(),Tt=_e.footL.subtract(_e.legL).length();this.skeletonSizes={spineLen:ze,hipsWidth:_e.uplegL.subtract(_e.uplegR).length(),shoulderWidth:_e.armL.subtract(_e.armR).length(),shoulderRatio:_e.shoulderL.subtract(Le).length()/_e.armL.subtract(Le).length(),armLen:He,forearmLen:xt,uplegLen:rt,legLen:Tt,headLen:_e.headEnd.subtract(_e.head).length()/ze};const Lt=z.Cross(_e.shoulderR.subtract(ve),_e.shoulderL.subtract(ve)).normalize();this.spineCurve=Tu(Gi=>{const vs=ae[Gi].absolutePosition.subtract(ve),ks=z.Dot(vs,Lt);return[vs.subtract(Lt.scale(ks)).length()/ze,ks/ze]},kw),this.nodeOrigin={position:p.absolutePosition.subtract(ae.hips.absolutePosition).applyRotationQuaternion(ae.hips.absoluteRotationQuaternion.conjugate()),rotation:p.absoluteRotationQuaternion.multiply(ae.hips.absoluteRotationQuaternion.conjugate())};let{min:Nt,max:qt}=p.getHierarchyBoundingVectors();const Xt=Nt.add(qt).scale(.5),zt=qt.subtract(Nt),Gt=Math.max(zt.x,zt.y,zt.z)*1.1*.5,xi=new z(Gt,Gt,Gt);Nt=Xt.subtract(xi),qt=Xt.add(xi),p.getChildMeshes(!1).forEach(Gi=>Gi.buildBoundingInfo(Nt,qt))}async update(p,_){var E,I;if(!this.loaded||!this.node)return;const Z=(E=p.poses[0])==null?void 0:E.points,{node:re,skeletonNodes:ae,skeletonSizes:he,spineCurve:_e}=this;if(!ae||!he||!_e||!Z)return re.setEnabled(!1),super.update(p,_);const ve=r.map(Tt=>Z[Tt]),Le=ve.map(Tt=>Tt.norm);this.equalize(Le);for(let Tt=0;Tt<4;Tt++)this.align(ve);const ze=this.estimateBones(Z,_e,he),He={position:ze.hips.position.add(this.nodeOrigin.position.applyRotationQuaternion(ze.hips.rotation)),rotation:ze.hips.rotation.multiply(this.nodeOrigin.rotation)};(I=this.skeleton)==null||I.returnToRest(),this.alignBone(He,re,!1),this.updateSpine(ze,ae);const xt=Tu(Tt=>({transform:ze[Tt],bone:ae[Tt]}),["armL","forearmL","handL","armR","forearmR","handR"]);this.updateArm({arm:xt.armL,forearm:xt.forearmL,hand:xt.handL},{shoulder:Z.shoulderL,elbow:Z.elbowL}),this.updateArm({arm:xt.armR,forearm:xt.forearmR,hand:xt.handR},{shoulder:Z.shoulderR,elbow:Z.elbowR});const rt=Tu(Tt=>({transform:ze[Tt],bone:ae[Tt]}),["uplegL","legL","footL","toeL","uplegR","legR","footR","toeR"]);return this.updateLeg({upleg:rt.uplegL,leg:rt.legL,foot:rt.footL,toe:rt.toeL},{hip:Z.hipL,knee:Z.kneeL,ankle:Z.ankleL}),this.updateLeg({upleg:rt.uplegR,leg:rt.legR,foot:rt.footR,toe:rt.toeR},{hip:Z.hipR,knee:Z.kneeR,ankle:Z.ankleR}),re.setEnabled(!0),super.update(p,_)}updateSpine(p,_){this.alignBone(p.hips,_.hips,!1),this.alignBone(p.spine,_.spine),this.alignBone(p.spine1,_.spine1),this.alignBone(p.spine2,_.spine2),this.alignBone(p.neck,_.neck,!1),_.neck.scaling.setAll(1.1),this.alignBone(p.head,_.head,!1),this.alignBone(p.shoulderL,_.shoulderL,!1),this.alignBone(p.shoulderR,_.shoulderR,!1)}updateArm(p,_){const{alignScore:E,alignVisibility:I}=this;this.alignBone(p.arm.transform,p.arm.bone),!(_.elbow.score<E&&_.elbow.visibility<I)&&(this.alignBone(p.forearm.transform,p.forearm.bone),p.hand.bone.scaling.setAll(.95))}updateLeg(p,_){const{alignScore:E,alignVisibility:I}=this;_.hip.score<E&&_.hip.visibility<I||(this.alignBone(p.upleg.transform,p.upleg.bone,!1),!(_.knee.score<E&&_.knee.visibility<I)&&(this.alignBone(p.leg.transform,p.leg.bone),!(_.ankle.score<E&&_.ankle.visibility<I)&&(this.alignBone(p.foot.transform,p.foot.bone),this.alignBone(p.toe.transform,p.toe.bone))))}estimateBones(p,_,E){const I=c(Le=>new z(...p[Le].metric)),Z=this.estimateTorso(I),re=this.estimateSpine(I,Z,_,E),ae=this.estimateArm({neck:Z.neck,shoulder:I.shoulderL,elbow:I.elbowL,wrist:I.wristL,index:I.indexL,pinky:I.pinkyL},Z,E,!0),he=this.estimateArm({neck:Z.neck,shoulder:I.shoulderR,elbow:I.elbowR,wrist:I.wristR,index:I.indexR,pinky:I.pinkyR},Z,E,!1),_e=this.estimateLeg({hip:I.hipL,knee:I.kneeL,ankle:I.ankleL,heel:I.heelL,footIndex:I.footIndexL},Z),ve=this.estimateLeg({hip:I.hipR,knee:I.kneeR,ankle:I.ankleR,heel:I.heelR,footIndex:I.footIndexR},Z);return ww(Mw({},re),{shoulderL:ae.shoulder,armL:ae.arm,forearmL:ae.forearm,handL:ae.hand,shoulderR:he.shoulder,armR:he.arm,forearmR:he.forearm,handR:he.hand,uplegL:_e.upleg,legL:_e.leg,footL:_e.foot,toeL:_e.toe,uplegR:ve.upleg,legR:ve.leg,footR:ve.foot,toeR:ve.toe})}estimateTorso(p){var _,E;const I=z.Lerp(p.hipL,p.hipR,.5),Z=p.hipL.subtract(p.hipR).normalize(),re=z.Lerp(p.shoulderL,p.shoulderR,.5),ae=p.shoulderL.subtract(p.shoulderR).normalize(),he=re.subtract(I).normalize(),_e=z.Cross(p.shoulderR.subtract(I),p.shoulderL.subtract(I)).normalize();if(this.tune.hipsD){const Xt=Z.scale(this.tune.hipsD[0]),zt=he.scale(this.tune.hipsD[1]).add(_e.scale((_=this.tune)==null?void 0:_.hipsD[2]));p.hipL.addInPlace(zt).addInPlace(Xt),p.hipR.addInPlace(zt).addInPlace(Xt.negate())}if(this.tune.shouldersD){const Xt=ae.scale(this.tune.shouldersD[0]),zt=he.scale(this.tune.shouldersD[1]).add(_e.scale((E=this.tune)==null?void 0:E.shouldersD[2]));p.shoulderL.addInPlace(zt).addInPlace(Xt),p.shoulderR.addInPlace(zt).addInPlace(Xt.negate())}const ve=p.elbowL.subtract(p.shoulderL).normalize(),Le=p.elbowR.subtract(p.shoulderR).normalize(),ze=z.Dot(ve,he),He=z.Dot(Le,he),xt=p.shoulderL.add(p.shoulderL.subtract(p.hipL).normalize().scale(((Math.acos(ze)/Math.PI)**2*2-1)*(ze>0?.04:.02))),rt=p.shoulderR.add(p.shoulderR.subtract(p.hipR).normalize().scale(((Math.acos(He)/Math.PI)**2*2-1)*(He>0?.04:.02))),Tt=z.Lerp(xt,rt,.5),Lt=z.Cross(rt.subtract(I),xt.subtract(I)).normalize(),Nt=Tt.subtract(I),qt=Nt.length();return Nt.normalize(),{hipsC:I,hipsY:Nt,hipsX:Z,torsoN:Lt,length:qt,neck:Tt,shoulderL0:xt,shoulderR0:rt}}estimateSpine(p,_,E,I){const Z=Tu(Nt=>{const qt=z.Lerp(p.hipL,_.shoulderL0,E[Nt][0]),Xt=z.Lerp(p.hipR,_.shoulderR0,E[Nt][0]),zt=z.Lerp(qt,Xt,.5),Gt=qt.subtract(Xt);return{position:zt,axisX:Gt}},["spine","spine1","spine2"]);if(this.tune.spineCurve){const Nt=this.tune.spineCurve*_.length;["spine","spine1","spine2"].forEach(qt=>Z[qt].position.addInPlace(_.torsoN.scale(E[qt][1]*Nt)))}const re=z.Lerp(p.earL,p.earR,.5),ae=re.subtract(p.nose).normalize(),he=p.earL.subtract(p.earR).normalize(),_e=he.cross(ae).add(ae.scale(.05)).normalize(),ve=this.tune.headRatio||.4,Le=I.headLen*_.length,ze=re.add(_e.cross(he).scale(.01)),He=ze.add(_e.scale(-ve*Le)),xt=ze.add(_e.scale((1-ve)*Le)),rt=z.Lerp(He,xt,2),Tt=_.shoulderL0.subtract(_.shoulderR0).normalize(),Lt=z.Lerp(Tt,he,.5);return{hips:this.estimateBone(_.hipsC,Z.spine.position,_.hipsX),spine:this.estimateBone(Z.spine.position,Z.spine1.position,Z.spine.axisX),spine1:this.estimateBone(Z.spine1.position,Z.spine2.position,Z.spine1.axisX),spine2:this.estimateBone(Z.spine2.position,_.neck,Z.spine2.axisX),neck:this.estimateBone(_.neck,He,Lt),head:this.estimateBone(He,xt,he),headEnd:this.estimateBone(xt,rt,he)}}estimateArm(p,_,E,I){const Z=z.Lerp(p.neck,p.shoulder,E.shoulderRatio),re=I?_.torsoN.clone():_.torsoN.negate(),ae=p.elbow.subtract(p.shoulder).normalize(),he=p.shoulder.subtract(p.neck).normalize(),_e=this.rotationBetween(he,ae),ve=re.applyRotationQuaternion(_e),Le=p.wrist.subtract(p.elbow).normalize(),ze=this.rotationBetween(ae,Le),He=ve.applyRotationQuaternion(ze),xt=z.Lerp(p.index,p.pinky,.5),rt=p.pinky.subtract(p.index);return I||rt.negateInPlace(),{shoulder:this.estimateBone(Z,p.shoulder,re),arm:this.estimateBone(p.shoulder,p.elbow,ve),forearm:this.estimateBone(p.elbow,p.wrist,He),hand:this.estimateBone(p.wrist,xt,rt)}}estimateLeg(p,_){const E=p.ankle.subtract(p.knee).normalize(),I=p.footIndex.subtract(p.heel).normalize(),Z=E.cross(I).normalize(),re=z.Lerp(p.heel,p.footIndex,.8),ae=p.knee.subtract(p.hip).normalize(),he=this.rotationBetween(_.hipsY.negate(),ae),_e=_.hipsX.negate().applyRotationQuaternion(he),ve=this.rotationBetween(ae,E),Le=_e.applyRotationQuaternion(ve);return{upleg:this.estimateBone(p.hip,p.knee,_e),leg:this.estimateBone(p.knee,p.ankle,Le),foot:this.estimateBone(p.ankle,re,Z),toe:this.estimateBone(re,p.footIndex,Z)}}estimateBone(p,_,E){const I=_.subtract(p).normalize(),Z=E.clone().normalize().cross(I).normalize(),re=I.cross(Z);return{position:p.clone(),rotation:e.RotationQuaternionFromAxis(re,I,Z)}}rotationBetween(p,_){const E=z.Cross(p,_);return new e(E.x,E.y,E.z,Math.sqrt(1+z.Dot(p,_))).normalize()}alignBone(p,_,E=!0){let I=p.rotation.clone(),Z=p.position.clone();_.parent instanceof R&&(Z=z.TransformCoordinates(Z,_.parent.computeWorldMatrix(!0).clone().invert()),I=_.parent.absoluteRotationQuaternion.conjugate().multiply(I),E&&(_.parent.scaling.setAll(Z.length()/_.position.length()),Z=z.TransformCoordinates(p.position,_.parent.computeWorldMatrix(!0).clone().invert()))),_.position=Z,_.rotationQuaternion=I}spineLength(p){const _=m(I=>new z(...p[x[I]]),Uw),{length:E}=this.estimateTorso(_);return E}equalize(p){const _=O.lerp(p[11],p[12],.5),E=O.lerp(p[23],p[24],.5),I=O.sub(_,E),Z=O.length(I),re=Math.abs(I[2])/Z,ae=.7;if(re<ae){const he=ae*(re/ae)**7,_e=O.normalizeToLen([I[0]/Z,I[1]/Z,he*Math.sign(I[2])],Z),ve=O.sub(_e,I);for(let Le=0;Le<23;Le++)p[Le][0]+=ve[0],p[Le][1]+=ve[1],p[Le][2]+=ve[2]}}resize(p){const{skeletonSizes:_}=this;if(!_)return;const E=(vs,ks)=>vs.forEach(Ur=>{p[Ur][0]+=ks[0],p[Ur][1]+=ks[1],p[Ur][2]+=ks[2]}),I=O.lerp(p[11],p[12],.5),Z=O.lerp(p[23],p[24],.5),re=this.spineLength(p),ae=O.sub(I,Z),he=O.scale(ae,.5*(_.spineLen/re-1)),_e=O.sub(p[11],p[12]),ve=O.scale(_e,.5*(_.shoulderWidth/O.length(_e)-1));E([11,13,15,17,19,21],O.add(he,ve)),E([12,14,16,18,20,22],O.add(he,O.negate(ve)));const Le=O.sub(p[23],p[24]),ze=O.scale(Le,.5*(_.hipsWidth/O.length(Le)-1));E([23,25,27,29,31],O.add(O.negate(he),ze)),E([24,26,28,30,32],O.add(O.negate(he),O.negate(ze)));const He=O.sub(p[13],p[11]),xt=O.sub(p[15],p[13]),rt=O.scale(He,_.armLen/O.length(He)-1);p[13]=O.add(p[13],rt),E([15,17,19,21],O.add(rt,O.scale(xt,_.forearmLen/O.length(xt)-1)));const Tt=O.sub(p[14],p[12]),Lt=O.sub(p[16],p[14]),Nt=O.scale(Tt,_.armLen/O.length(Tt)-1);p[14]=O.add(p[14],Nt),E([16,18,20,22],O.add(Nt,O.scale(Lt,_.forearmLen/O.length(Lt)-1)));const qt=O.sub(p[25],p[23]),Xt=O.sub(p[27],p[25]),zt=O.scale(qt,_.uplegLen/O.length(qt)-1);p[25]=O.add(p[25],zt),E([27,29,31],O.add(zt,O.scale(Xt,_.legLen/O.length(Xt)-1)));const Gt=O.sub(p[26],p[24]),xi=O.sub(p[28],p[26]),Gi=O.scale(Gt,_.uplegLen/O.length(Gt)-1);p[26]=O.add(p[26],Gi),E([28,30,32],O.add(Gi,O.scale(xi,_.legLen/O.length(xi)-1)))}align(p,_=!0){const E=p.map(ve=>ve.norm);this.resize(E);const{alignScore:I,alignVisibility:Z}=this,re=[];if([11,12,23,24].forEach(ve=>{(p[ve].score>I||p[ve].visibility>Z)&&re.push({world:E[ve],pixel:p[ve].pixel})}),re.length<2)return;const ae=b(re,{angle:this.cameraAngle,ratio:this.cameraRatio});p.forEach((ve,Le)=>{const ze=ve.metric;ze[0]=E[Le][0]+ae[0],ze[1]=E[Le][1]+ae[1],ze[2]=E[Le][2]+ae[2]});const he=2*Math.tan(.5*this.cameraAngle),_e=this.cameraRatio*he;[11,12,23,24].forEach(ve=>{const Le=p[ve],ze=[(Le.pixel[0]-.5)*_e,(Le.pixel[1]-.5)*he],He=[Le.metric[0]/Le.metric[2],Le.metric[1]/Le.metric[2]],xt=[.5*(ze[0]+He[0]),.5*(ze[1]+He[1])];Le.pixel=[xt[0]/_e+.5,xt[1]/he+.5,Le.pixel[2]]}),p.forEach(ve=>{if(_&&(ve.score>I||ve.visibility>Z)){const Le=[(ve.pixel[0]-.5)*_e,(ve.pixel[1]-.5)*he],ze=ve.metric,He=Math.sqrt(ze[0]**2+ze[1]**2+ze[2]**2),xt=Math.sqrt(Le[0]**2+Le[1]**2+1),rt=He/xt;ze[0]=Le[0]*rt,ze[1]=Le[1]*rt,ze[2]=rt}ve.metric[1]=-ve.metric[1],ve.metric[2]=-ve.metric[2]}),p.forEach(ve=>{const Le=ve.metric;ve.norm=[Le[0],-Le[1],-Le[2]]})}setupCamera(p,_){this.cameraRatio=p,this.cameraAngle=_}}class L3 extends null{constructor(p,_,E,I,Z={spineCurve:1,neckAdjust:.01,headRatio:.4}){super(p,Z),this.translation=_,this.rotation=E,this.scale=I}async update(p,_){var E;if(!this.loaded||!this.node)return;await super.update(p,_);const I=(E=p.poses[0])==null?void 0:E.points,{node:Z,translation:re,rotation:ae,scale:he}=this;if(!I)return;const _e=new z(...I.hipL.metric),ve=new z(...I.hipR.metric),Le=z.Lerp(_e,ve,.5);Z.position=re?Le.add(re):Le,ae&&(Z.rotationQuaternion=ae),he&&(Z.scaling=new z().setAll(he))}updateSpine(p){const{skeletonNodes:_}=this;_&&(this.alignBone(p.hips,_.hips),this.alignBone(p.spine,_.spine),this.alignBone(p.spine1,_.spine1),this.alignBone(p.spine2,_.spine2),this.alignBone(p.neck,_.neck),this.alignBone(p.head,_.head),this.alignBone(p.shoulderL,_.shoulderL),this.alignBone(p.shoulderR,_.shoulderR))}alignBone(p,_){let E=p.rotation.clone();_.parent instanceof R&&(_.parent.computeWorldMatrix(!0),E=_.parent.absoluteRotationQuaternion.conjugate().multiply(E)),_.rotationQuaternion=E}}const GT=null,Gw=(pe,p)=>D(pe,p),zw=pe=>Gw(pe,GT);class k3 extends null{setNode(p){var _;delete this.skirtSkeletonNodes,super.setNode(p);const E=(_=this.skeleton)==null?void 0:_.bones;if(!E)return;const I={uplegSkirtL:"leftuplegskirt",uplegSkirtR:"rightuplegskirt"},Z=zw(ae=>{var he;return(he=E.find(_e=>_e.name.toLowerCase().endsWith(I[ae])))==null?void 0:he.getTransformNode()});function re(ae){return GT.every(he=>ae[he])}re(Z)&&(this.skirtSkeletonNodes=Z)}async update(p,_){var E,I;if(!this.loaded||!this.node)return;await super.update(p,_);const{skeletonNodes:Z,skirtSkeletonNodes:re}=this;if(!Z||!re)return;const{uplegL:ae,uplegR:he,legL:_e,legR:ve}=Z,{uplegSkirtL:Le,uplegSkirtR:ze}=re,He=(E=ae.rotationQuaternion)!=null?E:e.Identity(),xt=_e.position.applyRotationQuaternion(He.invert()).normalize(),rt=xt.clone();rt.x=Math.min(rt.x,0),rt.normalize();const Tt=z.Cross(rt,xt),Lt=new e(Tt.x,Tt.y,Tt.z,Math.sqrt(1+z.Dot(rt,xt))).normalize();Le.position=ae.position,Le.scaling=ae.scaling,Le.rotationQuaternion=He.multiply(Lt);const Nt=(I=he.rotationQuaternion)!=null?I:e.Identity(),qt=ve.position.applyRotationQuaternion(Nt.invert()).normalize(),Xt=qt.clone();Xt.x=Math.max(Xt.x,0),Xt.normalize();const zt=z.Cross(Xt,qt),Gt=new e(zt.x,zt.y,zt.z,Math.sqrt(1+z.Dot(qt,Xt))).normalize();ze.position=he.position,ze.scaling=he.scaling,ze.rotationQuaternion=Nt.multiply(Gt)}}const Ww=`
attribute vec3 position;
#include<bonesDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
void main(void) {
    #include<instancesVertex>
    #include<bonesVertex>
    vec4 worldPos = finalWorld * vec4(position, 1.0);
    gl_Position = viewProjection * worldPos;
    #include<clipPlaneVertex>
}`,Hw=`
#include<clipPlaneFragmentDeclaration>
void main(void) {
    #include<clipPlaneFragment>
	gl_FragColor = vec4(0, 0, 0, 1);
}`;class zT extends Xh{constructor(p,_){super(p,_,"simpleOccluder",{attributes:["position"],uniforms:["world","viewProjection"]}),this.disableColorWrite=!0,this.needDepthPrePass=!0,this.transparencyMode=zi.MATERIAL_OPAQUE}}_a.ShadersStore.simpleOccluderVertexShader=Ww,_a.ShadersStore.simpleOccluderFragmentShader=Hw;class U3 extends null{constructor(p,_,E={spineCurve:1,neckAdjust:.01,headRatio:.4}){super(p,E),this.outfit=_}setNode(p){super.setNode(p);const{outfit:_,node:E}=this;!_||!E||E.getChildMeshes().forEach(I=>{const Z=re=>re?.some(ae=>typeof ae=="string"?I.name===ae:ae.test(I.name));if(Z(_.occluders)){const re=I.material;I.material=new zT("Occluder",I.getScene()),re?.getBindedMeshes().length===0&&re.dispose();return}if(Z(_.hidden)){I.setEnabled(!1);return}})}setOutfit(p,_){this.outfit=_,this.setNode(p)}}class G3 extends null{constructor(p=.55,_=256){super(["image","mask","part"],{rect:"4f"},Xw(p,_)),this.patchParts=[],this.keepParts=[],this.partsSkeletons=[],this.ordinal=y.PostRender}setParts(p=[],_=[]){this.partsSkeletons=[],this.patchParts=p,this.keepParts=_,this.partsTarget&&(this.partsTarget.renderList=[...p,..._],this.partsTarget.setMaterialForRendering(p,this.patchMaterial),this.partsTarget.setMaterialForRendering(_,this.keepMaterial),this.partsTarget.renderList.forEach(E=>E.skeleton&&this.partsSkeletons.indexOf(E.skeleton)<0&&this.partsSkeletons.push(E.skeleton)))}async load(p){if(!(p instanceof s_))return;const{scene:_,shaderCtx:E}=p;if(!(this.loaded||!E||!_))return this.partsTarget=new H4("MasksTarget",this.size,_),this.partsTarget.clearColor=new L(0,0,0,1),this.patchMaterial=new n("PatchMaskMaterial",_,"bodypatch",{attributes:["position"],uniforms:["world","viewProjection","color"]}),this.patchMaterial.setColor4("color",new L(1,0,0,1)),this.patchMaterial.backFaceCulling=!1,this.patchMaterial.needDepthPrePass=!0,this.patchMaterial.transparencyMode=t.MATERIAL_OPAQUE,this.keepMaterial=new n("KeepMaskMaterial",_,"bodypatch",{attributes:["position"],uniforms:["world","viewProjection","color"]}),this.keepMaterial.setColor4("color",new L(0,1,0,1)),this.keepMaterial.backFaceCulling=!1,this.keepMaterial.needDepthPrePass=!0,this.keepMaterial.transparencyMode=t.MATERIAL_OPAQUE,this.setParts(this.patchParts,this.keepParts),super.load(p)}unload(){var p,_,E;this.loaded&&((p=this.partsTarget)==null||p.dispose(),delete this.partsTarget,(_=this.patchMaterial)==null||_.dispose(),delete this.patchMaterial,(E=this.keepMaterial)==null||E.dispose(),delete this.keepMaterial,super.unload())}async process(p,_){const E=H1(p),{shader:I}=this;if(!E||!I)return!1;const Z=H2(E.box),re=this.renderParts();return I.process([_,E.texture,re||null],{rect:Z}),!0}renderParts(){var p,_,E;const{partsTarget:I,partsSkeletons:Z,shader:re}=this;return!I||!re?null:(Z.forEach(ae=>ae.prepare()),(p=I.renderList)==null||p.forEach(ae=>ae.computeWorldMatrix(!0)),I.render(),((E=(_=I.getInternalTexture())==null?void 0:_._hardwareTexture)==null?void 0:E._webGLTexture)||null)}setupVideo(p){var _;super.setupVideo(p),(_=this.partsTarget)==null||_.resize(p),this.setParts(this.patchParts,this.keepParts)}}const Xw=(pe=.55,p=256)=>{const _=Math.ceil(p/8);return`
        precision mediump float;
        varying vec2 xy;
        uniform vec2 wh;
        uniform vec4 rect;
        uniform sampler2D image;
        uniform sampler2D mask;
        uniform sampler2D part;
        #define M_SQRT2 1.414213562

        float readMask(vec2 xy0, vec2 dxyI) {
            return texture2D(mask, (xy0 + dxyI / wh - rect.xy) / rect.zw).r;
        }

        vec4 readPart(vec2 xy0, vec2 dxyI) {
            vec2 offset = xy0 + dxyI / wh;
            return texture2D(part, vec2(offset.x, 1.0 - offset.y));
        }

        vec4 readProp(vec2 xy0, vec2 dxyI, vec2 ddxyI) {
            return abs(dxyI.x) + abs(dxyI.y) < `+80 .toFixed(1)+` &&
                readMask(xy0, ddxyI) < `+pe+` ?
                texture2D(image, xy0 + ddxyI / wh) :
                texture2D(image, xy0 + dxyI / wh);
        }

        float traverse(vec2 xy0, vec2 dxyI) {
            bool bg = false;
            float d = 1.0;
            for (int di = 1; di < `+_+`; di++) {
                d = bg ? d : float(di * 8);
                bg = bg || readMask(xy0, d * dxyI) < `+pe+`;
            }
            bool bg1 = bg;
            for (int di = 1; di < 8; di++) {
                float d1 = d - 1.0;
                bg1 = bg1 && readMask(xy0, d1 * dxyI) < `+pe+`;
                d = bg1 ? d1 : d;
            }
            return bg ? d : -1.0;
        }

        vec2 searchPart(vec2 xy0, vec2 dxyI) {
            vec2 part = vec2(`+(2*p+8+1)+`);
            bool fg = true;
            float df = 1.0;
            for (int di = 1; di < `+_+`; di++) {
                df = float(di * 8);
                vec2 partD = readPart(xy0, df * dxyI).rg;
                fg = fg && readMask(xy0, df * dxyI) >= `+pe+`;
                part.r = fg && partD.r > 0.5 && df < part.r ? df : part.r;
                part.g = fg && partD.g > 0.5 && df < part.g ? df : part.g;
            }
            vec2 part0 = part;
            for (int di = 1; di < 8; di++) {
                vec2 df = part0 - vec2(di);
                float partDR = readPart(xy0, df.r * dxyI).r;
                float partDG = readPart(xy0, df.g * dxyI).g;
                bool fgR = readMask(xy0, df.r * dxyI) >= `+pe+`;
                bool fgG = readMask(xy0, df.g * dxyI) >= `+pe+`;
                part.r = fgR && partDR > 0.5 && df.r < part.r ? df.r : part.r;
                part.g = fgG && partDG > 0.5 && df.g < part.g ? df.g : part.g;
            }
            return part;
        }

        void main() {
            bool bg = texture2D(mask, (xy - rect.xy) / (rect.zw)).r < `+pe+`;
            vec4 color = texture2D(image, xy);
            if (bg) {
                gl_FragColor = color;
                return;
            }
            vec2 part = texture2D(part, vec2(xy.x, 1.0 - xy.y)).rg;
            if (part.g > 0.5 || part.r > 0.5) {
                gl_FragColor = color;
                return;
            }

            vec2 pX0 = searchPart(xy,  vec2( 1.0,  0.0));
            vec2 pX1 = searchPart(xy,  vec2(-1.0,  0.0));
            vec2 pY0 = searchPart(xy,  vec2( 0.0,  1.0));
            vec2 pY1 = searchPart(xy,  vec2( 0.0, -1.0));
            vec2 pD00 = searchPart(xy, vec2( 1.0,  1.0));
            vec2 pD01 = searchPart(xy, vec2( 1.0, -1.0));
            vec2 pD10 = searchPart(xy, vec2(-1.0,  1.0));
            vec2 pD11 = searchPart(xy, vec2(-1.0, -1.0));
            part = min(min(min(pX0,  pX1 ), min(pY0,  pY1 )),
                       min(min(pD00, pD01), min(pD10, pD11)) * M_SQRT2);
            if (part.g < part.r && part.g < float(`+p+`) ||
                part.r >= float(`+p+`)) {
                gl_FragColor = color;
                return;
            }

            float x0 = traverse(xy, vec2(-1.0, 0.0));
            bg = x0 > 0.0;
            vec4 cx0 = bg ? readProp(xy, vec2(-x0, 0.0),
                vec2(-2.0 * x0 + 1.0, 0.0)) : color;
            x0 = bg ? 1.0 / x0 : 0.0;

            float x1 = traverse(xy, vec2(1.0, 0.0));
            bg = x1 > 0.0;
            vec4 cx1 = bg ? readProp(xy, vec2(x1, 0.0),
                vec2(2.0 * x1 - 1.0, 0.0)) : color;
            x1 = bg ? 1.0 / x1 : 0.0;

            float y0 = traverse(xy, vec2(0.0, -1.0));
            bg = y0 > 0.0;
            vec4 cy0 = bg ? readProp(xy, vec2(0.0, -y0),
                vec2(0.0, -2.0 * y0 + 1.0)) : color;
            y0 = bg ? 1.0 / y0 : 0.0;

            float y1 = traverse(xy, vec2(0.0, 1.0));
            bg = y1 > 0.0;
            vec4 cy1 = bg ? readProp(xy, vec2(0.0, y1),
                vec2(0.0, 2.0 * y1 - 1.0)) : color;
            y1 = bg ? 1.0 / y1 : 0.0;

            float s = 1.0 / (x0 + x1 + y0 + y1);
            vec4 subst = cx0 * x0 * s + cx1 * x1 * s + cy0 * y0 * s + cy1 * y1 * s;
            if (part.g >= float(`+p+`)) {
                gl_FragColor = subst;
                return;
            }

            bvec2 b[8];
            b[0] = bvec2(pX0.r < pX0.g, pX0.g < pX0.r);
            b[1] = bvec2(pD00.r < pD00.g, pD00.g < pD00.r);
            b[2] = bvec2(pY0.r < pY0.g, pY0.g < pY0.r);
            b[3] = bvec2(pD10.r < pD10.g, pD10.g < pD10.r);
            b[4] = bvec2(pX1.r < pX1.g, pX1.g < pX1.r);
            b[5] = bvec2(pD11.r < pD11.g, pD11.g < pD11.r);
            b[6] = bvec2(pY1.r < pY1.g, pY1.g < pY1.r);
            b[7] = bvec2(pD01.r < pD01.g, pD01.g < pD01.r);
            float rs[8];
            rs[0] = pX0.r;
            rs[1] = pD00.r * M_SQRT2;
            rs[2] = pY0.r;
            rs[3] = pD10.r * M_SQRT2;
            rs[4] = pX1.r;
            rs[5] = pD11.r * M_SQRT2;
            rs[6] = pY1.r;
            rs[7] = pD01.r * M_SQRT2;
            float rMin = float(`+(2*p+8+1)+`);
            bool bMin = false;
            for (int i = 0; i < 8; i++) {
                if (rs[i] < rMin) {
                    rMin = rs[i];
                    bMin = (b[i + 2 < 8 ? i + 2 : i + 2 - 8].g ||
                            b[i + 3 < 8 ? i + 3 : i + 3 - 8].g ||
                            b[i + 4 < 8 ? i + 4 : i + 4 - 8].g ||
                            b[i + 5 < 8 ? i + 5 : i + 5 - 8].g ||
                            b[i + 6 < 8 ? i + 6 : i + 6 - 8].g) &&
                          !(b[i + 3 < 8 ? i + 3 : i + 3 - 8].r ||
                            b[i + 4 < 8 ? i + 4 : i + 4 - 8].r ||
                            b[i + 5 < 8 ? i + 5 : i + 5 - 8].r);
                }
            }

            // vec4 rs[8];
            // rs[0] = vec4(1, 0, pX0.r, pX0.r);
            // rs[1] = vec4(1, 1, pD00.r, pD00.r * M_SQRT2);
            // rs[2] = vec4(0, 1, pY0.r, pY0.r);
            // rs[3] = vec4(-1, 1, pD10.r, pD10.r * M_SQRT2);
            // rs[4] = vec4(-1, 0, pX1.r, pX1.r);
            // rs[5] = vec4(-1, -1, pD11.r, pD11.r * M_SQRT2);
            // rs[6] = vec4(-1, 0, pY1.r, pY1.r);
            // rs[7] = vec4(-1, 1, pD01.r, pD01.r * M_SQRT2);
            // vec4 rMin = rs[0];
            // for (int i = 1; i < 8; i++) {
            //     if (rs[i].w < rMin.w)
            //         rMin = rs[i];
            // }
            // vec2 d0 = rMin.xy;
            // float norm = abs(d0.x) + abs(d0.y);
            // vec2 d1 = vec2(-d0.x - d0.y, -d0.y + d0.x) / norm;
            // vec2 d2 = vec2(-d0.x + d0.y, -d0.y - d0.x) / norm;
            // float d0Len = length(d0);
            // float d1Len = length(d1);
            // vec2 xyR = xy + d0 * (rMin.z / 2.0 - 1.0) / wh;
            // vec2 c0 = searchPart(xyR, vec2(-d0.x, -d0.y)) * d0Len;
            // vec2 c1 = searchPart(xyR, vec2(-d0.y,  d0.x)) * d0Len;
            // vec2 c2 = searchPart(xyR, vec2( d0.y, -d0.x)) * d0Len;
            // vec2 c3 = searchPart(xyR, vec2( d1.x,  d1.y)) * d1Len;
            // vec2 c4 = searchPart(xyR, vec2( d2.x,  d2.y)) * d1Len;
            // bool bMin = (c0.g < c0.r || c1.g < c1.r || c2.g < c2.r ||
            //              c3.g < c3.r || c4.g < c4.r);

            if (bMin) {
                gl_FragColor = mix(subst, color, pow(part.r / part.g, 0.5));
                return;
            }
            gl_FragColor = subst;
        }`},Yw=`
attribute vec3 position;
#include<bonesDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
void main(void) {
    #include<instancesVertex>
    #include<bonesVertex>
    vec4 worldPos = finalWorld * vec4(position, 1.0);
    gl_Position = viewProjection * worldPos;
    #include<clipPlaneVertex>
}`,Kw=`
#include<clipPlaneFragmentDeclaration>
uniform vec4 color;
void main(void) {
    #include<clipPlaneFragment>
	gl_FragColor = color;
}`;_a.ShadersStore.bodypatchVertexShader=Yw,_a.ShadersStore.bodypatchFragmentShader=Kw;class jw extends jP{constructor(p){super(),this.node=p,this.cameraRatio=1920/1080,this.cameraAngle=10/180*Math.PI}async update(p,_){if(!this.loaded||!this.node)return;const{points:E=void 0,handedness:I=0,wrist:Z=void 0}=p.hands[0]||{};if(!E||!I||!Z)return this.node.setEnabled(!1),super.update(p,_);const re=new at(...E[1].metric),ae=new at(...E[0].metric),he=new at(...E[5].metric),_e=new at(...E[17].metric),ve=at.Lerp(re.subtract(ae).normalize(),he.subtract(_e).normalize(),.5).normalize();I>0&&ve.negateInPlace();const Le=2*Math.tan(.5*this.cameraAngle),ze=this.cameraRatio*Le,He=Z.lines.map(n0=>{const z0=[(n0.point[0]-.5)*ze,-(n0.point[1]-.5)*Le],W0=[n0.vector[0],-n0.vector[1]];return{point:z0,vector:W0}}),xt=new at(...He[0].vector,0).normalize(),rt=new at(...He[1].vector,0).normalize(),Tt=at.Cross(xt,rt).length(),Lt=(1-Math.abs(ve.z))*Tt,Nt=at.Lerp(xt,rt,.5).normalize(),qt=Math.sqrt(1-Lt**2);Nt.x/=qt,Nt.y/=qt,Nt.z=Lt,Nt.normalize();const Xt=Nt.clone(),zt=ve.cross(Xt).normalize(),Gt=Xt.cross(zt),xi=new at(...E[0].metric).z,Gi=new at(...He[0].point,1),vs=new at(...He[1].point,1),ks=new at(...He[2].point,1);Gi.scaleInPlace(xi),vs.scaleInPlace(xi),ks.scaleInPlace(xi),ks.x*=-1,ks.y*=-1;const Ur=.06,hn=.045,pn=zt.z**2,_n=zt.x**2+zt.y**2,x0=Ur*hn/Math.sqrt(Ur**2*_n+hn**2*pn),Ta=Gi.subtract(vs).length()/x0;return this.node.rotationQuaternion=us.RotationQuaternionFromAxis(Gt,Xt,zt),this.node.position=ks,this.node.scaling.setAll(Ta),this.node.setEnabled(!0),super.update(p,_)}setNode(p){this.node=p}setupCamera(p,_){this.cameraRatio=p,this.cameraAngle=_}}class z3 extends null{constructor(p,_=0){super(),this.node=p,this.renderOrder=_}async load(p){if(!this.loaded)return this.node instanceof H5&&(this.node.material&&(this.node.material.disableColorWrite=!0,this.node.material.needDepthPrePass=!0),this.node.renderingGroupId=this.renderOrder),this.node.getChildMeshes(!1).forEach(_=>{_.material&&(_.material.disableColorWrite=!0,_.material.needDepthPrePass=!0),_.renderingGroupId=this.renderOrder}),super.load(p)}}const qw=`
attribute vec3 position;
#include<bonesDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
varying vec2 xy;
void main(void) {
    #include<instancesVertex>
    #include<bonesVertex>
    vec4 worldPos = finalWorld * vec4(position, 1.0);
    gl_Position = viewProjection * worldPos;
    xy = 0.5 * (vec2(gl_Position.x, -gl_Position.y) / gl_Position.w + 1.0);
    #include<clipPlaneVertex>
}`,$w=.5,rN=`
#include<clipPlaneFragmentDeclaration>
varying vec2 xy;
uniform vec4 rect;
uniform sampler2D mask;
void main(void) {
    #include<clipPlaneFragment>
    bool bg = texture2D(mask, (xy - rect.xy) / (rect.zw)).r <= `+$w+`;
    if (bg)
        discard;
	gl_FragColor = vec4(0, 0, 0, 1);
}`;class nN extends null{constructor(p,_,E){super(p,_,"maskedOccluder",{attributes:["position"],uniforms:["world","viewProjection","rect"],samplers:["mask"]}),this.disableColorWrite=!0,this.needDepthPrePass=!0,this.transparencyMode=t.MATERIAL_OPAQUE,E&&this.setTexture("mask",E)}dispose(p,_,E){super.dispose(p,!1,E)}}_a.ShadersStore.maskedOccluderVertexShader=qw,_a.ShadersStore.maskedOccluderFragmentShader=rN;class W3 extends null{constructor(){super(...arguments),this.maskRect=new f}async load(p){this.loaded||!(p instanceof s_)||(await super.load(p),this.scene&&(this.maskTexture=new P(this.scene)))}unload(){var p,_,E,I;this.loaded&&((E=(_=(p=this.maskTexture)==null?void 0:p.getInternalTexture())==null?void 0:_._hardwareTexture)==null||E.reset(),(I=this.maskTexture)==null||I.dispose(),delete this.maskTexture,super.unload())}async update(p,_){var E;if(!this.loaded)return;const I=H1(p);if(!(!I||!this.maskTexture))return this.maskTexture._texture=((E=this.scene)==null?void 0:E.getEngine().wrapWebGLTexture(I.texture))||null,this.maskRect.set(...H2(I.box)),super.update(p,_)}createMaterial(){const{scene:p}=this;if(!p)return null;const _=new nN("OcclusionMaterial",p);return _.onBindObservable.add(()=>{const{maskTexture:E,maskRect:I}=this;_.setVector4("rect",I),E&&_.setTexture("mask",E)}),_}}class X3 extends null{constructor(p,_=.85,E=.03,I={minCutOff:.05,minCutOffD:.1,beta:.05}){super(void 0,_,E,I),this.scene=p,this.rangeMax=_,this.rangeMin=E,this.filterParams=I,this.intensityMap=new Map,this.adjustIntensities=Z=>{var re;this.scene&&this.envIntensity&&(this.scene.environmentIntensity=Z*this.envIntensity),(re=this.scene)==null||re.lights.forEach(ae=>{const he=this.intensityMap.get(ae);he&&(ae.intensity=Z*he)})},this.resetScene(),this.setCallback(this.adjustIntensities)}setScene(p){var _;this.scene&&this.envIntensity&&(this.scene.environmentIntensity=this.envIntensity),delete this.envIntensity,(_=this.scene)==null||_.lights.forEach(E=>{const I=this.intensityMap.get(E);I&&(E.intensity=I)}),this.intensityMap.clear(),this.envIntensity=p?.environmentIntensity,p?.lights.forEach(E=>this.intensityMap.set(E,E.intensity)),this.scene=p}resetScene(){this.setScene(this.scene)}load(p){return this.resetScene(),super.load(p)}unload(){this.setScene()}}sr.prototype._createDepthStencilCubeTexture=function(pe,p){const _=new c0(this,kn.DepthStencil);if(_.isCube=!0,this.webGLVersion===1)return Ti.Error("Depth cube texture is not supported by WebGL 1."),_;const E={bilinearFiltering:!1,comparisonFunction:0,generateStencil:!1,...p},I=this._gl;this._bindTextureDirectly(I.TEXTURE_CUBE_MAP,_,!0),this._setupDepthStencilTexture(_,pe,E.generateStencil,E.bilinearFiltering,E.comparisonFunction);for(let Z=0;Z<6;Z++)E.generateStencil?I.texImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Z,0,I.DEPTH24_STENCIL8,pe,pe,0,I.DEPTH_STENCIL,I.UNSIGNED_INT_24_8,null):I.texImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Z,0,I.DEPTH_COMPONENT24,pe,pe,0,I.DEPTH_COMPONENT,I.UNSIGNED_INT,null);return this._bindTextureDirectly(I.TEXTURE_CUBE_MAP,null),this._internalTexturesCache.push(_),_},sr.prototype._partialLoadFile=function(pe,p,_,E,I=null){const Z=ae=>{_[p]=ae,_._internalCount++,_._internalCount===6&&E(_)},re=(ae,he)=>{I&&ae&&I(ae.status+" "+ae.statusText,he)};this._loadFile(pe,Z,void 0,void 0,!0,re)},sr.prototype._cascadeLoadFiles=function(pe,p,_,E=null){const I=[];I._internalCount=0;for(let Z=0;Z<6;Z++)this._partialLoadFile(_[Z],Z,I,p,E)},sr.prototype._cascadeLoadImgs=function(pe,p,_,E,I=null,Z){const re=[];re._internalCount=0;for(let ae=0;ae<6;ae++)this._partialLoadImg(E[ae],ae,re,pe,p,_,I,Z)},sr.prototype._partialLoadImg=function(pe,p,_,E,I,Z,re=null,ae){const he=Y0();ul(pe,Le=>{_[p]=Le,_._internalCount++,E&&E.removePendingData(he),_._internalCount===6&&Z&&Z(I,_)},(Le,ze)=>{E&&E.removePendingData(he),re&&re(Le,ze)},E?E.offlineProvider:null,ae),E&&E.addPendingData(he)},sr.prototype._setCubeMapTextureParams=function(pe,p,_){const E=this._gl;E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_MAG_FILTER,E.LINEAR),E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_MIN_FILTER,p?E.LINEAR_MIPMAP_LINEAR:E.LINEAR),E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_WRAP_S,E.CLAMP_TO_EDGE),E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_WRAP_T,E.CLAMP_TO_EDGE),pe.samplingMode=p?3:2,p&&this.getCaps().textureMaxLevel&&_!==void 0&&_>0&&(E.texParameteri(E.TEXTURE_CUBE_MAP,E.TEXTURE_MAX_LEVEL,_),pe._maxLodLevel=_),this._bindTextureDirectly(E.TEXTURE_CUBE_MAP,null)},sr.prototype.createCubeTextureBase=function(pe,p,_,E,I=null,Z=null,re,ae=null,he=!1,_e=0,ve=0,Le=null,ze=null,He=null,xt=!1){const rt=Le||new c0(this,kn.Cube);rt.isCube=!0,rt.url=pe,rt.generateMipMaps=!E,rt._lodGenerationScale=_e,rt._lodGenerationOffset=ve,rt._useSRGBBuffer=!!xt&&this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU||!!E),rt!==Le&&(rt.label=pe.substring(0,60)),this._doNotHandleContextLost||(rt._extension=ae,rt._files=_);const Tt=pe;this._transformTextureUrl&&!Le&&(pe=this._transformTextureUrl(pe));const Lt=pe.split("?")[0],Nt=Lt.lastIndexOf("."),qt=ae||(Nt>-1?Lt.substring(Nt).toLowerCase():"");let Xt=null;for(const Gt of sr._TextureLoaders)if(Gt.canLoad(qt)){Xt=Gt;break}const zt=(Gt,xi)=>{pe===Tt?Z&&Gt&&Z(Gt.status+" "+Gt.statusText,xi):(Ti.Warn(`Failed to load ${pe}, falling back to the ${Tt}`),this.createCubeTextureBase(Tt,p,_,!!E,I,Z,re,ae,he,_e,ve,rt,ze,He,xt))};if(Xt){const Gt=xi=>{ze&&ze(rt,xi),Xt.loadCubeData(xi,rt,he,I,Z)};_&&_.length===6?Xt.supportCascades?this._cascadeLoadFiles(p,xi=>Gt(xi.map(Gi=>new Uint8Array(Gi))),_,Z):Z?Z("Textures type does not support cascades."):Ti.Warn("Texture loader does not support cascades."):this._loadFile(pe,xi=>Gt(new Uint8Array(xi)),void 0,void 0,!0,zt)}else{if(!_||_.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(p,rt,(Gt,xi)=>{He&&He(Gt,xi)},_,Z)}return this._internalTexturesCache.push(rt),rt},sr.prototype.createCubeTexture=function(pe,p,_,E,I=null,Z=null,re,ae=null,he=!1,_e=0,ve=0,Le=null,ze,He=!1){const xt=this._gl;return this.createCubeTextureBase(pe,p,_,!!E,I,Z,re,ae,he,_e,ve,Le,rt=>this._bindTextureDirectly(xt.TEXTURE_CUBE_MAP,rt,!0),(rt,Tt)=>{const Lt=this.needPOTTextures?sr.GetExponentOfTwo(Tt[0].width,this._caps.maxCubemapTextureSize):Tt[0].width,Nt=Lt,qt=[xt.TEXTURE_CUBE_MAP_POSITIVE_X,xt.TEXTURE_CUBE_MAP_POSITIVE_Y,xt.TEXTURE_CUBE_MAP_POSITIVE_Z,xt.TEXTURE_CUBE_MAP_NEGATIVE_X,xt.TEXTURE_CUBE_MAP_NEGATIVE_Y,xt.TEXTURE_CUBE_MAP_NEGATIVE_Z];this._bindTextureDirectly(xt.TEXTURE_CUBE_MAP,rt,!0),this._unpackFlipY(!1);const Xt=re?this._getInternalFormat(re,rt._useSRGBBuffer):rt._useSRGBBuffer?this._glSRGBExtensionValues.SRGB8_ALPHA8:xt.RGBA;let zt=re?this._getInternalFormat(re):xt.RGBA;rt._useSRGBBuffer&&this.webGLVersion===1&&(zt=Xt);for(let Gt=0;Gt<qt.length;Gt++)if(Tt[Gt].width!==Lt||Tt[Gt].height!==Nt){if(this._prepareWorkingCanvas(),!this._workingCanvas||!this._workingContext){Ti.Warn("Cannot create canvas to resize texture.");return}this._workingCanvas.width=Lt,this._workingCanvas.height=Nt,this._workingContext.drawImage(Tt[Gt],0,0,Tt[Gt].width,Tt[Gt].height,0,0,Lt,Nt),xt.texImage2D(qt[Gt],0,Xt,zt,xt.UNSIGNED_BYTE,this._workingCanvas)}else xt.texImage2D(qt[Gt],0,Xt,zt,xt.UNSIGNED_BYTE,Tt[Gt]);E||xt.generateMipmap(xt.TEXTURE_CUBE_MAP),this._setCubeMapTextureParams(rt,!E),rt.width=Lt,rt.height=Nt,rt.isReady=!0,re&&(rt.format=re),rt.onLoadedObservable.notifyObservers(rt),rt.onLoadedObservable.clear(),I&&I()},!!He)};class Rx extends na{set boundingBoxSize(p){if(this._boundingBoxSize&&this._boundingBoxSize.equals(p))return;this._boundingBoxSize=p;const _=this.getScene();_&&_.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}set rotationY(p){this._rotationY=p,this.setReflectionTextureMatrix(jt.RotationY(this._rotationY))}get rotationY(){return this._rotationY}get noMipmap(){return this._noMipmap}get forcedExtension(){return this._forcedExtension}static CreateFromImages(p,_,E){let I="";return p.forEach(Z=>I+=Z),new Rx(I,_,null,E,p)}static CreateFromPrefilteredData(p,_,E=null,I=!0){const Z=_.useDelayedTextureLoading;_.useDelayedTextureLoading=!1;const re=new Rx(p,_,null,!1,null,null,null,void 0,!0,E,I);return _.useDelayedTextureLoading=Z,re}constructor(p,_,E=null,I=!1,Z=null,re=null,ae=null,he=5,_e=!1,ve=null,Le=!1,ze=.8,He=0,xt,rt){super(_),this._lodScale=.8,this._lodOffset=0,this.onLoadObservable=new Ri,this.boundingBoxPosition=at.Zero(),this._rotationY=0,this._files=null,this._forcedExtension=null,this._extensions=null,this._textureMatrixRefraction=new jt,this.name=p,this.url=p,this._noMipmap=I,this.hasAlpha=!1,this._format=he,this.isCube=!0,this._textureMatrix=jt.Identity(),this._createPolynomials=Le,this.coordinatesMode=Ki.CUBIC_MODE,this._extensions=E,this._files=Z,this._forcedExtension=ve,this._loaderOptions=xt,this._useSRGBBuffer=rt,this._lodScale=ze,this._lodOffset=He,!(!p&&!Z)&&this.updateURL(p,ve,re,_e,ae,E,this.getScene()?.useDelayedTextureLoading,Z)}getClassName(){return"CubeTexture"}updateURL(p,_,E=null,I=!1,Z=null,re=null,ae=!1,he=null){(!this.name||this.name.startsWith("data:"))&&(this.name=p),this.url=p,_&&(this._forcedExtension=_);const _e=p.lastIndexOf("."),ve=_||(_e>-1?p.substring(_e).toLowerCase():""),Le=ve.indexOf(".dds")===0,ze=ve.indexOf(".env")===0,He=ve.indexOf(".basis")===0;if(ze?(this.gammaSpace=!1,this._prefiltered=!1,this.anisotropicFilteringLevel=1):(this._prefiltered=I,I&&(this.gammaSpace=!1,this.anisotropicFilteringLevel=1)),he)this._files=he;else if(!He&&!ze&&!Le&&!re&&(re=["_px.jpg","_py.jpg","_pz.jpg","_nx.jpg","_ny.jpg","_nz.jpg"]),this._files=this._files||[],this._files.length=0,re){for(let xt=0;xt<re.length;xt++)this._files.push(p+re[xt]);this._extensions=re}ae?(this.delayLoadState=4,this._delayedOnLoad=E,this._delayedOnError=Z):this._loadTexture(E,Z)}delayLoad(p){this.delayLoadState===4&&(p&&(this._forcedExtension=p),this.delayLoadState=1,this._loadTexture(this._delayedOnLoad,this._delayedOnError))}getReflectionTextureMatrix(){return this._textureMatrix}setReflectionTextureMatrix(p){if(p.updateFlag===this._textureMatrix.updateFlag||(p.isIdentity()!==this._textureMatrix.isIdentity()&&this.getScene()?.markAllMaterialsAsDirty(1,Z=>Z.getActiveTextures().indexOf(this)!==-1),this._textureMatrix=p,!this.getScene()?.useRightHandedSystem))return;const _=ui.Vector3[0],E=ui.Quaternion[0],I=ui.Vector3[1];this._textureMatrix.decompose(_,E,I),E.z*=-1,E.w*=-1,jt.ComposeToRef(_,E,I,this._textureMatrixRefraction)}getRefractionTextureMatrix(){return this.getScene()?.useRightHandedSystem?this._textureMatrixRefraction:this._textureMatrix}_loadTexture(p=null,_=null){const E=this.getScene(),I=this._texture;this._texture=this._getFromCache(this.url,this._noMipmap,void 0,void 0,this._useSRGBBuffer,this.isCube);const Z=()=>{this.onLoadObservable.notifyObservers(this),I&&(I.dispose(),this.getScene()?.markAllMaterialsAsDirty(1)),p&&p()},re=(ae,he)=>{this._loadingError=!0,this._errorObject={message:ae,exception:he},_&&_(ae,he),Ki.OnTextureLoadErrorObservable.notifyObservers(this)};this._texture?this._texture.isReady?lt.SetImmediate(()=>Z()):this._texture.onLoadedObservable.add(()=>Z()):(this._prefiltered?this._texture=this._getEngine().createPrefilteredCubeTexture(this.url,E,this._lodScale,this._lodOffset,p,re,this._format,this._forcedExtension,this._createPolynomials):this._texture=this._getEngine().createCubeTexture(this.url,E,this._files,this._noMipmap,p,re,this._format,this._forcedExtension,!1,this._lodScale,this._lodOffset,null,this._loaderOptions,!!this._useSRGBBuffer),this._texture?.onLoadedObservable.add(()=>this.onLoadObservable.notifyObservers(this)))}static Parse(p,_,E){const I=Hr.Parse(()=>{let Z=!1;return p.prefiltered&&(Z=p.prefiltered),new Rx(E+(p.url??p.name),_,p.extensions,!1,p.files||null,null,null,void 0,Z,p.forcedExtension)},p,_);if(p.boundingBoxPosition&&(I.boundingBoxPosition=at.FromArray(p.boundingBoxPosition)),p.boundingBoxSize&&(I.boundingBoxSize=at.FromArray(p.boundingBoxSize)),p.animations)for(let Z=0;Z<p.animations.length;Z++){const re=p.animations[Z],ae=r0("BABYLON.Animation");ae&&I.animations.push(ae.Parse(re))}return I}clone(){let p=0;const _=Hr.Clone(()=>{const E=new Rx(this.url,this.getScene()||this._getEngine(),this._extensions,this._noMipmap,this._files);return p=E.uniqueId,E},this);return _.uniqueId=p,_}}Rt([Ut()],Rx.prototype,"url",void 0),Rt([Yn()],Rx.prototype,"boundingBoxPosition",void 0),Rt([Yn()],Rx.prototype,"boundingBoxSize",null),Rt([Ut("rotationY")],Rx.prototype,"rotationY",null),Rt([Ut("files")],Rx.prototype,"_files",void 0),Rt([Ut("forcedExtension")],Rx.prototype,"_forcedExtension",void 0),Rt([Ut("extensions")],Rx.prototype,"_extensions",void 0),Rt([Uy("textureMatrix")],Rx.prototype,"_textureMatrix",void 0),Rt([Uy("textureMatrixRefraction")],Rx.prototype,"_textureMatrixRefraction",void 0),Ki._CubeTextureParser=Rx.Parse,Gs("BABYLON.CubeTexture",Rx);class un extends Ha{get range(){return this._range}set range(p){this._range=p,this._inverseSquaredRange=1/(this.range*this.range)}get intensityMode(){return this._intensityMode}set intensityMode(p){this._intensityMode=p,this._computePhotometricScale()}get radius(){return this._radius}set radius(p){this._radius=p,this._computePhotometricScale()}get shadowEnabled(){return this._shadowEnabled}set shadowEnabled(p){this._shadowEnabled!==p&&(this._shadowEnabled=p,this._markMeshesAsLightDirty())}get includedOnlyMeshes(){return this._includedOnlyMeshes}set includedOnlyMeshes(p){this._includedOnlyMeshes=p,this._hookArrayForIncludedOnly(p)}get excludedMeshes(){return this._excludedMeshes}set excludedMeshes(p){this._excludedMeshes=p,this._hookArrayForExcluded(p)}get excludeWithLayerMask(){return this._excludeWithLayerMask}set excludeWithLayerMask(p){this._excludeWithLayerMask=p,this._resyncMeshes()}get includeOnlyWithLayerMask(){return this._includeOnlyWithLayerMask}set includeOnlyWithLayerMask(p){this._includeOnlyWithLayerMask=p,this._resyncMeshes()}get lightmapMode(){return this._lightmapMode}set lightmapMode(p){this._lightmapMode!==p&&(this._lightmapMode=p,this._markMeshesAsLightDirty())}getViewMatrix(p){return null}getProjectionMatrix(p,_){return null}constructor(p,_){super(p,_),this.diffuse=new Rs(1,1,1),this.specular=new Rs(1,1,1),this.falloffType=un.FALLOFF_DEFAULT,this.intensity=1,this._range=Number.MAX_VALUE,this._inverseSquaredRange=0,this._photometricScale=1,this._intensityMode=un.INTENSITYMODE_AUTOMATIC,this._radius=1e-5,this.renderPriority=0,this._shadowEnabled=!0,this._excludeWithLayerMask=0,this._includeOnlyWithLayerMask=0,this._lightmapMode=0,this._shadowGenerators=null,this._excludedMeshesIds=new Array,this._includedOnlyMeshesIds=new Array,this._isLight=!0,this.getScene().addLight(this),this._uniformBuffer=new qs(this.getScene().getEngine(),void 0,void 0,p),this._buildUniformLayout(),this.includedOnlyMeshes=[],this.excludedMeshes=[],this._resyncMeshes()}transferTexturesToEffect(p,_){return this}_bindLight(p,_,E,I,Z=!0){const re=p.toString();let ae=!1;if(this._uniformBuffer.bindToEffect(E,"Light"+re),this._renderId!==_.getRenderId()||this._lastUseSpecular!==I||!this._uniformBuffer.useUbo){this._renderId=_.getRenderId(),this._lastUseSpecular=I;const he=this.getScaledIntensity();this.transferToEffect(E,re),this.diffuse.scaleToRef(he,jn.Color3[0]),this._uniformBuffer.updateColor4("vLightDiffuse",jn.Color3[0],this.range,re),I&&(this.specular.scaleToRef(he,jn.Color3[1]),this._uniformBuffer.updateColor4("vLightSpecular",jn.Color3[1],this.radius,re)),ae=!0}if(this.transferTexturesToEffect(E,re),_.shadowsEnabled&&this.shadowEnabled&&Z){const he=this.getShadowGenerator(_.activeCamera)??this.getShadowGenerator();he&&(he.bindShadowLight(re,E),ae=!0)}ae?this._uniformBuffer.update():this._uniformBuffer.bindUniformBuffer()}getClassName(){return"Light"}toString(p){let _="Name: "+this.name;if(_+=", type: "+["Point","Directional","Spot","Hemispheric"][this.getTypeID()],this.animations)for(let E=0;E<this.animations.length;E++)_+=", animation[0]: "+this.animations[E].toString(p);return _}_syncParentEnabledState(){super._syncParentEnabledState(),this.isDisposed()||this._resyncMeshes()}setEnabled(p){super.setEnabled(p),this._resyncMeshes()}getShadowGenerator(p=null){return this._shadowGenerators===null?null:this._shadowGenerators.get(p)??null}getShadowGenerators(){return this._shadowGenerators}getAbsolutePosition(){return at.Zero()}canAffectMesh(p){return p?!(this.includedOnlyMeshes&&this.includedOnlyMeshes.length>0&&this.includedOnlyMeshes.indexOf(p)===-1||this.excludedMeshes&&this.excludedMeshes.length>0&&this.excludedMeshes.indexOf(p)!==-1||this.includeOnlyWithLayerMask!==0&&!(this.includeOnlyWithLayerMask&p.layerMask)||this.excludeWithLayerMask!==0&&this.excludeWithLayerMask&p.layerMask):!0}dispose(p,_=!1){if(this._shadowGenerators){const E=this._shadowGenerators.values();for(let I=E.next();I.done!==!0;I=E.next())I.value.dispose();this._shadowGenerators=null}if(this.getScene().stopAnimation(this),this._parentContainer){const E=this._parentContainer.lights.indexOf(this);E>-1&&this._parentContainer.lights.splice(E,1),this._parentContainer=null}for(const E of this.getScene().meshes)E._removeLightSource(this,!0);this._uniformBuffer.dispose(),this.getScene().removeLight(this),super.dispose(p,_)}getTypeID(){return 0}getScaledIntensity(){return this._photometricScale*this.intensity}clone(p,_=null){const E=un.GetConstructorFromName(this.getTypeID(),p,this.getScene());if(!E)return null;const I=Hr.Clone(E,this);return p&&(I.name=p),_&&(I.parent=_),I.setEnabled(this.isEnabled()),this.onClonedObservable.notifyObservers(I),I}serialize(){const p=Hr.Serialize(this);return p.uniqueId=this.uniqueId,p.type=this.getTypeID(),this.parent&&this.parent._serializeAsParent(p),this.excludedMeshes.length>0&&(p.excludedMeshesIds=[],this.excludedMeshes.forEach(_=>{p.excludedMeshesIds.push(_.id)})),this.includedOnlyMeshes.length>0&&(p.includedOnlyMeshesIds=[],this.includedOnlyMeshes.forEach(_=>{p.includedOnlyMeshesIds.push(_.id)})),Hr.AppendSerializedAnimations(this,p),p.ranges=this.serializeAnimationRanges(),p.isEnabled=this.isEnabled(),p}static GetConstructorFromName(p,_,E){const I=Ha.Construct("Light_Type_"+p,_,E);return I||null}static Parse(p,_){const E=un.GetConstructorFromName(p.type,p.name,_);if(!E)return null;const I=Hr.Parse(E,p,_);if(p.excludedMeshesIds&&(I._excludedMeshesIds=p.excludedMeshesIds),p.includedOnlyMeshesIds&&(I._includedOnlyMeshesIds=p.includedOnlyMeshesIds),p.parentId!==void 0&&(I._waitingParentId=p.parentId),p.parentInstanceIndex!==void 0&&(I._waitingParentInstanceIndex=p.parentInstanceIndex),p.falloffType!==void 0&&(I.falloffType=p.falloffType),p.lightmapMode!==void 0&&(I.lightmapMode=p.lightmapMode),p.animations){for(let Z=0;Z<p.animations.length;Z++){const re=p.animations[Z],ae=r0("BABYLON.Animation");ae&&I.animations.push(ae.Parse(re))}Ha.ParseAnimationRanges(I,p,_)}return p.autoAnimate&&_.beginAnimation(I,p.autoAnimateFrom,p.autoAnimateTo,p.autoAnimateLoop,p.autoAnimateSpeed||1),p.isEnabled!==void 0&&I.setEnabled(p.isEnabled),I}_hookArrayForExcluded(p){const _=p.push;p.push=(...I)=>{const Z=_.apply(p,I);for(const re of I)re._resyncLightSource(this);return Z};const E=p.splice;p.splice=(I,Z)=>{const re=E.apply(p,[I,Z]);for(const ae of re)ae._resyncLightSource(this);return re};for(const I of p)I._resyncLightSource(this)}_hookArrayForIncludedOnly(p){const _=p.push;p.push=(...I)=>{const Z=_.apply(p,I);return this._resyncMeshes(),Z};const E=p.splice;p.splice=(I,Z)=>{const re=E.apply(p,[I,Z]);return this._resyncMeshes(),re},this._resyncMeshes()}_resyncMeshes(){for(const p of this.getScene().meshes)p._resyncLightSource(this)}_markMeshesAsLightDirty(){for(const p of this.getScene().meshes)p.lightSources.indexOf(this)!==-1&&p._markSubMeshesAsLightDirty()}_computePhotometricScale(){this._photometricScale=this._getPhotometricScale(),this.getScene().resetCachedMaterial()}_getPhotometricScale(){let p=0;const _=this.getTypeID();let E=this.intensityMode;switch(E===un.INTENSITYMODE_AUTOMATIC&&(_===un.LIGHTTYPEID_DIRECTIONALLIGHT?E=un.INTENSITYMODE_ILLUMINANCE:E=un.INTENSITYMODE_LUMINOUSINTENSITY),_){case un.LIGHTTYPEID_POINTLIGHT:case un.LIGHTTYPEID_SPOTLIGHT:switch(E){case un.INTENSITYMODE_LUMINOUSPOWER:p=1/(4*Math.PI);break;case un.INTENSITYMODE_LUMINOUSINTENSITY:p=1;break;case un.INTENSITYMODE_LUMINANCE:p=this.radius*this.radius;break}break;case un.LIGHTTYPEID_DIRECTIONALLIGHT:switch(E){case un.INTENSITYMODE_ILLUMINANCE:p=1;break;case un.INTENSITYMODE_LUMINANCE:{let I=this.radius;I=Math.max(I,.001),p=2*Math.PI*(1-Math.cos(I));break}}break;case un.LIGHTTYPEID_HEMISPHERICLIGHT:p=1;break}return p}_reorderLightsInScene(){const p=this.getScene();this._renderPriority!=0&&(p.requireLightSorting=!0),this.getScene().sortLightsByPriority()}}un.FALLOFF_DEFAULT=Kn.FALLOFF_DEFAULT,un.FALLOFF_PHYSICAL=Kn.FALLOFF_PHYSICAL,un.FALLOFF_GLTF=Kn.FALLOFF_GLTF,un.FALLOFF_STANDARD=Kn.FALLOFF_STANDARD,un.LIGHTMAP_DEFAULT=Kn.LIGHTMAP_DEFAULT,un.LIGHTMAP_SPECULAR=Kn.LIGHTMAP_SPECULAR,un.LIGHTMAP_SHADOWSONLY=Kn.LIGHTMAP_SHADOWSONLY,un.INTENSITYMODE_AUTOMATIC=Kn.INTENSITYMODE_AUTOMATIC,un.INTENSITYMODE_LUMINOUSPOWER=Kn.INTENSITYMODE_LUMINOUSPOWER,un.INTENSITYMODE_LUMINOUSINTENSITY=Kn.INTENSITYMODE_LUMINOUSINTENSITY,un.INTENSITYMODE_ILLUMINANCE=Kn.INTENSITYMODE_ILLUMINANCE,un.INTENSITYMODE_LUMINANCE=Kn.INTENSITYMODE_LUMINANCE,un.LIGHTTYPEID_POINTLIGHT=Kn.LIGHTTYPEID_POINTLIGHT,un.LIGHTTYPEID_DIRECTIONALLIGHT=Kn.LIGHTTYPEID_DIRECTIONALLIGHT,un.LIGHTTYPEID_SPOTLIGHT=Kn.LIGHTTYPEID_SPOTLIGHT,un.LIGHTTYPEID_HEMISPHERICLIGHT=Kn.LIGHTTYPEID_HEMISPHERICLIGHT,Rt([Ya()],un.prototype,"diffuse",void 0),Rt([Ya()],un.prototype,"specular",void 0),Rt([Ut()],un.prototype,"falloffType",void 0),Rt([Ut()],un.prototype,"intensity",void 0),Rt([Ut()],un.prototype,"range",null),Rt([Ut()],un.prototype,"intensityMode",null),Rt([Ut()],un.prototype,"radius",null),Rt([Ut()],un.prototype,"_renderPriority",void 0),Rt([ws("_reorderLightsInScene")],un.prototype,"renderPriority",void 0),Rt([Ut("shadowEnabled")],un.prototype,"_shadowEnabled",void 0),Rt([Ut("excludeWithLayerMask")],un.prototype,"_excludeWithLayerMask",void 0),Rt([Ut("includeOnlyWithLayerMask")],un.prototype,"_includeOnlyWithLayerMask",void 0),Rt([Ut("lightmapMode")],un.prototype,"_lightmapMode",void 0);class Xc extends un{constructor(){super(...arguments),this._needProjectionMatrixCompute=!0,this._viewMatrix=jt.Identity(),this._projectionMatrix=jt.Identity()}_setPosition(p){this._position=p}get position(){return this._position}set position(p){this._setPosition(p)}_setDirection(p){this._direction=p}get direction(){return this._direction}set direction(p){this._setDirection(p)}get shadowMinZ(){return this._shadowMinZ}set shadowMinZ(p){this._shadowMinZ=p,this.forceProjectionMatrixCompute()}get shadowMaxZ(){return this._shadowMaxZ}set shadowMaxZ(p){this._shadowMaxZ=p,this.forceProjectionMatrixCompute()}computeTransformedInformation(){return this.parent&&this.parent.getWorldMatrix?(this.transformedPosition||(this.transformedPosition=at.Zero()),at.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this.transformedPosition),this.direction&&(this.transformedDirection||(this.transformedDirection=at.Zero()),at.TransformNormalToRef(this.direction,this.parent.getWorldMatrix(),this.transformedDirection)),!0):!1}getDepthScale(){return 50}getShadowDirection(p){return this.transformedDirection?this.transformedDirection:this.direction}getAbsolutePosition(){return this.transformedPosition?this.transformedPosition:this.position}setDirectionToTarget(p){return this.direction=at.Normalize(p.subtract(this.position)),this.direction}getRotation(){this.direction.normalize();const p=at.Cross(this.direction,Gc.Y),_=at.Cross(p,this.direction);return at.RotationFromAxis(p,_,this.direction)}needCube(){return!1}needProjectionMatrixCompute(){return this._needProjectionMatrixCompute}forceProjectionMatrixCompute(){this._needProjectionMatrixCompute=!0}_initCache(){super._initCache(),this._cache.position=at.Zero()}_isSynchronized(){return!!this._cache.position.equals(this.position)}computeWorldMatrix(p){return!p&&this.isSynchronized()?(this._currentRenderId=this.getScene().getRenderId(),this._worldMatrix):(this._updateCache(),this._cache.position.copyFrom(this.position),this._worldMatrix||(this._worldMatrix=jt.Identity()),jt.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this.parent&&this.parent.getWorldMatrix&&(this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(),this._worldMatrix),this._markSyncedWithParent()),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix)}getDepthMinZ(p){return this.shadowMinZ!==void 0?this.shadowMinZ:p.minZ}getDepthMaxZ(p){return this.shadowMaxZ!==void 0?this.shadowMaxZ:p.maxZ}setShadowProjectionMatrix(p,_,E){return this.customProjectionMatrixBuilder?this.customProjectionMatrixBuilder(_,E,p):this._setDefaultShadowProjectionMatrix(p,_,E),this}_syncParentEnabledState(){super._syncParentEnabledState(),(!this.parent||!this.parent.getWorldMatrix)&&(this.transformedPosition=null,this.transformedDirection=null)}getViewMatrix(p){const _=ui.Vector3[0];let E=this.position;this.computeTransformedInformation()&&(E=this.transformedPosition),at.NormalizeToRef(this.getShadowDirection(p),_),Math.abs(at.Dot(_,at.Up()))===1&&(_.z=1e-13);const I=ui.Vector3[1];return E.addToRef(_,I),jt.LookAtLHToRef(E,I,at.Up(),this._viewMatrix),this._viewMatrix}getProjectionMatrix(p,_){return this.setShadowProjectionMatrix(this._projectionMatrix,p??this._viewMatrix,_??[]),this._projectionMatrix}}Rt([Yn()],Xc.prototype,"position",null),Rt([Yn()],Xc.prototype,"direction",null),Rt([Ut()],Xc.prototype,"shadowMinZ",null),Rt([Ut()],Xc.prototype,"shadowMaxZ",null),Ha.AddNodeConstructor("Light_Type_1",(pe,p)=>()=>new W2(pe,at.Zero(),p));class W2 extends Xc{get shadowFrustumSize(){return this._shadowFrustumSize}set shadowFrustumSize(p){this._shadowFrustumSize=p,this.forceProjectionMatrixCompute()}get shadowOrthoScale(){return this._shadowOrthoScale}set shadowOrthoScale(p){this._shadowOrthoScale=p,this.forceProjectionMatrixCompute()}get orthoLeft(){return this._orthoLeft}set orthoLeft(p){this._orthoLeft=p}get orthoRight(){return this._orthoRight}set orthoRight(p){this._orthoRight=p}get orthoTop(){return this._orthoTop}set orthoTop(p){this._orthoTop=p}get orthoBottom(){return this._orthoBottom}set orthoBottom(p){this._orthoBottom=p}constructor(p,_,E){super(p,E),this._shadowFrustumSize=0,this._shadowOrthoScale=.1,this.autoUpdateExtends=!0,this.autoCalcShadowZBounds=!1,this._orthoLeft=Number.MAX_VALUE,this._orthoRight=Number.MIN_VALUE,this._orthoTop=Number.MIN_VALUE,this._orthoBottom=Number.MAX_VALUE,this.position=_.scale(-1),this.direction=_}getClassName(){return"DirectionalLight"}getTypeID(){return un.LIGHTTYPEID_DIRECTIONALLIGHT}_setDefaultShadowProjectionMatrix(p,_,E){this.shadowFrustumSize>0?this._setDefaultFixedFrustumShadowProjectionMatrix(p):this._setDefaultAutoExtendShadowProjectionMatrix(p,_,E)}_setDefaultFixedFrustumShadowProjectionMatrix(p){const _=this.getScene().activeCamera;_&&jt.OrthoLHToRef(this.shadowFrustumSize,this.shadowFrustumSize,this.shadowMinZ!==void 0?this.shadowMinZ:_.minZ,this.shadowMaxZ!==void 0?this.shadowMaxZ:_.maxZ,p,this.getScene().getEngine().isNDCHalfZRange)}_setDefaultAutoExtendShadowProjectionMatrix(p,_,E){const I=this.getScene().activeCamera;if(!I)return;if(this.autoUpdateExtends||this._orthoLeft===Number.MAX_VALUE){const ve=at.Zero();this._orthoLeft=Number.MAX_VALUE,this._orthoRight=-Number.MAX_VALUE,this._orthoTop=-Number.MAX_VALUE,this._orthoBottom=Number.MAX_VALUE;let Le=Number.MAX_VALUE,ze=-Number.MAX_VALUE;for(let He=0;He<E.length;He++){const xt=E[He];if(!xt)continue;const Tt=xt.getBoundingInfo().boundingBox;for(let Lt=0;Lt<Tt.vectorsWorld.length;Lt++)at.TransformCoordinatesToRef(Tt.vectorsWorld[Lt],_,ve),ve.x<this._orthoLeft&&(this._orthoLeft=ve.x),ve.y<this._orthoBottom&&(this._orthoBottom=ve.y),ve.x>this._orthoRight&&(this._orthoRight=ve.x),ve.y>this._orthoTop&&(this._orthoTop=ve.y),this.autoCalcShadowZBounds&&(ve.z<Le&&(Le=ve.z),ve.z>ze&&(ze=ve.z))}this.autoCalcShadowZBounds&&(this._shadowMinZ=Le,this._shadowMaxZ=ze)}const Z=this._orthoRight-this._orthoLeft,re=this._orthoTop-this._orthoBottom,ae=this.shadowMinZ!==void 0?this.shadowMinZ:I.minZ,he=this.shadowMaxZ!==void 0?this.shadowMaxZ:I.maxZ,_e=this.getScene().getEngine().useReverseDepthBuffer;jt.OrthoOffCenterLHToRef(this._orthoLeft-Z*this.shadowOrthoScale,this._orthoRight+Z*this.shadowOrthoScale,this._orthoBottom-re*this.shadowOrthoScale,this._orthoTop+re*this.shadowOrthoScale,_e?he:ae,_e?ae:he,p,this.getScene().getEngine().isNDCHalfZRange)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(p,_){return this.computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z,1,_),this):(this._uniformBuffer.updateFloat4("vLightData",this.direction.x,this.direction.y,this.direction.z,1,_),this)}transferToNodeMaterialEffect(p,_){return this.computeTransformedInformation()?(p.setFloat3(_,this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z),this):(p.setFloat3(_,this.direction.x,this.direction.y,this.direction.z),this)}getDepthMinZ(p){const _=this._scene.getEngine();return!_.useReverseDepthBuffer&&_.isNDCHalfZRange?0:1}getDepthMaxZ(p){const _=this._scene.getEngine();return _.useReverseDepthBuffer&&_.isNDCHalfZRange?0:1}prepareLightSpecificDefines(p,_){p["DIRLIGHT"+_]=!0}}Rt([Ut()],W2.prototype,"shadowFrustumSize",null),Rt([Ut()],W2.prototype,"shadowOrthoScale",null),Rt([Ut()],W2.prototype,"autoUpdateExtends",void 0),Rt([Ut()],W2.prototype,"autoCalcShadowZBounds",void 0),Rt([Ut("orthoLeft")],W2.prototype,"_orthoLeft",void 0),Rt([Ut("orthoRight")],W2.prototype,"_orthoRight",void 0),Rt([Ut("orthoTop")],W2.prototype,"_orthoTop",void 0),Rt([Ut("orthoBottom")],W2.prototype,"_orthoBottom",void 0);class R0{static get ForceFullSceneLoadingForIncremental(){return R0._ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(p){R0._ForceFullSceneLoadingForIncremental=p}static get ShowLoadingScreen(){return R0._ShowLoadingScreen}static set ShowLoadingScreen(p){R0._ShowLoadingScreen=p}static get loggingLevel(){return R0._LoggingLevel}static set loggingLevel(p){R0._LoggingLevel=p}static get CleanBoneMatrixWeights(){return R0._CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(p){R0._CleanBoneMatrixWeights=p}}R0._ForceFullSceneLoadingForIncremental=!1,R0._ShowLoadingScreen=!0,R0._CleanBoneMatrixWeights=!1,R0._LoggingLevel=0;var Yh;(function(pe){pe[pe.Clean=0]="Clean",pe[pe.Stop=1]="Stop",pe[pe.Sync=2]="Sync",pe[pe.NoSync=3]="NoSync"})(Yh||(Yh={}));class wn{static get ForceFullSceneLoadingForIncremental(){return R0.ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(p){R0.ForceFullSceneLoadingForIncremental=p}static get ShowLoadingScreen(){return R0.ShowLoadingScreen}static set ShowLoadingScreen(p){R0.ShowLoadingScreen=p}static get loggingLevel(){return R0.loggingLevel}static set loggingLevel(p){R0.loggingLevel=p}static get CleanBoneMatrixWeights(){return R0.CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(p){R0.CleanBoneMatrixWeights=p}static GetDefaultPlugin(){return wn._RegisteredPlugins[".babylon"]}static _GetPluginForExtension(p){const _=wn._RegisteredPlugins[p];return _||(Ti.Warn("Unable to find a plugin to load "+p+" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes"),wn.GetDefaultPlugin())}static _GetPluginForDirectLoad(p){for(const _ in wn._RegisteredPlugins){const E=wn._RegisteredPlugins[_].plugin;if(E.canDirectLoad&&E.canDirectLoad(p))return wn._RegisteredPlugins[_]}return wn.GetDefaultPlugin()}static _GetPluginForFilename(p){const _=p.indexOf("?");_!==-1&&(p=p.substring(0,_));const E=p.lastIndexOf("."),I=p.substring(E,p.length).toLowerCase();return wn._GetPluginForExtension(I)}static _GetDirectLoad(p){return p.substr(0,5)==="data:"?p.substr(5):null}static _FormatErrorMessage(p,_,E){let Z="Unable to load from "+(p.rawData?"binary data":p.url);return _?Z+=`: ${_}`:E&&(Z+=`: ${E}`),Z}static _LoadData(p,_,E,I,Z,re,ae,he){const _e=wn._GetDirectLoad(p.url);if(p.rawData&&!ae)throw"When using ArrayBufferView to load data the file extension must be provided.";const ve=ae?wn._GetPluginForExtension(ae):_e?wn._GetPluginForDirectLoad(p.url):wn._GetPluginForFilename(p.url);if(p.rawData&&!ve.isBinary)throw"Loading from ArrayBufferView can not be used with plugins that don't support binary loading.";let Le;if(ve.plugin.createPlugin!==void 0?Le=ve.plugin.createPlugin():Le=ve.plugin,!Le)throw"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";if(wn.OnPluginActivatedObservable.notifyObservers(Le),_e&&(Le.canDirectLoad&&Le.canDirectLoad(p.url)||!R2(p.url))){if(Le.directLoad){const Xt=Le.directLoad(_,_e);Xt.then?Xt.then(zt=>{E(Le,zt)}).catch(zt=>{Z("Error in directLoad of _loadData: "+zt,zt)}):E(Le,Xt)}else E(Le,_e);return Le}const ze=ve.isBinary,He=(Xt,zt)=>{if(_.isDisposed){Z("Scene has been disposed");return}E(Le,Xt,zt)};let xt=null,rt=!1;const Tt=Le.onDisposeObservable;Tt&&Tt.add(()=>{rt=!0,xt&&(xt.abort(),xt=null),re()});const Lt=()=>{if(rt)return;const Xt=(zt,Gt)=>{Z(zt?.statusText,Gt)};if(!Le.loadFile&&p.rawData)throw"Plugin does not support loading ArrayBufferView.";xt=Le.loadFile?Le.loadFile(_,p.rawData||p.file||p.url,p.rootUrl,He,I,ze,Xt,he):_._loadFile(p.file||p.url,He,I,!0,ze,Xt)},Nt=_.getEngine();let qt=Nt.enableOfflineSupport;if(qt){let Xt=!1;for(const zt of _.disableOfflineSupportExceptionRules)if(zt.test(p.url)){Xt=!0;break}qt=!Xt}return qt&&ci.OfflineProviderFactory?_.offlineProvider=ci.OfflineProviderFactory(p.url,Lt,Nt.disableManifestCheck):Lt(),Le}static _GetFileInfo(p,_){let E,I,Z=null,re=null;if(!_)E=p,I=lt.GetFilename(p),p=lt.GetFolderPath(p);else if(_.name){const ae=_;E=`file:${ae.name}`,I=ae.name,Z=ae}else if(ArrayBuffer.isView(_))E="",I="arrayBuffer",re=_;else if(typeof _=="string"&&_.startsWith("data:"))E=_,I="";else{const ae=_;if(ae.substr(0,1)==="/")return lt.Error("Wrong sceneFilename parameter"),null;E=p+ae,I=ae}return{url:E,rootUrl:p,name:I,file:Z,rawData:re}}static GetPluginForExtension(p){return wn._GetPluginForExtension(p).plugin}static IsPluginForExtensionAvailable(p){return!!wn._RegisteredPlugins[p]}static RegisterPlugin(p){if(typeof p.extensions=="string"){const _=p.extensions;wn._RegisteredPlugins[_.toLowerCase()]={plugin:p,isBinary:!1}}else{const _=p.extensions;Object.keys(_).forEach(E=>{wn._RegisteredPlugins[E.toLowerCase()]={plugin:p,isBinary:_[E].isBinary}})}}static ImportMesh(p,_,E="",I=Mr.LastCreatedScene,Z=null,re=null,ae=null,he=null,_e=""){if(!I)return Ti.Error("No scene available to import mesh to"),null;const ve=wn._GetFileInfo(_,E);if(!ve)return null;const Le={};I.addPendingData(Le);const ze=()=>{I.removePendingData(Le)},He=(Tt,Lt)=>{const Nt=wn._FormatErrorMessage(ve,Tt,Lt);ae?ae(I,Nt,new Hx(Nt,Wx.SceneLoaderError,Lt)):Ti.Error(Nt),ze()},xt=re?Tt=>{try{re(Tt)}catch(Lt){He("Error in onProgress callback: "+Lt,Lt)}}:void 0,rt=(Tt,Lt,Nt,qt,Xt,zt,Gt)=>{if(I.importedMeshesFiles.push(ve.url),Z)try{Z(Tt,Lt,Nt,qt,Xt,zt,Gt)}catch(xi){He("Error in onSuccess callback: "+xi,xi)}I.removePendingData(Le)};return wn._LoadData(ve,I,(Tt,Lt,Nt)=>{if(Tt.rewriteRootURL&&(ve.rootUrl=Tt.rewriteRootURL(ve.rootUrl,Nt)),Tt.importMesh){const qt=Tt,Xt=[],zt=[],Gt=[];if(!qt.importMesh(p,I,Lt,ve.rootUrl,Xt,zt,Gt,He))return;I.loadingPluginName=Tt.name,rt(Xt,zt,Gt,[],[],[],[])}else Tt.importMeshAsync(p,I,Lt,ve.rootUrl,xt,ve.name).then(Xt=>{I.loadingPluginName=Tt.name,rt(Xt.meshes,Xt.particleSystems,Xt.skeletons,Xt.animationGroups,Xt.transformNodes,Xt.geometries,Xt.lights)}).catch(Xt=>{He(Xt.message,Xt)})},xt,He,ze,he,_e)}static ImportMeshAsync(p,_,E="",I=Mr.LastCreatedScene,Z=null,re=null,ae=""){return new Promise((he,_e)=>{wn.ImportMesh(p,_,E,I,(ve,Le,ze,He,xt,rt,Tt)=>{he({meshes:ve,particleSystems:Le,skeletons:ze,animationGroups:He,transformNodes:xt,geometries:rt,lights:Tt})},Z,(ve,Le,ze)=>{_e(ze||new Error(Le))},re,ae)})}static Load(p,_="",E=Mr.LastCreatedEngine,I=null,Z=null,re=null,ae=null,he=""){return E?wn.Append(p,_,new U0(E),I,Z,re,ae,he):(lt.Error("No engine available"),null)}static LoadAsync(p,_="",E=Mr.LastCreatedEngine,I=null,Z=null,re=""){return new Promise((ae,he)=>{wn.Load(p,_,E,_e=>{ae(_e)},I,(_e,ve,Le)=>{he(Le||new Error(ve))},Z,re)})}static Append(p,_="",E=Mr.LastCreatedScene,I=null,Z=null,re=null,ae=null,he=""){if(!E)return Ti.Error("No scene available to append to"),null;const _e=wn._GetFileInfo(p,_);if(!_e)return null;const ve={};E.addPendingData(ve);const Le=()=>{E.removePendingData(ve)};wn.ShowLoadingScreen&&!this._ShowingLoadingScreen&&(this._ShowingLoadingScreen=!0,E.getEngine().displayLoadingUI(),E.executeWhenReady(()=>{E.getEngine().hideLoadingUI(),this._ShowingLoadingScreen=!1}));const ze=(rt,Tt)=>{const Lt=wn._FormatErrorMessage(_e,rt,Tt);re?re(E,Lt,new Hx(Lt,Wx.SceneLoaderError,Tt)):Ti.Error(Lt),Le()},He=Z?rt=>{try{Z(rt)}catch(Tt){ze("Error in onProgress callback",Tt)}}:void 0,xt=()=>{if(I)try{I(E)}catch(rt){ze("Error in onSuccess callback",rt)}E.removePendingData(ve)};return wn._LoadData(_e,E,(rt,Tt)=>{if(rt.load){if(!rt.load(E,Tt,_e.rootUrl,ze))return;E.loadingPluginName=rt.name,xt()}else rt.loadAsync(E,Tt,_e.rootUrl,He,_e.name).then(()=>{E.loadingPluginName=rt.name,xt()}).catch(Nt=>{ze(Nt.message,Nt)})},He,ze,Le,ae,he)}static AppendAsync(p,_="",E=Mr.LastCreatedScene,I=null,Z=null,re=""){return new Promise((ae,he)=>{wn.Append(p,_,E,_e=>{ae(_e)},I,(_e,ve,Le)=>{he(Le||new Error(ve))},Z,re)})}static LoadAssetContainer(p,_="",E=Mr.LastCreatedScene,I=null,Z=null,re=null,ae=null,he=""){if(!E)return Ti.Error("No scene available to load asset container to"),null;const _e=wn._GetFileInfo(p,_);if(!_e)return null;const ve={};E.addPendingData(ve);const Le=()=>{E.removePendingData(ve)},ze=(rt,Tt)=>{const Lt=wn._FormatErrorMessage(_e,rt,Tt);re?re(E,Lt,new Hx(Lt,Wx.SceneLoaderError,Tt)):Ti.Error(Lt),Le()},He=Z?rt=>{try{Z(rt)}catch(Tt){ze("Error in onProgress callback",Tt)}}:void 0,xt=rt=>{if(I)try{I(rt)}catch(Tt){ze("Error in onSuccess callback",Tt)}E.removePendingData(ve)};return wn._LoadData(_e,E,(rt,Tt)=>{if(rt.loadAssetContainer){const Nt=rt.loadAssetContainer(E,Tt,_e.rootUrl,ze);if(!Nt)return;Nt.populateRootNodes(),E.loadingPluginName=rt.name,xt(Nt)}else rt.loadAssetContainerAsync?rt.loadAssetContainerAsync(E,Tt,_e.rootUrl,He,_e.name).then(Nt=>{Nt.populateRootNodes(),E.loadingPluginName=rt.name,xt(Nt)}).catch(Nt=>{ze(Nt.message,Nt)}):ze("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.")},He,ze,Le,ae,he)}static LoadAssetContainerAsync(p,_="",E=Mr.LastCreatedScene,I=null,Z=null){return new Promise((re,ae)=>{wn.LoadAssetContainer(p,_,E,he=>{re(he)},I,(he,_e,ve)=>{ae(ve||new Error(_e))},Z)})}static ImportAnimations(p,_="",E=Mr.LastCreatedScene,I=!0,Z=Yh.Clean,re=null,ae=null,he=null,_e=null,ve=null){if(!E){Ti.Error("No scene available to load animations to");return}if(I){for(const xt of E.animatables)xt.reset();E.stopAllAnimations(),E.animationGroups.slice().forEach(xt=>{xt.dispose()}),E.getNodes().forEach(xt=>{xt.animations&&(xt.animations=[])})}else switch(Z){case Yh.Clean:E.animationGroups.slice().forEach(He=>{He.dispose()});break;case Yh.Stop:E.animationGroups.forEach(He=>{He.stop()});break;case Yh.Sync:E.animationGroups.forEach(He=>{He.reset(),He.restart()});break;case Yh.NoSync:break;default:Ti.Error("Unknown animation group loading mode value '"+Z+"'");return}const Le=E.animatables.length,ze=He=>{He.mergeAnimationsTo(E,E.animatables.slice(Le),re),He.dispose(),E.onAnimationFileImportedObservable.notifyObservers(E),ae&&ae(E)};this.LoadAssetContainer(p,_,E,ze,he,_e,ve)}static ImportAnimationsAsync(p,_="",E=Mr.LastCreatedScene,I=!0,Z=Yh.Clean,re=null,ae=null,he=null,_e=null,ve=null){return new Promise((Le,ze)=>{wn.ImportAnimations(p,_,E,I,Z,re,He=>{Le(He)},he,(He,xt,rt)=>{ze(rt||new Error(xt))},ve)})}}wn.NO_LOGGING=0,wn.MINIMAL_LOGGING=1,wn.SUMMARY_LOGGING=2,wn.DETAILED_LOGGING=3,wn.OnPluginActivatedObservable=new Ri,wn._RegisteredPlugins={},wn._ShowingLoadingScreen=!1;var vu;(function(pe){pe[pe.CW=0]="CW",pe[pe.CCW=1]="CCW"})(vu||(vu={}));class Y3{static Interpolate(p,_,E,I,Z){const re=1-3*I+3*_,ae=3*I-6*_,he=3*_;let _e=p;for(let ve=0;ve<5;ve++){const Le=_e*_e,ze=Le*_e,He=re*ze+ae*Le+he*_e,xt=1/(3*re*Le+2*ae*_e+he);_e-=(He-p)*xt,_e=Math.min(1,Math.max(0,_e))}return 3*Math.pow(1-_e,2)*_e*E+3*(1-_e)*Math.pow(_e,2)*Z+Math.pow(_e,3)}}class Tl{constructor(p){this._radians=p,this._radians<0&&(this._radians+=2*Math.PI)}degrees(){return this._radians*180/Math.PI}radians(){return this._radians}static BetweenTwoPoints(p,_){const E=_.subtract(p),I=Math.atan2(E.y,E.x);return new Tl(I)}static BetweenTwoVectors(p,_){let E=p.lengthSquared()*_.lengthSquared();if(E===0)return new Tl(Math.PI/2);E=Math.sqrt(E);let I=p.dot(_)/E;I=Scalar.Clamp(I,-1,1);const Z=Math.acos(I);return new Tl(Z)}static FromRadians(p){return new Tl(p)}static FromDegrees(p){return new Tl(p*Math.PI/180)}}class aN{constructor(p,_,E){this.startPoint=p,this.midPoint=_,this.endPoint=E;const I=Math.pow(_.x,2)+Math.pow(_.y,2),Z=(Math.pow(p.x,2)+Math.pow(p.y,2)-I)/2,re=(I-Math.pow(E.x,2)-Math.pow(E.y,2))/2,ae=(p.x-_.x)*(_.y-E.y)-(_.x-E.x)*(p.y-_.y);this.centerPoint=new Vector2((Z*(_.y-E.y)-re*(p.y-_.y))/ae,((p.x-_.x)*re-(_.x-E.x)*Z)/ae),this.radius=this.centerPoint.subtract(this.startPoint).length(),this.startAngle=Tl.BetweenTwoPoints(this.centerPoint,this.startPoint);const he=this.startAngle.degrees();let _e=Tl.BetweenTwoPoints(this.centerPoint,this.midPoint).degrees(),ve=Tl.BetweenTwoPoints(this.centerPoint,this.endPoint).degrees();_e-he>180&&(_e-=360),_e-he<-180&&(_e+=360),ve-_e>180&&(ve-=360),ve-_e<-180&&(ve+=360),this.orientation=_e-he<0?vu.CW:vu.CCW,this.angle=Tl.FromDegrees(this.orientation===vu.CW?he-ve:ve-he)}}class WT{constructor(p,_){this._points=new Array,this._length=0,this.closed=!1,this._points.push(new Vector2(p,_))}addLineTo(p,_){if(this.closed)return this;const E=new Vector2(p,_),I=this._points[this._points.length-1];return this._points.push(E),this._length+=E.subtract(I).length(),this}addArcTo(p,_,E,I,Z=36){if(this.closed)return this;const re=this._points[this._points.length-1],ae=new Vector2(p,_),he=new Vector2(E,I),_e=new aN(re,ae,he);let ve=_e.angle.radians()/Z;_e.orientation===vu.CW&&(ve*=-1);let Le=_e.startAngle.radians()+ve;for(let ze=0;ze<Z;ze++){const He=Math.cos(Le)*_e.radius+_e.centerPoint.x,xt=Math.sin(Le)*_e.radius+_e.centerPoint.y;this.addLineTo(He,xt),Le+=ve}return this}addQuadraticCurveTo(p,_,E,I,Z=36){if(this.closed)return this;const re=(he,_e,ve,Le)=>(1-he)*(1-he)*_e+2*he*(1-he)*ve+he*he*Le,ae=this._points[this._points.length-1];for(let he=0;he<=Z;he++){const _e=he/Z,ve=re(_e,ae.x,p,E),Le=re(_e,ae.y,_,I);this.addLineTo(ve,Le)}return this}addBezierCurveTo(p,_,E,I,Z,re,ae=36){if(this.closed)return this;const he=(ve,Le,ze,He,xt)=>(1-ve)*(1-ve)*(1-ve)*Le+3*ve*(1-ve)*(1-ve)*ze+3*ve*ve*(1-ve)*He+ve*ve*ve*xt,_e=this._points[this._points.length-1];for(let ve=0;ve<=ae;ve++){const Le=ve/ae,ze=he(Le,_e.x,p,E,Z),He=he(Le,_e.y,_,I,re);this.addLineTo(ze,He)}return this}isPointInside(p){let _=!1;const E=this._points.length;for(let I=E-1,Z=0;Z<E;I=Z++){let re=this._points[I],ae=this._points[Z],he=ae.x-re.x,_e=ae.y-re.y;if(Math.abs(_e)>Number.EPSILON){if(_e<0&&(re=this._points[Z],he=-he,ae=this._points[I],_e=-_e),p.y<re.y||p.y>ae.y)continue;if(p.y===re.y&&p.x===re.x)return!0;{const ve=_e*(p.x-re.x)-he*(p.y-re.y);if(ve===0)return!0;if(ve<0)continue;_=!_}}else{if(p.y!==re.y)continue;if(ae.x<=p.x&&p.x<=re.x||re.x<=p.x&&p.x<=ae.x)return!0}}return _}close(){return this.closed=!0,this}length(){let p=this._length;if(this.closed){const _=this._points[this._points.length-1],E=this._points[0];p+=E.subtract(_).length()}return p}area(){const p=this._points.length;let _=0;for(let E=p-1,I=0;I<p;E=I++)_+=this._points[E].x*this._points[I].y-this._points[I].x*this._points[E].y;return _*.5}getPoints(){return this._points}getPointAtLengthPosition(p){if(p<0||p>1)return Vector2.Zero();const _=p*this.length();let E=0;for(let I=0;I<this._points.length;I++){const Z=(I+1)%this._points.length,re=this._points[I],he=this._points[Z].subtract(re),_e=he.length()+E;if(_>=E&&_<=_e){const ve=he.normalize(),Le=_-E;return new Vector2(re.x+ve.x*Le,re.y+ve.y*Le)}E=_e}return Vector2.Zero()}static StartingAt(p,_){return new WT(p,_)}}class HT{constructor(p,_=null,E,I=!1){this.path=p,this._curve=new Array,this._distances=new Array,this._tangents=new Array,this._normals=new Array,this._binormals=new Array,this._pointAtData={id:0,point:Vector3.Zero(),previousPointArrayIndex:0,position:0,subPosition:0,interpolateReady:!1,interpolationMatrix:Matrix.Identity()};for(let Z=0;Z<p.length;Z++)this._curve[Z]=p[Z].clone();this._raw=E||!1,this._alignTangentsWithPath=I,this._compute(_,I)}getCurve(){return this._curve}getPoints(){return this._curve}length(){return this._distances[this._distances.length-1]}getTangents(){return this._tangents}getNormals(){return this._normals}getBinormals(){return this._binormals}getDistances(){return this._distances}getPointAt(p){return this._updatePointAtData(p).point}getTangentAt(p,_=!1){return this._updatePointAtData(p,_),_?Vector3.TransformCoordinates(Vector3.Forward(),this._pointAtData.interpolationMatrix):this._tangents[this._pointAtData.previousPointArrayIndex]}getNormalAt(p,_=!1){return this._updatePointAtData(p,_),_?Vector3.TransformCoordinates(Vector3.Right(),this._pointAtData.interpolationMatrix):this._normals[this._pointAtData.previousPointArrayIndex]}getBinormalAt(p,_=!1){return this._updatePointAtData(p,_),_?Vector3.TransformCoordinates(Vector3.UpReadOnly,this._pointAtData.interpolationMatrix):this._binormals[this._pointAtData.previousPointArrayIndex]}getDistanceAt(p){return this.length()*p}getPreviousPointIndexAt(p){return this._updatePointAtData(p),this._pointAtData.previousPointArrayIndex}getSubPositionAt(p){return this._updatePointAtData(p),this._pointAtData.subPosition}getClosestPositionTo(p){let _=Number.MAX_VALUE,E=0;for(let I=0;I<this._curve.length-1;I++){const Z=this._curve[I+0],re=this._curve[I+1].subtract(Z).normalize(),ae=this._distances[I+1]-this._distances[I+0],he=Math.min(Math.max(Vector3.Dot(re,p.subtract(Z).normalize()),0)*Vector3.Distance(Z,p)/ae,1),_e=Vector3.Distance(Z.add(re.scale(he*ae)),p);_e<_&&(_=_e,E=(this._distances[I+0]+ae*he)/this.length())}return E}slice(p=0,_=1){if(p<0&&(p=1-p*-1%1),_<0&&(_=1-_*-1%1),p>_){const _e=p;p=_,_=_e}const E=this.getCurve(),I=this.getPointAt(p);let Z=this.getPreviousPointIndexAt(p);const re=this.getPointAt(_),ae=this.getPreviousPointIndexAt(_)+1,he=[];return p!==0&&(Z++,he.push(I)),he.push(...E.slice(Z,ae)),(_!==1||p===1)&&he.push(re),new HT(he,this.getNormalAt(p),this._raw,this._alignTangentsWithPath)}update(p,_=null,E=!1){for(let I=0;I<p.length;I++)this._curve[I].x=p[I].x,this._curve[I].y=p[I].y,this._curve[I].z=p[I].z;return this._compute(_,E),this}_compute(p,_=!1){const E=this._curve.length;if(E<2)return;this._tangents[0]=this._getFirstNonNullVector(0),this._raw||this._tangents[0].normalize(),this._tangents[E-1]=this._curve[E-1].subtract(this._curve[E-2]),this._raw||this._tangents[E-1].normalize();const I=this._tangents[0],Z=this._normalVector(I,p);this._normals[0]=Z,this._raw||this._normals[0].normalize(),this._binormals[0]=Vector3.Cross(I,this._normals[0]),this._raw||this._binormals[0].normalize(),this._distances[0]=0;let re,ae,he,_e,ve;for(let Le=1;Le<E;Le++)re=this._getLastNonNullVector(Le),Le<E-1&&(ae=this._getFirstNonNullVector(Le),this._tangents[Le]=_?ae:re.add(ae),this._tangents[Le].normalize()),this._distances[Le]=this._distances[Le-1]+this._curve[Le].subtract(this._curve[Le-1]).length(),he=this._tangents[Le],ve=this._binormals[Le-1],this._normals[Le]=Vector3.Cross(ve,he),this._raw||(this._normals[Le].length()===0?(_e=this._normals[Le-1],this._normals[Le]=_e.clone()):this._normals[Le].normalize()),this._binormals[Le]=Vector3.Cross(he,this._normals[Le]),this._raw||this._binormals[Le].normalize();this._pointAtData.id=NaN}_getFirstNonNullVector(p){let _=1,E=this._curve[p+_].subtract(this._curve[p]);for(;E.length()===0&&p+_+1<this._curve.length;)_++,E=this._curve[p+_].subtract(this._curve[p]);return E}_getLastNonNullVector(p){let _=1,E=this._curve[p].subtract(this._curve[p-_]);for(;E.length()===0&&p>_+1;)_++,E=this._curve[p].subtract(this._curve[p-_]);return E}_normalVector(p,_){let E,I=p.length();if(I===0&&(I=1),_==null){let Z;Scalar.WithinEpsilon(Math.abs(p.y)/I,1,Epsilon)?Scalar.WithinEpsilon(Math.abs(p.x)/I,1,Epsilon)?Scalar.WithinEpsilon(Math.abs(p.z)/I,1,Epsilon)?Z=Vector3.Zero():Z=new Vector3(0,0,1):Z=new Vector3(1,0,0):Z=new Vector3(0,-1,0),E=Vector3.Cross(p,Z)}else E=Vector3.Cross(p,_),Vector3.CrossToRef(E,p,E);return E.normalize(),E}_updatePointAtData(p,_=!1){if(this._pointAtData.id===p)return this._pointAtData.interpolateReady||this._updateInterpolationMatrix(),this._pointAtData;this._pointAtData.id=p;const E=this.getPoints();if(p<=0)return this._setPointAtData(0,0,E[0],0,_);if(p>=1)return this._setPointAtData(1,1,E[E.length-1],E.length-1,_);let I=E[0],Z,re=0;const ae=p*this.length();for(let he=1;he<E.length;he++){Z=E[he];const _e=Vector3.Distance(I,Z);if(re+=_e,re===ae)return this._setPointAtData(p,1,Z,he,_);if(re>ae){const Le=(re-ae)/_e,ze=I.subtract(Z),He=Z.add(ze.scaleInPlace(Le));return this._setPointAtData(p,1-Le,He,he-1,_)}I=Z}return this._pointAtData}_setPointAtData(p,_,E,I,Z){return this._pointAtData.point=E,this._pointAtData.position=p,this._pointAtData.subPosition=_,this._pointAtData.previousPointArrayIndex=I,this._pointAtData.interpolateReady=Z,Z&&this._updateInterpolationMatrix(),this._pointAtData}_updateInterpolationMatrix(){this._pointAtData.interpolationMatrix=Matrix.Identity();const p=this._pointAtData.previousPointArrayIndex;if(p!==this._tangents.length-1){const _=p+1,E=this._tangents[p].clone(),I=this._normals[p].clone(),Z=this._binormals[p].clone(),re=this._tangents[_].clone(),ae=this._normals[_].clone(),he=this._binormals[_].clone(),_e=Quaternion.RotationQuaternionFromAxis(I,Z,E),ve=Quaternion.RotationQuaternionFromAxis(ae,he,re);Quaternion.Slerp(_e,ve,this._pointAtData.subPosition).toRotationMatrix(this._pointAtData.interpolationMatrix)}}}class Kh{static CreateQuadraticBezier(p,_,E,I){I=I>2?I:3;const Z=[],re=(ae,he,_e,ve)=>(1-ae)*(1-ae)*he+2*ae*(1-ae)*_e+ae*ae*ve;for(let ae=0;ae<=I;ae++)Z.push(new Vector3(re(ae/I,p.x,_.x,E.x),re(ae/I,p.y,_.y,E.y),re(ae/I,p.z,_.z,E.z)));return new Kh(Z)}static CreateCubicBezier(p,_,E,I,Z){Z=Z>3?Z:4;const re=[],ae=(he,_e,ve,Le,ze)=>(1-he)*(1-he)*(1-he)*_e+3*he*(1-he)*(1-he)*ve+3*he*he*(1-he)*Le+he*he*he*ze;for(let he=0;he<=Z;he++)re.push(new Vector3(ae(he/Z,p.x,_.x,E.x,I.x),ae(he/Z,p.y,_.y,E.y,I.y),ae(he/Z,p.z,_.z,E.z,I.z)));return new Kh(re)}static CreateHermiteSpline(p,_,E,I,Z){const re=[],ae=1/Z;for(let he=0;he<=Z;he++)re.push(Vector3.Hermite(p,_,E,I,he*ae));return new Kh(re)}static CreateCatmullRomSpline(p,_,E){const I=[],Z=1/_;let re=0;if(E){const ae=p.length;for(let he=0;he<ae;he++){re=0;for(let _e=0;_e<_;_e++)I.push(Vector3.CatmullRom(p[he%ae],p[(he+1)%ae],p[(he+2)%ae],p[(he+3)%ae],re)),re+=Z}I.push(I[0])}else{const ae=[];ae.push(p[0].clone()),Array.prototype.push.apply(ae,p),ae.push(p[p.length-1].clone());let he=0;for(;he<ae.length-3;he++){re=0;for(let _e=0;_e<_;_e++)I.push(Vector3.CatmullRom(ae[he],ae[he+1],ae[he+2],ae[he+3],re)),re+=Z}he--,I.push(Vector3.CatmullRom(ae[he],ae[he+1],ae[he+2],ae[he+3],re))}return new Kh(I)}static ArcThru3Points(p,_,E,I=32,Z=!1,re=!1){const ae=[],he=_.subtract(p),_e=E.subtract(_),ve=p.subtract(E),Le=Vector3.Cross(he,_e),ze=Le.length();if(ze<Math.pow(10,-8))return new Kh(ae);const He=he.lengthSquared(),xt=_e.lengthSquared(),rt=ve.lengthSquared(),Tt=Le.lengthSquared(),Lt=he.length(),Nt=_e.length(),qt=ve.length(),Xt=.5*Lt*Nt*qt/ze,zt=Vector3.Dot(he,ve),Gt=Vector3.Dot(he,_e),xi=Vector3.Dot(_e,ve),Gi=-.5*xt*zt/Tt,vs=-.5*rt*Gt/Tt,ks=-.5*He*xi/Tt,Ur=p.scale(Gi).add(_.scale(vs)).add(E.scale(ks)),pn=p.subtract(Ur).normalize(),_n=Vector3.Cross(Le,pn).normalize();if(re){const x0=2*Math.PI/I;for(let Ta=0;Ta<=2*Math.PI;Ta+=x0)ae.push(Ur.add(pn.scale(Xt*Math.cos(Ta)).add(_n.scale(Xt*Math.sin(Ta)))));ae.push(p)}else{const x0=1/I;let Ta=0,n0=Vector3.Zero();do n0=Ur.add(pn.scale(Xt*Math.cos(Ta)).add(_n.scale(Xt*Math.sin(Ta)))),ae.push(n0),Ta+=x0;while(!n0.equalsWithEpsilon(E,Xt*x0*1.1));ae.push(E),Z&&ae.push(p)}return new Kh(ae)}constructor(p){this._length=0,this._points=p,this._length=this._computeLength(p)}getPoints(){return this._points}length(){return this._length}continue(p){const _=this._points[this._points.length-1],E=this._points.slice(),I=p.getPoints();for(let re=1;re<I.length;re++)E.push(I[re].subtract(I[0]).add(_));return new Kh(E)}_computeLength(p){let _=0;for(let E=1;E<p.length;E++)_+=p[E].subtract(p[E-1]).length();return _}}class XT{constructor(p=Vector3.Zero(),_=Vector3.Up()){this.position=p,this.normal=_}clone(){return new XT(this.position.clone(),this.normal.clone())}}class YT{constructor(p=Vector3.Zero(),_=Vector3.Up(),E=Vector2.Zero()){this.position=p,this.normal=_,this.uv=E}clone(){return new YT(this.position.clone(),this.normal.clone(),this.uv.clone())}}const vl=[Math.sqrt(1/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(3/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(15/(4*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(5/(16*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(15/(16*Math.PI))],xN=[()=>1,pe=>pe.y,pe=>pe.z,pe=>pe.x,pe=>pe.x*pe.y,pe=>pe.y*pe.z,pe=>3*pe.z*pe.z-1,pe=>pe.x*pe.z,pe=>pe.x*pe.x-pe.y*pe.y],nh=(pe,p)=>vl[pe]*xN[pe](p),ah=[Math.PI,2*Math.PI/3,2*Math.PI/3,2*Math.PI/3,Math.PI/4,Math.PI/4,Math.PI/4,Math.PI/4,Math.PI/4];class Ru{constructor(){this.preScaled=!1,this.l00=at.Zero(),this.l1_1=at.Zero(),this.l10=at.Zero(),this.l11=at.Zero(),this.l2_2=at.Zero(),this.l2_1=at.Zero(),this.l20=at.Zero(),this.l21=at.Zero(),this.l22=at.Zero()}addLight(p,_,E){ui.Vector3[0].set(_.r,_.g,_.b);const I=ui.Vector3[0],Z=ui.Vector3[1];I.scaleToRef(E,Z),Z.scaleToRef(nh(0,p),ui.Vector3[2]),this.l00.addInPlace(ui.Vector3[2]),Z.scaleToRef(nh(1,p),ui.Vector3[2]),this.l1_1.addInPlace(ui.Vector3[2]),Z.scaleToRef(nh(2,p),ui.Vector3[2]),this.l10.addInPlace(ui.Vector3[2]),Z.scaleToRef(nh(3,p),ui.Vector3[2]),this.l11.addInPlace(ui.Vector3[2]),Z.scaleToRef(nh(4,p),ui.Vector3[2]),this.l2_2.addInPlace(ui.Vector3[2]),Z.scaleToRef(nh(5,p),ui.Vector3[2]),this.l2_1.addInPlace(ui.Vector3[2]),Z.scaleToRef(nh(6,p),ui.Vector3[2]),this.l20.addInPlace(ui.Vector3[2]),Z.scaleToRef(nh(7,p),ui.Vector3[2]),this.l21.addInPlace(ui.Vector3[2]),Z.scaleToRef(nh(8,p),ui.Vector3[2]),this.l22.addInPlace(ui.Vector3[2])}scaleInPlace(p){this.l00.scaleInPlace(p),this.l1_1.scaleInPlace(p),this.l10.scaleInPlace(p),this.l11.scaleInPlace(p),this.l2_2.scaleInPlace(p),this.l2_1.scaleInPlace(p),this.l20.scaleInPlace(p),this.l21.scaleInPlace(p),this.l22.scaleInPlace(p)}convertIncidentRadianceToIrradiance(){this.l00.scaleInPlace(ah[0]),this.l1_1.scaleInPlace(ah[1]),this.l10.scaleInPlace(ah[2]),this.l11.scaleInPlace(ah[3]),this.l2_2.scaleInPlace(ah[4]),this.l2_1.scaleInPlace(ah[5]),this.l20.scaleInPlace(ah[6]),this.l21.scaleInPlace(ah[7]),this.l22.scaleInPlace(ah[8])}convertIrradianceToLambertianRadiance(){this.scaleInPlace(1/Math.PI)}preScaleForRendering(){this.preScaled=!0,this.l00.scaleInPlace(vl[0]),this.l1_1.scaleInPlace(vl[1]),this.l10.scaleInPlace(vl[2]),this.l11.scaleInPlace(vl[3]),this.l2_2.scaleInPlace(vl[4]),this.l2_1.scaleInPlace(vl[5]),this.l20.scaleInPlace(vl[6]),this.l21.scaleInPlace(vl[7]),this.l22.scaleInPlace(vl[8])}updateFromArray(p){return at.FromArrayToRef(p[0],0,this.l00),at.FromArrayToRef(p[1],0,this.l1_1),at.FromArrayToRef(p[2],0,this.l10),at.FromArrayToRef(p[3],0,this.l11),at.FromArrayToRef(p[4],0,this.l2_2),at.FromArrayToRef(p[5],0,this.l2_1),at.FromArrayToRef(p[6],0,this.l20),at.FromArrayToRef(p[7],0,this.l21),at.FromArrayToRef(p[8],0,this.l22),this}updateFromFloatsArray(p){return at.FromFloatsToRef(p[0],p[1],p[2],this.l00),at.FromFloatsToRef(p[3],p[4],p[5],this.l1_1),at.FromFloatsToRef(p[6],p[7],p[8],this.l10),at.FromFloatsToRef(p[9],p[10],p[11],this.l11),at.FromFloatsToRef(p[12],p[13],p[14],this.l2_2),at.FromFloatsToRef(p[15],p[16],p[17],this.l2_1),at.FromFloatsToRef(p[18],p[19],p[20],this.l20),at.FromFloatsToRef(p[21],p[22],p[23],this.l21),at.FromFloatsToRef(p[24],p[25],p[26],this.l22),this}static FromArray(p){return new Ru().updateFromArray(p)}static FromPolynomial(p){const _=new Ru;return _.l00=p.xx.scale(.376127).add(p.yy.scale(.376127)).add(p.zz.scale(.376126)),_.l1_1=p.y.scale(.977204),_.l10=p.z.scale(.977204),_.l11=p.x.scale(.977204),_.l2_2=p.xy.scale(1.16538),_.l2_1=p.yz.scale(1.16538),_.l20=p.zz.scale(1.34567).subtract(p.xx.scale(.672834)).subtract(p.yy.scale(.672834)),_.l21=p.zx.scale(1.16538),_.l22=p.xx.scale(1.16538).subtract(p.yy.scale(1.16538)),_.l1_1.scaleInPlace(-1),_.l11.scaleInPlace(-1),_.l2_1.scaleInPlace(-1),_.l21.scaleInPlace(-1),_.scaleInPlace(Math.PI),_}}class Mu{constructor(){this.x=at.Zero(),this.y=at.Zero(),this.z=at.Zero(),this.xx=at.Zero(),this.yy=at.Zero(),this.zz=at.Zero(),this.xy=at.Zero(),this.yz=at.Zero(),this.zx=at.Zero()}get preScaledHarmonics(){return this._harmonics||(this._harmonics=Ru.FromPolynomial(this)),this._harmonics.preScaled||this._harmonics.preScaleForRendering(),this._harmonics}addAmbient(p){ui.Vector3[0].copyFromFloats(p.r,p.g,p.b);const _=ui.Vector3[0];this.xx.addInPlace(_),this.yy.addInPlace(_),this.zz.addInPlace(_)}scaleInPlace(p){this.x.scaleInPlace(p),this.y.scaleInPlace(p),this.z.scaleInPlace(p),this.xx.scaleInPlace(p),this.yy.scaleInPlace(p),this.zz.scaleInPlace(p),this.yz.scaleInPlace(p),this.zx.scaleInPlace(p),this.xy.scaleInPlace(p)}updateFromHarmonics(p){return this._harmonics=p,this.x.copyFrom(p.l11),this.x.scaleInPlace(1.02333).scaleInPlace(-1),this.y.copyFrom(p.l1_1),this.y.scaleInPlace(1.02333).scaleInPlace(-1),this.z.copyFrom(p.l10),this.z.scaleInPlace(1.02333),this.xx.copyFrom(p.l00),ui.Vector3[0].copyFrom(p.l20).scaleInPlace(.247708),ui.Vector3[1].copyFrom(p.l22).scaleInPlace(.429043),this.xx.scaleInPlace(.886277).subtractInPlace(ui.Vector3[0]).addInPlace(ui.Vector3[1]),this.yy.copyFrom(p.l00),this.yy.scaleInPlace(.886277).subtractInPlace(ui.Vector3[0]).subtractInPlace(ui.Vector3[1]),this.zz.copyFrom(p.l00),ui.Vector3[0].copyFrom(p.l20).scaleInPlace(.495417),this.zz.scaleInPlace(.886277).addInPlace(ui.Vector3[0]),this.yz.copyFrom(p.l2_1),this.yz.scaleInPlace(.858086).scaleInPlace(-1),this.zx.copyFrom(p.l21),this.zx.scaleInPlace(.858086).scaleInPlace(-1),this.xy.copyFrom(p.l2_2),this.xy.scaleInPlace(.858086),this.scaleInPlace(1/Math.PI),this}static FromHarmonics(p){return new Mu().updateFromHarmonics(p)}static FromArray(p){const _=new Mu;return at.FromArrayToRef(p[0],0,_.x),at.FromArrayToRef(p[1],0,_.y),at.FromArrayToRef(p[2],0,_.z),at.FromArrayToRef(p[3],0,_.xx),at.FromArrayToRef(p[4],0,_.yy),at.FromArrayToRef(p[5],0,_.zz),at.FromArrayToRef(p[6],0,_.yz),at.FromArrayToRef(p[7],0,_.zx),at.FromArrayToRef(p[8],0,_.xy),_}}class ha{static RegisterShaderCodeProcessing(p,_){if(!_){delete ha._CustomShaderCodeProcessing[p??""];return}ha._CustomShaderCodeProcessing[p??""]=_}static _GetShaderCodeProcessing(p){return ha._CustomShaderCodeProcessing[p]??ha._CustomShaderCodeProcessing[""]}get samples(){return this._samples}set samples(p){this._samples=Math.min(p,this._engine.getCaps().maxMSAASamples),this._textures.forEach(_=>{_.setSamples(this._samples)})}getEffectName(){return this._fragmentUrl}set onActivate(p){this._onActivateObserver&&this.onActivateObservable.remove(this._onActivateObserver),p&&(this._onActivateObserver=this.onActivateObservable.add(p))}set onSizeChanged(p){this._onSizeChangedObserver&&this.onSizeChangedObservable.remove(this._onSizeChangedObserver),this._onSizeChangedObserver=this.onSizeChangedObservable.add(p)}set onApply(p){this._onApplyObserver&&this.onApplyObservable.remove(this._onApplyObserver),this._onApplyObserver=this.onApplyObservable.add(p)}set onBeforeRender(p){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(p)}set onAfterRender(p){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(p)}get inputTexture(){return this._textures.data[this._currentRenderTextureInd]}set inputTexture(p){this._forcedOutputTexture=p}restoreDefaultInputTexture(){this._forcedOutputTexture&&(this._forcedOutputTexture=null,this.markTextureDirty())}getCamera(){return this._camera}get texelSize(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.texelSize:(this._forcedOutputTexture&&this._texelSize.copyFromFloats(1/this._forcedOutputTexture.width,1/this._forcedOutputTexture.height),this._texelSize)}constructor(p,_,E,I,Z,re,ae=1,he,_e,ve=null,Le=0,ze="postprocess",He,xt=!1,rt=5,Tt=Wa.GLSL){this._parentContainer=null,this.width=-1,this.height=-1,this.nodeMaterialSource=null,this._outputTexture=null,this.autoClear=!0,this.forceAutoClearInAlphaMode=!1,this.alphaMode=0,this.animations=[],this.enablePixelPerfectMode=!1,this.forceFullscreenViewport=!0,this.scaleMode=1,this.alwaysForcePOT=!1,this._samples=1,this.adaptScaleToCurrentViewport=!1,this._reusable=!1,this._renderId=0,this.externalTextureSamplerBinding=!1,this._textures=new ct(2),this._textureCache=[],this._currentRenderTextureInd=0,this._scaleRatio=new xr(1,1),this._texelSize=xr.Zero(),this.onActivateObservable=new Ri,this.onSizeChangedObservable=new Ri,this.onApplyObservable=new Ri,this.onBeforeRenderObservable=new Ri,this.onAfterRenderObservable=new Ri,this.name=p;let Lt=1,Nt=null;if(E&&!Array.isArray(E)){const qt=E;E=qt.uniforms??null,I=qt.samplers??null,Lt=qt.size??1,re=qt.camera??null,ae=qt.samplingMode??1,he=qt.engine,_e=qt.reusable,ve=qt.defines??null,Le=qt.textureType??0,ze=qt.vertexUrl??"postprocess",He=qt.indexParameters,xt=qt.blockCompilation??!1,rt=qt.textureFormat??5,Tt=qt.shaderLanguage??Wa.GLSL,Nt=qt.uniformBuffers??null}else Z&&(typeof Z=="number"?Lt=Z:Lt={width:Z.width,height:Z.height});re!=null?(this._camera=re,this._scene=re.getScene(),re.attachPostProcess(this),this._engine=this._scene.getEngine(),this._scene.postProcesses.push(this),this.uniqueId=this._scene.getUniqueId()):he&&(this._engine=he,this._engine.postProcesses.push(this)),this._options=Lt,this.renderTargetSamplingMode=ae||1,this._reusable=_e||!1,this._textureType=Le,this._textureFormat=rt,this._shaderLanguage=Tt,this._samplers=I||[],this._samplers.push("textureSampler"),this._fragmentUrl=_,this._vertexUrl=ze,this._parameters=E||[],this._parameters.push("scale"),this._uniformBuffers=Nt||[],this._indexParameters=He,this._drawWrapper=new xo(this._engine),xt||this.updateEffect(ve)}getClassName(){return"PostProcess"}getEngine(){return this._engine}getEffect(){return this._drawWrapper.effect}shareOutputWith(p){return this._disposeTextures(),this._shareOutputWithPostProcess=p,this}useOwnOutput(){this._textures.length==0&&(this._textures=new ct(2)),this._shareOutputWithPostProcess=null}updateEffect(p=null,_=null,E=null,I,Z,re,ae,he){const _e=ha._GetShaderCodeProcessing(this.name);if(_e?.defineCustomBindings){const ve=_?.slice()??[];ve.push(...this._parameters);const Le=E?.slice()??[];Le.push(...this._samplers),p=_e.defineCustomBindings(this.name,p,ve,Le),_=ve,E=Le}this._postProcessDefines=p,this._drawWrapper.effect=this._engine.createEffect({vertex:ae??this._vertexUrl,fragment:he??this._fragmentUrl},{attributes:["position"],uniformsNames:_||this._parameters,uniformBuffersNames:this._uniformBuffers,samplers:E||this._samplers,defines:p!==null?p:"",fallbacks:null,onCompiled:Z??null,onError:re??null,indexParameters:I||this._indexParameters,processCodeAfterIncludes:_e?.processCodeAfterIncludes?(ve,Le)=>_e.processCodeAfterIncludes(this.name,ve,Le):null,processFinalCode:_e?.processFinalCode?(ve,Le)=>_e.processFinalCode(this.name,ve,Le):null,shaderLanguage:this._shaderLanguage},this._engine)}isReusable(){return this._reusable}markTextureDirty(){this.width=-1}_createRenderTargetTexture(p,_,E=0){for(let Z=0;Z<this._textureCache.length;Z++)if(this._textureCache[Z].texture.width===p.width&&this._textureCache[Z].texture.height===p.height&&this._textureCache[Z].postProcessChannel===E&&this._textureCache[Z].texture._generateDepthBuffer===_.generateDepthBuffer&&this._textureCache[Z].texture.samples===_.samples)return this._textureCache[Z].texture;const I=this._engine.createRenderTargetTexture(p,_);return this._textureCache.push({texture:I,postProcessChannel:E,lastUsedRenderId:-1}),I}_flushTextureCache(){const p=this._renderId;for(let _=this._textureCache.length-1;_>=0;_--)if(p-this._textureCache[_].lastUsedRenderId>100){let E=!1;for(let I=0;I<this._textures.length;I++)if(this._textures.data[I]===this._textureCache[_].texture){E=!0;break}E||(this._textureCache[_].texture.dispose(),this._textureCache.splice(_,1))}}resize(p,_,E=null,I=!1,Z=!1){this._textures.length>0&&this._textures.reset(),this.width=p,this.height=_;let re=null;if(E){for(let _e=0;_e<E._postProcesses.length;_e++)if(E._postProcesses[_e]!==null){re=E._postProcesses[_e];break}}const ae={width:this.width,height:this.height},he={generateMipMaps:I,generateDepthBuffer:Z||re===this,generateStencilBuffer:(Z||re===this)&&this._engine.isStencilEnable,samplingMode:this.renderTargetSamplingMode,type:this._textureType,format:this._textureFormat,samples:this._samples,label:"PostProcessRTT-"+this.name};this._textures.push(this._createRenderTargetTexture(ae,he,0)),this._reusable&&this._textures.push(this._createRenderTargetTexture(ae,he,1)),this._texelSize.copyFromFloats(1/this.width,1/this.height),this.onSizeChangedObservable.notifyObservers(this)}_getTarget(){let p;if(this._shareOutputWithPostProcess)p=this._shareOutputWithPostProcess.inputTexture;else if(this._forcedOutputTexture)p=this._forcedOutputTexture,this.width=this._forcedOutputTexture.width,this.height=this._forcedOutputTexture.height;else{p=this.inputTexture;let _;for(let E=0;E<this._textureCache.length;E++)if(this._textureCache[E].texture===p){_=this._textureCache[E];break}_&&(_.lastUsedRenderId=this._renderId)}return p}activate(p,_=null,E){p=p||this._camera;const I=p.getScene(),Z=I.getEngine(),re=Z.getCaps().maxTextureSize,ae=(_?_.width:this._engine.getRenderWidth(!0))*this._options|0,he=(_?_.height:this._engine.getRenderHeight(!0))*this._options|0;let _e=this._options.width||ae,ve=this._options.height||he;const Le=this.renderTargetSamplingMode!==7&&this.renderTargetSamplingMode!==1&&this.renderTargetSamplingMode!==2;let ze=null;if(!this._shareOutputWithPostProcess&&!this._forcedOutputTexture){if(this.adaptScaleToCurrentViewport){const He=Z.currentViewport;He&&(_e*=He.width,ve*=He.height)}(Le||this.alwaysForcePOT)&&(this._options.width||(_e=Z.needPOTTextures?ci.GetExponentOfTwo(_e,re,this.scaleMode):_e),this._options.height||(ve=Z.needPOTTextures?ci.GetExponentOfTwo(ve,re,this.scaleMode):ve)),(this.width!==_e||this.height!==ve||!(ze=this._getTarget()))&&this.resize(_e,ve,p,Le,E),this._textures.forEach(He=>{He.samples!==this.samples&&this._engine.updateRenderTargetTextureSampleCount(He,this.samples)}),this._flushTextureCache(),this._renderId++}return ze||(ze=this._getTarget()),this.enablePixelPerfectMode?(this._scaleRatio.copyFromFloats(ae/_e,he/ve),this._engine.bindFramebuffer(ze,0,ae,he,this.forceFullscreenViewport)):(this._scaleRatio.copyFromFloats(1,1),this._engine.bindFramebuffer(ze,0,void 0,void 0,this.forceFullscreenViewport)),this._engine._debugInsertMarker?.(`post process ${this.name} input`),this.onActivateObservable.notifyObservers(p),this.autoClear&&(this.alphaMode===0||this.forceAutoClearInAlphaMode)&&this._engine.clear(this.clearColor?this.clearColor:I.clearColor,I._allowPostProcessClearColor,!0,!0),this._reusable&&(this._currentRenderTextureInd=(this._currentRenderTextureInd+1)%2),ze}get isSupported(){return this._drawWrapper.effect.isSupported}get aspectRatio(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.aspectRatio:this._forcedOutputTexture?this._forcedOutputTexture.width/this._forcedOutputTexture.height:this.width/this.height}isReady(){return this._drawWrapper.effect?.isReady()??!1}apply(){if(!this._drawWrapper.effect?.isReady())return null;this._engine.enableEffect(this._drawWrapper),this._engine.setState(!1),this._engine.setDepthBuffer(!1),this._engine.setDepthWrite(!1),this._engine.setAlphaMode(this.alphaMode),this.alphaConstants&&this.getEngine().setAlphaConstants(this.alphaConstants.r,this.alphaConstants.g,this.alphaConstants.b,this.alphaConstants.a);let p;return this._shareOutputWithPostProcess?p=this._shareOutputWithPostProcess.inputTexture:this._forcedOutputTexture?p=this._forcedOutputTexture:p=this.inputTexture,this.externalTextureSamplerBinding||this._drawWrapper.effect._bindTexture("textureSampler",p?.texture),this._drawWrapper.effect.setVector2("scale",this._scaleRatio),this.onApplyObservable.notifyObservers(this._drawWrapper.effect),ha._GetShaderCodeProcessing(this.name)?.bindCustomBindings?.(this.name,this._drawWrapper.effect),this._drawWrapper.effect}_disposeTextures(){if(this._shareOutputWithPostProcess||this._forcedOutputTexture){this._disposeTextureCache();return}this._disposeTextureCache(),this._textures.dispose()}_disposeTextureCache(){for(let p=this._textureCache.length-1;p>=0;p--)this._textureCache[p].texture.dispose();this._textureCache.length=0}setPrePassRenderer(p){return this._prePassEffectConfiguration?(this._prePassEffectConfiguration=p.addEffectConfiguration(this._prePassEffectConfiguration),this._prePassEffectConfiguration.enabled=!0,!0):!1}dispose(p){p=p||this._camera,this._disposeTextures();let _;if(this._scene&&(_=this._scene.postProcesses.indexOf(this),_!==-1&&this._scene.postProcesses.splice(_,1)),this._parentContainer){const E=this._parentContainer.postProcesses.indexOf(this);E>-1&&this._parentContainer.postProcesses.splice(E,1),this._parentContainer=null}if(_=this._engine.postProcesses.indexOf(this),_!==-1&&this._engine.postProcesses.splice(_,1),!!p){if(p.detachPostProcess(this),_=p._postProcesses.indexOf(this),_===0&&p._postProcesses.length>0){const E=this._camera._getFirstPostProcess();E&&E.markTextureDirty()}this.onActivateObservable.clear(),this.onAfterRenderObservable.clear(),this.onApplyObservable.clear(),this.onBeforeRenderObservable.clear(),this.onSizeChangedObservable.clear()}}serialize(){const p=Hr.Serialize(this),_=this.getCamera()||this._scene&&this._scene.activeCamera;return p.customType="BABYLON."+this.getClassName(),p.cameraId=_?_.id:null,p.reusable=this._reusable,p.textureType=this._textureType,p.fragmentUrl=this._fragmentUrl,p.parameters=this._parameters,p.samplers=this._samplers,p.options=this._options,p.defines=this._postProcessDefines,p.textureFormat=this._textureFormat,p.vertexUrl=this._vertexUrl,p.indexParameters=this._indexParameters,p}clone(){const p=this.serialize();p._engine=this._engine,p.cameraId=null;const _=ha.Parse(p,this._scene,"");return _?(_.onActivateObservable=this.onActivateObservable.clone(),_.onSizeChangedObservable=this.onSizeChangedObservable.clone(),_.onApplyObservable=this.onApplyObservable.clone(),_.onBeforeRenderObservable=this.onBeforeRenderObservable.clone(),_.onAfterRenderObservable=this.onAfterRenderObservable.clone(),_._prePassEffectConfiguration=this._prePassEffectConfiguration,_):null}static Parse(p,_,E){const I=r0(p.customType);if(!I||!I._Parse)return null;const Z=_?_.getCameraById(p.cameraId):null;return I._Parse(p,Z,_,E)}static _Parse(p,_,E,I){return Hr.Parse(()=>new ha(p.name,p.fragmentUrl,p.parameters,p.samplers,p.options,_,p.renderTargetSamplingMode,p._engine,p.reusable,p.defines,p.textureType,p.vertexUrl,p.indexParameters,!1,p.textureFormat),p,E,I)}}ha._CustomShaderCodeProcessing={},Rt([Ut()],ha.prototype,"uniqueId",void 0),Rt([Ut()],ha.prototype,"name",void 0),Rt([Ut()],ha.prototype,"width",void 0),Rt([Ut()],ha.prototype,"height",void 0),Rt([Ut()],ha.prototype,"renderTargetSamplingMode",void 0),Rt([ky()],ha.prototype,"clearColor",void 0),Rt([Ut()],ha.prototype,"autoClear",void 0),Rt([Ut()],ha.prototype,"forceAutoClearInAlphaMode",void 0),Rt([Ut()],ha.prototype,"alphaMode",void 0),Rt([Ut()],ha.prototype,"alphaConstants",void 0),Rt([Ut()],ha.prototype,"enablePixelPerfectMode",void 0),Rt([Ut()],ha.prototype,"forceFullscreenViewport",void 0),Rt([Ut()],ha.prototype,"scaleMode",void 0),Rt([Ut()],ha.prototype,"alwaysForcePOT",void 0),Rt([Ut("samples")],ha.prototype,"_samples",void 0),Rt([Ut()],ha.prototype,"adaptScaleToCurrentViewport",void 0),Gs("BABYLON.PostProcess",ha);const KT="rgbdDecodePixelShader",jT=`varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;ji.ShadersStore[KT]=jT;const K3={name:KT,shader:jT},qT="passCubePixelShader",$T=`varying vec2 vUV;uniform samplerCube textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec2 uv=vUV*2.0-1.0;
#ifdef POSITIVEX
gl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));
#endif
#ifdef NEGATIVEX
gl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));
#endif
#ifdef POSITIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));
#endif
#ifdef NEGATIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));
#endif
#ifdef POSITIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,1.001));
#endif
#ifdef NEGATIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));
#endif
}`;ji.ShadersStore[qT]=$T;const j3={name:qT,shader:$T};class Kp extends ha{getClassName(){return"PassPostProcess"}constructor(p,_,E=null,I,Z,re,ae=0,he=!1){super(p,"pass",null,null,_,E,I,Z,re,void 0,ae,void 0,null,he)}static _Parse(p,_,E,I){return Hr.Parse(()=>new Kp(p.name,p.options,_,p.renderTargetSamplingMode,p._engine,p.reusable),p,E,I)}}Gs("BABYLON.PassPostProcess",Kp);class rv extends null{get face(){return this._face}set face(p){if(!(p<0||p>5))switch(this._face=p,this._face){case 0:this.updateEffect("#define POSITIVEX");break;case 1:this.updateEffect("#define NEGATIVEX");break;case 2:this.updateEffect("#define POSITIVEY");break;case 3:this.updateEffect("#define NEGATIVEY");break;case 4:this.updateEffect("#define POSITIVEZ");break;case 5:this.updateEffect("#define NEGATIVEZ");break}}getClassName(){return"PassCubePostProcess"}constructor(p,_,E=null,I,Z,re,ae=0,he=!1){super(p,"passCube",null,null,_,E,I,Z,re,"#define POSITIVEX",ae,void 0,null,he),this._face=0}static _Parse(p,_,E,I){return SerializationHelper.Parse(()=>new rv(p.name,p.options,_,p.renderTargetSamplingMode,p._engine,p.reusable),p,E,I)}}ci._RescalePostProcessFactory=pe=>new Kp("rescale",1,null,2,pe,!1,0);function lN(pe,p,_,E=!0){const I=pe.getScene(),Z=I.getEngine(),re=new z2("resized"+pe.name,{width:p,height:_},I,!pe.noMipmap,!0,pe._texture.type,!1,pe.samplingMode,!1);re.wrapU=pe.wrapU,re.wrapV=pe.wrapV,re.uOffset=pe.uOffset,re.vOffset=pe.vOffset,re.uScale=pe.uScale,re.vScale=pe.vScale,re.uAng=pe.uAng,re.vAng=pe.vAng,re.wAng=pe.wAng,re.coordinatesIndex=pe.coordinatesIndex,re.level=pe.level,re.anisotropicFilteringLevel=pe.anisotropicFilteringLevel,re._texture.isReady=!1,pe.wrapU=Ki.CLAMP_ADDRESSMODE,pe.wrapV=Ki.CLAMP_ADDRESSMODE;const ae=new Kp("pass",1,null,E?Ki.BILINEAR_SAMPLINGMODE:Ki.NEAREST_SAMPLINGMODE,Z,!1,0);return ae.externalTextureSamplerBinding=!0,ae.getEffect().executeWhenCompiled(()=>{ae.onApply=function(_e){_e.setTexture("textureSampler",pe)};const he=re.renderTarget;he&&(I.postProcessManager.directRender([ae],he),Z.unBindFramebuffer(he),re.disposeFramebufferObjects(),ae.dispose(),re.getInternalTexture().isReady=!0)}),re}function nv(pe,p,_,E,I,Z,re,ae){const he=p.getEngine();return p.isReady=!1,I=I??p.samplingMode,E=E??p.type,Z=Z??p.format,re=re??p.width,ae=ae??p.height,E===-1&&(E=0),new Promise(_e=>{const ve=new ha("postprocess",pe,null,null,1,null,I,he,!1,void 0,E,void 0,null,!1,Z);ve.externalTextureSamplerBinding=!0;const Le=he.createRenderTargetTexture({width:re,height:ae},{generateDepthBuffer:!1,generateMipMaps:!1,generateStencilBuffer:!1,samplingMode:I,type:E,format:Z});ve.getEffect().executeWhenCompiled(()=>{ve.onApply=ze=>{ze._bindTexture("textureSampler",p),ze.setFloat2("scale",1,1)},_.postProcessManager.directRender([ve],Le,!0),he.restoreDefaultFramebuffer(),he._releaseTexture(p),ve&&ve.dispose(),Le._swapAndDie(p),p.type=E,p.format=5,p.isReady=!0,_e(p)})})}let qm,av;function hN(pe){qm||(qm=new Float32Array(1),av=new Int32Array(qm.buffer)),qm[0]=pe;const p=av[0];let _=p>>16&32768,E=p>>12&2047;const I=p>>23&255;return I<103?_:I>142?(_|=31744,_|=(I==255?0:1)&&p&8388607,_):I<113?(E|=2048,_|=(E>>114-I)+(E>>113-I&1),_):(_|=I-112<<10|E>>1,_+=E&1,_)}function cN(pe){const p=(pe&32768)>>15,_=(pe&31744)>>10,E=pe&1023;return _===0?(p?-1:1)*Math.pow(2,-14)*(E/Math.pow(2,10)):_==31?E?NaN:(p?-1:1)*(1/0):(p?-1:1)*Math.pow(2,_-15)*(1+E/Math.pow(2,10))}const uN=async(pe,p,_,E,I)=>{const Z=pe.getScene(),re=Z.getEngine();let ae;if(!pe.isCube)ae=new ha("lod","lod",["lod","gamma"],null,1,null,Ki.NEAREST_NEAREST_MIPNEAREST,re);else{const ve=["#define POSITIVEX","#define NEGATIVEX","#define POSITIVEY","#define NEGATIVEY","#define POSITIVEZ","#define NEGATIVEZ"];ae=new ha("lodCube","lodCube",["lod","gamma"],null,1,null,Ki.NEAREST_NEAREST_MIPNEAREST,re,!1,ve[E])}await new Promise(ve=>{ae.getEffect().executeWhenCompiled(()=>{ve(0)})});const he=new z2("temp",{width:p,height:_},Z,!1);ae.onApply=function(ve){ve.setTexture("textureSampler",pe),ve.setFloat("lod",I),ve.setBool("gamma",pe.gammaSpace)};const _e=pe.getInternalTexture();try{if(he.renderTarget&&_e){const ve=_e.samplingMode;I!==0?pe.updateSamplingMode(Ki.NEAREST_NEAREST_MIPNEAREST):pe.updateSamplingMode(Ki.NEAREST_NEAREST),Z.postProcessManager.directRender([ae],he.renderTarget,!0),pe.updateSamplingMode(ve);const Le=await re.readPixels(0,0,p,_),ze=new Uint8Array(Le.buffer,0,Le.byteLength);return re.unBindFramebuffer(he.renderTarget),ze}else throw Error("Render to texture failed.")}finally{he.dispose(),ae.dispose()}};async function _N(pe,p,_,E=0,I=0){return!pe.isReady()&&pe._texture&&await new Promise((Z,re)=>{if(pe._texture===null){re(0);return}pe._texture.onLoadedObservable.addOnce(()=>{Z(0)})}),await uN(pe,p,_,E,I)}const q3={CreateResizedCopy:lN,ApplyPostProcess:nv,ToHalfFloat:hN,FromHalfFloat:cN,GetTextureDataAsync:_N};class n_{static ExpandRGBDTexture(p){const _=p._texture;if(!_||!p.isRGBD)return;const E=_.getEngine(),I=E.getCaps(),Z=_.isReady;let re=!1;I.textureHalfFloatRender&&I.textureHalfFloatLinearFiltering?(re=!0,_.type=2):I.textureFloatRender&&I.textureFloatLinearFiltering&&(re=!0,_.type=1),re&&(_.isReady=!1,_._isRGBD=!1,_.invertY=!1);const ae=()=>{const he=new ha("rgbdDecode","rgbdDecode",null,null,1,null,3,E,!1,void 0,_.type,void 0,null,!1);he.externalTextureSamplerBinding=!0;const _e=E.createRenderTargetTexture(_.width,{generateDepthBuffer:!1,generateMipMaps:!1,generateStencilBuffer:!1,samplingMode:_.samplingMode,type:_.type,format:5});he.getEffect().executeWhenCompiled(()=>{he.onApply=ve=>{ve._bindTexture("textureSampler",_),ve.setFloat2("scale",1,1)},p.getScene().postProcessManager.directRender([he],_e,!0),E.restoreDefaultFramebuffer(),E._releaseTexture(_),he&&he.dispose(),_e._swapAndDie(_),_.isReady=!0})};re&&(Z?ae():p.onLoadObservable.addOnce(ae))}static EncodeTextureToRGBD(p,_,E=0){return nv("rgbdEncode",p,_,E,1,5)}}class wu{constructor(p,_,E,I){this.name=p,this.worldAxisForNormal=_,this.worldAxisForFileX=E,this.worldAxisForFileY=I}}class $m{static ConvertCubeMapTextureToSphericalPolynomial(p){if(!p.isCube)return null;p.getScene()?.getEngine().flushFramebuffer();const _=p.getSize().width,E=p.readPixels(0,void 0,void 0,!1),I=p.readPixels(1,void 0,void 0,!1);let Z,re;p.isRenderTarget?(Z=p.readPixels(3,void 0,void 0,!1),re=p.readPixels(2,void 0,void 0,!1)):(Z=p.readPixels(2,void 0,void 0,!1),re=p.readPixels(3,void 0,void 0,!1));const ae=p.readPixels(4,void 0,void 0,!1),he=p.readPixels(5,void 0,void 0,!1),_e=p.gammaSpace,ve=5;let Le=0;return(p.textureType==1||p.textureType==2)&&(Le=1),new Promise(ze=>{Promise.all([I,E,Z,re,ae,he]).then(([He,xt,rt,Tt,Lt,Nt])=>{const qt={size:_,right:xt,left:He,up:rt,down:Tt,front:Lt,back:Nt,format:ve,type:Le,gammaSpace:_e};ze(this.ConvertCubeMapToSphericalPolynomial(qt))})})}static _AreaElement(p,_){return Math.atan2(p*_,Math.sqrt(p*p+_*_+1))}static ConvertCubeMapToSphericalPolynomial(p){const _=new Ru;let E=0;const I=2/p.size,Z=I,re=.5*I,ae=re-1;for(let ze=0;ze<6;ze++){const He=this._FileFaces[ze],xt=p[He.name];let rt=ae;const Tt=p.format===5?4:3;for(let Lt=0;Lt<p.size;Lt++){let Nt=ae;for(let qt=0;qt<p.size;qt++){const Xt=He.worldAxisForFileX.scale(Nt).add(He.worldAxisForFileY.scale(rt)).add(He.worldAxisForNormal);Xt.normalize();const zt=this._AreaElement(Nt-re,rt-re)-this._AreaElement(Nt-re,rt+re)-this._AreaElement(Nt+re,rt-re)+this._AreaElement(Nt+re,rt+re);let Gt=xt[Lt*p.size*Tt+qt*Tt+0],xi=xt[Lt*p.size*Tt+qt*Tt+1],Gi=xt[Lt*p.size*Tt+qt*Tt+2];isNaN(Gt)&&(Gt=0),isNaN(xi)&&(xi=0),isNaN(Gi)&&(Gi=0),p.type===0&&(Gt/=255,xi/=255,Gi/=255),p.gammaSpace&&(Gt=Math.pow($t.Clamp(Gt),ki),xi=Math.pow($t.Clamp(xi),ki),Gi=Math.pow($t.Clamp(Gi),ki));const vs=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const Ur=Math.max(Gt,xi,Gi);if(Ur>vs){const hn=vs/Ur;Gt*=hn,xi*=hn,Gi*=hn}}else Gt=$t.Clamp(Gt,0,vs),xi=$t.Clamp(xi,0,vs),Gi=$t.Clamp(Gi,0,vs);const ks=new Rs(Gt,xi,Gi);_.addLight(Xt,ks,zt),E+=zt,Nt+=I}rt+=Z}}const Le=4*Math.PI*6/6/E;return _.scaleInPlace(Le),_.convertIncidentRadianceToIrradiance(),_.convertIrradianceToLambertianRadiance(),Mu.FromHarmonics(_)}}$m._FileFaces=[new wu("right",new at(1,0,0),new at(0,0,-1),new at(0,-1,0)),new wu("left",new at(-1,0,0),new at(0,0,1),new at(0,-1,0)),new wu("up",new at(0,1,0),new at(1,0,0),new at(0,0,1)),new wu("down",new at(0,-1,0),new at(1,0,0),new at(0,0,-1)),new wu("front",new at(0,0,1),new at(1,0,0),new at(0,-1,0)),new wu("back",new at(0,0,-1),new at(-1,0,0),new at(0,-1,0))],$m.MAX_HDRI_VALUE=4096,$m.PRESERVE_CLAMPED_COLORS=!1,na.prototype.forceSphericalPolynomialsRecompute=function(){this._texture&&(this._texture._sphericalPolynomial=null,this._texture._sphericalPolynomialPromise=null,this._texture._sphericalPolynomialComputed=!1)},Object.defineProperty(na.prototype,"sphericalPolynomial",{get:function(){if(this._texture){if(this._texture._sphericalPolynomial||this._texture._sphericalPolynomialComputed)return this._texture._sphericalPolynomial;if(this._texture.isReady)return this._texture._sphericalPolynomialPromise||(this._texture._sphericalPolynomialPromise=$m.ConvertCubeMapTextureToSphericalPolynomial(this),this._texture._sphericalPolynomialPromise===null?this._texture._sphericalPolynomialComputed=!0:this._texture._sphericalPolynomialPromise.then(pe=>{this._texture._sphericalPolynomial=pe,this._texture._sphericalPolynomialComputed=!0})),null}return null},set:function(pe){this._texture&&(this._texture._sphericalPolynomial=pe)},enumerable:!0,configurable:!0});const xv="rgbdEncodePixelShader",lv=`varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);}`;ji.ShadersStore[xv]=lv;const $3={name:xv,shader:lv},a_="image/png",x_=2,jp=[134,22,135,150,246,214,150,54];function hv(pe){const p=new DataView(pe.buffer,pe.byteOffset,pe.byteLength);let _=0;for(let re=0;re<jp.length;re++)if(p.getUint8(_++)!==jp[re])return Ti.Error("Not a babylon environment map"),null;let E="",I=0;for(;I=p.getUint8(_++);)E+=String.fromCharCode(I);let Z=JSON.parse(E);return Z=rg(Z),Z.specular&&(Z.specular.specularDataPosition=_,Z.specular.lodGenerationScale=Z.specular.lodGenerationScale||.8),Z}function rg(pe){if(pe.version>x_)throw new Error(`Unsupported babylon environment map version "${pe.version}". Latest supported version is "${x_}".`);return pe.version===2||(pe={...pe,version:2,imageType:a_}),pe}async function TN(pe,p={}){const _=pe.getInternalTexture();if(!_)return Promise.reject("The cube texture is invalid.");const E=p.imageType??a_,I=_.getEngine();if(pe.textureType!==2&&pe.textureType!==1&&pe.textureType!==0&&pe.textureType!==0&&pe.textureType!==7&&pe.textureType!==-1)return Promise.reject("The cube texture should allow HDR (Full Float or Half Float).");let Z=1;if(!I.getCaps().textureFloatRender&&(Z=2,!I.getCaps().textureHalfFloatRender))return Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.");pe.sphericalPolynomial;const re=pe.getInternalTexture()?._sphericalPolynomialPromise,ae=_.width,he=new U0(I),_e={};I.flushFramebuffer();const ve=$t.ILog2(_.width);for(let zt=0;zt<=ve;zt++){const Gt=Math.pow(2,ve-zt);for(let xi=0;xi<6;xi++){let Gi=await pe.readPixels(xi,zt,void 0,!1);if(Gi&&Gi.byteLength===Gi.length){const hn=new Float32Array(Gi.byteLength*4);for(let pn=0;pn<Gi.byteLength;pn++)hn[pn]=Gi[pn]/255,hn[pn]=Math.pow(hn[pn],2.2);Gi=hn}else if(Gi&&pe.gammaSpace){const hn=Gi;for(let pn=0;pn<hn.length;pn++)hn[pn]=Math.pow(hn[pn],2.2)}const vs=I.createRawTexture(Gi,Gt,Gt,5,!1,!0,1,null,Z);await n_.EncodeTextureToRGBD(vs,he,Z);const ks=await I._readTexturePixels(vs,Gt,Gt),Ur=await Lx.DumpDataAsync(Gt,Gt,ks,E,void 0,!1,!0,p.imageQuality);_e[zt*6+xi]=Ur,vs.dispose()}}he.dispose(),re&&await re;const Le={version:x_,width:ae,imageType:E,irradiance:vN(pe),specular:{mipmaps:[],lodGenerationScale:pe.lodGenerationScale}};let ze=0;for(let zt=0;zt<=ve;zt++)for(let Gt=0;Gt<6;Gt++){const xi=_e[zt*6+Gt].byteLength;Le.specular.mipmaps.push({length:xi,position:ze}),ze+=xi}const He=JSON.stringify(Le),xt=new ArrayBuffer(He.length+1),rt=new Uint8Array(xt);for(let zt=0,Gt=He.length;zt<Gt;zt++)rt[zt]=He.charCodeAt(zt);rt[He.length]=0;const Tt=jp.length+ze+xt.byteLength,Lt=new ArrayBuffer(Tt),Nt=new Uint8Array(Lt),qt=new DataView(Lt);let Xt=0;for(let zt=0;zt<jp.length;zt++)qt.setUint8(Xt++,jp[zt]);Nt.set(new Uint8Array(xt),Xt),Xt+=xt.byteLength;for(let zt=0;zt<=ve;zt++)for(let Gt=0;Gt<6;Gt++){const xi=_e[zt*6+Gt];Nt.set(new Uint8Array(xi),Xt),Xt+=xi.byteLength}return Lt}function vN(pe){const p=pe.sphericalPolynomial;return p==null?null:{x:[p.x.x,p.x.y,p.x.z],y:[p.y.x,p.y.y,p.y.z],z:[p.z.x,p.z.y,p.z.z],xx:[p.xx.x,p.xx.y,p.xx.z],yy:[p.yy.x,p.yy.y,p.yy.z],zz:[p.zz.x,p.zz.y,p.zz.z],yz:[p.yz.x,p.yz.y,p.yz.z],zx:[p.zx.x,p.zx.y,p.zx.z],xy:[p.xy.x,p.xy.y,p.xy.z]}}function cv(pe,p){p=rg(p);const _=p.specular;let E=$t.Log2(p.width);if(E=Math.round(E)+1,_.mipmaps.length!==6*E)throw new Error(`Unsupported specular mipmaps number "${_.mipmaps.length}"`);const I=new Array(E);for(let Z=0;Z<E;Z++){I[Z]=new Array(6);for(let re=0;re<6;re++){const ae=_.mipmaps[Z*6+re];I[Z][re]=new Uint8Array(pe.buffer,pe.byteOffset+_.specularDataPosition+ae.position,ae.length)}}return I}function uv(pe,p,_){_=rg(_);const E=_.specular;if(!E)return Promise.resolve();pe._lodGenerationScale=E.lodGenerationScale;const I=cv(p,_);return ng(pe,I,_.imageType)}function pv(pe,p,_,E,I,Z,re,ae,he,_e,ve){return new Promise((Le,ze)=>{if(_){const He=p.createTexture(null,!0,!0,null,1,null,xt=>{ze(xt)},pe);E.getEffect().executeWhenCompiled(()=>{E.externalTextureSamplerBinding=!0,E.onApply=xt=>{xt._bindTexture("textureSampler",He),xt.setFloat2("scale",1,p._features.needsInvertingBitmap&&pe instanceof ImageBitmap?-1:1)},p.scenes.length&&(p.scenes[0].postProcessManager.directRender([E],_e,!0,Z,re),p.restoreDefaultFramebuffer(),He.dispose(),URL.revokeObjectURL(I),Le())})}else{if(p._uploadImageToTexture(ve,pe,Z,re),ae){const He=he[re];He&&p._uploadImageToTexture(He._texture,pe,Z,0)}Le()}})}function ng(pe,p,_=a_){if(!lt.IsExponentOfTwo(pe.width))throw new Error("Texture size must be a power of two");const E=$t.ILog2(pe.width)+1,I=pe.getEngine();let Z=!1,re=!1,ae=null,he=null,_e=null;const ve=I.getCaps();if(pe.format=5,pe.type=0,pe.generateMipMaps=!0,pe._cachedAnisotropicFilteringLevel=null,I.updateTextureSamplingMode(3,pe),ve.textureLOD?I._features.supportRenderAndCopyToLodForFloatTextures?ve.textureHalfFloatRender&&ve.textureHalfFloatLinearFiltering?(Z=!0,pe.type=2):ve.textureFloatRender&&ve.textureFloatLinearFiltering&&(Z=!0,pe.type=1):Z=!1:(Z=!1,re=!0,_e={}),Z)ae=new ha("rgbdDecode","rgbdDecode",null,null,1,null,3,I,!1,void 0,pe.type,void 0,null,!1),pe._isRGBD=!1,pe.invertY=!1,he=I.createRenderTargetCubeTexture(pe.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:pe.type,format:5});else if(pe._isRGBD=!0,pe.invertY=!0,re){const He=pe._lodGenerationScale,xt=pe._lodGenerationOffset;for(let rt=0;rt<3;rt++){const Lt=1-rt/2,Nt=xt,qt=(E-1)*He+xt,Xt=Nt+(qt-Nt)*Lt,zt=Math.round(Math.min(Math.max(Xt,0),qt)),Gt=new c0(I,kn.Temp);Gt.isCube=!0,Gt.invertY=!0,Gt.generateMipMaps=!1,I.updateTextureSamplingMode(2,Gt);const xi=new na(null);switch(xi._isCube=!0,xi._texture=Gt,_e[zt]=xi,rt){case 0:pe._lodTextureLow=xi;break;case 1:pe._lodTextureMid=xi;break;case 2:pe._lodTextureHigh=xi;break}}}const Le=[];for(let ze=0;ze<p.length;ze++)for(let He=0;He<6;He++){const xt=p[ze][He],rt=new Blob([xt],{type:_}),Tt=URL.createObjectURL(rt);let Lt;if(I._features.forceBitmapOverHTMLImageElement)Lt=I.createImageBitmap(rt,{premultiplyAlpha:"none"}).then(Nt=>pv(Nt,I,Z,ae,Tt,He,ze,re,_e,he,pe));else{const Nt=new Image;Nt.src=Tt,Lt=new Promise((qt,Xt)=>{Nt.onload=()=>{pv(Nt,I,Z,ae,Tt,He,ze,re,_e,he,pe).then(()=>qt()).catch(zt=>{Xt(zt)})},Nt.onerror=zt=>{Xt(zt)}})}Le.push(Lt)}if(p.length<E){let ze;const He=Math.pow(2,E-1-p.length),xt=He*He*4;switch(pe.type){case 0:{ze=new Uint8Array(xt);break}case 2:{ze=new Uint16Array(xt);break}case 1:{ze=new Float32Array(xt);break}}for(let rt=p.length;rt<E;rt++)for(let Tt=0;Tt<6;Tt++)I._uploadArrayBufferViewToTexture(pe,ze,Tt,rt)}return Promise.all(Le).then(()=>{he&&(I._releaseTexture(pe),he._swapAndDie(pe)),ae&&ae.dispose(),re&&(pe._lodTextureHigh&&pe._lodTextureHigh._texture&&(pe._lodTextureHigh._texture.isReady=!0),pe._lodTextureMid&&pe._lodTextureMid._texture&&(pe._lodTextureMid._texture.isReady=!0),pe._lodTextureLow&&pe._lodTextureLow._texture&&(pe._lodTextureLow._texture.isReady=!0))})}function _v(pe,p){p=rg(p);const _=p.irradiance;if(!_)return;const E=new Mu;at.FromArrayToRef(_.x,0,E.x),at.FromArrayToRef(_.y,0,E.y),at.FromArrayToRef(_.z,0,E.z),at.FromArrayToRef(_.xx,0,E.xx),at.FromArrayToRef(_.yy,0,E.yy),at.FromArrayToRef(_.zz,0,E.zz),at.FromArrayToRef(_.yz,0,E.yz),at.FromArrayToRef(_.zx,0,E.zx),at.FromArrayToRef(_.xy,0,E.xy),pe._sphericalPolynomial=E}function RN(pe,p,_,E,I){const Z=pe.getEngine().createRawCubeTexture(null,pe.width,pe.format,pe.type,pe.generateMipMaps,pe.invertY,pe.samplingMode,pe._compression),re=ng(Z,p).then(()=>pe);return pe.onRebuildCallback=ae=>({proxy:re,isReady:!0,isAsync:!0}),pe._source=kn.CubeRawRGBD,pe._bufferViewArrayArray=p,pe._lodGenerationScale=E,pe._lodGenerationOffset=I,pe._sphericalPolynomial=_,ng(pe,p).then(()=>(pe.isReady=!0,pe))}const rk={GetEnvInfo:hv,CreateEnvTextureAsync:TN,CreateImageDataArrayBufferViews:cv,UploadEnvLevelsAsync:uv,UploadLevelsAsync:ng,UploadEnvSpherical:_v};class MN{constructor(){this.supportCascades=!1}canLoad(p){return p.endsWith(".env")}loadCubeData(p,_,E,I,Z){if(Array.isArray(p))return;const re=hv(p);if(re){_.width=re.width,_.height=re.width;try{_v(_,re),uv(_,p,re).then(()=>{_.isReady=!0,_.onLoadedObservable.notifyObservers(_),_.onLoadedObservable.clear(),I&&I()},ae=>{Z?.("Can not upload environment levels",ae)})}catch(ae){Z?.("Can not upload environment file",ae)}}else Z&&Z("Can not parse the environment file",null)}loadData(){throw".env not supported in 2d."}}ci._TextureLoaders.push(new MN);class qp{get resolve(){return this._resolve}get reject(){return this._reject}constructor(){this.promise=new Promise((p,_)=>{this._resolve=p,this._reject=_})}}var ag;(function(pe){pe[pe.NONE=0]="NONE",pe[pe.STEP=1]="STEP"})(ag||(ag={}));class Lu{constructor(p,_,E){this.name=p,this.from=_,this.to=E}clone(){return new Lu(this.name,this.from,this.to)}}const wN=Object.freeze(new us(0,0,0,0)),LN=Object.freeze(at.Zero()),kN=Object.freeze(xr.Zero()),UN=Object.freeze(zo.Zero()),GN=Object.freeze(Rs.Black()),zN=Object.freeze(new Tr(0,0,0,0)),X2={key:0,repeatCount:0,loopMode:2};class Li{static _PrepareAnimation(p,_,E,I,Z,re,ae,he){let _e;if(!isNaN(parseFloat(Z))&&isFinite(Z)?_e=Li.ANIMATIONTYPE_FLOAT:Z instanceof us?_e=Li.ANIMATIONTYPE_QUATERNION:Z instanceof at?_e=Li.ANIMATIONTYPE_VECTOR3:Z instanceof xr?_e=Li.ANIMATIONTYPE_VECTOR2:Z instanceof Rs?_e=Li.ANIMATIONTYPE_COLOR3:Z instanceof Tr?_e=Li.ANIMATIONTYPE_COLOR4:Z instanceof zo&&(_e=Li.ANIMATIONTYPE_SIZE),_e==null)return null;const ve=new Li(p,_,E,_e,ae),Le=[{frame:0,value:Z},{frame:I,value:re}];return ve.setKeys(Le),he!==void 0&&ve.setEasingFunction(he),ve}static CreateAnimation(p,_,E,I){const Z=new Li(p+"Animation",p,E,_,Li.ANIMATIONLOOPMODE_CONSTANT);return Z.setEasingFunction(I),Z}static CreateAndStartAnimation(p,_,E,I,Z,re,ae,he,_e,ve,Le){const ze=Li._PrepareAnimation(p,E,I,Z,re,ae,he,_e);return!ze||(_.getScene&&(Le=_.getScene()),!Le)?null:Le.beginDirectAnimation(_,[ze],0,Z,ze.loopMode===1,1,ve)}static CreateAndStartHierarchyAnimation(p,_,E,I,Z,re,ae,he,_e,ve,Le){const ze=Li._PrepareAnimation(p,I,Z,re,ae,he,_e,ve);return ze?_.getScene().beginDirectHierarchyAnimation(_,E,[ze],0,re,ze.loopMode===1,1,Le):null}static CreateMergeAndStartAnimation(p,_,E,I,Z,re,ae,he,_e,ve){const Le=Li._PrepareAnimation(p,E,I,Z,re,ae,he,_e);return Le?(_.animations.push(Le),_.getScene().beginAnimation(_,0,Z,Le.loopMode===1,1,ve)):null}static MakeAnimationAdditive(p,_,E,I=!1,Z){let re;typeof _=="object"?re=_:re={referenceFrame:_??0,range:E,cloneOriginalAnimation:I,clonedAnimationName:Z};let ae=p;if(re.cloneOriginalAnimation&&(ae=p.clone(),ae.name=re.clonedAnimationName||ae.name),!ae._keys.length)return ae;const he=re.referenceFrame&&re.referenceFrame>=0?re.referenceFrame:0;let _e=0;const ve=ae._keys[0];let Le=ae._keys.length-1;const ze=ae._keys[Le],He={referenceValue:ve.value,referencePosition:ui.Vector3[0],referenceQuaternion:ui.Quaternion[0],referenceScaling:ui.Vector3[1],keyPosition:ui.Vector3[2],keyQuaternion:ui.Quaternion[1],keyScaling:ui.Vector3[3]};let xt=ve.frame,rt=ze.frame;if(re.range){const Nt=ae.getRange(re.range);Nt&&(xt=Nt.from,rt=Nt.to)}else xt=re.fromFrame??xt,rt=re.toFrame??rt;if(xt!==ve.frame&&(_e=ae.createKeyForFrame(xt)),rt!==ze.frame&&(Le=ae.createKeyForFrame(rt)),ae._keys.length===1){const Nt=ae._getKeyValue(ae._keys[0]);He.referenceValue=Nt.clone?Nt.clone():Nt}else if(he<=ve.frame){const Nt=ae._getKeyValue(ve.value);He.referenceValue=Nt.clone?Nt.clone():Nt}else if(he>=ze.frame){const Nt=ae._getKeyValue(ze.value);He.referenceValue=Nt.clone?Nt.clone():Nt}else{X2.key=0;const Nt=ae._interpolate(he,X2);He.referenceValue=Nt.clone?Nt.clone():Nt}ae.dataType===Li.ANIMATIONTYPE_QUATERNION?He.referenceValue.normalize().conjugateInPlace():ae.dataType===Li.ANIMATIONTYPE_MATRIX&&(He.referenceValue.decompose(He.referenceScaling,He.referenceQuaternion,He.referencePosition),He.referenceQuaternion.normalize().conjugateInPlace());let Tt=Number.MAX_VALUE;const Lt=re.clipKeys?[]:null;for(let Nt=_e;Nt<=Le;Nt++){let qt=ae._keys[Nt];if(Lt&&(qt={frame:qt.frame,value:qt.value.clone?qt.value.clone():qt.value,inTangent:qt.inTangent,outTangent:qt.outTangent,interpolation:qt.interpolation,lockedTangent:qt.lockedTangent},Tt===Number.MAX_VALUE&&(Tt=qt.frame),qt.frame-=Tt,Lt.push(qt)),!(Nt&&ae.dataType!==Li.ANIMATIONTYPE_FLOAT&&qt.value===ve.value))switch(ae.dataType){case Li.ANIMATIONTYPE_MATRIX:qt.value.decompose(He.keyScaling,He.keyQuaternion,He.keyPosition),He.keyPosition.subtractInPlace(He.referencePosition),He.keyScaling.divideInPlace(He.referenceScaling),He.referenceQuaternion.multiplyToRef(He.keyQuaternion,He.keyQuaternion),jt.ComposeToRef(He.keyScaling,He.keyQuaternion,He.keyPosition,qt.value);break;case Li.ANIMATIONTYPE_QUATERNION:He.referenceValue.multiplyToRef(qt.value,qt.value);break;case Li.ANIMATIONTYPE_VECTOR2:case Li.ANIMATIONTYPE_VECTOR3:case Li.ANIMATIONTYPE_COLOR3:case Li.ANIMATIONTYPE_COLOR4:qt.value.subtractToRef(He.referenceValue,qt.value);break;case Li.ANIMATIONTYPE_SIZE:qt.value.width-=He.referenceValue.width,qt.value.height-=He.referenceValue.height;break;default:qt.value-=He.referenceValue}}return Lt&&ae.setKeys(Lt,!0),ae}static TransitionTo(p,_,E,I,Z,re,ae,he=null){if(ae<=0)return E[p]=_,he&&he(),null;const _e=Z*(ae/1e3);re.setKeys([{frame:0,value:E[p].clone?E[p].clone():E[p]},{frame:_e,value:_}]),E.animations||(E.animations=[]),E.animations.push(re);const ve=I.beginAnimation(E,0,_e,!1);return ve.onAnimationEnd=he,ve}get runtimeAnimations(){return this._runtimeAnimations}get hasRunningRuntimeAnimations(){for(const p of this._runtimeAnimations)if(!p.isStopped())return!0;return!1}constructor(p,_,E,I,Z,re){this.name=p,this.targetProperty=_,this.framePerSecond=E,this.dataType=I,this.loopMode=Z,this.enableBlending=re,this._easingFunction=null,this._runtimeAnimations=new Array,this._events=new Array,this.blendingSpeed=.01,this._ranges={},this.targetPropertyPath=_.split("."),this.dataType=I,this.loopMode=Z===void 0?Li.ANIMATIONLOOPMODE_CYCLE:Z,this.uniqueId=Li._UniqueIdGenerator++}toString(p){let _="Name: "+this.name+", property: "+this.targetProperty;if(_+=", datatype: "+["Float","Vector3","Quaternion","Matrix","Color3","Vector2"][this.dataType],_+=", nKeys: "+(this._keys?this._keys.length:"none"),_+=", nRanges: "+(this._ranges?Object.keys(this._ranges).length:"none"),p){_+=", Ranges: {";let E=!0;for(const I in this._ranges)E&&(_+=", ",E=!1),_+=I;_+="}"}return _}addEvent(p){this._events.push(p),this._events.sort((_,E)=>_.frame-E.frame)}removeEvents(p){for(let _=0;_<this._events.length;_++)this._events[_].frame===p&&(this._events.splice(_,1),_--)}getEvents(){return this._events}createRange(p,_,E){this._ranges[p]||(this._ranges[p]=new Lu(p,_,E))}deleteRange(p,_=!0){const E=this._ranges[p];if(E){if(_){const I=E.from,Z=E.to;for(let re=this._keys.length-1;re>=0;re--)this._keys[re].frame>=I&&this._keys[re].frame<=Z&&this._keys.splice(re,1)}this._ranges[p]=null}}getRange(p){return this._ranges[p]}getKeys(){return this._keys}getHighestFrame(){let p=0;for(let _=0,E=this._keys.length;_<E;_++)p<this._keys[_].frame&&(p=this._keys[_].frame);return p}getEasingFunction(){return this._easingFunction}setEasingFunction(p){this._easingFunction=p}floatInterpolateFunction(p,_,E){return $t.Lerp(p,_,E)}floatInterpolateFunctionWithTangents(p,_,E,I,Z){return $t.Hermite(p,_,E,I,Z)}quaternionInterpolateFunction(p,_,E){return us.Slerp(p,_,E)}quaternionInterpolateFunctionWithTangents(p,_,E,I,Z){return us.Hermite(p,_,E,I,Z).normalize()}vector3InterpolateFunction(p,_,E){return at.Lerp(p,_,E)}vector3InterpolateFunctionWithTangents(p,_,E,I,Z){return at.Hermite(p,_,E,I,Z)}vector2InterpolateFunction(p,_,E){return xr.Lerp(p,_,E)}vector2InterpolateFunctionWithTangents(p,_,E,I,Z){return xr.Hermite(p,_,E,I,Z)}sizeInterpolateFunction(p,_,E){return zo.Lerp(p,_,E)}color3InterpolateFunction(p,_,E){return Rs.Lerp(p,_,E)}color3InterpolateFunctionWithTangents(p,_,E,I,Z){return Rs.Hermite(p,_,E,I,Z)}color4InterpolateFunction(p,_,E){return Tr.Lerp(p,_,E)}color4InterpolateFunctionWithTangents(p,_,E,I,Z){return Tr.Hermite(p,_,E,I,Z)}_getKeyValue(p){return typeof p=="function"?p():p}evaluate(p){return X2.key=0,this._interpolate(p,X2)}_interpolate(p,_,E=!1){if(_.loopMode===Li.ANIMATIONLOOPMODE_CONSTANT&&_.repeatCount>0)return _.highLimitValue.clone?_.highLimitValue.clone():_.highLimitValue;const I=this._keys,Z=I.length;let re=_.key;for(;re>=0&&p<I[re].frame;)--re;for(;re+1<=Z-1&&p>=I[re+1].frame;)++re;if(_.key=re,re<0)return E?void 0:this._getKeyValue(I[0].value);if(re+1>Z-1)return E?void 0:this._getKeyValue(I[Z-1].value);const ae=I[re],he=I[re+1];if(E&&(p===ae.frame||p===he.frame))return;const _e=this._getKeyValue(ae.value),ve=this._getKeyValue(he.value);if(ae.interpolation===ag.STEP)return he.frame>p?_e:ve;const Le=ae.outTangent!==void 0&&he.inTangent!==void 0,ze=he.frame-ae.frame;let He=(p-ae.frame)/ze;const xt=ae.easingFunction||this.getEasingFunction();switch(xt!==null&&(He=xt.ease(He)),this.dataType){case Li.ANIMATIONTYPE_FLOAT:{const rt=Le?this.floatInterpolateFunctionWithTangents(_e,ae.outTangent*ze,ve,he.inTangent*ze,He):this.floatInterpolateFunction(_e,ve,He);switch(_.loopMode){case Li.ANIMATIONLOOPMODE_CYCLE:case Li.ANIMATIONLOOPMODE_CONSTANT:case Li.ANIMATIONLOOPMODE_YOYO:return rt;case Li.ANIMATIONLOOPMODE_RELATIVE:case Li.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return(_.offsetValue??0)*_.repeatCount+rt}break}case Li.ANIMATIONTYPE_QUATERNION:{const rt=Le?this.quaternionInterpolateFunctionWithTangents(_e,ae.outTangent.scale(ze),ve,he.inTangent.scale(ze),He):this.quaternionInterpolateFunction(_e,ve,He);switch(_.loopMode){case Li.ANIMATIONLOOPMODE_CYCLE:case Li.ANIMATIONLOOPMODE_CONSTANT:case Li.ANIMATIONLOOPMODE_YOYO:return rt;case Li.ANIMATIONLOOPMODE_RELATIVE:case Li.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return rt.addInPlace((_.offsetValue||wN).scale(_.repeatCount))}return rt}case Li.ANIMATIONTYPE_VECTOR3:{const rt=Le?this.vector3InterpolateFunctionWithTangents(_e,ae.outTangent.scale(ze),ve,he.inTangent.scale(ze),He):this.vector3InterpolateFunction(_e,ve,He);switch(_.loopMode){case Li.ANIMATIONLOOPMODE_CYCLE:case Li.ANIMATIONLOOPMODE_CONSTANT:case Li.ANIMATIONLOOPMODE_YOYO:return rt;case Li.ANIMATIONLOOPMODE_RELATIVE:case Li.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return rt.add((_.offsetValue||LN).scale(_.repeatCount))}break}case Li.ANIMATIONTYPE_VECTOR2:{const rt=Le?this.vector2InterpolateFunctionWithTangents(_e,ae.outTangent.scale(ze),ve,he.inTangent.scale(ze),He):this.vector2InterpolateFunction(_e,ve,He);switch(_.loopMode){case Li.ANIMATIONLOOPMODE_CYCLE:case Li.ANIMATIONLOOPMODE_CONSTANT:case Li.ANIMATIONLOOPMODE_YOYO:return rt;case Li.ANIMATIONLOOPMODE_RELATIVE:case Li.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return rt.add((_.offsetValue||kN).scale(_.repeatCount))}break}case Li.ANIMATIONTYPE_SIZE:{switch(_.loopMode){case Li.ANIMATIONLOOPMODE_CYCLE:case Li.ANIMATIONLOOPMODE_CONSTANT:case Li.ANIMATIONLOOPMODE_YOYO:return this.sizeInterpolateFunction(_e,ve,He);case Li.ANIMATIONLOOPMODE_RELATIVE:case Li.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return this.sizeInterpolateFunction(_e,ve,He).add((_.offsetValue||UN).scale(_.repeatCount))}break}case Li.ANIMATIONTYPE_COLOR3:{const rt=Le?this.color3InterpolateFunctionWithTangents(_e,ae.outTangent.scale(ze),ve,he.inTangent.scale(ze),He):this.color3InterpolateFunction(_e,ve,He);switch(_.loopMode){case Li.ANIMATIONLOOPMODE_CYCLE:case Li.ANIMATIONLOOPMODE_CONSTANT:case Li.ANIMATIONLOOPMODE_YOYO:return rt;case Li.ANIMATIONLOOPMODE_RELATIVE:case Li.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return rt.add((_.offsetValue||GN).scale(_.repeatCount))}break}case Li.ANIMATIONTYPE_COLOR4:{const rt=Le?this.color4InterpolateFunctionWithTangents(_e,ae.outTangent.scale(ze),ve,he.inTangent.scale(ze),He):this.color4InterpolateFunction(_e,ve,He);switch(_.loopMode){case Li.ANIMATIONLOOPMODE_CYCLE:case Li.ANIMATIONLOOPMODE_CONSTANT:case Li.ANIMATIONLOOPMODE_YOYO:return rt;case Li.ANIMATIONLOOPMODE_RELATIVE:case Li.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return rt.add((_.offsetValue||zN).scale(_.repeatCount))}break}case Li.ANIMATIONTYPE_MATRIX:{switch(_.loopMode){case Li.ANIMATIONLOOPMODE_CYCLE:case Li.ANIMATIONLOOPMODE_CONSTANT:case Li.ANIMATIONLOOPMODE_YOYO:return Li.AllowMatricesInterpolation?this.matrixInterpolateFunction(_e,ve,He,_.workValue):_e;case Li.ANIMATIONLOOPMODE_RELATIVE:case Li.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return _e}break}}return 0}matrixInterpolateFunction(p,_,E,I){return Li.AllowMatrixDecomposeForInterpolation?I?(jt.DecomposeLerpToRef(p,_,E,I),I):jt.DecomposeLerp(p,_,E):I?(jt.LerpToRef(p,_,E,I),I):jt.Lerp(p,_,E)}clone(){const p=new Li(this.name,this.targetPropertyPath.join("."),this.framePerSecond,this.dataType,this.loopMode);if(p.enableBlending=this.enableBlending,p.blendingSpeed=this.blendingSpeed,this._keys&&p.setKeys(this._keys),this._ranges){p._ranges={};for(const _ in this._ranges){const E=this._ranges[_];E&&(p._ranges[_]=E.clone())}}return p}setKeys(p,_=!1){this._keys=_?p:p.slice(0)}createKeyForFrame(p){X2.key=0;const _=this._interpolate(p,X2,!0);if(!_)return this._keys[X2.key].frame===p?X2.key:X2.key+1;const E={frame:p,value:_.clone?_.clone():_};return this._keys.splice(X2.key+1,0,E),X2.key+1}serialize(){const p={};p.name=this.name,p.property=this.targetProperty,p.framePerSecond=this.framePerSecond,p.dataType=this.dataType,p.loopBehavior=this.loopMode,p.enableBlending=this.enableBlending,p.blendingSpeed=this.blendingSpeed;const _=this.dataType;p.keys=[];const E=this.getKeys();for(let I=0;I<E.length;I++){const Z=E[I],re={};switch(re.frame=Z.frame,_){case Li.ANIMATIONTYPE_FLOAT:re.values=[Z.value],Z.inTangent!==void 0&&re.values.push(Z.inTangent),Z.outTangent!==void 0&&(Z.inTangent===void 0&&re.values.push(void 0),re.values.push(Z.outTangent)),Z.interpolation!==void 0&&(Z.inTangent===void 0&&re.values.push(void 0),Z.outTangent===void 0&&re.values.push(void 0),re.values.push(Z.interpolation));break;case Li.ANIMATIONTYPE_QUATERNION:case Li.ANIMATIONTYPE_MATRIX:case Li.ANIMATIONTYPE_VECTOR3:case Li.ANIMATIONTYPE_COLOR3:case Li.ANIMATIONTYPE_COLOR4:re.values=Z.value.asArray(),Z.inTangent!=null&&re.values.push(Z.inTangent.asArray()),Z.outTangent!=null&&(Z.inTangent===void 0&&re.values.push(void 0),re.values.push(Z.outTangent.asArray())),Z.interpolation!==void 0&&(Z.inTangent===void 0&&re.values.push(void 0),Z.outTangent===void 0&&re.values.push(void 0),re.values.push(Z.interpolation));break}p.keys.push(re)}p.ranges=[];for(const I in this._ranges){const Z=this._ranges[I];if(!Z)continue;const re={};re.name=I,re.from=Z.from,re.to=Z.to,p.ranges.push(re)}return p}static _UniversalLerp(p,_,E){const I=p.constructor;return I.Lerp?I.Lerp(p,_,E):I.Slerp?I.Slerp(p,_,E):p.toFixed?p*(1-E)+E*_:_}static Parse(p){const _=new Li(p.name,p.property,p.framePerSecond,p.dataType,p.loopBehavior),E=p.dataType,I=[];let Z,re;for(p.enableBlending&&(_.enableBlending=p.enableBlending),p.blendingSpeed&&(_.blendingSpeed=p.blendingSpeed),re=0;re<p.keys.length;re++){const ae=p.keys[re];let he,_e,ve;switch(E){case Li.ANIMATIONTYPE_FLOAT:Z=ae.values[0],ae.values.length>=2&&(he=ae.values[1]),ae.values.length>=3&&(_e=ae.values[2]),ae.values.length>=4&&(ve=ae.values[3]);break;case Li.ANIMATIONTYPE_QUATERNION:if(Z=us.FromArray(ae.values),ae.values.length>=8){const ze=us.FromArray(ae.values.slice(4,8));ze.equals(us.Zero())||(he=ze)}if(ae.values.length>=12){const ze=us.FromArray(ae.values.slice(8,12));ze.equals(us.Zero())||(_e=ze)}ae.values.length>=13&&(ve=ae.values[12]);break;case Li.ANIMATIONTYPE_MATRIX:Z=jt.FromArray(ae.values),ae.values.length>=17&&(ve=ae.values[16]);break;case Li.ANIMATIONTYPE_COLOR3:Z=Rs.FromArray(ae.values),ae.values[3]&&(he=Rs.FromArray(ae.values[3])),ae.values[4]&&(_e=Rs.FromArray(ae.values[4])),ae.values[5]&&(ve=ae.values[5]);break;case Li.ANIMATIONTYPE_COLOR4:Z=Tr.FromArray(ae.values),ae.values[4]&&(he=Tr.FromArray(ae.values[4])),ae.values[5]&&(_e=Tr.FromArray(ae.values[5])),ae.values[6]&&(ve=Tr.FromArray(ae.values[6]));break;case Li.ANIMATIONTYPE_VECTOR3:default:Z=at.FromArray(ae.values),ae.values[3]&&(he=at.FromArray(ae.values[3])),ae.values[4]&&(_e=at.FromArray(ae.values[4])),ae.values[5]&&(ve=ae.values[5]);break}const Le={};Le.frame=ae.frame,Le.value=Z,he!=null&&(Le.inTangent=he),_e!=null&&(Le.outTangent=_e),ve!=null&&(Le.interpolation=ve),I.push(Le)}if(_.setKeys(I),p.ranges)for(re=0;re<p.ranges.length;re++)Z=p.ranges[re],_.createRange(Z.name,Z.from,Z.to);return _}static AppendSerializedAnimations(p,_){Hr.AppendSerializedAnimations(p,_)}static ParseFromFileAsync(p,_){return new Promise((E,I)=>{const Z=new Ua;Z.addEventListener("readystatechange",()=>{if(Z.readyState==4)if(Z.status==200){let re=JSON.parse(Z.responseText);if(re.animations&&(re=re.animations),re.length){const ae=[];for(const he of re)ae.push(this.Parse(he));E(ae)}else{const ae=this.Parse(re);p&&(ae.name=p),E(ae)}}else I("Unable to load the animation")}),Z.open("GET",_),Z.send()})}static ParseFromSnippetAsync(p){return new Promise((_,E)=>{const I=new Ua;I.addEventListener("readystatechange",()=>{if(I.readyState==4)if(I.status==200){const Z=JSON.parse(JSON.parse(I.responseText).jsonPayload);if(Z.animations){const re=JSON.parse(Z.animations),ae=[];for(const he of re.animations){const _e=this.Parse(he);_e.snippetId=p,ae.push(_e)}_(ae)}else{const re=JSON.parse(Z.animation),ae=this.Parse(re);ae.snippetId=p,_(ae)}}else E("Unable to load the snippet "+p)}),I.open("GET",this.SnippetUrl+"/"+p.replace(/#/g,"/")),I.send()})}}Li._UniqueIdGenerator=0,Li.AllowMatricesInterpolation=!1,Li.AllowMatrixDecomposeForInterpolation=!0,Li.SnippetUrl="https://snippet.babylonjs.com",Li.ANIMATIONTYPE_FLOAT=0,Li.ANIMATIONTYPE_VECTOR3=1,Li.ANIMATIONTYPE_QUATERNION=2,Li.ANIMATIONTYPE_MATRIX=3,Li.ANIMATIONTYPE_COLOR3=4,Li.ANIMATIONTYPE_COLOR4=7,Li.ANIMATIONTYPE_VECTOR2=5,Li.ANIMATIONTYPE_SIZE=6,Li.ANIMATIONLOOPMODE_RELATIVE=0,Li.ANIMATIONLOOPMODE_CYCLE=1,Li.ANIMATIONLOOPMODE_CONSTANT=2,Li.ANIMATIONLOOPMODE_YOYO=4,Li.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT=5,Li.CreateFromSnippetAsync=Li.ParseFromSnippetAsync,Gs("BABYLON.Animation",Li),Ha._AnimationRangeFactory=(pe,p,_)=>new Lu(pe,p,_);class WN{getClassName(){return"TargetedAnimation"}serialize(){const p={};return p.animation=this.animation.serialize(),p.targetId=this.target.id,p}}class xh{syncWithMask(){if(!this.mask){this._numActiveAnimatables=this._targetedAnimations.length;return}this._numActiveAnimatables=0;for(let p=0;p<this._animatables.length;++p){const _=this._animatables[p];this.mask.disabled||this.mask.retainsTarget(_.target.name)?(this._numActiveAnimatables++,_.paused&&_.restart()):_.paused||_.pause()}}removeUnmaskedAnimations(){if(!(!this.mask||this.mask.disabled)){for(let p=0;p<this._animatables.length;++p){const _=this._animatables[p];this.mask.retainsTarget(_.target.name)||(_.stop(),this._animatables.splice(p,1),--p)}for(let p=0;p<this._targetedAnimations.length;p++){const _=this._targetedAnimations[p];this.mask.retainsTarget(_.target.name)||(this._targetedAnimations.splice(p,1),--p)}}}get from(){return this._from}get to(){return this._to}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(p){if(this._speedRatio!==p){this._speedRatio=p;for(let _=0;_<this._animatables.length;_++){const E=this._animatables[_];E.speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(p){if(this._loopAnimation!==p){this._loopAnimation=p;for(let _=0;_<this._animatables.length;_++){const E=this._animatables[_];E.loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(p){if(this._isAdditive!==p){this._isAdditive=p;for(let _=0;_<this._animatables.length;_++){const E=this._animatables[_];E.isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(p){this._weight!==p&&(this._weight=p,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(p){if(this._playOrder!==p&&(this._playOrder=p,this._animatables.length>0)){for(let _=0;_<this._animatables.length;_++)this._animatables[_].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(p){if(this._enableBlending!==p&&(this._enableBlending=p,p!==null))for(let _=0;_<this._targetedAnimations.length;++_)this._targetedAnimations[_].animation.enableBlending=p}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(p){if(this._blendingSpeed!==p&&(this._blendingSpeed=p,p!==null))for(let _=0;_<this._targetedAnimations.length;++_)this._targetedAnimations[_].animation.blendingSpeed=p}getLength(p,_){p=p??this._from,_=_??this._to;const E=this.targetedAnimations[0].animation.framePerSecond*this._speedRatio;return(_-p)/E}static MergeAnimationGroups(p,_=!0,E=!1,I){if(p.length===0)return null;I=I??p[0].weight;let Z=Number.MAX_VALUE,re=-Number.MAX_VALUE;if(E)for(const he of p)he.from<Z&&(Z=he.from),he.to>re&&(re=he.to);const ae=new xh(p[0].name+"_merged",p[0]._scene,I);for(const he of p){E&&he.normalize(Z,re);for(const _e of he.targetedAnimations)ae.addTargetedAnimation(_e.animation,_e.target);_&&he.dispose()}return ae}constructor(p,_=null,E=-1,I=0){this.name=p,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._parentContainer=null,this.onAnimationEndObservable=new Ri,this.onAnimationLoopObservable=new Ri,this.onAnimationGroupLoopObservable=new Ri,this.onAnimationGroupEndObservable=new Ri,this.onAnimationGroupPauseObservable=new Ri,this.onAnimationGroupPlayObservable=new Ri,this.metadata=null,this._animationLoopFlags=[],this._scene=_||Mr.LastCreatedScene,this._weight=E,this._playOrder=I,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(p,_){const E=new WN;E.animation=p,E.target=_;const I=p.getKeys();return this._from>I[0].frame&&(this._from=I[0].frame),this._to<I[I.length-1].frame&&(this._to=I[I.length-1].frame),this._enableBlending!==null&&(p.enableBlending=this._enableBlending),this._blendingSpeed!==null&&(p.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(E),E}removeTargetedAnimation(p){for(let _=this._targetedAnimations.length-1;_>-1;_--)this._targetedAnimations[_].animation===p&&this._targetedAnimations.splice(_,1)}normalize(p=null,_=null){p==null&&(p=this._from),_==null&&(_=this._to);for(let E=0;E<this._targetedAnimations.length;E++){const Z=this._targetedAnimations[E].animation.getKeys(),re=Z[0],ae=Z[Z.length-1];if(re.frame>p){const he={frame:p,value:re.value,inTangent:re.inTangent,outTangent:re.outTangent,interpolation:re.interpolation};Z.splice(0,0,he)}if(ae.frame<_){const he={frame:_,value:ae.value,inTangent:ae.inTangent,outTangent:ae.outTangent,interpolation:ae.interpolation};Z.push(he)}}return this._from=p,this._to=_,this}_processLoop(p,_,E){p.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(_),!this._animationLoopFlags[E]&&(this._animationLoopFlags[E]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(p=!1,_=1,E,I,Z){if(this._isStarted||this._targetedAnimations.length===0)return this;this._loopAnimation=p,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let re=0;re<this._targetedAnimations.length;re++){const ae=this._targetedAnimations[re],he=this._scene.beginDirectAnimation(ae.target,[ae.animation],E!==void 0?E:this._from,I!==void 0?I:this._to,p,_,void 0,void 0,Z!==void 0?Z:this._isAdditive);he.weight=this._weight,he.playOrder=this._playOrder,he.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(ae),this._checkAnimationGroupEnded(he)},this._processLoop(he,ae,re),this._animatables.push(he)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=_,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let p=0;p<this._animatables.length;p++)this._animatables[p].pause();return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(p){return this.isStarted&&this._animatables.length===this._targetedAnimations.length?(p!==void 0&&(this.loopAnimation=p),this.restart()):(this.stop(),this.start(p,this._speedRatio)),this._isPaused=!1,this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(),this;for(let p=0;p<this._animatables.length;p++)this._animatables[p].reset();return this}restart(){if(!this._isStarted)return this;for(let p=0;p<this._animatables.length;p++)this._animatables[p].restart();return this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){if(!this._isStarted)return this;const p=this._animatables.slice();for(let E=0;E<p.length;E++)p[E].stop(void 0,void 0,!0);let _=0;for(let E=0;E<this._scene._activeAnimatables.length;E++){const I=this._scene._activeAnimatables[E];I._runtimeAnimations.length>0&&(this._scene._activeAnimatables[_++]=I)}return this._scene._activeAnimatables.length=_,this._isStarted=!1,this}setWeightForAllAnimatables(p){for(let _=0;_<this._animatables.length;_++){const E=this._animatables[_];E.weight=p}return this}syncAllAnimationsWith(p){for(let _=0;_<this._animatables.length;_++)this._animatables[_].syncWith(p);return this}goToFrame(p){if(!this._isStarted)return this;for(let _=0;_<this._animatables.length;_++)this._animatables[_].goToFrame(p);return this}dispose(){this._targetedAnimations.length=0,this._animatables.length=0;const p=this._scene.animationGroups.indexOf(this);if(p>-1&&this._scene.animationGroups.splice(p,1),this._parentContainer){const _=this._parentContainer.animationGroups.indexOf(this);_>-1&&this._parentContainer.animationGroups.splice(_,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(p){const _=this._animatables.indexOf(p);_>-1&&this._animatables.splice(_,1),this._animatables.length===0&&(this._isStarted=!1,this.onAnimationGroupEndObservable.notifyObservers(this))}clone(p,_,E=!1){const I=new xh(p||this.name,this._scene,this._weight,this._playOrder);I._from=this.from,I._to=this.to,I._speedRatio=this.speedRatio,I._loopAnimation=this.loopAnimation,I._isAdditive=this.isAdditive,I._enableBlending=this.enableBlending,I._blendingSpeed=this.blendingSpeed,I.metadata=this.metadata,I.mask=this.mask;for(const Z of this._targetedAnimations)I.addTargetedAnimation(E?Z.animation.clone():Z.animation,_?_(Z.target):Z.target);return I}serialize(){const p={};p.name=this.name,p.from=this.from,p.to=this.to,p.speedRatio=this.speedRatio,p.loopAnimation=this.loopAnimation,p.isAdditive=this.isAdditive,p.weight=this.weight,p.playOrder=this.playOrder,p.enableBlending=this.enableBlending,p.blendingSpeed=this.blendingSpeed,p.targetedAnimations=[];for(let _=0;_<this.targetedAnimations.length;_++){const E=this.targetedAnimations[_];p.targetedAnimations[_]=E.serialize()}return ri&&ri.HasTags(this)&&(p.tags=ri.GetTags(this)),this.metadata&&(p.metadata=this.metadata),p}static Parse(p,_){const E=new xh(p.name,_,p.weight,p.playOrder);for(let I=0;I<p.targetedAnimations.length;I++){const Z=p.targetedAnimations[I],re=Li.Parse(Z.animation),ae=Z.targetId;if(Z.animation.property==="influence"){const he=_.getMorphTargetById(ae);he&&E.addTargetedAnimation(re,he)}else{const he=_.getNodeById(ae);he!=null&&E.addTargetedAnimation(re,he)}}return ri&&ri.AddTagsTo(E,p.tags),p.from!==null&&p.to!==null&&E.normalize(p.from,p.to),p.speedRatio!==void 0&&(E._speedRatio=p.speedRatio),p.loopAnimation!==void 0&&(E._loopAnimation=p.loopAnimation),p.isAdditive!==void 0&&(E._isAdditive=p.isAdditive),p.weight!==void 0&&(E._weight=p.weight),p.playOrder!==void 0&&(E._playOrder=p.playOrder),p.enableBlending!==void 0&&(E._enableBlending=p.enableBlending),p.blendingSpeed!==void 0&&(E._blendingSpeed=p.blendingSpeed),p.metadata!==void 0&&(E.metadata=p.metadata),E}static MakeAnimationAdditive(p,_,E,I=!1,Z){let re;typeof _=="object"?re=_:re={referenceFrame:_,range:E,cloneOriginalAnimationGroup:I,clonedAnimationName:Z};let ae=p;re.cloneOriginalAnimationGroup&&(ae=p.clone(re.clonedAnimationGroupName||ae.name));const he=ae.targetedAnimations;for(let _e=0;_e<he.length;_e++){const ve=he[_e];ve.animation=Li.MakeAnimationAdditive(ve.animation,re)}if(ae.isAdditive=!0,re.clipKeys){let _e=Number.MAX_VALUE,ve=-Number.MAX_VALUE;const Le=ae.targetedAnimations;for(let ze=0;ze<Le.length;ze++){const rt=Le[ze].animation.getKeys();_e>rt[0].frame&&(_e=rt[0].frame),ve<rt[rt.length-1].frame&&(ve=rt[rt.length-1].frame)}ae._from=_e,ae._to=ve}return ae}static ClipKeys(p,_,E,I,Z){const re=p.clone(I||p.name);return xh.ClipKeysInPlace(re,_,E,Z)}static ClipKeysInPlace(p,_,E,I){return xh.ClipInPlace(p,_,E,I,!1)}static ClipFrames(p,_,E,I,Z){const re=p.clone(I||p.name);return xh.ClipFramesInPlace(re,_,E,Z)}static ClipFramesInPlace(p,_,E,I){return xh.ClipInPlace(p,_,E,I,!0)}static ClipInPlace(p,_,E,I,Z=!1){let re=Number.MAX_VALUE,ae=-Number.MAX_VALUE;const he=p.targetedAnimations;for(let _e=0;_e<he.length;_e++){const ve=he[_e],Le=I?ve.animation:ve.animation.clone();Z&&(Le.createKeyForFrame(_),Le.createKeyForFrame(E));const ze=Le.getKeys(),He=[];let xt=Number.MAX_VALUE;for(let rt=0;rt<ze.length;rt++){const Tt=ze[rt];if(!Z&&rt>=_&&rt<=E||Z&&Tt.frame>=_&&Tt.frame<=E){const Lt={frame:Tt.frame,value:Tt.value.clone?Tt.value.clone():Tt.value,inTangent:Tt.inTangent,outTangent:Tt.outTangent,interpolation:Tt.interpolation,lockedTangent:Tt.lockedTangent};xt===Number.MAX_VALUE&&(xt=Lt.frame),Lt.frame-=xt,He.push(Lt)}}if(He.length===0){he.splice(_e,1),_e--;continue}re>He[0].frame&&(re=He[0].frame),ae<He[He.length-1].frame&&(ae=He[He.length-1].frame),Le.setKeys(He,!0),ve.animation=Le}return p._from=re,p._to=ae,p}getClassName(){return"AnimationGroup"}toString(p){let _="Name: "+this.name;return _+=", type: "+this.getClassName(),p&&(_+=", from: "+this._from,_+=", to: "+this._to,_+=", isStarted: "+this._isStarted,_+=", speedRatio: "+this._speedRatio,_+=", targetedAnimations length: "+this._targetedAnimations.length,_+=", animatables length: "+this._animatables),_}}class ca extends Ha{get _matrix(){return this._compose(),this._localMatrix}set _matrix(p){p.updateFlag===this._localMatrix.updateFlag&&!this._needToCompose||(this._needToCompose=!1,this._localMatrix.copyFrom(p),this._markAsDirtyAndDecompose())}constructor(p,_,E=null,I=null,Z=null,re=null,ae=null){super(p,_.getScene()),this.name=p,this.children=[],this.animations=[],this._index=null,this._scalingDeterminant=1,this._needToDecompose=!0,this._needToCompose=!1,this._linkedTransformNode=null,this._waitingTransformNodeId=null,this._skeleton=_,this._localMatrix=I?.clone()??jt.Identity(),this._restMatrix=Z??this._localMatrix.clone(),this._bindMatrix=re??this._localMatrix.clone(),this._index=ae,this._absoluteMatrix=new jt,this._absoluteBindMatrix=new jt,this._absoluteInverseBindMatrix=new jt,this._finalMatrix=new jt,_.bones.push(this),this.setParent(E,!1),this._updateAbsoluteBindMatrices()}getClassName(){return"Bone"}getSkeleton(){return this._skeleton}get parent(){return this._parentNode}getParent(){return this.parent}getChildren(){return this.children}getIndex(){return this._index===null?this.getSkeleton().bones.indexOf(this):this._index}set parent(p){this.setParent(p)}setParent(p,_=!0){if(this.parent!==p){if(this.parent){const E=this.parent.children.indexOf(this);E!==-1&&this.parent.children.splice(E,1)}this._parentNode=p,this.parent&&this.parent.children.push(this),_&&this._updateAbsoluteBindMatrices(),this.markAsDirty()}}getLocalMatrix(){return this._compose(),this._localMatrix}getBindMatrix(){return this._bindMatrix}getBaseMatrix(){return this.getBindMatrix()}getRestMatrix(){return this._restMatrix}getRestPose(){return this.getRestMatrix()}setRestMatrix(p){this._restMatrix.copyFrom(p)}setRestPose(p){this.setRestMatrix(p)}getBindPose(){return this.getBindMatrix()}setBindMatrix(p){this.updateMatrix(p)}setBindPose(p){this.setBindMatrix(p)}getFinalMatrix(){return this._finalMatrix}getWorldMatrix(){return this.getFinalMatrix()}returnToRest(){if(this._linkedTransformNode){const p=ui.Vector3[0],_=ui.Quaternion[0],E=ui.Vector3[1];this.getRestMatrix().decompose(p,_,E),this._linkedTransformNode.position.copyFrom(E),this._linkedTransformNode.rotationQuaternion=this._linkedTransformNode.rotationQuaternion??us.Identity(),this._linkedTransformNode.rotationQuaternion.copyFrom(_),this._linkedTransformNode.scaling.copyFrom(p)}else this._matrix=this._restMatrix}getAbsoluteInverseBindMatrix(){return this._absoluteInverseBindMatrix}getInvertedAbsoluteTransform(){return this.getAbsoluteInverseBindMatrix()}getAbsoluteMatrix(){return this._absoluteMatrix}getAbsoluteTransform(){return this._absoluteMatrix}linkTransformNode(p){this._linkedTransformNode&&this._skeleton._numBonesWithLinkedTransformNode--,this._linkedTransformNode=p,this._linkedTransformNode&&this._skeleton._numBonesWithLinkedTransformNode++}getTransformNode(){return this._linkedTransformNode}get position(){return this._decompose(),this._localPosition}set position(p){this._decompose(),this._localPosition.copyFrom(p),this._markAsDirtyAndCompose()}get rotation(){return this.getRotation()}set rotation(p){this.setRotation(p)}get rotationQuaternion(){return this._decompose(),this._localRotation}set rotationQuaternion(p){this.setRotationQuaternion(p)}get scaling(){return this.getScale()}set scaling(p){this.setScale(p)}get animationPropertiesOverride(){return this._skeleton.animationPropertiesOverride}_decompose(){this._needToDecompose&&(this._needToDecompose=!1,this._localScaling||(this._localScaling=at.Zero(),this._localRotation=us.Zero(),this._localPosition=at.Zero()),this._localMatrix.decompose(this._localScaling,this._localRotation,this._localPosition))}_compose(){if(this._needToCompose){if(!this._localScaling){this._needToCompose=!1;return}this._needToCompose=!1,jt.ComposeToRef(this._localScaling,this._localRotation,this._localPosition,this._localMatrix)}}updateMatrix(p,_=!0,E=!0){this._bindMatrix.copyFrom(p),_&&this._updateAbsoluteBindMatrices(),E?this._matrix=p:this.markAsDirty()}_updateAbsoluteBindMatrices(p,_=!0){if(p||(p=this._bindMatrix),this.parent?p.multiplyToRef(this.parent._absoluteBindMatrix,this._absoluteBindMatrix):this._absoluteBindMatrix.copyFrom(p),this._absoluteBindMatrix.invertToRef(this._absoluteInverseBindMatrix),_)for(let E=0;E<this.children.length;E++)this.children[E]._updateAbsoluteBindMatrices();this._scalingDeterminant=this._absoluteBindMatrix.determinant()<0?-1:1}markAsDirty(){return this._currentRenderId++,this._childUpdateId++,this._skeleton._markAsDirty(),this}_markAsDirtyAndCompose(){this.markAsDirty(),this._needToCompose=!0}_markAsDirtyAndDecompose(){this.markAsDirty(),this._needToDecompose=!0}_updatePosition(p,_=Wn.LOCAL,E,I=!0){const Z=this.getLocalMatrix();if(_==Wn.LOCAL)I?(Z.addAtIndex(12,p.x),Z.addAtIndex(13,p.y),Z.addAtIndex(14,p.z)):Z.setTranslationFromFloats(p.x,p.y,p.z);else{let re=null;E&&(re=E.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const ae=ca._TmpMats[0],he=ca._TmpVecs[0];this.parent?E&&re?(ae.copyFrom(this.parent.getAbsoluteMatrix()),ae.multiplyToRef(re,ae)):ae.copyFrom(this.parent.getAbsoluteMatrix()):jt.IdentityToRef(ae),I&&ae.setTranslationFromFloats(0,0,0),ae.invert(),at.TransformCoordinatesToRef(p,ae,he),I?(Z.addAtIndex(12,he.x),Z.addAtIndex(13,he.y),Z.addAtIndex(14,he.z)):Z.setTranslationFromFloats(he.x,he.y,he.z)}this._markAsDirtyAndDecompose()}translate(p,_=Wn.LOCAL,E){this._updatePosition(p,_,E,!0)}setPosition(p,_=Wn.LOCAL,E){this._updatePosition(p,_,E,!1)}setAbsolutePosition(p,_){this.setPosition(p,Wn.WORLD,_)}scale(p,_,E,I=!1){const Z=this.getLocalMatrix(),re=ca._TmpMats[0];jt.ScalingToRef(p,_,E,re),re.multiplyToRef(Z,Z),re.invert();for(const ae of this.children){const he=ae.getLocalMatrix();he.multiplyToRef(re,he),he.multiplyAtIndex(12,p),he.multiplyAtIndex(13,_),he.multiplyAtIndex(14,E),ae._markAsDirtyAndDecompose()}if(this._markAsDirtyAndDecompose(),I)for(const ae of this.children)ae.scale(p,_,E,I)}setScale(p){this._decompose(),this._localScaling.copyFrom(p),this._markAsDirtyAndCompose()}getScale(){return this._decompose(),this._localScaling}getScaleToRef(p){this._decompose(),p.copyFrom(this._localScaling)}setYawPitchRoll(p,_,E,I=Wn.LOCAL,Z){if(I===Wn.LOCAL){const he=ca._TmpQuat;us.RotationYawPitchRollToRef(p,_,E,he),this.setRotationQuaternion(he,I,Z);return}const re=ca._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(re,Z))return;const ae=ca._TmpMats[1];jt.RotationYawPitchRollToRef(p,_,E,ae),re.multiplyToRef(ae,ae),this._rotateWithMatrix(ae,I,Z)}rotate(p,_,E=Wn.LOCAL,I){const Z=ca._TmpMats[0];Z.setTranslationFromFloats(0,0,0),jt.RotationAxisToRef(p,_,Z),this._rotateWithMatrix(Z,E,I)}setAxisAngle(p,_,E=Wn.LOCAL,I){if(E===Wn.LOCAL){const ae=ca._TmpQuat;us.RotationAxisToRef(p,_,ae),this.setRotationQuaternion(ae,E,I);return}const Z=ca._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(Z,I))return;const re=ca._TmpMats[1];jt.RotationAxisToRef(p,_,re),Z.multiplyToRef(re,re),this._rotateWithMatrix(re,E,I)}setRotation(p,_=Wn.LOCAL,E){this.setYawPitchRoll(p.y,p.x,p.z,_,E)}setRotationQuaternion(p,_=Wn.LOCAL,E){if(_===Wn.LOCAL){this._decompose(),this._localRotation.copyFrom(p),this._markAsDirtyAndCompose();return}const I=ca._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(I,E))return;const Z=ca._TmpMats[1];jt.FromQuaternionToRef(p,Z),I.multiplyToRef(Z,Z),this._rotateWithMatrix(Z,_,E)}setRotationMatrix(p,_=Wn.LOCAL,E){if(_===Wn.LOCAL){const re=ca._TmpQuat;us.FromRotationMatrixToRef(p,re),this.setRotationQuaternion(re,_,E);return}const I=ca._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(I,E))return;const Z=ca._TmpMats[1];Z.copyFrom(p),I.multiplyToRef(p,Z),this._rotateWithMatrix(Z,_,E)}_rotateWithMatrix(p,_=Wn.LOCAL,E){const I=this.getLocalMatrix(),Z=I.m[12],re=I.m[13],ae=I.m[14],he=this.getParent(),_e=ca._TmpMats[3],ve=ca._TmpMats[4];he&&_==Wn.WORLD?(E?(_e.copyFrom(E.getWorldMatrix()),he.getAbsoluteMatrix().multiplyToRef(_e,_e)):_e.copyFrom(he.getAbsoluteMatrix()),ve.copyFrom(_e),ve.invert(),I.multiplyToRef(_e,I),I.multiplyToRef(p,I),I.multiplyToRef(ve,I)):_==Wn.WORLD&&E?(_e.copyFrom(E.getWorldMatrix()),ve.copyFrom(_e),ve.invert(),I.multiplyToRef(_e,I),I.multiplyToRef(p,I),I.multiplyToRef(ve,I)):I.multiplyToRef(p,I),I.setTranslationFromFloats(Z,re,ae),this.computeAbsoluteMatrices(),this._markAsDirtyAndDecompose()}_getAbsoluteInverseMatrixUnscaledToRef(p,_){const E=ca._TmpMats[2];return p.copyFrom(this.getAbsoluteMatrix()),_?(p.multiplyToRef(_.getWorldMatrix(),p),jt.ScalingToRef(_.scaling.x,_.scaling.y,_.scaling.z,E)):jt.IdentityToRef(E),p.invert(),isNaN(p.m[0])?!1:(E.multiplyAtIndex(0,this._scalingDeterminant),p.multiplyToRef(E,p),!0)}getPosition(p=Wn.LOCAL,_=null){const E=at.Zero();return this.getPositionToRef(p,_,E),E}getPositionToRef(p=Wn.LOCAL,_,E){if(p==Wn.LOCAL){const I=this.getLocalMatrix();E.x=I.m[12],E.y=I.m[13],E.z=I.m[14]}else{let I=null;_&&(I=_.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();let Z=ca._TmpMats[0];_&&I?(Z.copyFrom(this.getAbsoluteMatrix()),Z.multiplyToRef(I,Z)):Z=this.getAbsoluteMatrix(),E.x=Z.m[12],E.y=Z.m[13],E.z=Z.m[14]}}getAbsolutePosition(p=null){const _=at.Zero();return this.getPositionToRef(Wn.WORLD,p,_),_}getAbsolutePositionToRef(p,_){this.getPositionToRef(Wn.WORLD,p,_)}computeAbsoluteMatrices(){if(this._compose(),this.parent)this._localMatrix.multiplyToRef(this.parent._absoluteMatrix,this._absoluteMatrix);else{this._absoluteMatrix.copyFrom(this._localMatrix);const E=this._skeleton.getPoseMatrix();E&&this._absoluteMatrix.multiplyToRef(E,this._absoluteMatrix)}const p=this.children,_=p.length;for(let E=0;E<_;E++)p[E].computeAbsoluteMatrices()}computeAbsoluteTransforms(){this.computeAbsoluteMatrices()}getDirection(p,_=null){const E=at.Zero();return this.getDirectionToRef(p,_,E),E}getDirectionToRef(p,_=null,E){let I=null;_&&(I=_.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const Z=ca._TmpMats[0];Z.copyFrom(this.getAbsoluteMatrix()),_&&I&&Z.multiplyToRef(I,Z),at.TransformNormalToRef(p,Z,E),E.normalize()}getRotation(p=Wn.LOCAL,_=null){const E=at.Zero();return this.getRotationToRef(p,_,E),E}getRotationToRef(p=Wn.LOCAL,_=null,E){const I=ca._TmpQuat;this.getRotationQuaternionToRef(p,_,I),I.toEulerAnglesToRef(E)}getRotationQuaternion(p=Wn.LOCAL,_=null){const E=us.Identity();return this.getRotationQuaternionToRef(p,_,E),E}getRotationQuaternionToRef(p=Wn.LOCAL,_=null,E){if(p==Wn.LOCAL)this._decompose(),E.copyFrom(this._localRotation);else{const I=ca._TmpMats[0],Z=this.getAbsoluteMatrix();_?Z.multiplyToRef(_.getWorldMatrix(),I):I.copyFrom(Z),I.multiplyAtIndex(0,this._scalingDeterminant),I.multiplyAtIndex(1,this._scalingDeterminant),I.multiplyAtIndex(2,this._scalingDeterminant),I.decompose(void 0,E,void 0)}}getRotationMatrix(p=Wn.LOCAL,_){const E=jt.Identity();return this.getRotationMatrixToRef(p,_,E),E}getRotationMatrixToRef(p=Wn.LOCAL,_,E){if(p==Wn.LOCAL)this.getLocalMatrix().getRotationMatrixToRef(E);else{const I=ca._TmpMats[0],Z=this.getAbsoluteMatrix();_?Z.multiplyToRef(_.getWorldMatrix(),I):I.copyFrom(Z),I.multiplyAtIndex(0,this._scalingDeterminant),I.multiplyAtIndex(1,this._scalingDeterminant),I.multiplyAtIndex(2,this._scalingDeterminant),I.getRotationMatrixToRef(E)}}getAbsolutePositionFromLocal(p,_=null){const E=at.Zero();return this.getAbsolutePositionFromLocalToRef(p,_,E),E}getAbsolutePositionFromLocalToRef(p,_=null,E){let I=null;_&&(I=_.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const Z=ca._TmpMats[0];Z.copyFrom(this.getAbsoluteMatrix()),_&&I&&Z.multiplyToRef(I,Z),at.TransformCoordinatesToRef(p,Z,E)}getLocalPositionFromAbsolute(p,_=null){const E=at.Zero();return this.getLocalPositionFromAbsoluteToRef(p,_,E),E}getLocalPositionFromAbsoluteToRef(p,_=null,E){let I=null;_&&(I=_.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const Z=ca._TmpMats[0];Z.copyFrom(this.getAbsoluteMatrix()),_&&I&&Z.multiplyToRef(I,Z),Z.invert(),at.TransformCoordinatesToRef(p,Z,E)}setCurrentPoseAsRest(){this.setRestMatrix(this.getLocalMatrix())}}ca._TmpVecs=Ts.BuildArray(2,at.Zero),ca._TmpQuat=us.Identity(),ca._TmpMats=Ts.BuildArray(5,jt.Identity),sr.prototype.updateRawTexture=function(pe,p,_,E,I=null,Z=0,re=!1){if(!pe)return;const ae=this._getRGBABufferInternalSizedFormat(Z,_,re),he=this._getInternalFormat(_),_e=this._getWebGLTextureType(Z);this._bindTextureDirectly(this._gl.TEXTURE_2D,pe,!0),this._unpackFlipY(E===void 0?!0:!!E),this._doNotHandleContextLost||(pe._bufferView=p,pe.format=_,pe.type=Z,pe.invertY=E,pe._compression=I),pe.width%4!==0&&this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,1),I&&p?this._gl.compressedTexImage2D(this._gl.TEXTURE_2D,0,this.getCaps().s3tc[I],pe.width,pe.height,0,p):this._gl.texImage2D(this._gl.TEXTURE_2D,0,ae,pe.width,pe.height,0,he,_e,p),pe.generateMipMaps&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null),pe.isReady=!0},sr.prototype.createRawTexture=function(pe,p,_,E,I,Z,re,ae=null,he=0,_e=0,ve=!1){const Le=new c0(this,kn.Raw);Le.baseWidth=p,Le.baseHeight=_,Le.width=p,Le.height=_,Le.format=E,Le.generateMipMaps=I,Le.samplingMode=re,Le.invertY=Z,Le._compression=ae,Le.type=he,Le._useSRGBBuffer=this._getUseSRGBBuffer(ve,!I),this._doNotHandleContextLost||(Le._bufferView=pe),this.updateRawTexture(Le,pe,E,Z,ae,he,Le._useSRGBBuffer),this._bindTextureDirectly(this._gl.TEXTURE_2D,Le,!0);const ze=this._getSamplingParameters(re,I);return this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MAG_FILTER,ze.mag),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MIN_FILTER,ze.min),I&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._internalTexturesCache.push(Le),Le},sr.prototype.createRawCubeTexture=function(pe,p,_,E,I,Z,re,ae=null){const he=this._gl,_e=new c0(this,kn.CubeRaw);_e.isCube=!0,_e.format=_,_e.type=E,this._doNotHandleContextLost||(_e._bufferViewArray=pe);const ve=this._getWebGLTextureType(E);let Le=this._getInternalFormat(_);Le===he.RGB&&(Le=he.RGBA),ve===he.FLOAT&&!this._caps.textureFloatLinearFiltering?(I=!1,re=1,Ti.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")):ve===this._gl.HALF_FLOAT_OES&&!this._caps.textureHalfFloatLinearFiltering?(I=!1,re=1,Ti.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")):ve===he.FLOAT&&!this._caps.textureFloatRender?(I=!1,Ti.Warn("Render to float textures is not supported. Mipmap generation forced to false.")):ve===he.HALF_FLOAT&&!this._caps.colorBufferFloat&&(I=!1,Ti.Warn("Render to half float textures is not supported. Mipmap generation forced to false."));const ze=p,He=ze;if(_e.width=ze,_e.height=He,_e.invertY=Z,_e._compression=ae,!this.needPOTTextures||lt.IsExponentOfTwo(_e.width)&&lt.IsExponentOfTwo(_e.height)||(I=!1),pe)this.updateRawCubeTexture(_e,pe,_,E,Z,ae);else{const Tt=this._getRGBABufferInternalSizedFormat(E),Lt=0;this._bindTextureDirectly(he.TEXTURE_CUBE_MAP,_e,!0);for(let Nt=0;Nt<6;Nt++)ae?he.compressedTexImage2D(he.TEXTURE_CUBE_MAP_POSITIVE_X+Nt,Lt,this.getCaps().s3tc[ae],_e.width,_e.height,0,void 0):he.texImage2D(he.TEXTURE_CUBE_MAP_POSITIVE_X+Nt,Lt,Tt,_e.width,_e.height,0,Le,ve,null);this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null)}this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,_e,!0),pe&&I&&this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);const rt=this._getSamplingParameters(re,I);return he.texParameteri(he.TEXTURE_CUBE_MAP,he.TEXTURE_MAG_FILTER,rt.mag),he.texParameteri(he.TEXTURE_CUBE_MAP,he.TEXTURE_MIN_FILTER,rt.min),he.texParameteri(he.TEXTURE_CUBE_MAP,he.TEXTURE_WRAP_S,he.CLAMP_TO_EDGE),he.texParameteri(he.TEXTURE_CUBE_MAP,he.TEXTURE_WRAP_T,he.CLAMP_TO_EDGE),this._bindTextureDirectly(he.TEXTURE_CUBE_MAP,null),_e.generateMipMaps=I,_e.samplingMode=re,_e.isReady=!0,_e},sr.prototype.updateRawCubeTexture=function(pe,p,_,E,I,Z=null,re=0){pe._bufferViewArray=p,pe.format=_,pe.type=E,pe.invertY=I,pe._compression=Z;const ae=this._gl,he=this._getWebGLTextureType(E);let _e=this._getInternalFormat(_);const ve=this._getRGBABufferInternalSizedFormat(E);let Le=!1;_e===ae.RGB&&(_e=ae.RGBA,Le=!0),this._bindTextureDirectly(ae.TEXTURE_CUBE_MAP,pe,!0),this._unpackFlipY(I===void 0?!0:!!I),pe.width%4!==0&&ae.pixelStorei(ae.UNPACK_ALIGNMENT,1);for(let He=0;He<6;He++){let xt=p[He];Z?ae.compressedTexImage2D(ae.TEXTURE_CUBE_MAP_POSITIVE_X+He,re,this.getCaps().s3tc[Z],pe.width,pe.height,0,xt):(Le&&(xt=Tv(xt,pe.width,pe.height,E)),ae.texImage2D(ae.TEXTURE_CUBE_MAP_POSITIVE_X+He,re,ve,pe.width,pe.height,0,_e,he,xt))}(!this.needPOTTextures||lt.IsExponentOfTwo(pe.width)&&lt.IsExponentOfTwo(pe.height))&&pe.generateMipMaps&&re===0&&this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),pe.isReady=!0},sr.prototype.createRawCubeTextureFromUrl=function(pe,p,_,E,I,Z,re,ae,he=null,_e=null,ve=3,Le=!1){const ze=this._gl,He=this.createRawCubeTexture(null,_,E,I,!Z,Le,ve,null);p?.addPendingData(He),He.url=pe,He.isReady=!1,this._internalTexturesCache.push(He);const xt=(Tt,Lt)=>{p?.removePendingData(He),_e&&Tt&&_e(Tt.status+" "+Tt.statusText,Lt)},rt=Tt=>{const Lt=He.width,Nt=re(Tt);if(Nt){if(ae){const qt=this._getWebGLTextureType(I);let Xt=this._getInternalFormat(E);const zt=this._getRGBABufferInternalSizedFormat(I);let Gt=!1;Xt===ze.RGB&&(Xt=ze.RGBA,Gt=!0),this._bindTextureDirectly(ze.TEXTURE_CUBE_MAP,He,!0),this._unpackFlipY(!1);const xi=ae(Nt);for(let Gi=0;Gi<xi.length;Gi++){const vs=Lt>>Gi;for(let ks=0;ks<6;ks++){let Ur=xi[Gi][ks];Gt&&(Ur=Tv(Ur,vs,vs,I)),ze.texImage2D(ks,Gi,zt,vs,vs,0,Xt,qt,Ur)}}this._bindTextureDirectly(ze.TEXTURE_CUBE_MAP,null)}else this.updateRawCubeTexture(He,Nt,E,I,Le);He.isReady=!0,p?.removePendingData(He),He.onLoadedObservable.notifyObservers(He),He.onLoadedObservable.clear(),he&&he()}};return this._loadFile(pe,Tt=>{rt(Tt)},void 0,p?.offlineProvider,!0,xt),He};function Tv(pe,p,_,E){let I,Z=1;E===1?I=new Float32Array(p*_*4):E===2?(I=new Uint16Array(p*_*4),Z=15360):E===7?I=new Uint32Array(p*_*4):I=new Uint8Array(p*_*4);for(let re=0;re<p;re++)for(let ae=0;ae<_;ae++){const he=(ae*p+re)*3,_e=(ae*p+re)*4;I[_e+0]=pe[he+0],I[_e+1]=pe[he+1],I[_e+2]=pe[he+2],I[_e+3]=Z}return I}function vv(pe){return function(p,_,E,I,Z,re,ae,he,_e=null,ve=0){const Le=pe?this._gl.TEXTURE_3D:this._gl.TEXTURE_2D_ARRAY,ze=pe?kn.Raw3D:kn.Raw2DArray,He=new c0(this,ze);He.baseWidth=_,He.baseHeight=E,He.baseDepth=I,He.width=_,He.height=E,He.depth=I,He.format=Z,He.type=ve,He.generateMipMaps=re,He.samplingMode=he,pe?He.is3D=!0:He.is2DArray=!0,this._doNotHandleContextLost||(He._bufferView=p),pe?this.updateRawTexture3D(He,p,Z,ae,_e,ve):this.updateRawTexture2DArray(He,p,Z,ae,_e,ve),this._bindTextureDirectly(Le,He,!0);const xt=this._getSamplingParameters(he,re);return this._gl.texParameteri(Le,this._gl.TEXTURE_MAG_FILTER,xt.mag),this._gl.texParameteri(Le,this._gl.TEXTURE_MIN_FILTER,xt.min),re&&this._gl.generateMipmap(Le),this._bindTextureDirectly(Le,null),this._internalTexturesCache.push(He),He}}sr.prototype.createRawTexture2DArray=vv(!1),sr.prototype.createRawTexture3D=vv(!0);function Rv(pe){return function(p,_,E,I,Z=null,re=0){const ae=pe?this._gl.TEXTURE_3D:this._gl.TEXTURE_2D_ARRAY,he=this._getWebGLTextureType(re),_e=this._getInternalFormat(E),ve=this._getRGBABufferInternalSizedFormat(re,E);this._bindTextureDirectly(ae,p,!0),this._unpackFlipY(I===void 0?!0:!!I),this._doNotHandleContextLost||(p._bufferView=_,p.format=E,p.invertY=I,p._compression=Z),p.width%4!==0&&this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,1),Z&&_?this._gl.compressedTexImage3D(ae,0,this.getCaps().s3tc[Z],p.width,p.height,p.depth,0,_):this._gl.texImage3D(ae,0,ve,p.width,p.height,p.depth,0,_e,he,_),p.generateMipMaps&&this._gl.generateMipmap(ae),this._bindTextureDirectly(ae,null),p.isReady=!0}}sr.prototype.updateRawTexture2DArray=Rv(!1),sr.prototype.updateRawTexture3D=Rv(!0);class Y2 extends Ki{constructor(p,_,E,I,Z,re=!0,ae=!1,he=3,_e=0,ve,Le){super(null,Z,!re,ae,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,ve),this.format=I,this._engine&&(!this._engine._caps.textureFloatLinearFiltering&&_e===1&&(he=1),!this._engine._caps.textureHalfFloatLinearFiltering&&_e===2&&(he=1),this._texture=this._engine.createRawTexture(p,_,E,I,re,ae,he,null,_e,ve??0,Le??!1),this.wrapU=Ki.CLAMP_ADDRESSMODE,this.wrapV=Ki.CLAMP_ADDRESSMODE)}update(p){this._getEngine().updateRawTexture(this._texture,p,this._texture.format,this._texture.invertY,null,this._texture.type,this._texture._useSRGBBuffer)}static CreateLuminanceTexture(p,_,E,I,Z=!0,re=!1,ae=3){return new Y2(p,_,E,1,I,Z,re,ae)}static CreateLuminanceAlphaTexture(p,_,E,I,Z=!0,re=!1,ae=3){return new Y2(p,_,E,2,I,Z,re,ae)}static CreateAlphaTexture(p,_,E,I,Z=!0,re=!1,ae=3){return new Y2(p,_,E,0,I,Z,re,ae)}static CreateRGBTexture(p,_,E,I,Z=!0,re=!1,ae=3,he=0,_e=0,ve=!1){return new Y2(p,_,E,4,I,Z,re,ae,he,_e,ve)}static CreateRGBATexture(p,_,E,I,Z=!0,re=!1,ae=3,he=0,_e=0,ve=!1){return new Y2(p,_,E,5,I,Z,re,ae,he,_e,ve)}static CreateRGBAStorageTexture(p,_,E,I,Z=!0,re=!1,ae=3,he=0,_e=!1){return new Y2(p,_,E,5,I,Z,re,ae,he,1,_e)}static CreateRTexture(p,_,E,I,Z=!0,re=!1,ae=Ki.TRILINEAR_SAMPLINGMODE,he=1){return new Y2(p,_,E,6,I,Z,re,ae,he)}static CreateRStorageTexture(p,_,E,I,Z=!0,re=!1,ae=Ki.TRILINEAR_SAMPLINGMODE,he=1){return new Y2(p,_,E,6,I,Z,re,ae,he,1)}}class xg{get useTextureToStoreBoneMatrices(){return this._useTextureToStoreBoneMatrices}set useTextureToStoreBoneMatrices(p){this._useTextureToStoreBoneMatrices=p,this._markAsDirty()}get animationPropertiesOverride(){return this._animationPropertiesOverride?this._animationPropertiesOverride:this._scene.animationPropertiesOverride}set animationPropertiesOverride(p){this._animationPropertiesOverride=p}get isUsingTextureForMatrices(){return this.useTextureToStoreBoneMatrices&&this._canUseTextureForBones}get uniqueId(){return this._uniqueId}constructor(p,_,E){this.name=p,this.id=_,this.bones=[],this.needInitialSkinMatrix=!1,this._isDirty=!0,this._meshesWithPoseMatrix=new Array,this._identity=jt.Identity(),this._currentRenderId=-1,this._ranges={},this._absoluteTransformIsDirty=!0,this._canUseTextureForBones=!1,this._uniqueId=0,this._numBonesWithLinkedTransformNode=0,this._hasWaitingData=null,this._parentContainer=null,this.doNotSerialize=!1,this._useTextureToStoreBoneMatrices=!0,this._animationPropertiesOverride=null,this.onBeforeComputeObservable=new Ri,this.bones=[],this._scene=E||Mr.LastCreatedScene,this._uniqueId=this._scene.getUniqueId(),this._scene.addSkeleton(this),this._isDirty=!0;const I=this._scene.getEngine().getCaps();this._canUseTextureForBones=I.textureFloat&&I.maxVertexTextureImageUnits>0}getClassName(){return"Skeleton"}getChildren(){return this.bones.filter(p=>!p.getParent())}getTransformMatrices(p){return this.needInitialSkinMatrix?(p._bonesTransformMatrices||this.prepare(!0),p._bonesTransformMatrices):((!this._transformMatrices||this._isDirty)&&this.prepare(!this._transformMatrices),this._transformMatrices)}getTransformMatrixTexture(p){return this.needInitialSkinMatrix&&p._transformMatrixTexture?p._transformMatrixTexture:this._transformMatrixTexture}getScene(){return this._scene}toString(p){let _=`Name: ${this.name}, nBones: ${this.bones.length}`;if(_+=`, nAnimationRanges: ${this._ranges?Object.keys(this._ranges).length:"none"}`,p){_+=", Ranges: {";let E=!0;for(const I in this._ranges)E&&(_+=", ",E=!1),_+=I;_+="}"}return _}getBoneIndexByName(p){for(let _=0,E=this.bones.length;_<E;_++)if(this.bones[_].name===p)return _;return-1}createAnimationRange(p,_,E){if(!this._ranges[p]){this._ranges[p]=new Lu(p,_,E);for(let I=0,Z=this.bones.length;I<Z;I++)this.bones[I].animations[0]&&this.bones[I].animations[0].createRange(p,_,E)}}deleteAnimationRange(p,_=!0){for(let E=0,I=this.bones.length;E<I;E++)this.bones[E].animations[0]&&this.bones[E].animations[0].deleteRange(p,_);this._ranges[p]=null}getAnimationRange(p){return this._ranges[p]||null}getAnimationRanges(){const p=[];let _;for(_ in this._ranges)p.push(this._ranges[_]);return p}copyAnimationRange(p,_,E=!1){if(this._ranges[_]||!p.getAnimationRange(_))return!1;let I=!0;const Z=this._getHighestAnimationFrame()+1,re={},ae=p.bones;let he,_e;for(_e=0,he=ae.length;_e<he;_e++)re[ae[_e].name]=ae[_e];this.bones.length!==ae.length&&(Ti.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${ae.length}`),I=!1);const ve=E&&this.dimensionsAtRest&&p.dimensionsAtRest?this.dimensionsAtRest.divide(p.dimensionsAtRest):null;for(_e=0,he=this.bones.length;_e<he;_e++){const ze=this.bones[_e].name,He=re[ze];He?I=I&&this.bones[_e].copyAnimationRange(He,_,Z,E,ve):(Ti.Warn("copyAnimationRange: not same rig, missing source bone "+ze),I=!1)}const Le=p.getAnimationRange(_);return Le&&(this._ranges[_]=new Lu(_,Le.from+Z,Le.to+Z)),I}returnToRest(){for(const p of this.bones)p._index!==-1&&p.returnToRest()}_getHighestAnimationFrame(){let p=0;for(let _=0,E=this.bones.length;_<E;_++)if(this.bones[_].animations[0]){const I=this.bones[_].animations[0].getHighestFrame();p<I&&(p=I)}return p}beginAnimation(p,_,E,I){const Z=this.getAnimationRange(p);return Z?this._scene.beginAnimation(this,Z.from,Z.to,_,E,I):null}static MakeAnimationAdditive(p,_=0,E){const I=p.getAnimationRange(E);if(!I)return null;const Z=p._scene.getAllAnimatablesByTarget(p);let re=null;for(let he=0;he<Z.length;he++){const _e=Z[he];if(_e.fromFrame===I?.from&&_e.toFrame===I?.to){re=_e;break}}const ae=p.getAnimatables();for(let he=0;he<ae.length;he++){const ve=ae[he].animations;if(ve)for(let Le=0;Le<ve.length;Le++)Li.MakeAnimationAdditive(ve[Le],_,E)}return re&&(re.isAdditive=!0),p}_markAsDirty(){this._isDirty=!0,this._absoluteTransformIsDirty=!0}_registerMeshWithPoseMatrix(p){this._meshesWithPoseMatrix.push(p)}_unregisterMeshWithPoseMatrix(p){const _=this._meshesWithPoseMatrix.indexOf(p);_>-1&&this._meshesWithPoseMatrix.splice(_,1)}_computeTransformMatrices(p,_){this.onBeforeComputeObservable.notifyObservers(this);for(let E=0;E<this.bones.length;E++){const I=this.bones[E];I._childUpdateId++;const Z=I.getParent();if(Z?I.getLocalMatrix().multiplyToRef(Z.getFinalMatrix(),I.getFinalMatrix()):_?I.getLocalMatrix().multiplyToRef(_,I.getFinalMatrix()):I.getFinalMatrix().copyFrom(I.getLocalMatrix()),I._index!==-1){const re=I._index===null?E:I._index;I.getAbsoluteInverseBindMatrix().multiplyToArray(I.getFinalMatrix(),p,re*16)}}this._identity.copyToArray(p,this.bones.length*16)}prepare(p=!1){if(!p){const _=this.getScene().getRenderId();if(this._currentRenderId===_)return;this._currentRenderId=_}if(this._numBonesWithLinkedTransformNode>0){for(const _ of this.bones)if(_._linkedTransformNode){const E=_._linkedTransformNode;_.position=E.position,E.rotationQuaternion?_.rotationQuaternion=E.rotationQuaternion:_.rotation=E.rotation,_.scaling=E.scaling}}if(this.needInitialSkinMatrix)for(const _ of this._meshesWithPoseMatrix){const E=_.getPoseMatrix();let I=this._isDirty;if((!_._bonesTransformMatrices||_._bonesTransformMatrices.length!==16*(this.bones.length+1))&&(_._bonesTransformMatrices=new Float32Array(16*(this.bones.length+1)),I=!0),!!I){if(this._synchronizedWithMesh!==_){this._synchronizedWithMesh=_;for(const Z of this.bones)Z.getParent()||(Z.getBindMatrix().multiplyToRef(E,ui.Matrix[1]),Z._updateAbsoluteBindMatrices(ui.Matrix[1]));if(this.isUsingTextureForMatrices){const Z=(this.bones.length+1)*4;(!_._transformMatrixTexture||_._transformMatrixTexture.getSize().width!==Z)&&(_._transformMatrixTexture&&_._transformMatrixTexture.dispose(),_._transformMatrixTexture=Y2.CreateRGBATexture(_._bonesTransformMatrices,(this.bones.length+1)*4,1,this._scene,!1,!1,1,1))}}this._computeTransformMatrices(_._bonesTransformMatrices,E),this.isUsingTextureForMatrices&&_._transformMatrixTexture&&_._transformMatrixTexture.update(_._bonesTransformMatrices)}}else{if(!this._isDirty)return;(!this._transformMatrices||this._transformMatrices.length!==16*(this.bones.length+1))&&(this._transformMatrices=new Float32Array(16*(this.bones.length+1)),this.isUsingTextureForMatrices&&(this._transformMatrixTexture&&this._transformMatrixTexture.dispose(),this._transformMatrixTexture=Y2.CreateRGBATexture(this._transformMatrices,(this.bones.length+1)*4,1,this._scene,!1,!1,1,1))),this._computeTransformMatrices(this._transformMatrices,null),this.isUsingTextureForMatrices&&this._transformMatrixTexture&&this._transformMatrixTexture.update(this._transformMatrices)}this._isDirty=!1}getAnimatables(){if(!this._animatables||this._animatables.length!==this.bones.length){this._animatables=[];for(let p=0;p<this.bones.length;p++)this._animatables.push(this.bones[p])}return this._animatables}clone(p,_){const E=new xg(p,_||p,this._scene);E.needInitialSkinMatrix=this.needInitialSkinMatrix;for(let I=0;I<this.bones.length;I++){const Z=this.bones[I];let re=null;const ae=Z.getParent();if(ae){const _e=this.bones.indexOf(ae);re=E.bones[_e]}const he=new ca(Z.name,E,re,Z.getBindMatrix().clone(),Z.getRestMatrix().clone());he._index=Z._index,Z._linkedTransformNode&&he.linkTransformNode(Z._linkedTransformNode),jo.DeepCopy(Z.animations,he.animations)}if(this._ranges){E._ranges={};for(const I in this._ranges){const Z=this._ranges[I];Z&&(E._ranges[I]=Z.clone())}}return this._isDirty=!0,E.prepare(!0),E}enableBlending(p=.01){this.bones.forEach(_=>{_.animations.forEach(E=>{E.enableBlending=!0,E.blendingSpeed=p})})}dispose(){if(this._meshesWithPoseMatrix.length=0,this.getScene().stopAnimation(this),this.getScene().removeSkeleton(this),this._parentContainer){const p=this._parentContainer.skeletons.indexOf(this);p>-1&&this._parentContainer.skeletons.splice(p,1),this._parentContainer=null}this._transformMatrixTexture&&(this._transformMatrixTexture.dispose(),this._transformMatrixTexture=null)}serialize(){const p={};p.name=this.name,p.id=this.id,this.dimensionsAtRest&&(p.dimensionsAtRest=this.dimensionsAtRest.asArray()),p.bones=[],p.needInitialSkinMatrix=this.needInitialSkinMatrix;for(let _=0;_<this.bones.length;_++){const E=this.bones[_],I=E.getParent(),Z={parentBoneIndex:I?this.bones.indexOf(I):-1,index:E.getIndex(),name:E.name,id:E.id,matrix:E.getBindMatrix().toArray(),rest:E.getRestMatrix().toArray(),linkedTransformNodeId:E.getTransformNode()?.id};p.bones.push(Z),E.length&&(Z.length=E.length),E.metadata&&(Z.metadata=E.metadata),E.animations&&E.animations.length>0&&(Z.animation=E.animations[0].serialize()),p.ranges=[];for(const re in this._ranges){const ae=this._ranges[re];if(!ae)continue;const he={};he.name=re,he.from=ae.from,he.to=ae.to,p.ranges.push(he)}}return p}static Parse(p,_){const E=new xg(p.name,p.id,_);p.dimensionsAtRest&&(E.dimensionsAtRest=at.FromArray(p.dimensionsAtRest)),E.needInitialSkinMatrix=p.needInitialSkinMatrix;let I;for(I=0;I<p.bones.length;I++){const Z=p.bones[I],re=p.bones[I].index;let ae=null;Z.parentBoneIndex>-1&&(ae=E.bones[Z.parentBoneIndex]);const he=Z.rest?jt.FromArray(Z.rest):null,_e=new ca(Z.name,E,ae,jt.FromArray(Z.matrix),he,null,re);Z.id!==void 0&&Z.id!==null&&(_e.id=Z.id),Z.length&&(_e.length=Z.length),Z.metadata&&(_e.metadata=Z.metadata),Z.animation&&_e.animations.push(Li.Parse(Z.animation)),Z.linkedTransformNodeId!==void 0&&Z.linkedTransformNodeId!==null&&(E._hasWaitingData=!0,_e._waitingTransformNodeId=Z.linkedTransformNodeId)}if(p.ranges)for(I=0;I<p.ranges.length;I++){const Z=p.ranges[I];E.createAnimationRange(Z.name,Z.from,Z.to)}return E}computeAbsoluteMatrices(p=!1){(this._absoluteTransformIsDirty||p)&&(this.bones[0].computeAbsoluteMatrices(),this._absoluteTransformIsDirty=!1)}computeAbsoluteTransforms(p=!1){this.computeAbsoluteMatrices(p)}getPoseMatrix(){let p=null;return this._meshesWithPoseMatrix.length>0&&(p=this._meshesWithPoseMatrix[0].getPoseMatrix()),p}sortBones(){const p=[],_=new Array(this.bones.length);for(let E=0;E<this.bones.length;E++)this._sortBones(E,p,_);this.bones=p}_sortBones(p,_,E){if(E[p])return;E[p]=!0;const I=this.bones[p];if(!I)return;I._index===void 0&&(I._index=p);const Z=I.getParent();Z&&this._sortBones(this.bones.indexOf(Z),_,E),_.push(I)}setCurrentPoseAsRest(){this.bones.forEach(p=>{p.setCurrentPoseAsRest()})}}const HN="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==";let XN=0;const o_=pe=>{if(!pe.environmentBRDFTexture){const p=pe.useDelayedTextureLoading;pe.useDelayedTextureLoading=!1;const _=pe._blockEntityCollection;pe._blockEntityCollection=!1;const E=Ki.CreateFromBase64String(HN,"EnvironmentBRDFTexture"+XN++,pe,!0,!1,Ki.BILINEAR_SAMPLINGMODE);pe._blockEntityCollection=_;const I=pe.getEngine().getLoadedTexturesCache(),Z=I.indexOf(E.getInternalTexture());Z!==-1&&I.splice(Z,1),E.isRGBD=!0,E.wrapU=Ki.CLAMP_ADDRESSMODE,E.wrapV=Ki.CLAMP_ADDRESSMODE,pe.environmentBRDFTexture=E,pe.useDelayedTextureLoading=p,n_.ExpandRGBDTexture(E);const re=pe.getEngine().onContextRestoredObservable.add(()=>{E.isRGBD=!0;const ae=pe.onBeforeRenderObservable.add(()=>{E.isReady()&&(pe.onBeforeRenderObservable.remove(ae),n_.ExpandRGBDTexture(E))})});pe.onDisposeObservable.add(()=>{pe.getEngine().onContextRestoredObservable.remove(re)})}return pe.environmentBRDFTexture},nk={GetEnvironmentBRDFTexture:o_},YN=new RegExp("^([gimus]+)!");class jh{constructor(p){this._plugins=[],this._activePlugins=[],this._activePluginsForExtraEvents=[],this._material=p,this._scene=p.getScene(),this._engine=this._scene.getEngine()}_addPlugin(p){for(let I=0;I<this._plugins.length;++I)if(this._plugins[I].name===p.name)return!1;if(this._material._uniformBufferLayoutBuilt)throw`The plugin "${p.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;const _=p.getClassName();jh._MaterialPluginClassToMainDefine[_]||(jh._MaterialPluginClassToMainDefine[_]="MATERIALPLUGIN_"+ ++jh._MaterialPluginCounter),this._material._callbackPluginEventGeneric=(I,Z)=>this._handlePluginEvent(I,Z),this._plugins.push(p),this._plugins.sort((I,Z)=>I.priority-Z.priority),this._codeInjectionPoints={};const E={};E[jh._MaterialPluginClassToMainDefine[_]]={type:"boolean",default:!0};for(const I of this._plugins)I.collectDefines(E),this._collectPointNames("vertex",I.getCustomCode("vertex")),this._collectPointNames("fragment",I.getCustomCode("fragment"));return this._defineNamesFromPlugins=E,!0}_activatePlugin(p){this._activePlugins.indexOf(p)===-1&&(this._activePlugins.push(p),this._activePlugins.sort((_,E)=>_.priority-E.priority),this._material._callbackPluginEventIsReadyForSubMesh=this._handlePluginEventIsReadyForSubMesh.bind(this),this._material._callbackPluginEventPrepareDefinesBeforeAttributes=this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this),this._material._callbackPluginEventPrepareDefines=this._handlePluginEventPrepareDefines.bind(this),this._material._callbackPluginEventBindForSubMesh=this._handlePluginEventBindForSubMesh.bind(this),p.registerForExtraEvents&&(this._activePluginsForExtraEvents.push(p),this._activePluginsForExtraEvents.sort((_,E)=>_.priority-E.priority),this._material._callbackPluginEventHasRenderTargetTextures=this._handlePluginEventHasRenderTargetTextures.bind(this),this._material._callbackPluginEventFillRenderTargetTextures=this._handlePluginEventFillRenderTargetTextures.bind(this),this._material._callbackPluginEventHardBindForSubMesh=this._handlePluginEventHardBindForSubMesh.bind(this)))}getPlugin(p){for(let _=0;_<this._plugins.length;++_)if(this._plugins[_].name===p)return this._plugins[_];return null}_handlePluginEventIsReadyForSubMesh(p){let _=!0;for(const E of this._activePlugins)_=_&&E.isReadyForSubMesh(p.defines,this._scene,this._engine,p.subMesh);p.isReadyForSubMesh=_}_handlePluginEventPrepareDefinesBeforeAttributes(p){for(const _ of this._activePlugins)_.prepareDefinesBeforeAttributes(p.defines,this._scene,p.mesh)}_handlePluginEventPrepareDefines(p){for(const _ of this._activePlugins)_.prepareDefines(p.defines,this._scene,p.mesh)}_handlePluginEventHardBindForSubMesh(p){for(const _ of this._activePluginsForExtraEvents)_.hardBindForSubMesh(this._material._uniformBuffer,this._scene,this._engine,p.subMesh)}_handlePluginEventBindForSubMesh(p){for(const _ of this._activePlugins)_.bindForSubMesh(this._material._uniformBuffer,this._scene,this._engine,p.subMesh)}_handlePluginEventHasRenderTargetTextures(p){let _=!1;for(const E of this._activePluginsForExtraEvents)if(_=E.hasRenderTargetTextures(),_)break;p.hasRenderTargetTextures=_}_handlePluginEventFillRenderTargetTextures(p){for(const _ of this._activePluginsForExtraEvents)_.fillRenderTargetTextures(p.renderTargets)}_handlePluginEvent(p,_){switch(p){case vx.GetActiveTextures:{const E=_;for(const I of this._activePlugins)I.getActiveTextures(E.activeTextures);break}case vx.GetAnimatables:{const E=_;for(const I of this._activePlugins)I.getAnimatables(E.animatables);break}case vx.HasTexture:{const E=_;let I=!1;for(const Z of this._activePlugins)if(I=Z.hasTexture(E.texture),I)break;E.hasTexture=I;break}case vx.Disposed:{const E=_;for(const I of this._plugins)I.dispose(E.forceDisposeTextures);break}case vx.GetDefineNames:{const E=_;E.defineNames=this._defineNamesFromPlugins;break}case vx.PrepareEffect:{const E=_;for(const I of this._activePlugins)E.fallbackRank=I.addFallbacks(E.defines,E.fallbacks,E.fallbackRank),I.getAttributes(E.attributes,this._scene,E.mesh);this._uniformList.length>0&&E.uniforms.push(...this._uniformList),this._samplerList.length>0&&E.samplers.push(...this._samplerList),this._uboList.length>0&&E.uniformBuffersNames.push(...this._uboList),E.customCode=this._injectCustomCode(E,E.customCode);break}case vx.PrepareUniformBuffer:{const E=_;this._uboDeclaration="",this._vertexDeclaration="",this._fragmentDeclaration="",this._uniformList=[],this._samplerList=[],this._uboList=[];for(const I of this._plugins){const Z=I.getUniforms();if(Z){if(Z.ubo)for(const re of Z.ubo){if(re.size&&re.type){const ae=re.arraySize??0;E.ubo.addUniform(re.name,re.size,ae),this._uboDeclaration+=`${re.type} ${re.name}${ae>0?`[${ae}]`:""};
`}this._uniformList.push(re.name)}Z.vertex&&(this._vertexDeclaration+=Z.vertex+`
`),Z.fragment&&(this._fragmentDeclaration+=Z.fragment+`
`)}I.getSamplers(this._samplerList),I.getUniformBuffersNames(this._uboList)}break}}}_collectPointNames(p,_){if(_)for(const E in _)this._codeInjectionPoints[p]||(this._codeInjectionPoints[p]={}),this._codeInjectionPoints[p][E]=!0}_injectCustomCode(p,_){return(E,I)=>{_&&(I=_(E,I)),this._uboDeclaration&&(I=I.replace("#define ADDITIONAL_UBO_DECLARATION",this._uboDeclaration)),this._vertexDeclaration&&(I=I.replace("#define ADDITIONAL_VERTEX_DECLARATION",this._vertexDeclaration)),this._fragmentDeclaration&&(I=I.replace("#define ADDITIONAL_FRAGMENT_DECLARATION",this._fragmentDeclaration));const Z=this._codeInjectionPoints?.[E];if(!Z)return I;let re=null;for(let ae in Z){let he="";for(const _e of this._activePlugins){let ve=_e.getCustomCode(E)?.[ae];if(ve){if(_e.resolveIncludes){if(re===null){const Le=Wa.GLSL;re={defines:[],indexParameters:p.indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:void 0,supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:ji.GetShadersRepository(Le),includesShadersStore:ji.GetIncludesShadersStore(Le),version:void 0,platformName:this._engine.shaderPlatformName,processingContext:void 0,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:void 0}}re.isFragment=E==="fragment",xx._ProcessIncludes(ve,re,Le=>ve=Le)}he+=ve+`
`}}if(he.length>0)if(ae.charAt(0)==="!"){ae=ae.substring(1);let _e="g";if(ae.charAt(0)==="!")_e="",ae=ae.substring(1);else{const He=YN.exec(ae);He&&He.length>=2&&(_e=He[1],ae=ae.substring(_e.length+1))}_e.indexOf("g")<0&&(_e+="g");const ve=I,Le=new RegExp(ae,_e);let ze=Le.exec(ve);for(;ze!==null;){let He=he;for(let xt=0;xt<ze.length;++xt)He=He.replace("$"+xt,ze[xt]);I=I.replace(ze[0],He),ze=Le.exec(ve)}}else{const _e="#define "+ae;I=I.replace(_e,`
`+he+`
`+_e)}}return I}}}jh._MaterialPluginClassToMainDefine={},jh._MaterialPluginCounter=0,Mr.OnEnginesDisposedObservable.add(()=>{Mv()});const qh=[];let l_=!1,h_=null;function ak(pe,p){l_||(h_=Material.OnEventObservable.add(E=>{for(const[,I]of qh)I(E)},MaterialPluginEvent.Created),l_=!0);const _=qh.filter(([E,I])=>E===pe);_.length>0?_[0][1]=p:qh.push([pe,p])}function xk(pe){for(let p=0;p<qh.length;++p)if(qh[p][0]===pe)return qh.splice(p,1),qh.length===0&&Mv(),!0;return!1}function Mv(){qh.length=0,l_=!1,zi.OnEventObservable.remove(h_),h_=null}class K2{_enable(p){p&&this._pluginManager._activatePlugin(this)}constructor(p,_,E,I,Z=!0,re=!1,ae=!1){this.priority=500,this.resolveIncludes=!1,this.registerForExtraEvents=!1,this._material=p,this.name=_,this.priority=E,this.resolveIncludes=ae,p.pluginManager||(p.pluginManager=new jh(p),p.onDisposeObservable.add(()=>{p.pluginManager=void 0})),this._pluginDefineNames=I,this._pluginManager=p.pluginManager,Z&&this._pluginManager._addPlugin(this),re&&this._enable(!0),this.markAllDefinesAsDirty=p._dirtyCallbacks[63]}getClassName(){return"MaterialPluginBase"}isReadyForSubMesh(p,_,E,I){return!0}hardBindForSubMesh(p,_,E,I){}bindForSubMesh(p,_,E,I){}dispose(p){}getCustomCode(p){return null}collectDefines(p){if(this._pluginDefineNames)for(const _ of Object.keys(this._pluginDefineNames)){if(_[0]==="_")continue;const E=typeof this._pluginDefineNames[_];p[_]={type:E==="number"?"number":E==="string"?"string":E==="boolean"?"boolean":"object",default:this._pluginDefineNames[_]}}}prepareDefinesBeforeAttributes(p,_,E){}prepareDefines(p,_,E){}hasTexture(p){return!1}hasRenderTargetTextures(){return!1}fillRenderTargetTextures(p){}getActiveTextures(p){}getAnimatables(p){}addFallbacks(p,_,E){return E}getSamplers(p){}getAttributes(p,_,E){}getUniformBuffersNames(p){}getUniforms(){return{}}copyTo(p){Hr.Clone(()=>p,this)}serialize(){return Hr.Serialize(this)}parse(p,_,E){Hr.Parse(()=>this,p,_,E)}}Rt([Ut()],K2.prototype,"name",void 0),Rt([Ut()],K2.prototype,"priority",void 0),Rt([Ut()],K2.prototype,"resolveIncludes",void 0),Rt([Ut()],K2.prototype,"registerForExtraEvents",void 0);class KN extends Hh{constructor(){super(...arguments),this.BRDF_V_HEIGHT_CORRELATED=!1,this.MS_BRDF_ENERGY_CONSERVATION=!1,this.SPHERICAL_HARMONICS=!1,this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION=!1}}class Mx extends K2{_markAllSubMeshesAsMiscDirty(){this._internalMarkAllSubMeshesAsMiscDirty()}constructor(p,_=!0){super(p,"PBRBRDF",90,new KN,_),this._useEnergyConservation=Mx.DEFAULT_USE_ENERGY_CONSERVATION,this.useEnergyConservation=Mx.DEFAULT_USE_ENERGY_CONSERVATION,this._useSmithVisibilityHeightCorrelated=Mx.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED,this.useSmithVisibilityHeightCorrelated=Mx.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED,this._useSphericalHarmonics=Mx.DEFAULT_USE_SPHERICAL_HARMONICS,this.useSphericalHarmonics=Mx.DEFAULT_USE_SPHERICAL_HARMONICS,this._useSpecularGlossinessInputEnergyConservation=Mx.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION,this.useSpecularGlossinessInputEnergyConservation=Mx.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION,this._internalMarkAllSubMeshesAsMiscDirty=p._dirtyCallbacks[16],this._enable(!0)}prepareDefines(p){p.BRDF_V_HEIGHT_CORRELATED=this._useSmithVisibilityHeightCorrelated,p.MS_BRDF_ENERGY_CONSERVATION=this._useEnergyConservation&&this._useSmithVisibilityHeightCorrelated,p.SPHERICAL_HARMONICS=this._useSphericalHarmonics,p.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION=this._useSpecularGlossinessInputEnergyConservation}getClassName(){return"PBRBRDFConfiguration"}}Mx.DEFAULT_USE_ENERGY_CONSERVATION=!0,Mx.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED=!0,Mx.DEFAULT_USE_SPHERICAL_HARMONICS=!0,Mx.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION=!0,Rt([Ut(),ws("_markAllSubMeshesAsMiscDirty")],Mx.prototype,"useEnergyConservation",void 0),Rt([Ut(),ws("_markAllSubMeshesAsMiscDirty")],Mx.prototype,"useSmithVisibilityHeightCorrelated",void 0),Rt([Ut(),ws("_markAllSubMeshesAsMiscDirty")],Mx.prototype,"useSphericalHarmonics",void 0),Rt([Ut(),ws("_markAllSubMeshesAsMiscDirty")],Mx.prototype,"useSpecularGlossinessInputEnergyConservation",void 0);class c_{constructor(){this.previousWorldMatrices={},this.previousBones={}}static AddUniforms(p){p.push("previousWorld","previousViewProjection","mPreviousBones")}static AddSamplers(p){}bindForSubMesh(p,_,E,I,Z){if(_.prePassRenderer&&_.prePassRenderer.enabled&&_.prePassRenderer.currentRTisSceneRT&&_.prePassRenderer.getIndex(2)!==-1){this.previousWorldMatrices[E.uniqueId]||(this.previousWorldMatrices[E.uniqueId]=I.clone()),this.previousViewProjection||(this.previousViewProjection=_.getTransformMatrix().clone(),this.currentViewProjection=_.getTransformMatrix().clone());const re=_.getEngine();this.currentViewProjection.updateFlag!==_.getTransformMatrix().updateFlag?(this._lastUpdateFrameId=re.frameId,this.previousViewProjection.copyFrom(this.currentViewProjection),this.currentViewProjection.copyFrom(_.getTransformMatrix())):this._lastUpdateFrameId!==re.frameId&&(this._lastUpdateFrameId=re.frameId,this.previousViewProjection.copyFrom(this.currentViewProjection)),p.setMatrix("previousWorld",this.previousWorldMatrices[E.uniqueId]),p.setMatrix("previousViewProjection",this.previousViewProjection),this.previousWorldMatrices[E.uniqueId]=I.clone()}}}class Ms{static get DiffuseTextureEnabled(){return this._DiffuseTextureEnabled}static set DiffuseTextureEnabled(p){this._DiffuseTextureEnabled!==p&&(this._DiffuseTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get DetailTextureEnabled(){return this._DetailTextureEnabled}static set DetailTextureEnabled(p){this._DetailTextureEnabled!==p&&(this._DetailTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get DecalMapEnabled(){return this._DecalMapEnabled}static set DecalMapEnabled(p){this._DecalMapEnabled!==p&&(this._DecalMapEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get AmbientTextureEnabled(){return this._AmbientTextureEnabled}static set AmbientTextureEnabled(p){this._AmbientTextureEnabled!==p&&(this._AmbientTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get OpacityTextureEnabled(){return this._OpacityTextureEnabled}static set OpacityTextureEnabled(p){this._OpacityTextureEnabled!==p&&(this._OpacityTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get ReflectionTextureEnabled(){return this._ReflectionTextureEnabled}static set ReflectionTextureEnabled(p){this._ReflectionTextureEnabled!==p&&(this._ReflectionTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get EmissiveTextureEnabled(){return this._EmissiveTextureEnabled}static set EmissiveTextureEnabled(p){this._EmissiveTextureEnabled!==p&&(this._EmissiveTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get SpecularTextureEnabled(){return this._SpecularTextureEnabled}static set SpecularTextureEnabled(p){this._SpecularTextureEnabled!==p&&(this._SpecularTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get BumpTextureEnabled(){return this._BumpTextureEnabled}static set BumpTextureEnabled(p){this._BumpTextureEnabled!==p&&(this._BumpTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get LightmapTextureEnabled(){return this._LightmapTextureEnabled}static set LightmapTextureEnabled(p){this._LightmapTextureEnabled!==p&&(this._LightmapTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get RefractionTextureEnabled(){return this._RefractionTextureEnabled}static set RefractionTextureEnabled(p){this._RefractionTextureEnabled!==p&&(this._RefractionTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get ColorGradingTextureEnabled(){return this._ColorGradingTextureEnabled}static set ColorGradingTextureEnabled(p){this._ColorGradingTextureEnabled!==p&&(this._ColorGradingTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get FresnelEnabled(){return this._FresnelEnabled}static set FresnelEnabled(p){this._FresnelEnabled!==p&&(this._FresnelEnabled=p,ci.MarkAllMaterialsAsDirty(4))}static get ClearCoatTextureEnabled(){return this._ClearCoatTextureEnabled}static set ClearCoatTextureEnabled(p){this._ClearCoatTextureEnabled!==p&&(this._ClearCoatTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get ClearCoatBumpTextureEnabled(){return this._ClearCoatBumpTextureEnabled}static set ClearCoatBumpTextureEnabled(p){this._ClearCoatBumpTextureEnabled!==p&&(this._ClearCoatBumpTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get ClearCoatTintTextureEnabled(){return this._ClearCoatTintTextureEnabled}static set ClearCoatTintTextureEnabled(p){this._ClearCoatTintTextureEnabled!==p&&(this._ClearCoatTintTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get SheenTextureEnabled(){return this._SheenTextureEnabled}static set SheenTextureEnabled(p){this._SheenTextureEnabled!==p&&(this._SheenTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get AnisotropicTextureEnabled(){return this._AnisotropicTextureEnabled}static set AnisotropicTextureEnabled(p){this._AnisotropicTextureEnabled!==p&&(this._AnisotropicTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get ThicknessTextureEnabled(){return this._ThicknessTextureEnabled}static set ThicknessTextureEnabled(p){this._ThicknessTextureEnabled!==p&&(this._ThicknessTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get RefractionIntensityTextureEnabled(){return this._ThicknessTextureEnabled}static set RefractionIntensityTextureEnabled(p){this._RefractionIntensityTextureEnabled!==p&&(this._RefractionIntensityTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get TranslucencyIntensityTextureEnabled(){return this._ThicknessTextureEnabled}static set TranslucencyIntensityTextureEnabled(p){this._TranslucencyIntensityTextureEnabled!==p&&(this._TranslucencyIntensityTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}static get IridescenceTextureEnabled(){return this._IridescenceTextureEnabled}static set IridescenceTextureEnabled(p){this._IridescenceTextureEnabled!==p&&(this._IridescenceTextureEnabled=p,ci.MarkAllMaterialsAsDirty(1))}}Ms._DiffuseTextureEnabled=!0,Ms._DetailTextureEnabled=!0,Ms._DecalMapEnabled=!0,Ms._AmbientTextureEnabled=!0,Ms._OpacityTextureEnabled=!0,Ms._ReflectionTextureEnabled=!0,Ms._EmissiveTextureEnabled=!0,Ms._SpecularTextureEnabled=!0,Ms._BumpTextureEnabled=!0,Ms._LightmapTextureEnabled=!0,Ms._RefractionTextureEnabled=!0,Ms._ColorGradingTextureEnabled=!0,Ms._FresnelEnabled=!0,Ms._ClearCoatTextureEnabled=!0,Ms._ClearCoatBumpTextureEnabled=!0,Ms._ClearCoatTintTextureEnabled=!0,Ms._SheenTextureEnabled=!0,Ms._AnisotropicTextureEnabled=!0,Ms._ThicknessTextureEnabled=!0,Ms._RefractionIntensityTextureEnabled=!0,Ms._TranslucencyIntensityTextureEnabled=!0,Ms._IridescenceTextureEnabled=!0;const wv="prePassDeclaration",Lv=`#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;ji.IncludesShadersStore[wv]=Lv;const lk={name:wv,shader:Lv},kv="oitDeclaration",Uv=`#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;
#endif
`;ji.IncludesShadersStore[kv]=Uv;const hk={name:kv,shader:Uv},Gv="decalFragmentDeclaration",zv=`#ifdef DECAL
uniform vec4 vDecalInfos;
#endif
`;ji.IncludesShadersStore[Gv]=zv;const ck={name:Gv,shader:zv},Wv="pbrFragmentDeclaration",Hv=`uniform vec4 vEyePosition;uniform vec3 vReflectionColor;uniform vec4 vAlbedoColor;uniform vec4 vLightingIntensity;uniform vec4 vReflectivityColor;uniform vec4 vMetallicReflectanceFactors;uniform vec3 vEmissiveColor;uniform float visibility;uniform vec3 vAmbientColor;
#ifdef ALBEDO
uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform vec4 vAmbientInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#ifdef OPACITY
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef REFLECTIVITY
uniform vec3 vReflectivityInfos;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#ifdef REALTIME_FILTERING
uniform vec2 vReflectionFilteringInfo;
#endif
uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; 
#endif
#endif
#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)
uniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; 
#endif
#ifdef CLEARCOAT
uniform vec2 vClearCoatParams;uniform vec4 vClearCoatRefractionParams;
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform vec2 vClearCoatTangentSpaceParams;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT
uniform vec4 vClearCoatTintParams;uniform float clearCoatColorAtDistance;
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#endif
#ifdef IRIDESCENCE
uniform vec4 vIridescenceParams;
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
uniform vec3 vAnisotropy;
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
uniform vec4 vSheenColor;
#ifdef SHEEN_ROUGHNESS
uniform float vSheenRoughness;
#endif
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionMicrosurfaceInfos;uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#ifdef REALTIME_FILTERING
uniform vec2 vRefractionFilteringInfo;
#endif
#ifdef SS_DISPERSION
uniform float dispersion;
#endif
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
uniform vec2 vThicknessParam;uniform vec3 vDiffusionDistance;uniform vec4 vTintColor;uniform vec3 vSubSurfaceIntensity;
#endif
#ifdef PREPASS
#ifdef SS_SCATTERING
uniform float scatteringDiffusionProfile;
#endif
#endif
#if DEBUGMODE>0
uniform vec2 vDebugMode;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#include<decalFragmentDeclaration>
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#define ADDITIONAL_FRAGMENT_DECLARATION
`;ji.IncludesShadersStore[Wv]=Hv;const uk={name:Wv,shader:Hv},Xv="sceneUboDeclaration",Yv=`layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;mat4 projection;vec4 vEyePosition;};
`;ji.IncludesShadersStore[Xv]=Yv;const pk={name:Xv,shader:Yv},Kv="meshUboDeclaration",jv=`#ifdef WEBGL2
uniform mat4 world;uniform float visibility;
#else
layout(std140,column_major) uniform;uniform Mesh
{mat4 world;float visibility;};
#endif
#define WORLD_UBO
`;ji.IncludesShadersStore[Kv]=jv;const _k={name:Kv,shader:jv},qv="pbrUboDeclaration",$v=`layout(std140,column_major) uniform;uniform Material {vec2 vAlbedoInfos;vec4 vAmbientInfos;vec2 vOpacityInfos;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec3 vReflectivityInfos;vec2 vMicroSurfaceSamplerInfos;vec2 vReflectionInfos;vec2 vReflectionFilteringInfo;vec3 vReflectionPosition;vec3 vReflectionSize;vec3 vBumpInfos;mat4 albedoMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 reflectivityMatrix;mat4 microSurfaceSamplerMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;mat4 reflectionMatrix;vec3 vReflectionColor;vec4 vAlbedoColor;vec4 vLightingIntensity;vec3 vReflectionMicrosurfaceInfos;float pointSize;vec4 vReflectivityColor;vec3 vEmissiveColor;vec3 vAmbientColor;vec2 vDebugMode;vec4 vMetallicReflectanceFactors;vec2 vMetallicReflectanceInfos;mat4 metallicReflectanceMatrix;vec2 vReflectanceInfos;mat4 reflectanceMatrix;vec3 vSphericalL00;vec3 vSphericalL1_1;vec3 vSphericalL10;vec3 vSphericalL11;vec3 vSphericalL2_2;vec3 vSphericalL2_1;vec3 vSphericalL20;vec3 vSphericalL21;vec3 vSphericalL22;vec3 vSphericalX;vec3 vSphericalY;vec3 vSphericalZ;vec3 vSphericalXX_ZZ;vec3 vSphericalYY_ZZ;vec3 vSphericalZZ;vec3 vSphericalXY;vec3 vSphericalYZ;vec3 vSphericalZX;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;ji.IncludesShadersStore[qv]=$v;const Tk={name:qv,shader:$v},rA="mainUVVaryingDeclaration",nA=`#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;ji.IncludesShadersStore[rA]=nA;const vk={name:rA,shader:nA},aA="pbrFragmentExtraDeclaration",xA=`varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
`;ji.IncludesShadersStore[aA]=xA;const Rk={name:aA,shader:xA},lA="lightFragmentDeclaration",hA=`#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X};
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#endif
`;ji.IncludesShadersStore[lA]=hA;const Mk={name:lA,shader:hA},cA="lightUboDeclaration",uA=`#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X}; 
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;ji.IncludesShadersStore[cA]=uA;const wk={name:cA,shader:uA},pA="samplerFragmentDeclaration",_A=`#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;ji.IncludesShadersStore[pA]=_A;const Lk={name:pA,shader:_A},TA="samplerFragmentAlternateDeclaration",vA=`#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
#endif
`;ji.IncludesShadersStore[TA]=vA;const kk={name:TA,shader:vA},RA="pbrFragmentSamplersDeclaration",MA=`#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)
#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef CLEARCOAT
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)
uniform sampler2D clearCoatRoughnessSampler;
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)
uniform sampler2D sheenRoughnessSampler;
#endif
#endif
#ifdef ANISOTROPIC
#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)
#endif
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
#define sampleReflection(s,c) textureCube(s,c)
uniform samplerCube reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform samplerCube irradianceSampler;
#endif
#else
#define sampleReflection(s,c) texture2D(s,c)
uniform sampler2D reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D reflectionSamplerLow;uniform sampler2D reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform sampler2D irradianceSampler;
#endif
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#endif
#ifdef ENVIRONMENTBRDF
uniform sampler2D environmentBrdfSampler;
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
#ifdef SS_REFRACTIONMAP_3D
#define sampleRefraction(s,c) textureCube(s,c)
uniform samplerCube refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube refractionSamplerLow;uniform samplerCube refractionSamplerHigh;
#endif
#else
#define sampleRefraction(s,c) texture2D(s,c)
uniform sampler2D refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D refractionSamplerLow;uniform sampler2D refractionSamplerHigh;
#endif
#endif
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)
#endif
`;ji.IncludesShadersStore[RA]=MA;const Uk={name:RA,shader:MA},wA="imageProcessingDeclaration",LA=`#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`;ji.IncludesShadersStore[wA]=LA;const Gk={name:wA,shader:LA},kA="logDepthDeclaration",UA=`#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;varying float vFragmentDepth;
#endif
`;ji.IncludesShadersStore[kA]=UA;const zk={name:kA,shader:UA},GA="fogFragmentDeclaration",zA=`#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()
{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)
{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}
else if (FOGMODE_EXP==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}
else if (FOGMODE_EXP2==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}
return clamp(fogCoeff,0.0,1.0);}
#endif
`;ji.IncludesShadersStore[GA]=zA;const Wk={name:GA,shader:zA},WA="subSurfaceScatteringFunctions",HA=`bool testLightingForSSS(float diffusionProfile)
{return diffusionProfile<1.;}`;ji.IncludesShadersStore[WA]=HA;const Hk={name:WA,shader:HA},XA="importanceSampling",YA=`vec3 hemisphereCosSample(vec2 u) {float phi=2.*PI*u.x;float cosTheta2=1.-u.y;float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDggx(vec2 u,float a) {float phi=2.*PI*u.x;float cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { 
float phi=2.*PI*u.x;float sinTheta=pow(u.y,a/(2.*a+1.));float cosTheta=sqrt(1.-sinTheta*sinTheta);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}`;ji.IncludesShadersStore[XA]=YA;const Xk={name:XA,shader:YA},KA="pbrHelperFunctions",jA=`#define MINIMUMVARIANCE 0.0005
float convertRoughnessToAverageSlope(float roughness)
{return square(roughness)+MINIMUMVARIANCE;}
float fresnelGrazingReflectance(float reflectance0) {float reflectance90=saturate(reflectance0*25.0);return reflectance90;}
vec2 getAARoughnessFactors(vec3 normalVector) {
#ifdef SPECULARAA
vec3 nDfdx=dFdx(normalVector.xyz);vec3 nDfdy=dFdy(normalVector.xyz);float slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));float geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);float geometricAlphaGFactor=sqrt(slopeSquare);geometricAlphaGFactor*=0.75;return vec2(geometricRoughnessFactor,geometricAlphaGFactor);
#else
return vec2(0.);
#endif
}
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_LEGACY
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;vec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);vec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);vec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));return anisotropicNormal;}
#else
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(mix(alphaG,1.0,anisotropy*anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG,MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 bentNormal=cross(B,V);bentNormal=normalize(cross(bentNormal,B));float a=square(square(1.0-anisotropy*(1.0-roughness)));bentNormal=normalize(mix(bentNormal,N,a));return bentNormal;}
#endif
#endif
#if defined(CLEARCOAT) || defined(SS_REFRACTION)
vec3 cocaLambert(vec3 alpha,float distance) {return exp(-alpha*distance);}
vec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {return cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));}
vec3 computeColorAtDistanceInMedia(vec3 color,float distance) {return -log(color)/distance;}
vec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 clearCoatAbsorption=mix(vec3(1.0),
cocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),
clearCoatIntensity);return clearCoatAbsorption;}
#endif
#ifdef MICROSURFACEAUTOMATIC
float computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)
{const float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;float reflectivityLuminance=getLuminance(reflectivityColor);float reflectivityLuma=sqrt(reflectivityLuminance);microSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;return microSurface;}
#endif
`;ji.IncludesShadersStore[KA]=jA;const Yk={name:KA,shader:jA},qA="imageProcessingFunctions",$A=`#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;}
#endif
#ifdef TONEMAPPING_ACES
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);vec3 RRTAndODTFit(vec3 v)
{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}
vec3 ACESFitted(vec3 color)
{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
vec4 applyImageProcessing(vec4 result) {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#ifdef TONEMAPPING
#ifdef TONEMAPPING_ACES
result.rgb=ACESFitted(result.rgb);
#else
const float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
#endif
result.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return result;}`;ji.IncludesShadersStore[qA]=$A;const Kk={name:qA,shader:$A},rS="shadowsFragmentFunctions",nS=`#ifdef SHADOWS
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}
#define inline
float computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);}
#define inline
float computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}
#define inline
float computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
#else
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define GREATEST_LESS_THAN_ONE 0.99999994
/* disable_uniformity_analysis */
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.)
);const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}
else
{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
if (numBlocker<1.0) {return 1.0;}
else
{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#endif
#endif
`;ji.IncludesShadersStore[rS]=nS;const jk={name:rS,shader:nS},aS="harmonicsFunctions",xS=`#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
vec3 computeEnvironmentIrradiance(vec3 normal) {return vSphericalL00
+ vSphericalL1_1*(normal.y)
+ vSphericalL10*(normal.z)
+ vSphericalL11*(normal.x)
+ vSphericalL2_2*(normal.y*normal.x)
+ vSphericalL2_1*(normal.y*normal.z)
+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)
+ vSphericalL21*(normal.z*normal.x)
+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));}
#else
vec3 computeEnvironmentIrradiance(vec3 normal) {float Nx=normal.x;float Ny=normal.y;float Nz=normal.z;vec3 C1=vSphericalZZ.rgb;vec3 Cx=vSphericalX.rgb;vec3 Cy=vSphericalY.rgb;vec3 Cz=vSphericalZ.rgb;vec3 Cxx_zz=vSphericalXX_ZZ.rgb;vec3 Cyy_zz=vSphericalYY_ZZ.rgb;vec3 Cxy=vSphericalXY.rgb;vec3 Cyz=vSphericalYZ.rgb;vec3 Czx=vSphericalZX.rgb;vec3 a1=Cyy_zz*Ny+Cy;vec3 a2=Cyz*Nz+a1;vec3 b1=Czx*Nz+Cx;vec3 b2=Cxy*Ny+b1;vec3 b3=Cxx_zz*Nx+b2;vec3 t1=Cz *Nz+C1;vec3 t2=a2 *Ny+t1;vec3 t3=b3 *Nx+t2;return t3;}
#endif
#endif
`;ji.IncludesShadersStore[aS]=xS;const qk={name:aS,shader:xS},lS="pbrDirectLightingSetupFunctions",hS=`struct preLightingInfo
{vec3 lightOffset;float lightDistanceSquared;float lightDistance;float attenuation;vec3 L;vec3 H;float NdotV;float NdotLUnclamped;float NdotL;float VdotH;float roughness;
#ifdef IRIDESCENCE
float iridescenceIntensity;
#endif
};preLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightOffset=lightData.xyz-vPositionW;result.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);result.lightDistance=sqrt(result.lightDistanceSquared);result.L=normalize(result.lightOffset);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightDistance=length(-lightData.xyz);result.L=normalize(-lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.NdotL=dot(N,lightData.xyz)*0.5+0.5;result.NdotL=saturateEps(result.NdotL);result.NdotLUnclamped=result.NdotL;
#ifdef SPECULARTERM
result.L=normalize(lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));
#endif
return result;}`;ji.IncludesShadersStore[lS]=hS;const $k={name:lS,shader:hS},cS="pbrDirectLightingFalloffFunctions",uS=`float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)
{return max(0.,1.0-length(lightOffset)/range);}
float computeDistanceLightFalloff_Physical(float lightDistanceSquared)
{return 1.0/maxEps(lightDistanceSquared);}
float computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)
{float lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);float factor=lightDistanceSquared*inverseSquaredRange;float attenuation=saturate(1.0-factor*factor);attenuation*=attenuation;lightDistanceFalloff*=attenuation;return lightDistanceFalloff;}
float computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDistanceLightFalloff_Physical(lightDistanceSquared);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);
#else
return computeDistanceLightFalloff_Standard(lightOffset,range);
#endif
}
float computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)
{float falloff=0.0;float cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));if (cosAngle>=cosHalfAngle)
{falloff=max(0.,pow(cosAngle,exponent));}
return falloff;}
float computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)
{const float kMinusLog2ConeAngleIntensityRatio=6.64385618977; 
float concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);vec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);float falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));return falloff;}
float computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)
{float cd=dot(-lightDirection,directionToLightCenterW);float falloff=saturate(cd*lightAngleScale+lightAngleOffset);falloff*=falloff;return falloff;}
float computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);
#else
return computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);
#endif
}`;ji.IncludesShadersStore[cS]=uS;const rU={name:cS,shader:uS},pS="pbrBRDFFunctions",_S=`#define FRESNEL_MAXIMUM_ON_ROUGH 0.25
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}
#endif
#ifdef ENVIRONMENTBRDF
vec3 getBRDFLookup(float NdotV,float perceptualRoughness) {vec2 UV=vec2(NdotV,perceptualRoughness);vec4 brdfLookup=texture2D(environmentBrdfSampler,UV);
#ifdef ENVIRONMENTBRDF_RGBD
brdfLookup.rgb=fromRGBD(brdfLookup.rgba);
#endif
return brdfLookup.rgb;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;
#endif
return reflectance;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;
#endif
return reflectance;}
#endif
/* NOT USED
#if defined(SHEEN) && defined(SHEEN_SOFTER)
float getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)
{float c=1.0-NdotV;float c3=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}
#endif
*/
#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)
vec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)
{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
/**
* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.
* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table
*/
vec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {vec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}
#endif
vec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
float fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
#ifdef CLEARCOAT
vec3 getR0RemappedForClearCoat(vec3 f0) {
#ifdef CLEARCOAT_DEFAULTIOR
#ifdef MOBILE
return saturate(f0*(f0*0.526868+0.529324)-0.0482256);
#else
return saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);
#endif
#else
vec3 s=sqrt(f0);vec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);return square(t);
#endif
}
#endif
#ifdef IRIDESCENCE
const mat3 XYZ_TO_REC709=mat3(
3.2404542,-0.9692660, 0.0556434,
-1.5371385, 1.8760108,-0.2040259,
-0.4985314, 0.0415560, 1.0572252
);vec3 getIORTfromAirToSurfaceR0(vec3 f0) {vec3 sqrtF0=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}
vec3 getR0fromIORs(vec3 iorT,float iorI) {return square((iorT-vec3(iorI))/(iorT+vec3(iorI)));}
float getR0fromIORs(float iorT,float iorI) {return square((iorT-iorI)/(iorT+iorI));}
vec3 evalSensitivity(float opd,vec3 shift) {float phase=2.0*PI*opd*1.0e-9;const vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);const vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);const vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}
vec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {vec3 I=vec3(1.0);float iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}
float cosTheta2=sqrt(cosTheta2Sq);float R0=getR0fromIORs(iridescenceIOR,outsideIOR);float R12=fresnelSchlickGGX(cosTheta1,R0,1.);float R21=R12;float T121=1.0-R12;float phi12=0.0;if (iridescenceIOR<outsideIOR) phi12=PI;float phi21=PI-phi12;vec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); 
vec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);vec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));vec3 phi23=vec3(0.0);if (baseIOR[0]<iridescenceIOR) phi23[0]=PI;if (baseIOR[1]<iridescenceIOR) phi23[1]=PI;if (baseIOR[2]<iridescenceIOR) phi23[2]=PI;float opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=square(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for (int m=1; m<=2; ++m)
{Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);I+=Cm*Sm;}
return max(I,vec3(0.0));}
#endif
float normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)
{float a2=square(alphaG);float d=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}
#ifdef SHEEN
float normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)
{float invR=1./alphaG;float cos2h=NdotH*NdotH;float sin2h=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}
#endif
#ifdef ANISOTROPIC
float normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {float a2=alphaTB.x*alphaTB.y;vec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}
#endif
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {
#ifdef MOBILE
float GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);float GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);
#else
float a2=alphaG*alphaG;float GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);float GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);
#endif
}
#else
float smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)
{
#ifdef MOBILE
return 1.0/(dot+alphaG+(1.0-alphaG)*dot ));
#else
float alphaSquared=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));
#endif
}
float smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)
{float visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}
#endif
#ifdef ANISOTROPIC
float smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {float lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));float lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));float v=0.5/(lambdaV+lambdaL);return v;}
#endif
#ifdef CLEARCOAT
float visibility_Kelemen(float VdotH) {return 0.25/(VdotH*VdotH); }
#endif
#ifdef SHEEN
float visibility_Ashikhmin(float NdotL,float NdotV)
{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}
/* NOT USED
#ifdef SHEEN_SOFTER
float l(float x,float alphaG)
{float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}
float lambdaSheen(float cosTheta,float alphaG)
{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}
float visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)
{float G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}
#endif
*/
#endif
float diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {float diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));float diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));float diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;float fresnel =
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}
#ifdef SS_TRANSLUCENCY
vec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {vec3 S=1./maxEps(diffusionDistance);vec3 temp=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}
float computeWrappedDiffuseNdotL(float NdotL,float w) {float t=1.0+w;float invt2=1.0/square(t);return saturate((NdotL+w)*invt2);}
#endif
`;ji.IncludesShadersStore[pS]=_S;const nU={name:pS,shader:_S},TS="hdrFilteringFunctions",vS=`#ifdef NUM_SAMPLES
#if NUM_SAMPLES>0
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
float radicalInverse_VdC(uint bits) 
{bits=(bits<<16u) | (bits>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10; }
vec2 hammersley(uint i,uint N)
{return vec2(float(i)/float(N),radicalInverse_VdC(i));}
#else
float vanDerCorpus(int n,int base)
{float invBase=1.0/float(base);float denom =1.0;float result =0.0;for(int i=0; i<32; ++i)
{if(n>0)
{denom =mod(float(n),2.0);result+=denom*invBase;invBase=invBase/2.0;n =int(float(n)/2.0);}}
return result;}
vec2 hammersley(int i,int N)
{return vec2(float(i)/float(N),vanDerCorpus(i,2));}
#endif
float log4(float x) {return log2(x)/2.;}
const float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);const float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;const float K=4.;
#define inline
vec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 result=vec3(0.0);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 Ls=hemisphereCosSample(Xi);Ls=normalize(Ls);vec3 Ns=vec3(0.,0.,1.);float NoL=dot(Ns,Ls);if (NoL>0.) {float pdf_inversed=PI/NoL;float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(l,0.0,maxLevel);vec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c;}}
result=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}
#define inline
vec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 c=textureCube(inputTexture,n).rgb; 
if (alphaG==0.) {
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
return c;} else {vec3 result=vec3(0.);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);float weight=0.;
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);float NoV=1.;float NoH=H.z;float NoH2=H.z*H.z;float NoL=2.*NoH2-1.;vec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {float pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(float(l),0.0,maxLevel);weight+=NoL;vec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c*NoL;}}
result=result/weight;return result;}}
#endif
#endif
`;ji.IncludesShadersStore[TS]=vS;const aU={name:TS,shader:vS},RS="pbrDirectLightingFunctions",MS=`#define CLEARCOATREFLECTANCE90 1.0
struct lightingInfo
{vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef CLEARCOAT
vec4 clearCoat;
#endif
#ifdef SHEEN
vec3 sheen;
#endif
};float adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {
#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)
float lightRoughness=lightRadius/lightDistance;float totalRoughness=saturate(lightRoughness+roughness);return totalRoughness;
#else
return roughness;
#endif
}
vec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {return mix(groundColor,lightColor,info.NdotL);}
vec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {float diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*info.attenuation*info.NdotL*lightColor;}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return toLinearSpace(textureColor);}
#ifdef SS_TRANSLUCENCY
vec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {float NdotL=absEps(info.NdotLUnclamped);float wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);float trAdapt=step(0.,info.NdotLUnclamped);vec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);float diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;}
#endif
#ifdef SPECULARTERM
vec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);
#else
float smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);
#endif
vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef ANISOTROPIC
vec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float TdotH=dot(T,info.H);float BdotH=dot(B,info.H);float TdotV=dot(T,V);float BdotV=dot(B,V);float TdotL=dot(T,info.L);float BdotL=dot(B,info.L);float alphaG=convertRoughnessToAverageSlope(info.roughness);vec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);alphaTB=max(alphaTB,square(geometricRoughnessFactor));vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);float smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef CLEARCOAT
vec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {float NccdotL=saturateEps(dot(Ncc,info.L));float NccdotH=saturateEps(dot(Ncc,info.H));float clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);float fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnel*=clearCoatIntensity;float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);float kelemenVisibility=visibility_Kelemen(info.VdotH);float clearCoatTerm=fresnel*distribution*kelemenVisibility;return vec4(
clearCoatTerm*info.attenuation*NccdotL*lightColor,
1.0-fresnel
);}
vec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);float NdotLRefract=saturateEps(dot(Ncc,LRefract));vec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);return absorption;}
#endif
#ifdef SHEEN
vec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);float fresnel=1.;float distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);/*#ifdef SHEEN_SOFTER
float visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);
#else */
float visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);/* #endif */
float sheenTerm=fresnel*distribution*visibility;return sheenTerm*info.attenuation*info.NdotL*lightColor;}
#endif
`;ji.IncludesShadersStore[RS]=MS;const xU={name:RS,shader:MS},wS="pbrIBLFunctions",LS=`#if defined(REFLECTION) || defined(SS_REFRACTION)
float getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {float microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;float lod=log2(microsurfaceAverageSlopeTexels);return lod;}
float getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {float lod=log2(cubeMapDimensionPixels)*roughness;return lod;}
#endif
#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)
float environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {float temp=NdotVUnclamped+ambientOcclusion;return saturate(square(temp)-1.0+ambientOcclusion);}
#endif
#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)
float environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {vec3 reflection=reflect(view,normal);float temp=saturate(1.0+1.1*dot(reflection,geometricNormal));return square(temp);}
#endif
#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)
#define UNPACK_LOD(x) (1.0-x)*255.0
float getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {float microsurfaceAverageSlope=alphaG;microsurfaceAverageSlope*=sqrt(abs(NdotV));return getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);}
#endif
`;ji.IncludesShadersStore[wS]=LS;const lU={name:wS,shader:LS},kS="bumpFragmentMainFunctions",US=`#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#if defined(WEBGL2) || defined(WEBGPU)
mat4 toNormalMatrix(mat4 wMatrix)
{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}
#else
mat4 toNormalMatrix(mat4 m)
{float
a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],
a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],
a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],
a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],
b00=a00*a11-a01*a10,
b01=a00*a12-a02*a10,
b02=a00*a13-a03*a10,
b03=a01*a12-a02*a11,
b04=a01*a13-a03*a11,
b05=a02*a13-a03*a12,
b06=a20*a31-a21*a30,
b07=a20*a32-a22*a30,
b08=a20*a33-a23*a30,
b09=a21*a32-a22*a31,
b10=a21*a33-a23*a31,
b11=a22*a33-a23*a32,
det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(
a11*b11-a12*b10+a13*b09,
a02*b10-a01*b11-a03*b09,
a31*b05-a32*b04+a33*b03,
a22*b04-a21*b05-a23*b03,
a12*b08-a10*b11-a13*b07,
a00*b11-a02*b08+a03*b07,
a32*b02-a30*b05-a33*b01,
a20*b05-a22*b02+a23*b01,
a10*b10-a11*b08+a13*b06,
a01*b08-a00*b10-a03*b06,
a30*b04-a31*b02+a33*b00,
a21*b02-a20*b04-a23*b00,
a11*b07-a10*b09-a12*b06,
a00*b09-a01*b07+a02*b06,
a31*b01-a30*b03-a32*b00,
a20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],
mi[0][1],mi[1][1],mi[2][1],mi[3][1],
mi[0][2],mi[1][2],mi[2][2],mi[3][2],
mi[0][3],mi[1][3],mi[2][3],mi[3][3]);}
#endif
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}
#endif
`;ji.IncludesShadersStore[kS]=US;const hU={name:kS,shader:US},GS="bumpFragmentFunctions",zS=`#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)
{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)
{}
else if (currSampledHeight>currRayHeight)
{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}
else
{currRayHeight-=stepSize;vLastOffset=vCurrOffset;
#ifdef PARALLAX_RHS
vCurrOffset-=stepSize*vMaxOffset;
#else
vCurrOffset+=stepSize*vMaxOffset;
#endif
lastSampledHeight=currSampledHeight;}}
return vCurrOffset;}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;
#ifdef PARALLAX_RHS
return texCoordOffset;
#else
return -texCoordOffset;
#endif
}
#endif
`;ji.IncludesShadersStore[GS]=zS;const cU={name:GS,shader:zS},WS="reflectionFunction",HS=`vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*(view*worldPos));}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*vec4(positionW,1.));}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;ji.IncludesShadersStore[WS]=HS;const uU={name:WS,shader:HS},XS="decalFragment",YS=`#ifdef DECAL
#ifdef GAMMADECAL
decalColor.rgb=toLinearSpace(decalColor.rgb);
#endif
#ifdef DECAL_SMOOTHALPHA
decalColor.a*=decalColor.a;
#endif
surfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);
#endif
`;ji.IncludesShadersStore[XS]=YS;const pU={name:XS,shader:YS},KS="pbrBlockAlbedoOpacity",jS=`struct albedoOpacityOutParams
{vec3 surfaceAlbedo;float alpha;};
#define pbr_inline
void albedoOpacityBlock(
in vec4 vAlbedoColor,
#ifdef ALBEDO
in vec4 albedoTexture,
in vec2 albedoInfos,
#endif
#ifdef OPACITY
in vec4 opacityMap,
in vec2 vOpacityInfos,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
#ifdef DECAL
in vec4 decalColor,
in vec4 vDecalInfos,
#endif
out albedoOpacityOutParams outParams
)
{vec3 surfaceAlbedo=vAlbedoColor.rgb;float alpha=vAlbedoColor.a;
#ifdef ALBEDO
#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)
alpha*=albedoTexture.a;
#endif
#ifdef GAMMAALBEDO
surfaceAlbedo*=toLinearSpace(albedoTexture.rgb);
#else
surfaceAlbedo*=albedoTexture.rgb;
#endif
surfaceAlbedo*=albedoInfos.y;
#endif
#ifndef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
surfaceAlbedo*=vColor.rgb;
#endif
#ifdef DETAIL
float detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);surfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; 
#endif
#ifdef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALBEDO
#ifdef OPACITY
#ifdef OPACITYRGB
alpha=getLuminance(opacityMap.rgb);
#else
alpha*=opacityMap.a;
#endif
alpha*=vOpacityInfos.y;
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)
#ifdef ALPHATEST 
#if DEBUGMODE != 88
if (alpha<ALPHATESTVALUE)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
#endif
outParams.surfaceAlbedo=surfaceAlbedo;outParams.alpha=alpha;}
`;ji.IncludesShadersStore[KS]=jS;const _U={name:KS,shader:jS},qS="pbrBlockReflectivity",$S=`struct reflectivityOutParams
{float microSurface;float roughness;vec3 surfaceReflectivityColor;
#ifdef METALLICWORKFLOW
vec3 surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
vec3 ambientOcclusionColor;
#endif
#if DEBUGMODE>0
#ifdef METALLICWORKFLOW
vec2 metallicRoughness;
#ifdef REFLECTIVITY
vec4 surfaceMetallicColorMap;
#endif
#ifndef FROSTBITE_REFLECTANCE
vec3 metallicF0;
#endif
#else
#ifdef REFLECTIVITY
vec4 surfaceReflectivityColorMap;
#endif
#endif
#endif
};
#define pbr_inline
void reflectivityBlock(
in vec4 vReflectivityColor,
#ifdef METALLICWORKFLOW
in vec3 surfaceAlbedo,
in vec4 metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
in vec3 reflectivityInfos,
in vec4 surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
in vec3 ambientOcclusionColorIn,
#endif
#ifdef MICROSURFACEMAP
in vec4 microSurfaceTexel,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
out reflectivityOutParams outParams
)
{float microSurface=vReflectivityColor.a;vec3 surfaceReflectivityColor=vReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec2 metallicRoughness=surfaceReflectivityColor.rg;
#ifdef REFLECTIVITY
#if DEBUGMODE>0
outParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef AOSTOREINMETALMAPRED
vec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);outParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);
#endif
#ifdef METALLNESSSTOREINMETALMAPBLUE
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;
#else
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;
#endif
#ifdef ROUGHNESSSTOREINMETALMAPALPHA
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;
#else
#ifdef ROUGHNESSSTOREINMETALMAPGREEN
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;
#endif
#endif
#endif
#ifdef DETAIL
float detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);float loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);float hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);metallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));
#endif
#ifdef MICROSURFACEMAP
metallicRoughness.g*=microSurfaceTexel.r;
#endif
#if DEBUGMODE>0
outParams.metallicRoughness=metallicRoughness;
#endif
#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS
microSurface=1.0-metallicRoughness.g;vec3 baseColor=surfaceAlbedo;
#ifdef FROSTBITE_REFLECTANCE
outParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);surfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);
#else
vec3 metallicF0=metallicReflectanceFactors.rgb;
#if DEBUGMODE>0
outParams.metallicF0=metallicF0;
#endif
outParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);surfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);
#endif
#else
#ifdef REFLECTIVITY
surfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;
#if DEBUGMODE>0
outParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef MICROSURFACEFROMREFLECTIVITYMAP
microSurface*=surfaceMetallicOrReflectivityColorMap.a;microSurface*=reflectivityInfos.z;
#else
#ifdef MICROSURFACEAUTOMATIC
microSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);
#endif
#ifdef MICROSURFACEMAP
microSurface*=microSurfaceTexel.r;
#endif
#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE
#endif
#endif
#endif
microSurface=saturate(microSurface);float roughness=1.-microSurface;outParams.microSurface=microSurface;outParams.roughness=roughness;outParams.surfaceReflectivityColor=surfaceReflectivityColor;}
`;ji.IncludesShadersStore[qS]=$S;const TU={name:qS,shader:$S},rC="pbrBlockAmbientOcclusion",nC=`struct ambientOcclusionOutParams
{vec3 ambientOcclusionColor;
#if DEBUGMODE>0 && defined(AMBIENT)
vec3 ambientOcclusionColorMap;
#endif
};
#define pbr_inline
void ambientOcclusionBlock(
#ifdef AMBIENT
in vec3 ambientOcclusionColorMap_,
in vec4 vAmbientInfos,
#endif
out ambientOcclusionOutParams outParams
)
{vec3 ambientOcclusionColor=vec3(1.,1.,1.);
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;
#ifdef AMBIENTINGRAYSCALE
ambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);
#endif
ambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);
#if DEBUGMODE>0
outParams.ambientOcclusionColorMap=ambientOcclusionColorMap;
#endif
#endif
outParams.ambientOcclusionColor=ambientOcclusionColor;}
`;ji.IncludesShadersStore[rC]=nC;const vU={name:rC,shader:nC},aC="pbrBlockAlphaFresnel",xC=`#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
struct alphaFresnelOutParams
{float alpha;};
#define pbr_inline
void alphaFresnelBlock(
in vec3 normalW,
in vec3 viewDirectionW,
in float alpha,
in float microSurface,
out alphaFresnelOutParams outParams
)
{float opacityPerceptual=alpha;
#ifdef LINEARALPHAFRESNEL
float opacity0=opacityPerceptual;
#else
float opacity0=opacityPerceptual*opacityPerceptual;
#endif
float opacity90=fresnelGrazingReflectance(opacity0);vec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);outParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;
#ifdef ALPHATEST
if (outParams.alpha<ALPHATESTVALUE)
discard;
#ifndef ALPHABLEND
outParams.alpha=1.0;
#endif
#endif
}
#endif
#endif
`;ji.IncludesShadersStore[aC]=xC;const RU={name:aC,shader:xC},lC="pbrBlockAnisotropic",hC=`#ifdef ANISOTROPIC
struct anisotropicOutParams
{float anisotropy;vec3 anisotropicTangent;vec3 anisotropicBitangent;vec3 anisotropicNormal;
#if DEBUGMODE>0 && defined(ANISOTROPIC_TEXTURE)
vec3 anisotropyMapData;
#endif
};
#define pbr_inline
void anisotropicBlock(
in vec3 vAnisotropy,
in float roughness,
#ifdef ANISOTROPIC_TEXTURE
in vec3 anisotropyMapData,
#endif
in mat3 TBN,
in vec3 normalW,
in vec3 viewDirectionW,
out anisotropicOutParams outParams
)
{float anisotropy=vAnisotropy.b;vec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);
#ifdef ANISOTROPIC_TEXTURE
anisotropy*=anisotropyMapData.b;
#if DEBUGMODE>0
outParams.anisotropyMapData=anisotropyMapData;
#endif
anisotropyMapData.rg=anisotropyMapData.rg*2.0-1.0;
#ifdef ANISOTROPIC_LEGACY
anisotropyDirection.rg*=anisotropyMapData.rg;
#else
anisotropyDirection.xy=mat2(anisotropyDirection.x,anisotropyDirection.y,-anisotropyDirection.y,anisotropyDirection.x)*normalize(anisotropyMapData.rg);
#endif
#endif
mat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));vec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);vec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));outParams.anisotropy=anisotropy;outParams.anisotropicTangent=anisotropicTangent;outParams.anisotropicBitangent=anisotropicBitangent;outParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy,roughness);}
#endif
`;ji.IncludesShadersStore[lC]=hC;const MU={name:lC,shader:hC},cC="pbrBlockReflection",uC=`#ifdef REFLECTION
struct reflectionOutParams
{vec4 environmentRadiance;vec3 environmentIrradiance;
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords;
#else
vec2 reflectionCoords;
#endif
#ifdef SS_TRANSLUCENCY
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
vec3 irradianceVector;
#endif
#endif
#endif
};
#define pbr_inline
void createReflectionCoords(
in vec3 vPositionW,
in vec3 normalW,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REFLECTIONMAP_3D
out vec3 reflectionCoords
#else
out vec2 reflectionCoords
#endif
)
{
#ifdef ANISOTROPIC
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);
#else
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
reflectionCoords=reflectionVector;
#else
reflectionCoords=reflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
reflectionCoords/=reflectionVector.z;
#endif
reflectionCoords.y=1.0-reflectionCoords.y;
#endif
}
#define pbr_inline
#define inline
void sampleReflectionTexture(
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
const vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
const vec2 reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out vec4 environmentRadiance
)
{
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);
#elif defined(LINEARSPECULARREFLECTION)
float reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);
#else
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);
#endif
#ifdef LODBASEDMICROSFURACE
reflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;
#ifdef LODINREFLECTIONALPHA
float automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);float requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);
#else
float requestedReflectionLOD=reflectionLOD;
#endif
#ifdef REALTIME_FILTERING
environmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);
#else
environmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);
#endif
#else
float lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);if (lodReflectionNormalizedDoubled<1.0){environmentRadiance=mix(
sampleReflection(reflectionSamplerHigh,reflectionCoords),
environmentMid,
lodReflectionNormalizedDoubled
);} else {environmentRadiance=mix(
environmentMid,
sampleReflection(reflectionSamplerLow,reflectionCoords),
lodReflectionNormalizedDoubled-1.0
);}
#endif
#ifdef RGBDREFLECTION
environmentRadiance.rgb=fromRGBD(environmentRadiance);
#endif
#ifdef GAMMAREFLECTION
environmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);
#endif
environmentRadiance.rgb*=vReflectionInfos.x;environmentRadiance.rgb*=vReflectionColor.rgb;}
#define pbr_inline
#define inline
void reflectionBlock(
in vec3 vPositionW,
in vec3 normalW,
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
in vec3 vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in mat4 reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out reflectionOutParams outParams
)
{vec4 environmentRadiance=vec4(0.,0.,0.,0.);
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords=vec3(0.);
#else
vec2 reflectionCoords=vec2(0.);
#endif
createReflectionCoords(
vPositionW,
normalW,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
reflectionCoords
);sampleReflectionTexture(
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
#ifdef REFLECTIONMAP_3D
reflectionSampler,
reflectionCoords,
#else
reflectionSampler,
reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentRadiance
);vec3 environmentIrradiance=vec3(0.,0.,0.);
#ifdef USESPHERICALFROMREFLECTIONMAP
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
environmentIrradiance=vEnvironmentIrradiance;
#else
#ifdef ANISOTROPIC
vec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;
#else
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#if defined(REALTIME_FILTERING)
environmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);
#else
environmentIrradiance=computeEnvironmentIrradiance(irradianceVector);
#endif
#ifdef SS_TRANSLUCENCY
outParams.irradianceVector=irradianceVector;
#endif
#endif
#elif defined(USEIRRADIANCEMAP)
vec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);environmentIrradiance=environmentIrradiance4.rgb;
#ifdef RGBDREFLECTION
environmentIrradiance.rgb=fromRGBD(environmentIrradiance4);
#endif
#ifdef GAMMAREFLECTION
environmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);
#endif
#endif
environmentIrradiance*=vReflectionColor.rgb;outParams.environmentRadiance=environmentRadiance;outParams.environmentIrradiance=environmentIrradiance;outParams.reflectionCoords=reflectionCoords;}
#endif
`;ji.IncludesShadersStore[cC]=uC;const wU={name:cC,shader:uC},_C="pbrBlockSheen",TC=`#ifdef SHEEN
struct sheenOutParams
{float sheenIntensity;vec3 sheenColor;float sheenRoughness;
#ifdef SHEEN_LINKWITHALBEDO
vec3 surfaceAlbedo;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
float sheenAlbedoScaling;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 finalSheenRadianceScaled;
#endif
#if DEBUGMODE>0
#ifdef SHEEN_TEXTURE
vec4 sheenMapData;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 sheenEnvironmentReflectance;
#endif
#endif
};
#define pbr_inline
#define inline
void sheenBlock(
in vec4 vSheenColor,
#ifdef SHEEN_ROUGHNESS
in float vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 sheenMapRoughnessData,
#endif
#endif
in float roughness,
#ifdef SHEEN_TEXTURE
in vec4 sheenMapData,
in float sheenMapLevel,
#endif
in float reflectance,
#ifdef SHEEN_LINKWITHALBEDO
in vec3 baseColor,
in vec3 surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
in float NdotV,
in vec3 environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
in vec2 AARoughnessFactors,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
in vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
in vec2 reflectionCoords,
#endif
in float NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
in float seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
in float eho,
#endif
#endif
out sheenOutParams outParams
)
{float sheenIntensity=vSheenColor.a;
#ifdef SHEEN_TEXTURE
#if DEBUGMODE>0
outParams.sheenMapData=sheenMapData;
#endif
#endif
#ifdef SHEEN_LINKWITHALBEDO
float sheenFactor=pow5(1.0-sheenIntensity);vec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);float sheenRoughness=sheenIntensity;outParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#else
vec3 sheenColor=vSheenColor.rgb;
#ifdef SHEEN_TEXTURE
#ifdef SHEEN_GAMMATEXTURE
sheenColor.rgb*=toLinearSpace(sheenMapData.rgb);
#else
sheenColor.rgb*=sheenMapData.rgb;
#endif
sheenColor.rgb*=sheenMapLevel;
#endif
#ifdef SHEEN_ROUGHNESS
float sheenRoughness=vSheenRoughness;
#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE
#if defined(SHEEN_TEXTURE)
sheenRoughness*=sheenMapData.a;
#endif
#elif defined(SHEEN_TEXTURE_ROUGHNESS)
#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL
sheenRoughness*=sheenMapData.a;
#else
sheenRoughness*=sheenMapRoughnessData.a;
#endif
#endif
#else
float sheenRoughness=roughness;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#endif
#if !defined(SHEEN_ALBEDOSCALING)
sheenIntensity*=(1.-reflectance);
#endif
sheenColor*=sheenIntensity;
#endif
#ifdef ENVIRONMENTBRDF
/*#ifdef SHEEN_SOFTER
vec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));
#else*/
#ifdef SHEEN_ROUGHNESS
vec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);
#else
vec3 environmentSheenBrdf=environmentBrdf;
#endif
/*#endif*/
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
float sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);
#ifdef SPECULARAA
sheenAlphaG+=AARoughnessFactors.y;
#endif
vec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);sampleReflectionTexture(
sheenAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
sheenRoughness,
#endif
reflectionSampler,
reflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentSheenRadiance
);vec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
sheenEnvironmentReflectance*=seo;
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
sheenEnvironmentReflectance*=eho;
#endif
#if DEBUGMODE>0
outParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;
#endif
outParams.finalSheenRadianceScaled=
environmentSheenRadiance.rgb *
sheenEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
outParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;
#endif
outParams.sheenIntensity=sheenIntensity;outParams.sheenColor=sheenColor;outParams.sheenRoughness=sheenRoughness;}
#endif
`;ji.IncludesShadersStore[_C]=TC;const LU={name:_C,shader:TC},vC="pbrBlockClearcoat",RC=`struct clearcoatOutParams
{vec3 specularEnvironmentR0;float conservationFactor;vec3 clearCoatNormalW;vec2 clearCoatAARoughnessFactors;float clearCoatIntensity;float clearCoatRoughness;
#ifdef REFLECTION
vec3 finalClearCoatRadianceScaled;
#endif
#ifdef CLEARCOAT_TINT
vec3 absorption;float clearCoatNdotVRefract;vec3 clearCoatColor;float clearCoatThickness;
#endif
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
vec3 energyConservationFactorClearCoat;
#endif
#if DEBUGMODE>0
#ifdef CLEARCOAT_BUMP
mat3 TBNClearCoat;
#endif
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData;
#endif
#ifdef REFLECTION
vec4 environmentClearCoatRadiance;vec3 clearCoatEnvironmentReflectance;
#endif
float clearCoatNdotV;
#endif
};
#ifdef CLEARCOAT
#define pbr_inline
#define inline
void clearcoatBlock(
in vec3 vPositionW,
in vec3 geometricNormalW,
in vec3 viewDirectionW,
in vec2 vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 clearCoatMapRoughnessData,
#endif
in vec3 specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
in vec4 vClearCoatTintParams,
in float clearCoatColorAtDistance,
in vec4 vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
in vec4 clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
in vec2 vClearCoatBumpInfos,
in vec4 clearCoatBumpMapData,
in vec2 vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
in mat3 vTBN,
#else
in vec2 vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
in mat4 normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
in vec3 faceNormal,
#endif
#ifdef REFLECTION
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
in float ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
in float frontFacingMultiplier,
#endif
out clearcoatOutParams outParams
)
{float clearCoatIntensity=vClearCoatParams.x;float clearCoatRoughness=vClearCoatParams.y;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE
clearCoatRoughness*=clearCoatMapData.y;
#endif
#if DEBUGMODE>0
outParams.clearCoatMapData=clearCoatMapData;
#endif
#endif
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL
clearCoatRoughness*=clearCoatMapData.y;
#else
clearCoatRoughness*=clearCoatMapRoughnessData.y;
#endif
#endif
outParams.clearCoatIntensity=clearCoatIntensity;outParams.clearCoatRoughness=clearCoatRoughness;
#ifdef CLEARCOAT_TINT
vec3 clearCoatColor=vClearCoatTintParams.rgb;float clearCoatThickness=vClearCoatTintParams.a;
#ifdef CLEARCOAT_TINT_TEXTURE
#ifdef CLEARCOAT_TINT_GAMMATEXTURE
clearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);
#else
clearCoatColor*=clearCoatTintMapData.rgb;
#endif
clearCoatThickness*=clearCoatTintMapData.a;
#if DEBUGMODE>0
outParams.clearCoatTintMapData=clearCoatTintMapData;
#endif
#endif
outParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);outParams.clearCoatThickness=clearCoatThickness;
#endif
#ifdef CLEARCOAT_REMAP_F0
vec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);
#else
vec3 specularEnvironmentR0Updated=specularEnvironmentR0;
#endif
outParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);vec3 clearCoatNormalW=geometricNormalW;
#ifdef CLEARCOAT_BUMP
#ifdef NORMALXYSCALE
float clearCoatNormalScale=1.0;
#else
float clearCoatNormalScale=vClearCoatBumpInfos.y;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBNClearCoat=vTBN;
#else
vec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;mat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);
#endif
#if DEBUGMODE>0
outParams.TBNClearCoat=TBNClearCoat;
#endif
#ifdef OBJECTSPACE_NORMALMAP
clearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);clearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);
#else
clearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
clearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
clearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;
#endif
outParams.clearCoatNormalW=clearCoatNormalW;outParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);float clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);float clearCoatNdotV=absEps(clearCoatNdotVUnclamped);
#if DEBUGMODE>0
outParams.clearCoatNdotV=clearCoatNdotV;
#endif
#ifdef CLEARCOAT_TINT
vec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);outParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));
#endif
#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))
vec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);
#endif
#if defined(REFLECTION)
float clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);
#ifdef SPECULARAA
clearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;
#endif
vec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);vec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
clearCoatReflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
vec3 clearCoatReflectionCoords=clearCoatReflectionVector;
#else
vec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
clearCoatReflectionCoords/=clearCoatReflectionVector.z;
#endif
clearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;
#endif
sampleReflectionTexture(
clearCoatAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
clearCoatNdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
clearCoatRoughness,
#endif
reflectionSampler,
clearCoatReflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentClearCoatRadiance
);
#if DEBUGMODE>0
outParams.environmentClearCoatRadiance=environmentClearCoatRadiance;
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);clearCoatEnvironmentReflectance*=clearCoatEho;
#endif
#endif
#endif
#else
vec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));
#endif
clearCoatEnvironmentReflectance*=clearCoatIntensity;
#if DEBUGMODE>0
outParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;
#endif
outParams.finalClearCoatRadianceScaled=
environmentClearCoatRadiance.rgb *
clearCoatEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(CLEARCOAT_TINT)
outParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);
#endif
float fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnelIBLClearCoat*=clearCoatIntensity;outParams.conservationFactor=(1.-fresnelIBLClearCoat);
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
outParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);
#endif
}
#endif
`;ji.IncludesShadersStore[vC]=RC;const kU={name:vC,shader:RC},MC="pbrBlockIridescence",wC=`struct iridescenceOutParams
{float iridescenceIntensity;float iridescenceIOR;float iridescenceThickness;vec3 specularEnvironmentR0;};
#ifdef IRIDESCENCE
#define pbr_inline
#define inline
void iridescenceBlock(
in vec4 vIridescenceParams,
in float viewAngle,
in vec3 specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
in vec2 iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
in vec2 iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
in float NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#endif
out iridescenceOutParams outParams
)
{float iridescenceIntensity=vIridescenceParams.x;float iridescenceIOR=vIridescenceParams.y;float iridescenceThicknessMin=vIridescenceParams.z;float iridescenceThicknessMax=vIridescenceParams.w;float iridescenceThicknessWeight=1.;
#ifdef IRIDESCENCE_TEXTURE
iridescenceIntensity*=iridescenceMapData.x;
#ifdef IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE
iridescenceThicknessWeight=iridescenceMapData.g;
#endif
#endif
#if defined(IRIDESCENCE_THICKNESS_TEXTURE)
iridescenceThicknessWeight=iridescenceThicknessMapData.g;
#endif
float iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);float topIor=1.; 
#ifdef CLEARCOAT
float clearCoatIntensity=vClearCoatParams.x;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#endif
topIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);viewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));
#endif
vec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);outParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);outParams.iridescenceIntensity=iridescenceIntensity;outParams.iridescenceThickness=iridescenceThickness;outParams.iridescenceIOR=iridescenceIOR;}
#endif
`;ji.IncludesShadersStore[MC]=wC;const UU={name:MC,shader:wC},LC="pbrBlockSubSurface",kC=`struct subSurfaceOutParams
{vec3 specularEnvironmentReflectance;
#ifdef SS_REFRACTION
vec3 finalRefraction;vec3 surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
float alpha;
#endif
#ifdef REFLECTION
float refractionFactorForIrradiance;
#endif
#endif
#ifdef SS_TRANSLUCENCY
vec3 transmittance;float translucencyIntensity;
#ifdef REFLECTION
vec3 refractionIrradiance;
#endif
#endif
#if DEBUGMODE>0
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction;vec3 refractionTransmittance;
#endif
#endif
};
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
#define pbr_inline
#define inline
vec4 sampleEnvironmentRefraction(
in float ior
,in float thickness
,in float refractionLOD
,in vec3 normalW
,in vec3 vPositionW
,in vec3 viewDirectionW
,in mat4 view
,in vec4 vRefractionInfos
,in mat4 refractionMatrix
,in vec4 vRefractionMicrosurfaceInfos
,in float alphaG
#ifdef SS_REFRACTIONMAP_3D
,in samplerCube refractionSampler
#ifndef LODBASEDMICROSFURACE
,in samplerCube refractionSamplerLow
,in samplerCube refractionSamplerHigh
#endif
#else
,in sampler2D refractionSampler
#ifndef LODBASEDMICROSFURACE
,in sampler2D refractionSamplerLow
,in sampler2D refractionSamplerHigh
#endif
#endif
#ifdef ANISOTROPIC
,in anisotropicOutParams anisotropicOut
#endif
#ifdef REALTIME_FILTERING
,in vec2 vRefractionFilteringInfo
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
,in vec3 refractionPosition
,in vec3 refractionSize
#endif
) {vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef ANISOTROPIC
vec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,ior);
#else
vec3 refractionVector=refract(-viewDirectionW,normalW,ior);
#endif
#ifdef SS_REFRACTIONMAP_OPPOSITEZ
refractionVector.z*=-1.0;
#endif
#ifdef SS_REFRACTIONMAP_3D
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;vec3 refractionCoords=refractionVector;refractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));
#else
#ifdef SS_USE_THICKNESS_AS_DEPTH
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));
#endif
vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;
#endif
#ifdef LODBASEDMICROSFURACE
refractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;
#ifdef SS_LODINREFRACTIONALPHA
float automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);float requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);
#else
float requestedRefractionLOD=refractionLOD;
#endif
#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)
environmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);
#else
environmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);
#endif
#else
float lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));float lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;vec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);if (lodRefractionNormalizedDoubled<1.0){environmentRefraction=mix(
sampleRefraction(refractionSamplerHigh,refractionCoords),
environmentRefractionMid,
lodRefractionNormalizedDoubled
);} else {environmentRefraction=mix(
environmentRefractionMid,
sampleRefraction(refractionSamplerLow,refractionCoords),
lodRefractionNormalizedDoubled-1.0
);}
#endif
#ifdef SS_RGBDREFRACTION
environmentRefraction.rgb=fromRGBD(environmentRefraction);
#endif
#ifdef SS_GAMMAREFRACTION
environmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);
#endif
return environmentRefraction;}
#endif
#define pbr_inline
#define inline
void subSurfaceBlock(
in vec3 vSubSurfaceIntensity,
in vec2 vThicknessParam,
in vec4 vTintColor,
in vec3 normalW,
in vec3 specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
in vec4 thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
in vec4 refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
in vec4 translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
in mat4 reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in vec3 irradianceVector_,
#endif
#if defined(REALTIME_FILTERING)
in samplerCube reflectionSampler,
in vec2 vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
in vec3 surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
in vec3 vPositionW,
in vec3 viewDirectionW,
in mat4 view,
in vec4 vRefractionInfos,
in mat4 refractionMatrix,
in vec4 vRefractionMicrosurfaceInfos,
in vec4 vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
in float alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
in float NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
in float roughness,
#endif
in float alphaG,
#ifdef SS_REFRACTIONMAP_3D
in samplerCube refractionSampler,
#ifndef LODBASEDMICROSFURACE
in samplerCube refractionSamplerLow,
in samplerCube refractionSamplerHigh,
#endif
#else
in sampler2D refractionSampler,
#ifndef LODBASEDMICROSFURACE
in sampler2D refractionSamplerLow,
in sampler2D refractionSamplerHigh,
#endif
#endif
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
in vec2 vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
in vec3 refractionPosition,
in vec3 refractionSize,
#endif
#ifdef SS_DISPERSION
in float dispersion,
#endif
#endif
#ifdef SS_TRANSLUCENCY
in vec3 vDiffusionDistance,
#endif
out subSurfaceOutParams outParams
)
{outParams.specularEnvironmentReflectance=specularEnvironmentReflectance;
#ifdef SS_REFRACTION
float refractionIntensity=vSubSurfaceIntensity.x;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
refractionIntensity*=(1.0-alpha);outParams.alpha=1.0;
#endif
#endif
#ifdef SS_TRANSLUCENCY
float translucencyIntensity=vSubSurfaceIntensity.y;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
#if defined(SS_USE_GLTF_TEXTURES)
float thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;
#else
float thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;
#endif
#if DEBUGMODE>0
outParams.thicknessMap=thicknessMap;
#endif
#ifdef SS_MASK_FROM_THICKNESS_TEXTURE
#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE)
#if defined(SS_USE_GLTF_TEXTURES)
refractionIntensity*=thicknessMap.r;
#else
refractionIntensity*=thicknessMap.g;
#endif
#endif
#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE)
translucencyIntensity*=thicknessMap.b;
#endif
#endif
#else
float thickness=vThicknessParam.y;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
#ifdef SS_USE_GLTF_TEXTURES
refractionIntensity*=refractionIntensityMap.r;
#else
refractionIntensity*=refractionIntensityMap.g;
#endif
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensity*=translucencyIntensityMap.b;
#endif
#ifdef SS_TRANSLUCENCY
thickness=maxEps(thickness);vec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);transmittance*=translucencyIntensity;outParams.transmittance=transmittance;outParams.translucencyIntensity=translucencyIntensity;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef SS_HAS_THICKNESS
float ior=vRefractionInfos.y;
#else
float ior=vRefractionMicrosurfaceInfos.w;
#endif
#ifdef SS_LODINREFRACTIONALPHA
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);
#elif defined(SS_LINEARSPECULARREFRACTION)
float refractionRoughness=alphaG;refractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);
#else
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);
#endif
float refraction_ior=vRefractionInfos.y;
#ifdef SS_DISPERSION
float realIOR=1.0/refraction_ior;float iorDispersionSpread=0.04*dispersion*(realIOR-1.0);vec3 iors=vec3(1.0/(realIOR-iorDispersionSpread),refraction_ior,1.0/(realIOR+iorDispersionSpread));for (int i=0; i<3; i++) {refraction_ior=iors[i];
#endif
vec4 envSample=sampleEnvironmentRefraction(refraction_ior,thickness,refractionLOD,normalW,vPositionW,viewDirectionW,view,vRefractionInfos,refractionMatrix,vRefractionMicrosurfaceInfos,alphaG
#ifdef SS_REFRACTIONMAP_3D
,refractionSampler
#ifndef LODBASEDMICROSFURACE
,refractionSamplerLow
,refractionSamplerHigh
#endif
#else
,refractionSampler
#ifndef LODBASEDMICROSFURACE
,refractionSamplerLow
,refractionSamplerHigh
#endif
#endif
#ifdef ANISOTROPIC
,anisotropicOut
#endif
#ifdef REALTIME_FILTERING
,vRefractionFilteringInfo
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
,refractionPosition
,refractionSize
#endif
);
#ifdef SS_DISPERSION
environmentRefraction[i]=envSample[i];}
#else
environmentRefraction=envSample;
#endif
environmentRefraction.rgb*=vRefractionInfos.x;
#endif
#ifdef SS_REFRACTION
vec3 refractionTransmittance=vec3(refractionIntensity);
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,thickness);
#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)
float maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);vec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);environmentRefraction.rgb*=volumeAlbedo;
#else
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);
#endif
#ifdef SS_ALBEDOFORREFRACTIONTINT
environmentRefraction.rgb*=surfaceAlbedo.rgb;
#endif
outParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);
#ifdef REFLECTION
outParams.refractionFactorForIrradiance=(1.-refractionIntensity);
#endif
#ifdef UNUSED_MULTIPLEBOUNCES
vec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);outParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);
#endif
refractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;
#if DEBUGMODE>0
outParams.refractionTransmittance=refractionTransmittance;
#endif
outParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;
#if DEBUGMODE>0
outParams.environmentRefraction=environmentRefraction;
#endif
#endif
#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)
#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#else
vec3 irradianceVector=irradianceVector_;
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP)
#if defined(REALTIME_FILTERING)
vec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);
#else
vec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);
#endif
#elif defined(USEIRRADIANCEMAP)
#ifdef REFLECTIONMAP_3D
vec3 irradianceCoords=irradianceVector;
#else
vec2 irradianceCoords=irradianceVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
irradianceCoords/=irradianceVector.z;
#endif
irradianceCoords.y=1.0-irradianceCoords.y;
#endif
vec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);
#ifdef RGBDREFLECTION
refractionIrradiance.rgb=fromRGBD(refractionIrradiance);
#endif
#ifdef GAMMAREFLECTION
refractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);
#endif
#else
vec4 refractionIrradiance=vec4(0.);
#endif
refractionIrradiance.rgb*=transmittance;
#ifdef SS_ALBEDOFORTRANSLUCENCYTINT
refractionIrradiance.rgb*=surfaceAlbedo.rgb;
#endif
outParams.refractionIrradiance=refractionIrradiance.rgb;
#endif
}
#endif
`;ji.IncludesShadersStore[LC]=kC;const GU={name:LC,shader:kC},UC="pbrBlockNormalGeometric",GC=`vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#endif
vec3 geometricNormalW=normalW;
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
geometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;
#endif
`;ji.IncludesShadersStore[UC]=GC;const zU={name:UC,shader:GC},zC="bumpFragment",WC=`vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
#define CUSTOM_FRAGMENT_BUMP_FRAGMENT
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;ji.IncludesShadersStore[zC]=WC;const WU={name:zC,shader:WC},HC="pbrBlockNormalFinal",XC=`#if defined(FORCENORMALFORWARD) && defined(NORMAL)
vec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#if defined(TWOSIDEDLIGHTING)
faceNormal=gl_FrontFacing ? faceNormal : -faceNormal;
#endif
normalW*=sign(dot(normalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
`;ji.IncludesShadersStore[HC]=XC;const HU={name:HC,shader:XC},YC="depthPrePass",KC=`#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);return;
#endif
`;ji.IncludesShadersStore[YC]=KC;const XU={name:YC,shader:KC},jC="pbrBlockLightmapInit",qC=`#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
#ifdef GAMMALIGHTMAP
lightmapColor.rgb=toLinearSpace(lightmapColor.rgb);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
`;ji.IncludesShadersStore[jC]=qC;const YU={name:jC,shader:qC},$C="pbrBlockGeometryInfo",rR=`float NdotVUnclamped=dot(normalW,viewDirectionW);float NdotV=absEps(NdotVUnclamped);float alphaG=convertRoughnessToAverageSlope(roughness);vec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);
#ifdef SPECULARAA
alphaG+=AARoughnessFactors.y;
#endif
#if defined(ENVIRONMENTBRDF)
vec3 environmentBrdf=getBRDFLookup(NdotV,roughness);
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
#ifdef AMBIENTINGRAYSCALE
float ambientMonochrome=aoOut.ambientOcclusionColor.r;
#else
float ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);
#endif
float seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);
#endif
#endif
#endif
#endif
`;ji.IncludesShadersStore[$C]=rR;const KU={name:$C,shader:rR},nR="pbrBlockReflectance0",aR=`float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);vec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);
#else 
vec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);
#endif
#ifdef ALPHAFRESNEL
float reflectance90=fresnelGrazingReflectance(reflectance);specularEnvironmentR90=specularEnvironmentR90*reflectance90;
#endif
`;ji.IncludesShadersStore[nR]=aR;const jU={name:nR,shader:aR},xR="pbrBlockReflectance",lR=`#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);
#ifdef RADIANCEOCCLUSION
specularEnvironmentReflectance*=seo;
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
specularEnvironmentReflectance*=eho;
#endif
#endif
#endif
#else
vec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));
#endif
#ifdef CLEARCOAT
specularEnvironmentReflectance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
specularEnvironmentReflectance*=clearcoatOut.absorption;
#endif
#endif
`;ji.IncludesShadersStore[xR]=lR;const qU={name:xR,shader:lR},hR="pbrBlockDirectLighting",cR=`vec3 diffuseBase=vec3(0.,0.,0.);
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
#ifdef CLEARCOAT
vec3 clearCoatBase=vec3(0.,0.,0.);
#endif
#ifdef SHEEN
vec3 sheenBase=vec3(0.,0.,0.);
#endif
preLightingInfo preInfo;lightingInfo info;float shadow=1.; 
float aggShadow=0.;float numLights=0.;
#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
vec3 absorption=vec3(0.);
#endif
`;ji.IncludesShadersStore[hR]=cR;const $U={name:hR,shader:cR},uR="lightFragment",pR=`#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {index{X}=i;break;}}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{index{X}+=1;float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
aggShadow+=shadow;numLights+=1.0;
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;ji.IncludesShadersStore[uR]=pR;const r4={name:uR,shader:pR},_R="pbrBlockFinalLitComponents",TR=`aggShadow=aggShadow/numLights;
#if defined(ENVIRONMENTBRDF)
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);
#endif
#endif
#ifndef METALLICWORKFLOW
#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION
surfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;
#endif
#endif
#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)
surfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;
#endif
#ifdef REFLECTION
vec3 finalIrradiance=reflectionOut.environmentIrradiance;
#if defined(CLEARCOAT)
finalIrradiance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
finalIrradiance*=clearcoatOut.absorption;
#endif
#endif
#if defined(SS_REFRACTION)
finalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;
#endif
#if defined(SS_TRANSLUCENCY)
finalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);finalIrradiance+=subSurfaceOut.refractionIrradiance;
#endif
finalIrradiance*=surfaceAlbedo.rgb;finalIrradiance*=vLightingIntensity.z;finalIrradiance*=aoOut.ambientOcclusionColor;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase;finalSpecular=max(finalSpecular,0.0);vec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalSpecularScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalSpecularScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef REFLECTION
vec3 finalRadiance=reflectionOut.environmentRadiance.rgb;finalRadiance*=subSurfaceOut.specularEnvironmentReflectance;vec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalRadianceScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalRadianceScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef SHEEN
vec3 finalSheen=sheenBase*sheenOut.sheenColor;finalSheen=max(finalSheen,0.0);vec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;
#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef CLEARCOAT
vec3 finalClearCoat=clearCoatBase;finalClearCoat=max(finalClearCoat,0.0);vec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;
#ifdef CLEARCOAT_TINT
subSurfaceOut.finalRefraction*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef ALPHABLEND
float luminanceOverAlpha=0.0;
#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)
luminanceOverAlpha+=getLuminance(finalRadianceScaled);
#if defined(CLEARCOAT)
luminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);
#endif
#endif
#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)
luminanceOverAlpha+=getLuminance(finalSpecularScaled);
#endif
#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)
luminanceOverAlpha+=getLuminance(finalClearCoatScaled);
#endif
#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)
alpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);
#endif
#endif
`;ji.IncludesShadersStore[_R]=TR;const n4={name:_R,shader:TR},vR="pbrBlockFinalUnlitComponents",RR=`vec3 finalDiffuse=diffuseBase;finalDiffuse*=surfaceAlbedo.rgb;finalDiffuse=max(finalDiffuse,0.0);finalDiffuse*=vLightingIntensity.x;vec3 finalAmbient=vAmbientColor;finalAmbient*=surfaceAlbedo.rgb;vec3 finalEmissive=vEmissiveColor;
#ifdef EMISSIVE
vec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;
#ifdef GAMMAEMISSIVE
finalEmissive*=toLinearSpace(emissiveColorTex.rgb);
#else
finalEmissive*=emissiveColorTex.rgb;
#endif
finalEmissive*= vEmissiveInfos.y;
#endif
finalEmissive*=vLightingIntensity.y;
#ifdef AMBIENT
vec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);
#else
vec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;
#endif
finalAmbient*=aoOut.ambientOcclusionColor;finalDiffuse*=ambientOcclusionForDirectDiffuse;
`;ji.IncludesShadersStore[vR]=RR;const a4={name:vR,shader:RR},MR="pbrBlockFinalColorComposition",wR=`vec4 finalColor=vec4(
#ifndef UNLIT
#ifdef REFLECTION
finalIrradiance +
#endif
#ifdef SPECULARTERM
finalSpecularScaled +
#endif
#ifdef SHEEN
finalSheenScaled +
#endif
#ifdef CLEARCOAT
finalClearCoatScaled +
#endif
#ifdef REFLECTION
finalRadianceScaled +
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled +
#endif
#ifdef CLEARCOAT
clearcoatOut.finalClearCoatRadianceScaled +
#endif
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction +
#endif
#endif
finalAmbient +
finalDiffuse,
alpha);
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
finalColor.rgb*=lightmapColor.rgb;
#else
finalColor.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
finalColor.rgb+=finalEmissive;
#define CUSTOM_FRAGMENT_BEFORE_FOG
finalColor=max(finalColor,0.0);
`;ji.IncludesShadersStore[MR]=wR;const x4={name:MR,shader:wR},LR="logDepthFragment",kR=`#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`;ji.IncludesShadersStore[LR]=kR;const l4={name:LR,shader:kR},UR="fogFragment",GR=`#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`;ji.IncludesShadersStore[UR]=GR;const h4={name:UR,shader:GR},zR="pbrBlockImageProcessing",WR=`#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)
#if !defined(SKIPFINALCOLORCLAMP)
finalColor.rgb=clamp(finalColor.rgb,0.,30.0);
#endif
#else
finalColor=applyImageProcessing(finalColor);
#endif
finalColor.a*=visibility;
#ifdef PREMULTIPLYALPHA
finalColor.rgb*=finalColor.a;
#endif
`;ji.IncludesShadersStore[zR]=WR;const c4={name:zR,shader:WR},HR="oitFragment",XR=`#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);return;}
#endif
`;ji.IncludesShadersStore[HR]=XR;const u4={name:HR,shader:XR},YR="pbrDebug",KR=`#if DEBUGMODE>0
if (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {
#if DEBUGMODE==1
gl_FragColor.rgb=vPositionW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==2 && defined(NORMAL)
gl_FragColor.rgb=vNormalW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==5
gl_FragColor.rgb=normalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==6 && defined(MAINUV1)
gl_FragColor.rgb=vec3(vMainUV1,0.0);
#elif DEBUGMODE==7 && defined(MAINUV2)
gl_FragColor.rgb=vec3(vMainUV2,0.0);
#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==10 && defined(CLEARCOAT)
gl_FragColor.rgb=clearcoatOut.clearCoatNormalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==11 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicNormal;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==12 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicTangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==13 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicBitangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==20 && defined(ALBEDO)
gl_FragColor.rgb=albedoTexture.rgb;
#ifndef GAMMAALBEDO
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==21 && defined(AMBIENT)
gl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;
#elif DEBUGMODE==22 && defined(OPACITY)
gl_FragColor.rgb=opacityMap.rgb;
#elif DEBUGMODE==23 && defined(EMISSIVE)
gl_FragColor.rgb=emissiveColorTex.rgb;
#ifndef GAMMAEMISSIVE
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==24 && defined(LIGHTMAP)
gl_FragColor.rgb=lightmapColor.rgb;
#ifndef GAMMALIGHTMAP
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;
#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);
#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
gl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;
#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)
gl_FragColor.rgb=sheenOut.sheenMapData.rgb;
#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)
gl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;
#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)
gl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;
#elif DEBUGMODE==32 && defined(BUMP)
gl_FragColor.rgb=texture2D(bumpSampler,vBumpUV).rgb;
#elif DEBUGMODE==40 && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==41 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)
gl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==50
gl_FragColor.rgb=diffuseBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==51 && defined(SPECULARTERM)
gl_FragColor.rgb=specularBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==52 && defined(CLEARCOAT)
gl_FragColor.rgb=clearCoatBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==53 && defined(SHEEN)
gl_FragColor.rgb=sheenBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==54 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==60
gl_FragColor.rgb=surfaceAlbedo.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==61
gl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);
#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.metallicF0;
#elif DEBUGMODE==63
gl_FragColor.rgb=vec3(roughness);
#elif DEBUGMODE==64
gl_FragColor.rgb=vec3(alphaG);
#elif DEBUGMODE==65
gl_FragColor.rgb=vec3(NdotV);
#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
gl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==67 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);
#elif DEBUGMODE==68 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);
#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)
gl_FragColor.rgb=subSurfaceOut.transmittance;
#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.refractionTransmittance;
#elif DEBUGMODE==72
gl_FragColor.rgb=vec3(microSurface);
#elif DEBUGMODE==73
gl_FragColor.rgb=vAlbedoColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==74 && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=vReflectivityColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==75
gl_FragColor.rgb=vEmissiveColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)
gl_FragColor.rgb=vec3(seo);
#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION)
gl_FragColor.rgb=vec3(eho);
#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)
gl_FragColor.rgb=vec3(energyConservationFactor);
#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=specularEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)
gl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==86 && defined(ALPHABLEND)
gl_FragColor.rgb=vec3(luminanceOverAlpha);
#elif DEBUGMODE==87
gl_FragColor.rgb=vec3(alpha);
#elif DEBUGMODE==88 && defined(ALBEDO)
gl_FragColor.rgb=vec3(albedoTexture.a);
#else
float stripeWidth=30.;float stripePos=floor((gl_FragCoord.x+gl_FragCoord.y)/stripeWidth);float whichColor=mod(stripePos,2.);vec3 color1=vec3(.6,.2,.2);vec3 color2=vec3(.3,.1,.1);gl_FragColor.rgb=mix(color1,color2,whichColor);
#endif
gl_FragColor.rgb*=vDebugMode.y;
#ifdef DEBUGMODE_NORMALIZE
gl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;
#endif
#ifdef DEBUGMODE_GAMMA
gl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);
#endif
gl_FragColor.a=1.0;
#ifdef PREPASS
gl_FragData[0]=toLinearSpace(gl_FragColor); 
gl_FragData[1]=vec4(0.,0.,0.,0.); 
#endif
#ifdef DEBUGMODE_FORCERETURN
return;
#endif
}
#endif
`;ji.IncludesShadersStore[YR]=KR;const p4={name:YR,shader:KR},jR="pbrPixelShader",qR=`#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#extension GL_OES_standard_derivatives : enable
#endif
#ifdef LODBASEDMICROSFURACE
#extension GL_EXT_shader_texture_lod : enable
#endif
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
precision highp float;
#include<oitDeclaration>
#ifndef FROMLINEARSPACE
#define FROMLINEARSPACE
#endif
#include<__decl__pbrFragment>
#include<pbrFragmentExtraDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<pbrFragmentSamplersDeclaration>
#include<imageProcessingDeclaration>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#include<helperFunctions>
#include<subSurfaceScatteringFunctions>
#include<importanceSampling>
#include<pbrHelperFunctions>
#include<imageProcessingFunctions>
#include<shadowsFragmentFunctions>
#include<harmonicsFunctions>
#include<pbrDirectLightingSetupFunctions>
#include<pbrDirectLightingFalloffFunctions>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
#include<pbrDirectLightingFunctions>
#include<pbrIBLFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#ifdef REFLECTION
#include<reflectionFunction>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
#include<pbrBlockAlbedoOpacity>
#include<pbrBlockReflectivity>
#include<pbrBlockAmbientOcclusion>
#include<pbrBlockAlphaFresnel>
#include<pbrBlockAnisotropic>
#include<pbrBlockReflection>
#include<pbrBlockSheen>
#include<pbrBlockClearcoat>
#include<pbrBlockIridescence>
#include<pbrBlockSubSurface>
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#include<pbrBlockNormalGeometric>
#include<bumpFragment>
#include<pbrBlockNormalFinal>
albedoOpacityOutParams albedoOpacityOut;
#ifdef ALBEDO
vec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#endif
#ifdef DECAL
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#endif
albedoOpacityBlock(
vAlbedoColor,
#ifdef ALBEDO
albedoTexture,
vAlbedoInfos,
#endif
#ifdef OPACITY
opacityMap,
vOpacityInfos,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
#ifdef DECAL
decalColor,
vDecalInfos,
#endif
albedoOpacityOut
);vec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;float alpha=albedoOpacityOut.alpha;
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
#include<depthPrePass>
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
ambientOcclusionOutParams aoOut;
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;
#endif
ambientOcclusionBlock(
#ifdef AMBIENT
ambientOcclusionColorMap,
vAmbientInfos,
#endif
aoOut
);
#include<pbrBlockLightmapInit>
#ifdef UNLIT
vec3 diffuseBase=vec3(1.,1.,1.);
#else
vec3 baseColor=surfaceAlbedo;reflectivityOutParams reflectivityOut;
#if defined(REFLECTIVITY)
vec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);vec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;
#ifndef METALLICWORKFLOW
#ifdef REFLECTIVITY_GAMMA
surfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);
#endif
surfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;
#endif
#endif
#if defined(MICROSURFACEMAP)
vec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;
#endif
#ifdef METALLICWORKFLOW
vec4 metallicReflectanceFactors=vMetallicReflectanceFactors;
#ifdef REFLECTANCE
vec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);
#ifdef REFLECTANCE_GAMMA
reflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);
#endif
metallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;
#endif
#ifdef METALLIC_REFLECTANCE
vec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);
#ifdef METALLIC_REFLECTANCE_GAMMA
metallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);
#endif
#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY
metallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;
#endif
metallicReflectanceFactors*=metallicReflectanceFactorsMap.a;
#endif
#endif
reflectivityBlock(
vReflectivityColor,
#ifdef METALLICWORKFLOW
surfaceAlbedo,
metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
vReflectivityInfos,
surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor,
#endif
#ifdef MICROSURFACEMAP
microSurfaceTexel,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
reflectivityOut
);float microSurface=reflectivityOut.microSurface;float roughness=reflectivityOut.roughness;
#ifdef METALLICWORKFLOW
surfaceAlbedo=reflectivityOut.surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;
#endif
#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
alphaFresnelOutParams alphaFresnelOut;alphaFresnelBlock(
normalW,
viewDirectionW,
alpha,
microSurface,
alphaFresnelOut
);alpha=alphaFresnelOut.alpha;
#endif
#endif
#include<pbrBlockGeometryInfo>
#ifdef ANISOTROPIC
anisotropicOutParams anisotropicOut;
#ifdef ANISOTROPIC_TEXTURE
vec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;
#endif
anisotropicBlock(
vAnisotropy,
roughness,
#ifdef ANISOTROPIC_TEXTURE
anisotropyMapData,
#endif
TBN,
normalW,
viewDirectionW,
anisotropicOut
);
#endif
#ifdef REFLECTION
reflectionOutParams reflectionOut;
#ifndef USE_CUSTOM_REFLECTION
reflectionBlock(
vPositionW,
normalW,
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
reflectionSampler,
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
reflectionOut
);
#else
#define CUSTOM_REFLECTION
#endif
#endif
#include<pbrBlockReflectance0>
#ifdef SHEEN
sheenOutParams sheenOut;
#ifdef SHEEN_TEXTURE
vec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);
#endif
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;
#endif
sheenBlock(
vSheenColor,
#ifdef SHEEN_ROUGHNESS
vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
sheenMapRoughnessData,
#endif
#endif
roughness,
#ifdef SHEEN_TEXTURE
sheenMapData,
vSheenInfos.y,
#endif
reflectance,
#ifdef SHEEN_LINKWITHALBEDO
baseColor,
surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
NdotV,
environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
AARoughnessFactors,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
reflectionOut.reflectionCoords,
NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
eho,
#endif
#endif
sheenOut
);
#ifdef SHEEN_LINKWITHALBEDO
surfaceAlbedo=sheenOut.surfaceAlbedo;
#endif
#endif
#ifdef CLEARCOAT
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;
#endif
#endif
#ifdef IRIDESCENCE
iridescenceOutParams iridescenceOut;
#ifdef IRIDESCENCE_TEXTURE
vec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
vec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;
#endif
iridescenceBlock(
vIridescenceParams,
NdotV,
specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#endif
iridescenceOut
);float iridescenceIntensity=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;
#endif
clearcoatOutParams clearcoatOut;
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);
#endif
#ifdef CLEARCOAT_BUMP
vec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);
#endif
clearcoatBlock(
vPositionW,
geometricNormalW,
viewDirectionW,
vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
clearCoatMapRoughnessData,
#endif
specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
vClearCoatTintParams,
clearCoatColorAtDistance,
vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
vClearCoatBumpInfos,
clearCoatBumpMapData,
vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
vTBN,
#else
vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
faceNormal,
#endif
#ifdef REFLECTION
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
(gl_FrontFacing ? 1. : -1.),
#endif
clearcoatOut
);
#else
clearcoatOut.specularEnvironmentR0=specularEnvironmentR0;
#endif
#include<pbrBlockReflectance>
subSurfaceOutParams subSurfaceOut;
#ifdef SUBSURFACE
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
vec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
vec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);
#endif
subSurfaceBlock(
vSubSurfaceIntensity,
vThicknessParam,
vTintColor,
normalW,
specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionOut.irradianceVector,
#endif
#if defined(REALTIME_FILTERING)
reflectionSampler,
vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
vPositionW,
viewDirectionW,
view,
vRefractionInfos,
refractionMatrix,
vRefractionMicrosurfaceInfos,
vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
roughness,
#endif
alphaG,
refractionSampler,
#ifndef LODBASEDMICROSFURACE
refractionSamplerLow,
refractionSamplerHigh,
#endif
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
vRefractionPosition,
vRefractionSize,
#endif
#ifdef SS_DISPERSION
dispersion,
#endif
#endif
#ifdef SS_TRANSLUCENCY
vDiffusionDistance,
#endif
subSurfaceOut
);
#ifdef SS_REFRACTION
surfaceAlbedo=subSurfaceOut.surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha=subSurfaceOut.alpha;
#endif
#endif
#else
subSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;
#endif
#include<pbrBlockDirectLighting>
#include<lightFragment>[0..maxSimultaneousLights]
#include<pbrBlockFinalLitComponents>
#endif 
#include<pbrBlockFinalUnlitComponents>
#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION
#include<pbrBlockFinalColorComposition>
#include<logDepthFragment>
#include<fogFragment>(color,finalColor)
#include<pbrBlockImageProcessing>
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_ALBEDO_SQRT
vec3 sqAlbedo=sqrt(surfaceAlbedo); 
#endif
#ifdef PREPASS_IRRADIANCE
vec3 irradiance=finalDiffuse;
#ifndef UNLIT
#ifdef REFLECTION
irradiance+=finalIrradiance;
#endif
#endif
#ifdef SS_SCATTERING
gl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); 
irradiance/=sqAlbedo;
#else
gl_FragData[0]=finalColor; 
float scatteringDiffusionProfile=255.;
#endif
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); 
#else
gl_FragData[0]=vec4(finalColor.rgb,finalColor.a);
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); 
#else
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); 
#endif
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#ifndef UNLIT
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularEnvironmentR0,microSurface)*writeGeometryInfo;
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=finalColor;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {frontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);} else {backColor+=finalColor;}
#endif
#include<pbrDebug>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;ji.ShadersStore[jR]=qR;const _4={name:jR,shader:qR},$R="decalVertexDeclaration",rI=`#ifdef DECAL
uniform vec4 vDecalInfos;uniform mat4 decalMatrix;
#endif
`;ji.IncludesShadersStore[$R]=rI;const T4={name:$R,shader:rI},nI="pbrVertexDeclaration",aI=`uniform mat4 view;uniform mat4 viewProjection;
#ifdef ALBEDO
uniform mat4 albedoMatrix;uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;uniform vec4 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;
#endif
#ifdef REFLECTIVITY 
uniform vec3 vReflectivityInfos;uniform mat4 reflectivityMatrix;
#endif
#ifdef METALLIC_REFLECTANCE
uniform vec2 vMetallicReflectanceInfos;uniform mat4 metallicReflectanceMatrix;
#endif
#ifdef REFLECTANCE
uniform vec2 vReflectanceInfos;uniform mat4 reflectanceMatrix;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;uniform mat4 microSurfaceSamplerMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform mat4 bumpMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;
#endif
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#ifdef IRIDESCENCE
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
#endif
#ifdef NORMAL
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;uniform mat4 detailMatrix;
#endif
#include<decalVertexDeclaration>
#define ADDITIONAL_VERTEX_DECLARATION
`;ji.IncludesShadersStore[nI]=aI;const v4={name:nI,shader:aI},xI="uvAttributeDeclaration",lI=`#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;ji.IncludesShadersStore[xI]=lI;const R4={name:xI,shader:lI},hI="bakedVertexAnimationDeclaration",cI=`#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}
#endif
`;ji.IncludesShadersStore[hI]=cI;const M4={name:hI,shader:cI},uI="prePassVertexDeclaration",pI=`#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;
#endif
#endif
`;ji.IncludesShadersStore[uI]=pI;const w4={name:uI,shader:pI},_I="samplerVertexDeclaration",TI=`#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;ji.IncludesShadersStore[_I]=TI;const L4={name:_I,shader:TI},vI="bumpVertexDeclaration",RI=`#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;ji.IncludesShadersStore[vI]=RI;const k4={name:vI,shader:RI},MI="fogVertexDeclaration",wI=`#ifdef FOG
varying vec3 vFogDistance;
#endif
`;ji.IncludesShadersStore[MI]=wI;const U4={name:MI,shader:wI},LI="lightVxFragmentDeclaration",kI=`#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`;ji.IncludesShadersStore[LI]=kI;const G4={name:LI,shader:kI},UI="lightVxUboDeclaration",GI=`#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;ji.IncludesShadersStore[UI]=GI;const z4={name:UI,shader:GI},zI="morphTargetsVertexGlobalDeclaration",WI=`#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}
#endif
#endif
`;ji.IncludesShadersStore[zI]=WI;const W4={name:zI,shader:WI},HI="morphTargetsVertexDeclaration",XI=`#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#elif {X}==0
uniform int morphTargetCount;
#endif
#endif
`;ji.IncludesShadersStore[HI]=XI;const X4={name:HI,shader:XI},YI="morphTargetsVertexGlobal",KI=`#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;ji.IncludesShadersStore[YI]=KI;const Y4={name:YI,shader:KI},jI="morphTargetsVertex",qI=`#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
#if {X}==0
for (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (i>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];
#endif
}
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;ji.IncludesShadersStore[jI]=qI;const K4={name:jI,shader:qI},$I="bakedVertexAnimation",r1=`#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;}
#endif
`;ji.IncludesShadersStore[$I]=r1;const j4={name:$I,shader:r1},n1="prePassVertex",a1=`#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;ji.IncludesShadersStore[n1]=a1;const q4={name:n1,shader:a1},x1="uvVariableDeclaration",l1=`#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;ji.IncludesShadersStore[x1]=l1;const $4={name:x1,shader:l1},h1="samplerVertexImplementation",c1=`#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}
#ifdef UV2
else if (v_INFONAME_==1.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}
#endif
#endif
`;ji.IncludesShadersStore[h1]=c1;const r5={name:h1,shader:c1},u1="bumpVertex",_1=`#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;ji.IncludesShadersStore[u1]=_1;const n5={name:u1,shader:_1},T1="fogVertex",v1=`#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`;ji.IncludesShadersStore[T1]=v1;const a5={name:T1,shader:v1},R1="shadowsVertex",M1=`#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;ji.IncludesShadersStore[R1]=M1;const x5={name:R1,shader:M1},w1="vertexColorMixing",L1=`#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;ji.IncludesShadersStore[w1]=L1;const l5={name:w1,shader:L1},k1="logDepthVertex",U1=`#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`;ji.IncludesShadersStore[k1]=U1;const h5={name:k1,shader:U1},G1="pbrVertexShader",z1=`precision highp float;
#include<__decl__pbrVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#include<mainUVVaryingDeclaration>[1..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)
#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)
#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
#ifdef CLEARCOAT
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)
#endif
#ifdef SUBSURFACE
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)
#endif
varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#include<harmonicsFunctions>
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vPositionW=vec3(worldPos);
#include<prePassVertex>
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
vec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
vEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#if DEBUGMODE>0
vClipSpacePosition=gl_Position;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#ifdef CLEARCOAT
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)
#endif
#ifdef SHEEN
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.z)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)
#endif
#ifdef SUBSURFACE
#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)
#endif
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;ji.ShadersStore[G1]=z1;const c5={name:G1,shader:z1};class jN extends Hh{constructor(){super(...arguments),this.CLEARCOAT=!1,this.CLEARCOAT_DEFAULTIOR=!1,this.CLEARCOAT_TEXTURE=!1,this.CLEARCOAT_TEXTURE_ROUGHNESS=!1,this.CLEARCOAT_TEXTUREDIRECTUV=0,this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV=0,this.CLEARCOAT_BUMP=!1,this.CLEARCOAT_BUMPDIRECTUV=0,this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,this.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL=!1,this.CLEARCOAT_REMAP_F0=!1,this.CLEARCOAT_TINT=!1,this.CLEARCOAT_TINT_TEXTURE=!1,this.CLEARCOAT_TINT_TEXTUREDIRECTUV=0,this.CLEARCOAT_TINT_GAMMATEXTURE=!1}}class nx extends K2{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(p,_=!0){super(p,"PBRClearCoat",100,new jN,_),this._isEnabled=!1,this.isEnabled=!1,this.intensity=1,this.roughness=0,this._indexOfRefraction=nx._DefaultIndexOfRefraction,this.indexOfRefraction=nx._DefaultIndexOfRefraction,this._texture=null,this.texture=null,this._useRoughnessFromMainTexture=!0,this.useRoughnessFromMainTexture=!0,this._textureRoughness=null,this.textureRoughness=null,this._remapF0OnInterfaceChange=!0,this.remapF0OnInterfaceChange=!0,this._bumpTexture=null,this.bumpTexture=null,this._isTintEnabled=!1,this.isTintEnabled=!1,this.tintColor=Rs.White(),this.tintColorAtDistance=1,this.tintThickness=1,this._tintTexture=null,this.tintTexture=null,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1]}isReadyForSubMesh(p,_,E){if(!this._isEnabled)return!0;const I=this._material._disableBumpMap;return!(p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ms.ClearCoatTextureEnabled&&!this._texture.isReadyOrNotBlocking()||this._textureRoughness&&Ms.ClearCoatTextureEnabled&&!this._textureRoughness.isReadyOrNotBlocking()||E.getCaps().standardDerivatives&&this._bumpTexture&&Ms.ClearCoatBumpTextureEnabled&&!I&&!this._bumpTexture.isReady()||this._isTintEnabled&&this._tintTexture&&Ms.ClearCoatTintTextureEnabled&&!this._tintTexture.isReadyOrNotBlocking()))}prepareDefinesBeforeAttributes(p,_){this._isEnabled?(p.CLEARCOAT=!0,p.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE=this._useRoughnessFromMainTexture,p.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL=this._texture!==null&&this._texture._texture===this._textureRoughness?._texture&&this._texture.checkTransformsAreIdentical(this._textureRoughness),p.CLEARCOAT_REMAP_F0=this._remapF0OnInterfaceChange,p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ms.ClearCoatTextureEnabled?lr.PrepareDefinesForMergedUV(this._texture,p,"CLEARCOAT_TEXTURE"):p.CLEARCOAT_TEXTURE=!1,this._textureRoughness&&Ms.ClearCoatTextureEnabled?lr.PrepareDefinesForMergedUV(this._textureRoughness,p,"CLEARCOAT_TEXTURE_ROUGHNESS"):p.CLEARCOAT_TEXTURE_ROUGHNESS=!1,this._bumpTexture&&Ms.ClearCoatBumpTextureEnabled?lr.PrepareDefinesForMergedUV(this._bumpTexture,p,"CLEARCOAT_BUMP"):p.CLEARCOAT_BUMP=!1,p.CLEARCOAT_DEFAULTIOR=this._indexOfRefraction===nx._DefaultIndexOfRefraction,this._isTintEnabled?(p.CLEARCOAT_TINT=!0,this._tintTexture&&Ms.ClearCoatTintTextureEnabled?(lr.PrepareDefinesForMergedUV(this._tintTexture,p,"CLEARCOAT_TINT_TEXTURE"),p.CLEARCOAT_TINT_GAMMATEXTURE=this._tintTexture.gammaSpace):p.CLEARCOAT_TINT_TEXTURE=!1):(p.CLEARCOAT_TINT=!1,p.CLEARCOAT_TINT_TEXTURE=!1))):(p.CLEARCOAT=!1,p.CLEARCOAT_TEXTURE=!1,p.CLEARCOAT_TEXTURE_ROUGHNESS=!1,p.CLEARCOAT_BUMP=!1,p.CLEARCOAT_TINT=!1,p.CLEARCOAT_TINT_TEXTURE=!1,p.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,p.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL=!1,p.CLEARCOAT_DEFAULTIOR=!1,p.CLEARCOAT_TEXTUREDIRECTUV=0,p.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV=0,p.CLEARCOAT_BUMPDIRECTUV=0,p.CLEARCOAT_REMAP_F0=!1,p.CLEARCOAT_TINT_TEXTUREDIRECTUV=0,p.CLEARCOAT_TINT_GAMMATEXTURE=!1)}bindForSubMesh(p,_,E,I){if(!this._isEnabled)return;const Z=I.materialDefines,re=this._material.isFrozen,ae=this._material._disableBumpMap,he=this._material._invertNormalMapX,_e=this._material._invertNormalMapY,ve=Z.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;if(!p.useUbo||!re||!p.isSync){ve&&Ms.ClearCoatTextureEnabled?(p.updateFloat4("vClearCoatInfos",this._texture.coordinatesIndex,this._texture.level,-1,-1),lr.BindTextureMatrix(this._texture,p,"clearCoat")):(this._texture||this._textureRoughness)&&Ms.ClearCoatTextureEnabled&&(p.updateFloat4("vClearCoatInfos",this._texture?.coordinatesIndex??0,this._texture?.level??0,this._textureRoughness?.coordinatesIndex??0,this._textureRoughness?.level??0),this._texture&&lr.BindTextureMatrix(this._texture,p,"clearCoat"),this._textureRoughness&&!ve&&!Z.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE&&lr.BindTextureMatrix(this._textureRoughness,p,"clearCoatRoughness")),this._bumpTexture&&E.getCaps().standardDerivatives&&Ms.ClearCoatTextureEnabled&&!ae&&(p.updateFloat2("vClearCoatBumpInfos",this._bumpTexture.coordinatesIndex,this._bumpTexture.level),lr.BindTextureMatrix(this._bumpTexture,p,"clearCoatBump"),_._mirroredCameraPosition?p.updateFloat2("vClearCoatTangentSpaceParams",he?1:-1,_e?1:-1):p.updateFloat2("vClearCoatTangentSpaceParams",he?-1:1,_e?-1:1)),this._tintTexture&&Ms.ClearCoatTintTextureEnabled&&(p.updateFloat2("vClearCoatTintInfos",this._tintTexture.coordinatesIndex,this._tintTexture.level),lr.BindTextureMatrix(this._tintTexture,p,"clearCoatTint")),p.updateFloat2("vClearCoatParams",this.intensity,this.roughness);const Le=1-this._indexOfRefraction,ze=1+this._indexOfRefraction,He=Math.pow(-Le/ze,2),xt=1/this._indexOfRefraction;p.updateFloat4("vClearCoatRefractionParams",He,xt,Le,ze),this._isTintEnabled&&(p.updateFloat4("vClearCoatTintParams",this.tintColor.r,this.tintColor.g,this.tintColor.b,Math.max(1e-5,this.tintThickness)),p.updateFloat("clearCoatColorAtDistance",Math.max(1e-5,this.tintColorAtDistance)))}_.texturesEnabled&&(this._texture&&Ms.ClearCoatTextureEnabled&&p.setTexture("clearCoatSampler",this._texture),this._textureRoughness&&!ve&&!Z.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE&&Ms.ClearCoatTextureEnabled&&p.setTexture("clearCoatRoughnessSampler",this._textureRoughness),this._bumpTexture&&E.getCaps().standardDerivatives&&Ms.ClearCoatBumpTextureEnabled&&!ae&&p.setTexture("clearCoatBumpSampler",this._bumpTexture),this._isTintEnabled&&this._tintTexture&&Ms.ClearCoatTintTextureEnabled&&p.setTexture("clearCoatTintSampler",this._tintTexture))}hasTexture(p){return this._texture===p||this._textureRoughness===p||this._bumpTexture===p||this._tintTexture===p}getActiveTextures(p){this._texture&&p.push(this._texture),this._textureRoughness&&p.push(this._textureRoughness),this._bumpTexture&&p.push(this._bumpTexture),this._tintTexture&&p.push(this._tintTexture)}getAnimatables(p){this._texture&&this._texture.animations&&this._texture.animations.length>0&&p.push(this._texture),this._textureRoughness&&this._textureRoughness.animations&&this._textureRoughness.animations.length>0&&p.push(this._textureRoughness),this._bumpTexture&&this._bumpTexture.animations&&this._bumpTexture.animations.length>0&&p.push(this._bumpTexture),this._tintTexture&&this._tintTexture.animations&&this._tintTexture.animations.length>0&&p.push(this._tintTexture)}dispose(p){p&&(this._texture?.dispose(),this._textureRoughness?.dispose(),this._bumpTexture?.dispose(),this._tintTexture?.dispose())}getClassName(){return"PBRClearCoatConfiguration"}addFallbacks(p,_,E){return p.CLEARCOAT_BUMP&&_.addFallback(E++,"CLEARCOAT_BUMP"),p.CLEARCOAT_TINT&&_.addFallback(E++,"CLEARCOAT_TINT"),p.CLEARCOAT&&_.addFallback(E++,"CLEARCOAT"),E}getSamplers(p){p.push("clearCoatSampler","clearCoatRoughnessSampler","clearCoatBumpSampler","clearCoatTintSampler")}getUniforms(){return{ubo:[{name:"vClearCoatParams",size:2,type:"vec2"},{name:"vClearCoatRefractionParams",size:4,type:"vec4"},{name:"vClearCoatInfos",size:4,type:"vec4"},{name:"clearCoatMatrix",size:16,type:"mat4"},{name:"clearCoatRoughnessMatrix",size:16,type:"mat4"},{name:"vClearCoatBumpInfos",size:2,type:"vec2"},{name:"vClearCoatTangentSpaceParams",size:2,type:"vec2"},{name:"clearCoatBumpMatrix",size:16,type:"mat4"},{name:"vClearCoatTintParams",size:4,type:"vec4"},{name:"clearCoatColorAtDistance",size:1,type:"float"},{name:"vClearCoatTintInfos",size:2,type:"vec2"},{name:"clearCoatTintMatrix",size:16,type:"mat4"}]}}}nx._DefaultIndexOfRefraction=1.5,Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],nx.prototype,"isEnabled",void 0),Rt([Ut()],nx.prototype,"intensity",void 0),Rt([Ut()],nx.prototype,"roughness",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],nx.prototype,"indexOfRefraction",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],nx.prototype,"texture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],nx.prototype,"useRoughnessFromMainTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],nx.prototype,"textureRoughness",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],nx.prototype,"remapF0OnInterfaceChange",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],nx.prototype,"bumpTexture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],nx.prototype,"isTintEnabled",void 0),Rt([Ya()],nx.prototype,"tintColor",void 0),Rt([Ut()],nx.prototype,"tintColorAtDistance",void 0),Rt([Ut()],nx.prototype,"tintThickness",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],nx.prototype,"tintTexture",void 0);class qN extends Hh{constructor(){super(...arguments),this.IRIDESCENCE=!1,this.IRIDESCENCE_TEXTURE=!1,this.IRIDESCENCE_TEXTUREDIRECTUV=0,this.IRIDESCENCE_THICKNESS_TEXTURE=!1,this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV=0,this.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE=!1}}class $x extends K2{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(p,_=!0){super(p,"PBRIridescence",110,new qN,_),this._isEnabled=!1,this.isEnabled=!1,this.intensity=1,this.minimumThickness=$x._DefaultMinimumThickness,this.maximumThickness=$x._DefaultMaximumThickness,this.indexOfRefraction=$x._DefaultIndexOfRefraction,this._texture=null,this.texture=null,this._thicknessTexture=null,this.thicknessTexture=null,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1]}isReadyForSubMesh(p,_){return this._isEnabled?!(p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ms.IridescenceTextureEnabled&&!this._texture.isReadyOrNotBlocking()||this._thicknessTexture&&Ms.IridescenceTextureEnabled&&!this._thicknessTexture.isReadyOrNotBlocking())):!0}prepareDefinesBeforeAttributes(p,_){this._isEnabled?(p.IRIDESCENCE=!0,p.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE=this._texture!==null&&this._texture._texture===this._thicknessTexture?._texture&&this._texture.checkTransformsAreIdentical(this._thicknessTexture),p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ms.IridescenceTextureEnabled?lr.PrepareDefinesForMergedUV(this._texture,p,"IRIDESCENCE_TEXTURE"):p.IRIDESCENCE_TEXTURE=!1,!p.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE&&this._thicknessTexture&&Ms.IridescenceTextureEnabled?lr.PrepareDefinesForMergedUV(this._thicknessTexture,p,"IRIDESCENCE_THICKNESS_TEXTURE"):p.IRIDESCENCE_THICKNESS_TEXTURE=!1)):(p.IRIDESCENCE=!1,p.IRIDESCENCE_TEXTURE=!1,p.IRIDESCENCE_THICKNESS_TEXTURE=!1,p.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE=!1,p.IRIDESCENCE_TEXTUREDIRECTUV=0,p.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV=0)}bindForSubMesh(p,_,E,I){if(!this._isEnabled)return;const Z=I.materialDefines,re=this._material.isFrozen,ae=Z.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE;(!p.useUbo||!re||!p.isSync)&&(ae&&Ms.IridescenceTextureEnabled?(p.updateFloat4("vIridescenceInfos",this._texture.coordinatesIndex,this._texture.level,-1,-1),lr.BindTextureMatrix(this._texture,p,"iridescence")):(this._texture||this._thicknessTexture)&&Ms.IridescenceTextureEnabled&&(p.updateFloat4("vIridescenceInfos",this._texture?.coordinatesIndex??0,this._texture?.level??0,this._thicknessTexture?.coordinatesIndex??0,this._thicknessTexture?.level??0),this._texture&&lr.BindTextureMatrix(this._texture,p,"iridescence"),this._thicknessTexture&&!ae&&!Z.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE&&lr.BindTextureMatrix(this._thicknessTexture,p,"iridescenceThickness")),p.updateFloat4("vIridescenceParams",this.intensity,this.indexOfRefraction,this.minimumThickness,this.maximumThickness)),_.texturesEnabled&&(this._texture&&Ms.IridescenceTextureEnabled&&p.setTexture("iridescenceSampler",this._texture),this._thicknessTexture&&!ae&&!Z.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE&&Ms.IridescenceTextureEnabled&&p.setTexture("iridescenceThicknessSampler",this._thicknessTexture))}hasTexture(p){return this._texture===p||this._thicknessTexture===p}getActiveTextures(p){this._texture&&p.push(this._texture),this._thicknessTexture&&p.push(this._thicknessTexture)}getAnimatables(p){this._texture&&this._texture.animations&&this._texture.animations.length>0&&p.push(this._texture),this._thicknessTexture&&this._thicknessTexture.animations&&this._thicknessTexture.animations.length>0&&p.push(this._thicknessTexture)}dispose(p){p&&(this._texture?.dispose(),this._thicknessTexture?.dispose())}getClassName(){return"PBRIridescenceConfiguration"}addFallbacks(p,_,E){return p.IRIDESCENCE&&_.addFallback(E++,"IRIDESCENCE"),E}getSamplers(p){p.push("iridescenceSampler","iridescenceThicknessSampler")}getUniforms(){return{ubo:[{name:"vIridescenceParams",size:4,type:"vec4"},{name:"vIridescenceInfos",size:4,type:"vec4"},{name:"iridescenceMatrix",size:16,type:"mat4"},{name:"iridescenceThicknessMatrix",size:16,type:"mat4"}]}}}$x._DefaultMinimumThickness=100,$x._DefaultMaximumThickness=400,$x._DefaultIndexOfRefraction=1.3,Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],$x.prototype,"isEnabled",void 0),Rt([Ut()],$x.prototype,"intensity",void 0),Rt([Ut()],$x.prototype,"minimumThickness",void 0),Rt([Ut()],$x.prototype,"maximumThickness",void 0),Rt([Ut()],$x.prototype,"indexOfRefraction",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],$x.prototype,"texture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],$x.prototype,"thicknessTexture",void 0);class $N extends Hh{constructor(){super(...arguments),this.ANISOTROPIC=!1,this.ANISOTROPIC_TEXTURE=!1,this.ANISOTROPIC_TEXTUREDIRECTUV=0,this.ANISOTROPIC_LEGACY=!1,this.MAINUV1=!1}}class ku extends K2{set angle(p){this.direction.x=Math.cos(p),this.direction.y=Math.sin(p)}get angle(){return Math.atan2(this.direction.y,this.direction.x)}_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}_markAllSubMeshesAsMiscDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsMiscDirty()}constructor(p,_=!0){super(p,"PBRAnisotropic",110,new $N,_),this._isEnabled=!1,this.isEnabled=!1,this.intensity=1,this.direction=new xr(1,0),this._texture=null,this.texture=null,this._legacy=!1,this.legacy=!1,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1],this._internalMarkAllSubMeshesAsMiscDirty=p._dirtyCallbacks[16]}isReadyForSubMesh(p,_){return this._isEnabled?!(p._areTexturesDirty&&_.texturesEnabled&&this._texture&&Ms.AnisotropicTextureEnabled&&!this._texture.isReadyOrNotBlocking()):!0}prepareDefinesBeforeAttributes(p,_,E){this._isEnabled?(p.ANISOTROPIC=this._isEnabled,this._isEnabled&&!E.isVerticesDataPresent(ut.TangentKind)&&(p._needUVs=!0,p.MAINUV1=!0),p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ms.AnisotropicTextureEnabled?lr.PrepareDefinesForMergedUV(this._texture,p,"ANISOTROPIC_TEXTURE"):p.ANISOTROPIC_TEXTURE=!1),p._areMiscDirty&&(p.ANISOTROPIC_LEGACY=this._legacy)):(p.ANISOTROPIC=!1,p.ANISOTROPIC_TEXTURE=!1,p.ANISOTROPIC_TEXTUREDIRECTUV=0,p.ANISOTROPIC_LEGACY=!1)}bindForSubMesh(p,_){if(!this._isEnabled)return;const E=this._material.isFrozen;(!p.useUbo||!E||!p.isSync)&&(this._texture&&Ms.AnisotropicTextureEnabled&&(p.updateFloat2("vAnisotropyInfos",this._texture.coordinatesIndex,this._texture.level),lr.BindTextureMatrix(this._texture,p,"anisotropy")),p.updateFloat3("vAnisotropy",this.direction.x,this.direction.y,this.intensity)),_.texturesEnabled&&this._texture&&Ms.AnisotropicTextureEnabled&&p.setTexture("anisotropySampler",this._texture)}hasTexture(p){return this._texture===p}getActiveTextures(p){this._texture&&p.push(this._texture)}getAnimatables(p){this._texture&&this._texture.animations&&this._texture.animations.length>0&&p.push(this._texture)}dispose(p){p&&this._texture&&this._texture.dispose()}getClassName(){return"PBRAnisotropicConfiguration"}addFallbacks(p,_,E){return p.ANISOTROPIC&&_.addFallback(E++,"ANISOTROPIC"),E}getSamplers(p){p.push("anisotropySampler")}getUniforms(){return{ubo:[{name:"vAnisotropy",size:3,type:"vec3"},{name:"vAnisotropyInfos",size:2,type:"vec2"},{name:"anisotropyMatrix",size:16,type:"mat4"}]}}parse(p,_,E){super.parse(p,_,E),p.legacy===void 0&&(this.legacy=!0)}}Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],ku.prototype,"isEnabled",void 0),Rt([Ut()],ku.prototype,"intensity",void 0),Rt([au()],ku.prototype,"direction",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],ku.prototype,"texture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsMiscDirty")],ku.prototype,"legacy",void 0);class rD extends Hh{constructor(){super(...arguments),this.SHEEN=!1,this.SHEEN_TEXTURE=!1,this.SHEEN_GAMMATEXTURE=!1,this.SHEEN_TEXTURE_ROUGHNESS=!1,this.SHEEN_TEXTUREDIRECTUV=0,this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV=0,this.SHEEN_LINKWITHALBEDO=!1,this.SHEEN_ROUGHNESS=!1,this.SHEEN_ALBEDOSCALING=!1,this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,this.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL=!1}}class Rl extends K2{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(p,_=!0){super(p,"Sheen",120,new rD,_),this._isEnabled=!1,this.isEnabled=!1,this._linkSheenWithAlbedo=!1,this.linkSheenWithAlbedo=!1,this.intensity=1,this.color=Rs.White(),this._texture=null,this.texture=null,this._useRoughnessFromMainTexture=!0,this.useRoughnessFromMainTexture=!0,this._roughness=null,this.roughness=null,this._textureRoughness=null,this.textureRoughness=null,this._albedoScaling=!1,this.albedoScaling=!1,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1]}isReadyForSubMesh(p,_){return this._isEnabled?!(p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ms.SheenTextureEnabled&&!this._texture.isReadyOrNotBlocking()||this._textureRoughness&&Ms.SheenTextureEnabled&&!this._textureRoughness.isReadyOrNotBlocking())):!0}prepareDefinesBeforeAttributes(p,_){this._isEnabled?(p.SHEEN=!0,p.SHEEN_LINKWITHALBEDO=this._linkSheenWithAlbedo,p.SHEEN_ROUGHNESS=this._roughness!==null,p.SHEEN_ALBEDOSCALING=this._albedoScaling,p.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE=this._useRoughnessFromMainTexture,p.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL=this._texture!==null&&this._texture._texture===this._textureRoughness?._texture&&this._texture.checkTransformsAreIdentical(this._textureRoughness),p._areTexturesDirty&&_.texturesEnabled&&(this._texture&&Ms.SheenTextureEnabled?(lr.PrepareDefinesForMergedUV(this._texture,p,"SHEEN_TEXTURE"),p.SHEEN_GAMMATEXTURE=this._texture.gammaSpace):p.SHEEN_TEXTURE=!1,this._textureRoughness&&Ms.SheenTextureEnabled?lr.PrepareDefinesForMergedUV(this._textureRoughness,p,"SHEEN_TEXTURE_ROUGHNESS"):p.SHEEN_TEXTURE_ROUGHNESS=!1)):(p.SHEEN=!1,p.SHEEN_TEXTURE=!1,p.SHEEN_TEXTURE_ROUGHNESS=!1,p.SHEEN_LINKWITHALBEDO=!1,p.SHEEN_ROUGHNESS=!1,p.SHEEN_ALBEDOSCALING=!1,p.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,p.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL=!1,p.SHEEN_GAMMATEXTURE=!1,p.SHEEN_TEXTUREDIRECTUV=0,p.SHEEN_TEXTURE_ROUGHNESSDIRECTUV=0)}bindForSubMesh(p,_,E,I){if(!this._isEnabled)return;const Z=I.materialDefines,re=this._material.isFrozen,ae=Z.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;(!p.useUbo||!re||!p.isSync)&&(ae&&Ms.SheenTextureEnabled?(p.updateFloat4("vSheenInfos",this._texture.coordinatesIndex,this._texture.level,-1,-1),lr.BindTextureMatrix(this._texture,p,"sheen")):(this._texture||this._textureRoughness)&&Ms.SheenTextureEnabled&&(p.updateFloat4("vSheenInfos",this._texture?.coordinatesIndex??0,this._texture?.level??0,this._textureRoughness?.coordinatesIndex??0,this._textureRoughness?.level??0),this._texture&&lr.BindTextureMatrix(this._texture,p,"sheen"),this._textureRoughness&&!ae&&!Z.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE&&lr.BindTextureMatrix(this._textureRoughness,p,"sheenRoughness")),p.updateFloat4("vSheenColor",this.color.r,this.color.g,this.color.b,this.intensity),this._roughness!==null&&p.updateFloat("vSheenRoughness",this._roughness)),_.texturesEnabled&&(this._texture&&Ms.SheenTextureEnabled&&p.setTexture("sheenSampler",this._texture),this._textureRoughness&&!ae&&!Z.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE&&Ms.SheenTextureEnabled&&p.setTexture("sheenRoughnessSampler",this._textureRoughness))}hasTexture(p){return this._texture===p||this._textureRoughness===p}getActiveTextures(p){this._texture&&p.push(this._texture),this._textureRoughness&&p.push(this._textureRoughness)}getAnimatables(p){this._texture&&this._texture.animations&&this._texture.animations.length>0&&p.push(this._texture),this._textureRoughness&&this._textureRoughness.animations&&this._textureRoughness.animations.length>0&&p.push(this._textureRoughness)}dispose(p){p&&(this._texture?.dispose(),this._textureRoughness?.dispose())}getClassName(){return"PBRSheenConfiguration"}addFallbacks(p,_,E){return p.SHEEN&&_.addFallback(E++,"SHEEN"),E}getSamplers(p){p.push("sheenSampler","sheenRoughnessSampler")}getUniforms(){return{ubo:[{name:"vSheenColor",size:4,type:"vec4"},{name:"vSheenRoughness",size:1,type:"float"},{name:"vSheenInfos",size:4,type:"vec4"},{name:"sheenMatrix",size:16,type:"mat4"},{name:"sheenRoughnessMatrix",size:16,type:"mat4"}]}}}Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Rl.prototype,"isEnabled",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Rl.prototype,"linkSheenWithAlbedo",void 0),Rt([Ut()],Rl.prototype,"intensity",void 0),Rt([Ya()],Rl.prototype,"color",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Rl.prototype,"texture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Rl.prototype,"useRoughnessFromMainTexture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Rl.prototype,"roughness",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Rl.prototype,"textureRoughness",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Rl.prototype,"albedoScaling",void 0);class nD extends Hh{constructor(){super(...arguments),this.SUBSURFACE=!1,this.SS_REFRACTION=!1,this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=!1,this.SS_TRANSLUCENCY=!1,this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=!1,this.SS_SCATTERING=!1,this.SS_DISPERSION=!1,this.SS_THICKNESSANDMASK_TEXTURE=!1,this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV=0,this.SS_HAS_THICKNESS=!1,this.SS_REFRACTIONINTENSITY_TEXTURE=!1,this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV=0,this.SS_TRANSLUCENCYINTENSITY_TEXTURE=!1,this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV=0,this.SS_REFRACTIONMAP_3D=!1,this.SS_REFRACTIONMAP_OPPOSITEZ=!1,this.SS_LODINREFRACTIONALPHA=!1,this.SS_GAMMAREFRACTION=!1,this.SS_RGBDREFRACTION=!1,this.SS_LINEARSPECULARREFRACTION=!1,this.SS_LINKREFRACTIONTOTRANSPARENCY=!1,this.SS_ALBEDOFORREFRACTIONTINT=!1,this.SS_ALBEDOFORTRANSLUCENCYTINT=!1,this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=!1,this.SS_USE_THICKNESS_AS_DEPTH=!1,this.SS_MASK_FROM_THICKNESS_TEXTURE=!1,this.SS_USE_GLTF_TEXTURES=!1}}class Ga extends K2{get scatteringDiffusionProfile(){return this._scene.subSurfaceConfiguration?this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex]:null}set scatteringDiffusionProfile(p){this._scene.enableSubSurfaceForPrePass()&&p&&(this._scatteringDiffusionProfileIndex=this._scene.subSurfaceConfiguration.addDiffusionProfile(p))}get volumeIndexOfRefraction(){return this._volumeIndexOfRefraction>=1?this._volumeIndexOfRefraction:this._indexOfRefraction}set volumeIndexOfRefraction(p){p>=1?this._volumeIndexOfRefraction=p:this._volumeIndexOfRefraction=-1}_markAllSubMeshesAsTexturesDirty(){this._enable(this._isRefractionEnabled||this._isTranslucencyEnabled||this._isScatteringEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}_markScenePrePassDirty(){this._internalMarkAllSubMeshesAsTexturesDirty(),this._internalMarkScenePrePassDirty()}constructor(p,_=!0){super(p,"PBRSubSurface",130,new nD,_),this._isRefractionEnabled=!1,this.isRefractionEnabled=!1,this._isTranslucencyEnabled=!1,this.isTranslucencyEnabled=!1,this._isDispersionEnabled=!1,this.isDispersionEnabled=!1,this._isScatteringEnabled=!1,this.isScatteringEnabled=!1,this._scatteringDiffusionProfileIndex=0,this.refractionIntensity=1,this.translucencyIntensity=1,this.useAlbedoToTintRefraction=!1,this.useAlbedoToTintTranslucency=!1,this._thicknessTexture=null,this.thicknessTexture=null,this._refractionTexture=null,this.refractionTexture=null,this._indexOfRefraction=1.5,this.indexOfRefraction=1.5,this._volumeIndexOfRefraction=-1,this._invertRefractionY=!1,this.invertRefractionY=!1,this._linkRefractionWithTransparency=!1,this.linkRefractionWithTransparency=!1,this.minimumThickness=0,this.maximumThickness=1,this.useThicknessAsDepth=!1,this.tintColor=Rs.White(),this.tintColorAtDistance=1,this.dispersion=0,this.diffusionDistance=Rs.White(),this._useMaskFromThicknessTexture=!1,this.useMaskFromThicknessTexture=!1,this._refractionIntensityTexture=null,this.refractionIntensityTexture=null,this._translucencyIntensityTexture=null,this.translucencyIntensityTexture=null,this._useGltfStyleTextures=!1,this.useGltfStyleTextures=!1,this._scene=p.getScene(),this.registerForExtraEvents=!0,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1],this._internalMarkScenePrePassDirty=p._dirtyCallbacks[32]}isReadyForSubMesh(p,_){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled)return!0;if(p._areTexturesDirty&&_.texturesEnabled){if(this._thicknessTexture&&Ms.ThicknessTextureEnabled&&!this._thicknessTexture.isReadyOrNotBlocking())return!1;const E=this._getRefractionTexture(_);if(E&&Ms.RefractionTextureEnabled&&!E.isReadyOrNotBlocking())return!1}return!0}prepareDefinesBeforeAttributes(p,_){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled){p.SUBSURFACE=!1,p.SS_DISPERSION=!1,p.SS_TRANSLUCENCY=!1,p.SS_SCATTERING=!1,p.SS_REFRACTION=!1,p.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=!1,p.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=!1,p.SS_THICKNESSANDMASK_TEXTURE=!1,p.SS_THICKNESSANDMASK_TEXTUREDIRECTUV=0,p.SS_HAS_THICKNESS=!1,p.SS_REFRACTIONINTENSITY_TEXTURE=!1,p.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV=0,p.SS_TRANSLUCENCYINTENSITY_TEXTURE=!1,p.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV=0,p.SS_REFRACTIONMAP_3D=!1,p.SS_REFRACTIONMAP_OPPOSITEZ=!1,p.SS_LODINREFRACTIONALPHA=!1,p.SS_GAMMAREFRACTION=!1,p.SS_RGBDREFRACTION=!1,p.SS_LINEARSPECULARREFRACTION=!1,p.SS_LINKREFRACTIONTOTRANSPARENCY=!1,p.SS_ALBEDOFORREFRACTIONTINT=!1,p.SS_ALBEDOFORTRANSLUCENCYTINT=!1,p.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=!1,p.SS_USE_THICKNESS_AS_DEPTH=!1,p.SS_MASK_FROM_THICKNESS_TEXTURE=!1,p.SS_USE_GLTF_TEXTURES=!1;return}if(p._areTexturesDirty){p.SUBSURFACE=!0,p.SS_DISPERSION=this._isDispersionEnabled,p.SS_TRANSLUCENCY=this._isTranslucencyEnabled,p.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=!1,p.SS_SCATTERING=this._isScatteringEnabled,p.SS_THICKNESSANDMASK_TEXTURE=!1,p.SS_REFRACTIONINTENSITY_TEXTURE=!1,p.SS_TRANSLUCENCYINTENSITY_TEXTURE=!1,p.SS_HAS_THICKNESS=!1,p.SS_MASK_FROM_THICKNESS_TEXTURE=!1,p.SS_USE_GLTF_TEXTURES=!1,p.SS_REFRACTION=!1,p.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=!1,p.SS_REFRACTIONMAP_3D=!1,p.SS_GAMMAREFRACTION=!1,p.SS_RGBDREFRACTION=!1,p.SS_LINEARSPECULARREFRACTION=!1,p.SS_REFRACTIONMAP_OPPOSITEZ=!1,p.SS_LODINREFRACTIONALPHA=!1,p.SS_LINKREFRACTIONTOTRANSPARENCY=!1,p.SS_ALBEDOFORREFRACTIONTINT=!1,p.SS_ALBEDOFORTRANSLUCENCYTINT=!1,p.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=!1,p.SS_USE_THICKNESS_AS_DEPTH=!1;const E=!!this._thicknessTexture&&!!this._refractionIntensityTexture&&this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture)&&this._refractionIntensityTexture._texture===this._thicknessTexture._texture,I=!!this._thicknessTexture&&!!this._translucencyIntensityTexture&&this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture)&&this._translucencyIntensityTexture._texture===this._thicknessTexture._texture,Z=(E||!this._refractionIntensityTexture)&&(I||!this._translucencyIntensityTexture);if(p._areTexturesDirty&&_.texturesEnabled&&(this._thicknessTexture&&Ms.ThicknessTextureEnabled&&lr.PrepareDefinesForMergedUV(this._thicknessTexture,p,"SS_THICKNESSANDMASK_TEXTURE"),this._refractionIntensityTexture&&Ms.RefractionIntensityTextureEnabled&&!Z&&lr.PrepareDefinesForMergedUV(this._refractionIntensityTexture,p,"SS_REFRACTIONINTENSITY_TEXTURE"),this._translucencyIntensityTexture&&Ms.TranslucencyIntensityTextureEnabled&&!Z&&lr.PrepareDefinesForMergedUV(this._translucencyIntensityTexture,p,"SS_TRANSLUCENCYINTENSITY_TEXTURE")),p.SS_HAS_THICKNESS=this.maximumThickness-this.minimumThickness!==0,p.SS_MASK_FROM_THICKNESS_TEXTURE=(this._useMaskFromThicknessTexture||!!this._refractionIntensityTexture||!!this._translucencyIntensityTexture)&&Z,p.SS_USE_GLTF_TEXTURES=this._useGltfStyleTextures,p.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=(this._useMaskFromThicknessTexture||!!this._refractionIntensityTexture)&&Z,p.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=(this._useMaskFromThicknessTexture||!!this._translucencyIntensityTexture)&&Z,this._isRefractionEnabled&&_.texturesEnabled){const re=this._getRefractionTexture(_);re&&Ms.RefractionTextureEnabled&&(p.SS_REFRACTION=!0,p.SS_REFRACTIONMAP_3D=re.isCube,p.SS_GAMMAREFRACTION=re.gammaSpace,p.SS_RGBDREFRACTION=re.isRGBD,p.SS_LINEARSPECULARREFRACTION=re.linearSpecularLOD,p.SS_REFRACTIONMAP_OPPOSITEZ=this._scene.useRightHandedSystem&&re.isCube?!re.invertZ:re.invertZ,p.SS_LODINREFRACTIONALPHA=re.lodLevelInAlpha,p.SS_LINKREFRACTIONTOTRANSPARENCY=this._linkRefractionWithTransparency,p.SS_ALBEDOFORREFRACTIONTINT=this.useAlbedoToTintRefraction,p.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=re.isCube&&re.boundingBoxSize,p.SS_USE_THICKNESS_AS_DEPTH=this.useThicknessAsDepth)}this._isTranslucencyEnabled&&(p.SS_ALBEDOFORTRANSLUCENCYTINT=this.useAlbedoToTintTranslucency)}}hardBindForSubMesh(p,_,E,I){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled)return;I.getRenderingMesh().getWorldMatrix().decompose(ui.Vector3[0]);const Z=Math.max(Math.abs(ui.Vector3[0].x),Math.abs(ui.Vector3[0].y),Math.abs(ui.Vector3[0].z));p.updateFloat2("vThicknessParam",this.minimumThickness*Z,(this.maximumThickness-this.minimumThickness)*Z)}bindForSubMesh(p,_,E,I){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled)return;const Z=I.materialDefines,re=this._material.isFrozen,ae=this._material.realTimeFiltering,he=Z.LODBASEDMICROSFURACE,_e=this._getRefractionTexture(_);if(!p.useUbo||!re||!p.isSync){if(this._thicknessTexture&&Ms.ThicknessTextureEnabled&&(p.updateFloat2("vThicknessInfos",this._thicknessTexture.coordinatesIndex,this._thicknessTexture.level),lr.BindTextureMatrix(this._thicknessTexture,p,"thickness")),this._refractionIntensityTexture&&Ms.RefractionIntensityTextureEnabled&&Z.SS_REFRACTIONINTENSITY_TEXTURE&&(p.updateFloat2("vRefractionIntensityInfos",this._refractionIntensityTexture.coordinatesIndex,this._refractionIntensityTexture.level),lr.BindTextureMatrix(this._refractionIntensityTexture,p,"refractionIntensity")),this._translucencyIntensityTexture&&Ms.TranslucencyIntensityTextureEnabled&&Z.SS_TRANSLUCENCYINTENSITY_TEXTURE&&(p.updateFloat2("vTranslucencyIntensityInfos",this._translucencyIntensityTexture.coordinatesIndex,this._translucencyIntensityTexture.level),lr.BindTextureMatrix(this._translucencyIntensityTexture,p,"translucencyIntensity")),_e&&Ms.RefractionTextureEnabled){p.updateMatrix("refractionMatrix",_e.getRefractionTextureMatrix());let ve=1;_e.isCube||_e.depth&&(ve=_e.depth);const Le=_e.getSize().width,ze=this.volumeIndexOfRefraction;if(p.updateFloat4("vRefractionInfos",_e.level,1/ze,ve,this._invertRefractionY?-1:1),p.updateFloat4("vRefractionMicrosurfaceInfos",Le,_e.lodGenerationScale,_e.lodGenerationOffset,1/this.indexOfRefraction),ae&&p.updateFloat2("vRefractionFilteringInfo",Le,$t.Log2(Le)),_e.boundingBoxSize){const He=_e;p.updateVector3("vRefractionPosition",He.boundingBoxPosition),p.updateVector3("vRefractionSize",He.boundingBoxSize)}}this._isScatteringEnabled&&p.updateFloat("scatteringDiffusionProfile",this._scatteringDiffusionProfileIndex),p.updateColor3("vDiffusionDistance",this.diffusionDistance),p.updateFloat4("vTintColor",this.tintColor.r,this.tintColor.g,this.tintColor.b,Math.max(1e-5,this.tintColorAtDistance)),p.updateFloat3("vSubSurfaceIntensity",this.refractionIntensity,this.translucencyIntensity,0),p.updateFloat("dispersion",this.dispersion)}_.texturesEnabled&&(this._thicknessTexture&&Ms.ThicknessTextureEnabled&&p.setTexture("thicknessSampler",this._thicknessTexture),this._refractionIntensityTexture&&Ms.RefractionIntensityTextureEnabled&&Z.SS_REFRACTIONINTENSITY_TEXTURE&&p.setTexture("refractionIntensitySampler",this._refractionIntensityTexture),this._translucencyIntensityTexture&&Ms.TranslucencyIntensityTextureEnabled&&Z.SS_TRANSLUCENCYINTENSITY_TEXTURE&&p.setTexture("translucencyIntensitySampler",this._translucencyIntensityTexture),_e&&Ms.RefractionTextureEnabled&&(he?p.setTexture("refractionSampler",_e):(p.setTexture("refractionSampler",_e._lodTextureMid||_e),p.setTexture("refractionSamplerLow",_e._lodTextureLow||_e),p.setTexture("refractionSamplerHigh",_e._lodTextureHigh||_e))))}_getRefractionTexture(p){return this._refractionTexture?this._refractionTexture:this._isRefractionEnabled?p.environmentTexture:null}get disableAlphaBlending(){return this._isRefractionEnabled&&this._linkRefractionWithTransparency}fillRenderTargetTextures(p){Ms.RefractionTextureEnabled&&this._refractionTexture&&this._refractionTexture.isRenderTarget&&p.push(this._refractionTexture)}hasTexture(p){return this._thicknessTexture===p||this._refractionTexture===p}hasRenderTargetTextures(){return!!(Ms.RefractionTextureEnabled&&this._refractionTexture&&this._refractionTexture.isRenderTarget)}getActiveTextures(p){this._thicknessTexture&&p.push(this._thicknessTexture),this._refractionTexture&&p.push(this._refractionTexture)}getAnimatables(p){this._thicknessTexture&&this._thicknessTexture.animations&&this._thicknessTexture.animations.length>0&&p.push(this._thicknessTexture),this._refractionTexture&&this._refractionTexture.animations&&this._refractionTexture.animations.length>0&&p.push(this._refractionTexture)}dispose(p){p&&(this._thicknessTexture&&this._thicknessTexture.dispose(),this._refractionTexture&&this._refractionTexture.dispose())}getClassName(){return"PBRSubSurfaceConfiguration"}addFallbacks(p,_,E){return p.SS_SCATTERING&&_.addFallback(E++,"SS_SCATTERING"),p.SS_TRANSLUCENCY&&_.addFallback(E++,"SS_TRANSLUCENCY"),E}getSamplers(p){p.push("thicknessSampler","refractionIntensitySampler","translucencyIntensitySampler","refractionSampler","refractionSamplerLow","refractionSamplerHigh")}getUniforms(){return{ubo:[{name:"vRefractionMicrosurfaceInfos",size:4,type:"vec4"},{name:"vRefractionFilteringInfo",size:2,type:"vec2"},{name:"vTranslucencyIntensityInfos",size:2,type:"vec2"},{name:"vRefractionInfos",size:4,type:"vec4"},{name:"refractionMatrix",size:16,type:"mat4"},{name:"vThicknessInfos",size:2,type:"vec2"},{name:"vRefractionIntensityInfos",size:2,type:"vec2"},{name:"thicknessMatrix",size:16,type:"mat4"},{name:"refractionIntensityMatrix",size:16,type:"mat4"},{name:"translucencyIntensityMatrix",size:16,type:"mat4"},{name:"vThicknessParam",size:2,type:"vec2"},{name:"vDiffusionDistance",size:3,type:"vec3"},{name:"vTintColor",size:4,type:"vec4"},{name:"vSubSurfaceIntensity",size:3,type:"vec3"},{name:"vRefractionPosition",size:3,type:"vec3"},{name:"vRefractionSize",size:3,type:"vec3"},{name:"scatteringDiffusionProfile",size:1,type:"float"},{name:"dispersion",size:1,type:"float"}]}}}Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"isRefractionEnabled",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"isTranslucencyEnabled",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"isDispersionEnabled",void 0),Rt([Ut(),ws("_markScenePrePassDirty")],Ga.prototype,"isScatteringEnabled",void 0),Rt([Ut()],Ga.prototype,"_scatteringDiffusionProfileIndex",void 0),Rt([Ut()],Ga.prototype,"refractionIntensity",void 0),Rt([Ut()],Ga.prototype,"translucencyIntensity",void 0),Rt([Ut()],Ga.prototype,"useAlbedoToTintRefraction",void 0),Rt([Ut()],Ga.prototype,"useAlbedoToTintTranslucency",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"thicknessTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"refractionTexture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"indexOfRefraction",void 0),Rt([Ut()],Ga.prototype,"_volumeIndexOfRefraction",void 0),Rt([ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"volumeIndexOfRefraction",null),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"invertRefractionY",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"linkRefractionWithTransparency",void 0),Rt([Ut()],Ga.prototype,"minimumThickness",void 0),Rt([Ut()],Ga.prototype,"maximumThickness",void 0),Rt([Ut()],Ga.prototype,"useThicknessAsDepth",void 0),Rt([Ya()],Ga.prototype,"tintColor",void 0),Rt([Ut()],Ga.prototype,"tintColorAtDistance",void 0),Rt([Ut()],Ga.prototype,"dispersion",void 0),Rt([Ya()],Ga.prototype,"diffusionDistance",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"useMaskFromThicknessTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"refractionIntensityTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"translucencyIntensityTexture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ga.prototype,"useGltfStyleTextures",void 0);class aD extends Hh{constructor(){super(...arguments),this.DETAIL=!1,this.DETAILDIRECTUV=0,this.DETAIL_NORMALBLENDMETHOD=0}}class Yc extends K2{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(p,_=!0){super(p,"DetailMap",140,new aD,_),this._texture=null,this.diffuseBlendLevel=1,this.roughnessBlendLevel=1,this.bumpLevel=1,this._normalBlendMethod=zi.MATERIAL_NORMALBLENDMETHOD_WHITEOUT,this._isEnabled=!1,this.isEnabled=!1,this._internalMarkAllSubMeshesAsTexturesDirty=p._dirtyCallbacks[1]}isReadyForSubMesh(p,_,E){return this._isEnabled?!(p._areTexturesDirty&&_.texturesEnabled&&E.getCaps().standardDerivatives&&this._texture&&Ms.DetailTextureEnabled&&!this._texture.isReady()):!0}prepareDefines(p,_){if(this._isEnabled){p.DETAIL_NORMALBLENDMETHOD=this._normalBlendMethod;const E=_.getEngine();p._areTexturesDirty&&(E.getCaps().standardDerivatives&&this._texture&&Ms.DetailTextureEnabled&&this._isEnabled?(lr.PrepareDefinesForMergedUV(this._texture,p,"DETAIL"),p.DETAIL_NORMALBLENDMETHOD=this._normalBlendMethod):p.DETAIL=!1)}else p.DETAIL=!1}bindForSubMesh(p,_){if(!this._isEnabled)return;const E=this._material.isFrozen;(!p.useUbo||!E||!p.isSync)&&this._texture&&Ms.DetailTextureEnabled&&(p.updateFloat4("vDetailInfos",this._texture.coordinatesIndex,this.diffuseBlendLevel,this.bumpLevel,this.roughnessBlendLevel),lr.BindTextureMatrix(this._texture,p,"detail")),_.texturesEnabled&&this._texture&&Ms.DetailTextureEnabled&&p.setTexture("detailSampler",this._texture)}hasTexture(p){return this._texture===p}getActiveTextures(p){this._texture&&p.push(this._texture)}getAnimatables(p){this._texture&&this._texture.animations&&this._texture.animations.length>0&&p.push(this._texture)}dispose(p){p&&this._texture?.dispose()}getClassName(){return"DetailMapConfiguration"}getSamplers(p){p.push("detailSampler")}getUniforms(){return{ubo:[{name:"vDetailInfos",size:4,type:"vec4"},{name:"detailMatrix",size:16,type:"mat4"}]}}}Rt([Hn("detailTexture"),ws("_markAllSubMeshesAsTexturesDirty")],Yc.prototype,"texture",void 0),Rt([Ut()],Yc.prototype,"diffuseBlendLevel",void 0),Rt([Ut()],Yc.prototype,"roughnessBlendLevel",void 0),Rt([Ut()],Yc.prototype,"bumpLevel",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Yc.prototype,"normalBlendMethod",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Yc.prototype,"isEnabled",void 0);const Uu={effect:null,subMesh:null};class W1 extends Hh{constructor(p){super(p),this.PBR=!0,this.NUM_SAMPLES="0",this.REALTIME_FILTERING=!1,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.ALBEDO=!1,this.GAMMAALBEDO=!1,this.ALBEDODIRECTUV=0,this.VERTEXCOLOR=!1,this.BAKED_VERTEX_ANIMATION_TEXTURE=!1,this.AMBIENT=!1,this.AMBIENTDIRECTUV=0,this.AMBIENTINGRAYSCALE=!1,this.OPACITY=!1,this.VERTEXALPHA=!1,this.OPACITYDIRECTUV=0,this.OPACITYRGB=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHABLEND=!1,this.ALPHAFROMALBEDO=!1,this.ALPHATESTVALUE="0.5",this.SPECULAROVERALPHA=!1,this.RADIANCEOVERALPHA=!1,this.ALPHAFRESNEL=!1,this.LINEARALPHAFRESNEL=!1,this.PREMULTIPLYALPHA=!1,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.GAMMAEMISSIVE=!1,this.REFLECTIVITY=!1,this.REFLECTIVITY_GAMMA=!1,this.REFLECTIVITYDIRECTUV=0,this.SPECULARTERM=!1,this.MICROSURFACEFROMREFLECTIVITYMAP=!1,this.MICROSURFACEAUTOMATIC=!1,this.LODBASEDMICROSFURACE=!1,this.MICROSURFACEMAP=!1,this.MICROSURFACEMAPDIRECTUV=0,this.METALLICWORKFLOW=!1,this.ROUGHNESSSTOREINMETALMAPALPHA=!1,this.ROUGHNESSSTOREINMETALMAPGREEN=!1,this.METALLNESSSTOREINMETALMAPBLUE=!1,this.AOSTOREINMETALMAPRED=!1,this.METALLIC_REFLECTANCE=!1,this.METALLIC_REFLECTANCE_GAMMA=!1,this.METALLIC_REFLECTANCEDIRECTUV=0,this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY=!1,this.REFLECTANCE=!1,this.REFLECTANCE_GAMMA=!1,this.REFLECTANCEDIRECTUV=0,this.ENVIRONMENTBRDF=!1,this.ENVIRONMENTBRDF_RGBD=!1,this.NORMAL=!1,this.TANGENT=!1,this.BUMP=!1,this.BUMPDIRECTUV=0,this.OBJECTSPACE_NORMALMAP=!1,this.PARALLAX=!1,this.PARALLAX_RHS=!1,this.PARALLAXOCCLUSION=!1,this.NORMALXYSCALE=!0,this.LIGHTMAP=!1,this.LIGHTMAPDIRECTUV=0,this.USELIGHTMAPASSHADOWMAP=!1,this.GAMMALIGHTMAP=!1,this.RGBDLIGHTMAP=!1,this.REFLECTION=!1,this.REFLECTIONMAP_3D=!1,this.REFLECTIONMAP_SPHERICAL=!1,this.REFLECTIONMAP_PLANAR=!1,this.REFLECTIONMAP_CUBIC=!1,this.USE_LOCAL_REFLECTIONMAP_CUBIC=!1,this.REFLECTIONMAP_PROJECTION=!1,this.REFLECTIONMAP_SKYBOX=!1,this.REFLECTIONMAP_EXPLICIT=!1,this.REFLECTIONMAP_EQUIRECTANGULAR=!1,this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,this.INVERTCUBICMAP=!1,this.USESPHERICALFROMREFLECTIONMAP=!1,this.USEIRRADIANCEMAP=!1,this.USESPHERICALINVERTEX=!1,this.REFLECTIONMAP_OPPOSITEZ=!1,this.LODINREFLECTIONALPHA=!1,this.GAMMAREFLECTION=!1,this.RGBDREFLECTION=!1,this.LINEARSPECULARREFLECTION=!1,this.RADIANCEOCCLUSION=!1,this.HORIZONOCCLUSION=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.INSTANCESCOLOR=!1,this.PREPASS=!1,this.PREPASS_IRRADIANCE=!1,this.PREPASS_IRRADIANCE_INDEX=-1,this.PREPASS_ALBEDO_SQRT=!1,this.PREPASS_ALBEDO_SQRT_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_NORMAL_WORLDSPACE=!1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_VELOCITY=!1,this.PREPASS_VELOCITY_INDEX=-1,this.PREPASS_REFLECTIVITY=!1,this.PREPASS_REFLECTIVITY_INDEX=-1,this.SCENE_MRT_COUNT=0,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.NONUNIFORMSCALING=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=!1,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.DITHER=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.EXPOSURE=!1,this.MULTIVIEW=!1,this.ORDER_INDEPENDENT_TRANSPARENCY=!1,this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!1,this.USEPHYSICALLIGHTFALLOFF=!1,this.USEGLTFLIGHTFALLOFF=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.POINTSIZE=!1,this.FOG=!1,this.LOGARITHMICDEPTH=!1,this.CAMERA_ORTHOGRAPHIC=!1,this.CAMERA_PERSPECTIVE=!1,this.FORCENORMALFORWARD=!1,this.SPECULARAA=!1,this.UNLIT=!1,this.DECAL_AFTER_DETAIL=!1,this.DEBUGMODE=0,this.rebuild()}reset(){super.reset(),this.ALPHATESTVALUE="0.5",this.PBR=!0,this.NORMALXYSCALE=!0}}class ua extends Xb{get realTimeFiltering(){return this._realTimeFiltering}set realTimeFiltering(p){this._realTimeFiltering=p,this.markAsDirty(1)}get realTimeFilteringQuality(){return this._realTimeFilteringQuality}set realTimeFilteringQuality(p){this._realTimeFilteringQuality=p,this.markAsDirty(1)}get canRenderToMRT(){return!0}_attachImageProcessingConfiguration(p){p!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),p?this._imageProcessingConfiguration=p:this._imageProcessingConfiguration=this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add(()=>{this._markAllSubMeshesAsImageProcessingDirty()})))}constructor(p,_){super(p,_),this._directIntensity=1,this._emissiveIntensity=1,this._environmentIntensity=1,this._specularIntensity=1,this._lightingInfos=new Lr(this._directIntensity,this._emissiveIntensity,this._environmentIntensity,this._specularIntensity),this._disableBumpMap=!1,this._albedoTexture=null,this._ambientTexture=null,this._ambientTextureStrength=1,this._ambientTextureImpactOnAnalyticalLights=ua.DEFAULT_AO_ON_ANALYTICAL_LIGHTS,this._opacityTexture=null,this._reflectionTexture=null,this._emissiveTexture=null,this._reflectivityTexture=null,this._metallicTexture=null,this._metallic=null,this._roughness=null,this._metallicF0Factor=1,this._metallicReflectanceColor=Rs.White(),this._useOnlyMetallicFromMetallicReflectanceTexture=!1,this._metallicReflectanceTexture=null,this._reflectanceTexture=null,this._microSurfaceTexture=null,this._bumpTexture=null,this._lightmapTexture=null,this._ambientColor=new Rs(0,0,0),this._albedoColor=new Rs(1,1,1),this._reflectivityColor=new Rs(1,1,1),this._reflectionColor=new Rs(1,1,1),this._emissiveColor=new Rs(0,0,0),this._microSurface=.9,this._useLightmapAsShadowmap=!1,this._useHorizonOcclusion=!0,this._useRadianceOcclusion=!0,this._useAlphaFromAlbedoTexture=!1,this._useSpecularOverAlpha=!0,this._useMicroSurfaceFromReflectivityMapAlpha=!1,this._useRoughnessFromMetallicTextureAlpha=!0,this._useRoughnessFromMetallicTextureGreen=!1,this._useMetallnessFromMetallicTextureBlue=!1,this._useAmbientOcclusionFromMetallicTextureRed=!1,this._useAmbientInGrayScale=!1,this._useAutoMicroSurfaceFromReflectivityMap=!1,this._lightFalloff=ua.LIGHTFALLOFF_PHYSICAL,this._useRadianceOverAlpha=!0,this._useObjectSpaceNormalMap=!1,this._useParallax=!1,this._useParallaxOcclusion=!1,this._parallaxScaleBias=.05,this._disableLighting=!1,this._maxSimultaneousLights=4,this._invertNormalMapX=!1,this._invertNormalMapY=!1,this._twoSidedLighting=!1,this._alphaCutOff=.4,this._forceAlphaTest=!1,this._useAlphaFresnel=!1,this._useLinearAlphaFresnel=!1,this._environmentBRDFTexture=null,this._forceIrradianceInFragment=!1,this._realTimeFiltering=!1,this._realTimeFilteringQuality=8,this._forceNormalForward=!1,this._enableSpecularAntiAliasing=!1,this._imageProcessingObserver=null,this._renderTargets=new ct(16),this._globalAmbientColor=new Rs(0,0,0),this._unlit=!1,this._applyDecalMapAfterDetailMap=!1,this._debugMode=0,this.debugMode=0,this.debugLimit=-1,this.debugFactor=1,this._cacheHasRenderTargetTextures=!1,this.brdf=new Mx(this),this.clearCoat=new nx(this),this.iridescence=new $x(this),this.anisotropy=new ku(this),this.sheen=new Rl(this),this.subSurface=new Ga(this),this.detailMap=new Yc(this),this._attachImageProcessingConfiguration(null),this.getRenderTargetTextures=()=>(this._renderTargets.reset(),Ms.ReflectionTextureEnabled&&this._reflectionTexture&&this._reflectionTexture.isRenderTarget&&this._renderTargets.push(this._reflectionTexture),this._eventInfo.renderTargets=this._renderTargets,this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),this._renderTargets),this._environmentBRDFTexture=o_(this.getScene()),this.prePassConfiguration=new c_}get hasRenderTargetTextures(){return Ms.ReflectionTextureEnabled&&this._reflectionTexture&&this._reflectionTexture.isRenderTarget?!0:this._cacheHasRenderTargetTextures}get isPrePassCapable(){return!this.disableDepthWrite}getClassName(){return"PBRBaseMaterial"}get _disableAlphaBlending(){return this._transparencyMode===ua.PBRMATERIAL_OPAQUE||this._transparencyMode===ua.PBRMATERIAL_ALPHATEST||this.subSurface?.disableAlphaBlending}needAlphaBlending(){return this._disableAlphaBlending?!1:this.alpha<1||this._opacityTexture!=null||this._shouldUseAlphaFromAlbedoTexture()}needAlphaTesting(){return this._forceAlphaTest?!0:this.subSurface?.disableAlphaBlending?!1:this._hasAlphaChannel()&&(this._transparencyMode==null||this._transparencyMode===ua.PBRMATERIAL_ALPHATEST)}_shouldUseAlphaFromAlbedoTexture(){return this._albedoTexture!=null&&this._albedoTexture.hasAlpha&&this._useAlphaFromAlbedoTexture&&this._transparencyMode!==ua.PBRMATERIAL_OPAQUE}_hasAlphaChannel(){return this._albedoTexture!=null&&this._albedoTexture.hasAlpha||this._opacityTexture!=null}getAlphaTestTexture(){return this._albedoTexture}isReadyForSubMesh(p,_,E){this._uniformBufferLayoutBuilt||this.buildUniformLayout();const I=_._drawWrapper;if(I.effect&&this.isFrozen&&I._wasPreviouslyReady&&I._wasPreviouslyUsingInstances===E)return!0;_.materialDefines||(this._callbackPluginEventGeneric(vx.GetDefineNames,this._eventInfo),_.materialDefines=new W1(this._eventInfo.defineNames));const Z=_.materialDefines;if(this._isReadyForSubMesh(_))return!0;const re=this.getScene(),ae=re.getEngine();if(Z._areTexturesDirty&&(this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._cacheHasRenderTargetTextures=this._eventInfo.hasRenderTargetTextures,re.texturesEnabled)){if(this._albedoTexture&&Ms.DiffuseTextureEnabled&&!this._albedoTexture.isReadyOrNotBlocking()||this._ambientTexture&&Ms.AmbientTextureEnabled&&!this._ambientTexture.isReadyOrNotBlocking()||this._opacityTexture&&Ms.OpacityTextureEnabled&&!this._opacityTexture.isReadyOrNotBlocking())return!1;const ze=this._getReflectionTexture();if(ze&&Ms.ReflectionTextureEnabled){if(!ze.isReadyOrNotBlocking())return!1;if(ze.irradianceTexture){if(!ze.irradianceTexture.isReadyOrNotBlocking())return!1}else if(!ze.sphericalPolynomial&&ze.getInternalTexture()?._sphericalPolynomialPromise)return!1}if(this._lightmapTexture&&Ms.LightmapTextureEnabled&&!this._lightmapTexture.isReadyOrNotBlocking()||this._emissiveTexture&&Ms.EmissiveTextureEnabled&&!this._emissiveTexture.isReadyOrNotBlocking())return!1;if(Ms.SpecularTextureEnabled){if(this._metallicTexture){if(!this._metallicTexture.isReadyOrNotBlocking())return!1}else if(this._reflectivityTexture&&!this._reflectivityTexture.isReadyOrNotBlocking())return!1;if(this._metallicReflectanceTexture&&!this._metallicReflectanceTexture.isReadyOrNotBlocking()||this._reflectanceTexture&&!this._reflectanceTexture.isReadyOrNotBlocking()||this._microSurfaceTexture&&!this._microSurfaceTexture.isReadyOrNotBlocking())return!1}if(ae.getCaps().standardDerivatives&&this._bumpTexture&&Ms.BumpTextureEnabled&&!this._disableBumpMap&&!this._bumpTexture.isReady()||this._environmentBRDFTexture&&Ms.ReflectionTextureEnabled&&!this._environmentBRDFTexture.isReady())return!1}if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=Z,this._eventInfo.subMesh=_,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh||Z._areImageProcessingDirty&&this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.isReady())return!1;!ae.getCaps().standardDerivatives&&!p.isVerticesDataPresent(ut.NormalKind)&&(p.createNormals(!0),Ti.Warn("PBRMaterial: Normals have been created for the mesh: "+p.name));const he=_.effect,_e=Z._areLightsDisposed;let ve=this._prepareEffect(p,Z,this.onCompiled,this.onError,E,null,_.getRenderingMesh().hasThinInstances),Le=!1;if(ve)if(this._onEffectCreatedObservable&&(Uu.effect=ve,Uu.subMesh=_,this._onEffectCreatedObservable.notifyObservers(Uu)),this.allowShaderHotSwapping&&he&&!ve.isReady()){if(ve=he,Z.markAsUnprocessed(),Le=this.isFrozen,_e)return Z._areLightsDisposed=!0,!1}else re.resetCachedMaterial(),_.setEffect(ve,Z,this._materialContext);return!_.effect||!_.effect.isReady()?!1:(Z._renderId=re.getRenderId(),I._wasPreviouslyReady=!Le,I._wasPreviouslyUsingInstances=!!E,this._checkScenePerformancePriority(),!0)}isMetallicWorkflow(){return!!(this._metallic!=null||this._roughness!=null||this._metallicTexture)}_prepareEffect(p,_,E=null,I=null,Z=null,re=null,ae){if(this._prepareDefines(p,_,Z,re,ae),!_.isDirty)return null;_.markAsProcessed();const _e=this.getScene().getEngine(),ve=new Hb;let Le=0;_.USESPHERICALINVERTEX&&ve.addFallback(Le++,"USESPHERICALINVERTEX"),_.FOG&&ve.addFallback(Le,"FOG"),_.SPECULARAA&&ve.addFallback(Le,"SPECULARAA"),_.POINTSIZE&&ve.addFallback(Le,"POINTSIZE"),_.LOGARITHMICDEPTH&&ve.addFallback(Le,"LOGARITHMICDEPTH"),_.PARALLAX&&ve.addFallback(Le,"PARALLAX"),_.PARALLAX_RHS&&ve.addFallback(Le,"PARALLAX_RHS"),_.PARALLAXOCCLUSION&&ve.addFallback(Le++,"PARALLAXOCCLUSION"),_.ENVIRONMENTBRDF&&ve.addFallback(Le++,"ENVIRONMENTBRDF"),_.TANGENT&&ve.addFallback(Le++,"TANGENT"),_.BUMP&&ve.addFallback(Le++,"BUMP"),Le=lr.HandleFallbacksForShadows(_,ve,this._maxSimultaneousLights,Le++),_.SPECULARTERM&&ve.addFallback(Le++,"SPECULARTERM"),_.USESPHERICALFROMREFLECTIONMAP&&ve.addFallback(Le++,"USESPHERICALFROMREFLECTIONMAP"),_.USEIRRADIANCEMAP&&ve.addFallback(Le++,"USEIRRADIANCEMAP"),_.LIGHTMAP&&ve.addFallback(Le++,"LIGHTMAP"),_.NORMAL&&ve.addFallback(Le++,"NORMAL"),_.AMBIENT&&ve.addFallback(Le++,"AMBIENT"),_.EMISSIVE&&ve.addFallback(Le++,"EMISSIVE"),_.VERTEXCOLOR&&ve.addFallback(Le++,"VERTEXCOLOR"),_.MORPHTARGETS&&ve.addFallback(Le++,"MORPHTARGETS"),_.MULTIVIEW&&ve.addFallback(0,"MULTIVIEW");const ze=[ut.PositionKind];_.NORMAL&&ze.push(ut.NormalKind),_.TANGENT&&ze.push(ut.TangentKind);for(let zt=1;zt<=6;++zt)_["UV"+zt]&&ze.push(`uv${zt===1?"":zt}`);_.VERTEXCOLOR&&ze.push(ut.ColorKind),lr.PrepareAttributesForBones(ze,p,_,ve),lr.PrepareAttributesForInstances(ze,_),lr.PrepareAttributesForMorphTargets(ze,p,_),lr.PrepareAttributesForBakedVertexAnimation(ze,p,_);let He="pbr";const xt=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vAlbedoColor","vReflectivityColor","vMetallicReflectanceFactors","vEmissiveColor","visibility","vReflectionColor","vFogInfos","vFogColor","pointSize","vAlbedoInfos","vAmbientInfos","vOpacityInfos","vReflectionInfos","vReflectionPosition","vReflectionSize","vEmissiveInfos","vReflectivityInfos","vReflectionFilteringInfo","vMetallicReflectanceInfos","vReflectanceInfos","vMicroSurfaceSamplerInfos","vBumpInfos","vLightmapInfos","mBones","albedoMatrix","ambientMatrix","opacityMatrix","reflectionMatrix","emissiveMatrix","reflectivityMatrix","normalMatrix","microSurfaceSamplerMatrix","bumpMatrix","lightmapMatrix","metallicReflectanceMatrix","reflectanceMatrix","vLightingIntensity","logarithmicDepthConstant","vSphericalX","vSphericalY","vSphericalZ","vSphericalXX_ZZ","vSphericalYY_ZZ","vSphericalZZ","vSphericalXY","vSphericalYZ","vSphericalZX","vSphericalL00","vSphericalL1_1","vSphericalL10","vSphericalL11","vSphericalL2_2","vSphericalL2_1","vSphericalL20","vSphericalL21","vSphericalL22","vReflectionMicrosurfaceInfos","vTangentSpaceParams","boneTextureWidth","vDebugMode","morphTargetTextureInfo","morphTargetTextureIndices"],rt=["albedoSampler","reflectivitySampler","ambientSampler","emissiveSampler","bumpSampler","lightmapSampler","opacitySampler","reflectionSampler","reflectionSamplerLow","reflectionSamplerHigh","irradianceSampler","microSurfaceSampler","environmentBrdfSampler","boneSampler","metallicReflectanceSampler","reflectanceSampler","morphTargets","oitDepthSampler","oitFrontColorSampler"],Tt=["Material","Scene","Mesh"],Lt={maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:_.NUM_MORPH_INFLUENCERS};this._eventInfo.fallbacks=ve,this._eventInfo.fallbackRank=Le,this._eventInfo.defines=_,this._eventInfo.uniforms=xt,this._eventInfo.attributes=ze,this._eventInfo.samplers=rt,this._eventInfo.uniformBuffersNames=Tt,this._eventInfo.customCode=void 0,this._eventInfo.mesh=p,this._eventInfo.indexParameters=Lt,this._callbackPluginEventGeneric(vx.PrepareEffect,this._eventInfo),c_.AddUniforms(xt),c_.AddSamplers(rt),_b(xt),zn&&(zn.PrepareUniforms(xt,_),zn.PrepareSamplers(rt,_)),lr.PrepareUniformsAndSamplersList({uniformsNames:xt,uniformBuffersNames:Tt,samplers:rt,defines:_,maxSimultaneousLights:this._maxSimultaneousLights});const Nt={};this.customShaderNameResolve&&(He=this.customShaderNameResolve(He,xt,Tt,rt,_,ze,Nt));const qt=_.toString(),Xt=_e.createEffect(He,{attributes:ze,uniformsNames:xt,uniformBuffersNames:Tt,samplers:rt,defines:qt,fallbacks:ve,onCompiled:E,onError:I,indexParameters:Lt,processFinalCode:Nt.processFinalCode,processCodeAfterIncludes:this._eventInfo.customCode,multiTarget:_.PREPASS},_e);return this._eventInfo.customCode=void 0,Xt}_prepareDefines(p,_,E=null,I=null,Z=!1){const re=this.getScene(),ae=re.getEngine();lr.PrepareDefinesForLights(re,p,_,!0,this._maxSimultaneousLights,this._disableLighting),_._needNormals=!0,lr.PrepareDefinesForMultiview(re,_);const he=this.needAlphaBlendingForMesh(p)&&this.getScene().useOrderIndependentTransparency;if(lr.PrepareDefinesForPrePass(re,_,this.canRenderToMRT&&!he),lr.PrepareDefinesForOIT(re,_,he),_.METALLICWORKFLOW=this.isMetallicWorkflow(),_._areTexturesDirty){_._needUVs=!1;for(let _e=1;_e<=6;++_e)_["MAINUV"+_e]=!1;if(re.texturesEnabled){_.ALBEDODIRECTUV=0,_.AMBIENTDIRECTUV=0,_.OPACITYDIRECTUV=0,_.EMISSIVEDIRECTUV=0,_.REFLECTIVITYDIRECTUV=0,_.MICROSURFACEMAPDIRECTUV=0,_.METALLIC_REFLECTANCEDIRECTUV=0,_.REFLECTANCEDIRECTUV=0,_.BUMPDIRECTUV=0,_.LIGHTMAPDIRECTUV=0,ae.getCaps().textureLOD&&(_.LODBASEDMICROSFURACE=!0),this._albedoTexture&&Ms.DiffuseTextureEnabled?(lr.PrepareDefinesForMergedUV(this._albedoTexture,_,"ALBEDO"),_.GAMMAALBEDO=this._albedoTexture.gammaSpace):_.ALBEDO=!1,this._ambientTexture&&Ms.AmbientTextureEnabled?(lr.PrepareDefinesForMergedUV(this._ambientTexture,_,"AMBIENT"),_.AMBIENTINGRAYSCALE=this._useAmbientInGrayScale):_.AMBIENT=!1,this._opacityTexture&&Ms.OpacityTextureEnabled?(lr.PrepareDefinesForMergedUV(this._opacityTexture,_,"OPACITY"),_.OPACITYRGB=this._opacityTexture.getAlphaFromRGB):_.OPACITY=!1;const _e=this._getReflectionTexture();if(_e&&Ms.ReflectionTextureEnabled){switch(_.REFLECTION=!0,_.GAMMAREFLECTION=_e.gammaSpace,_.RGBDREFLECTION=_e.isRGBD,_.LODINREFLECTIONALPHA=_e.lodLevelInAlpha,_.LINEARSPECULARREFLECTION=_e.linearSpecularLOD,this.realTimeFiltering&&this.realTimeFilteringQuality>0?(_.NUM_SAMPLES=""+this.realTimeFilteringQuality,ae._features.needTypeSuffixInShaderConstants&&(_.NUM_SAMPLES=_.NUM_SAMPLES+"u"),_.REALTIME_FILTERING=!0):_.REALTIME_FILTERING=!1,_.INVERTCUBICMAP=_e.coordinatesMode===Ki.INVCUBIC_MODE,_.REFLECTIONMAP_3D=_e.isCube,_.REFLECTIONMAP_OPPOSITEZ=_.REFLECTIONMAP_3D&&this.getScene().useRightHandedSystem?!_e.invertZ:_e.invertZ,_.REFLECTIONMAP_CUBIC=!1,_.REFLECTIONMAP_EXPLICIT=!1,_.REFLECTIONMAP_PLANAR=!1,_.REFLECTIONMAP_PROJECTION=!1,_.REFLECTIONMAP_SKYBOX=!1,_.REFLECTIONMAP_SPHERICAL=!1,_.REFLECTIONMAP_EQUIRECTANGULAR=!1,_.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,_.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,_e.coordinatesMode){case Ki.EXPLICIT_MODE:_.REFLECTIONMAP_EXPLICIT=!0;break;case Ki.PLANAR_MODE:_.REFLECTIONMAP_PLANAR=!0;break;case Ki.PROJECTION_MODE:_.REFLECTIONMAP_PROJECTION=!0;break;case Ki.SKYBOX_MODE:_.REFLECTIONMAP_SKYBOX=!0;break;case Ki.SPHERICAL_MODE:_.REFLECTIONMAP_SPHERICAL=!0;break;case Ki.EQUIRECTANGULAR_MODE:_.REFLECTIONMAP_EQUIRECTANGULAR=!0;break;case Ki.FIXED_EQUIRECTANGULAR_MODE:_.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!0;break;case Ki.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:_.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!0;break;case Ki.CUBIC_MODE:case Ki.INVCUBIC_MODE:default:_.REFLECTIONMAP_CUBIC=!0,_.USE_LOCAL_REFLECTIONMAP_CUBIC=!!_e.boundingBoxSize;break}_e.coordinatesMode!==Ki.SKYBOX_MODE&&(_e.irradianceTexture?(_.USEIRRADIANCEMAP=!0,_.USESPHERICALFROMREFLECTIONMAP=!1):_e.isCube&&(_.USESPHERICALFROMREFLECTIONMAP=!0,_.USEIRRADIANCEMAP=!1,this._forceIrradianceInFragment||this.realTimeFiltering||this._twoSidedLighting||ae.getCaps().maxVaryingVectors<=8?_.USESPHERICALINVERTEX=!1:_.USESPHERICALINVERTEX=!0))}else _.REFLECTION=!1,_.REFLECTIONMAP_3D=!1,_.REFLECTIONMAP_SPHERICAL=!1,_.REFLECTIONMAP_PLANAR=!1,_.REFLECTIONMAP_CUBIC=!1,_.USE_LOCAL_REFLECTIONMAP_CUBIC=!1,_.REFLECTIONMAP_PROJECTION=!1,_.REFLECTIONMAP_SKYBOX=!1,_.REFLECTIONMAP_EXPLICIT=!1,_.REFLECTIONMAP_EQUIRECTANGULAR=!1,_.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,_.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,_.INVERTCUBICMAP=!1,_.USESPHERICALFROMREFLECTIONMAP=!1,_.USEIRRADIANCEMAP=!1,_.USESPHERICALINVERTEX=!1,_.REFLECTIONMAP_OPPOSITEZ=!1,_.LODINREFLECTIONALPHA=!1,_.GAMMAREFLECTION=!1,_.RGBDREFLECTION=!1,_.LINEARSPECULARREFLECTION=!1;if(this._lightmapTexture&&Ms.LightmapTextureEnabled?(lr.PrepareDefinesForMergedUV(this._lightmapTexture,_,"LIGHTMAP"),_.USELIGHTMAPASSHADOWMAP=this._useLightmapAsShadowmap,_.GAMMALIGHTMAP=this._lightmapTexture.gammaSpace,_.RGBDLIGHTMAP=this._lightmapTexture.isRGBD):_.LIGHTMAP=!1,this._emissiveTexture&&Ms.EmissiveTextureEnabled?(lr.PrepareDefinesForMergedUV(this._emissiveTexture,_,"EMISSIVE"),_.GAMMAEMISSIVE=this._emissiveTexture.gammaSpace):_.EMISSIVE=!1,Ms.SpecularTextureEnabled){if(this._metallicTexture?(lr.PrepareDefinesForMergedUV(this._metallicTexture,_,"REFLECTIVITY"),_.ROUGHNESSSTOREINMETALMAPALPHA=this._useRoughnessFromMetallicTextureAlpha,_.ROUGHNESSSTOREINMETALMAPGREEN=!this._useRoughnessFromMetallicTextureAlpha&&this._useRoughnessFromMetallicTextureGreen,_.METALLNESSSTOREINMETALMAPBLUE=this._useMetallnessFromMetallicTextureBlue,_.AOSTOREINMETALMAPRED=this._useAmbientOcclusionFromMetallicTextureRed,_.REFLECTIVITY_GAMMA=!1):this._reflectivityTexture?(lr.PrepareDefinesForMergedUV(this._reflectivityTexture,_,"REFLECTIVITY"),_.MICROSURFACEFROMREFLECTIVITYMAP=this._useMicroSurfaceFromReflectivityMapAlpha,_.MICROSURFACEAUTOMATIC=this._useAutoMicroSurfaceFromReflectivityMap,_.REFLECTIVITY_GAMMA=this._reflectivityTexture.gammaSpace):_.REFLECTIVITY=!1,this._metallicReflectanceTexture||this._reflectanceTexture){const ve=this._metallicReflectanceTexture!==null&&this._metallicReflectanceTexture._texture===this._reflectanceTexture?._texture&&this._metallicReflectanceTexture.checkTransformsAreIdentical(this._reflectanceTexture);_.METALLIC_REFLECTANCE_USE_ALPHA_ONLY=this._useOnlyMetallicFromMetallicReflectanceTexture&&!ve,this._metallicReflectanceTexture?(lr.PrepareDefinesForMergedUV(this._metallicReflectanceTexture,_,"METALLIC_REFLECTANCE"),_.METALLIC_REFLECTANCE_GAMMA=this._metallicReflectanceTexture.gammaSpace):_.METALLIC_REFLECTANCE=!1,this._reflectanceTexture&&!ve&&(!this._metallicReflectanceTexture||this._metallicReflectanceTexture&&this._useOnlyMetallicFromMetallicReflectanceTexture)?(lr.PrepareDefinesForMergedUV(this._reflectanceTexture,_,"REFLECTANCE"),_.REFLECTANCE_GAMMA=this._reflectanceTexture.gammaSpace):_.REFLECTANCE=!1}else _.METALLIC_REFLECTANCE=!1,_.REFLECTANCE=!1;this._microSurfaceTexture?lr.PrepareDefinesForMergedUV(this._microSurfaceTexture,_,"MICROSURFACEMAP"):_.MICROSURFACEMAP=!1}else _.REFLECTIVITY=!1,_.MICROSURFACEMAP=!1;ae.getCaps().standardDerivatives&&this._bumpTexture&&Ms.BumpTextureEnabled&&!this._disableBumpMap?(lr.PrepareDefinesForMergedUV(this._bumpTexture,_,"BUMP"),this._useParallax&&this._albedoTexture&&Ms.DiffuseTextureEnabled?(_.PARALLAX=!0,_.PARALLAX_RHS=re.useRightHandedSystem,_.PARALLAXOCCLUSION=!!this._useParallaxOcclusion):_.PARALLAX=!1,_.OBJECTSPACE_NORMALMAP=this._useObjectSpaceNormalMap):(_.BUMP=!1,_.PARALLAX=!1,_.PARALLAX_RHS=!1,_.PARALLAXOCCLUSION=!1,_.OBJECTSPACE_NORMALMAP=!1),this._environmentBRDFTexture&&Ms.ReflectionTextureEnabled?(_.ENVIRONMENTBRDF=!0,_.ENVIRONMENTBRDF_RGBD=this._environmentBRDFTexture.isRGBD):(_.ENVIRONMENTBRDF=!1,_.ENVIRONMENTBRDF_RGBD=!1),this._shouldUseAlphaFromAlbedoTexture()?_.ALPHAFROMALBEDO=!0:_.ALPHAFROMALBEDO=!1}_.SPECULAROVERALPHA=this._useSpecularOverAlpha,this._lightFalloff===ua.LIGHTFALLOFF_STANDARD?(_.USEPHYSICALLIGHTFALLOFF=!1,_.USEGLTFLIGHTFALLOFF=!1):this._lightFalloff===ua.LIGHTFALLOFF_GLTF?(_.USEPHYSICALLIGHTFALLOFF=!1,_.USEGLTFLIGHTFALLOFF=!0):(_.USEPHYSICALLIGHTFALLOFF=!0,_.USEGLTFLIGHTFALLOFF=!1),_.RADIANCEOVERALPHA=this._useRadianceOverAlpha,!this.backFaceCulling&&this._twoSidedLighting?_.TWOSIDEDLIGHTING=!0:_.TWOSIDEDLIGHTING=!1,_.SPECULARAA=ae.getCaps().standardDerivatives&&this._enableSpecularAntiAliasing}(_._areTexturesDirty||_._areMiscDirty)&&(_.ALPHATESTVALUE=`${this._alphaCutOff}${this._alphaCutOff%1===0?".":""}`,_.PREMULTIPLYALPHA=this.alphaMode===7||this.alphaMode===8,_.ALPHABLEND=this.needAlphaBlendingForMesh(p),_.ALPHAFRESNEL=this._useAlphaFresnel||this._useLinearAlphaFresnel,_.LINEARALPHAFRESNEL=this._useLinearAlphaFresnel),_._areImageProcessingDirty&&this._imageProcessingConfiguration&&this._imageProcessingConfiguration.prepareDefines(_),_.FORCENORMALFORWARD=this._forceNormalForward,_.RADIANCEOCCLUSION=this._useRadianceOcclusion,_.HORIZONOCCLUSION=this._useHorizonOcclusion,_._areMiscDirty&&(lr.PrepareDefinesForMisc(p,re,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(p)||this._forceAlphaTest,_,this._applyDecalMapAfterDetailMap),_.UNLIT=this._unlit||(this.pointsCloud||this.wireframe)&&!p.isVerticesDataPresent(ut.NormalKind),_.DEBUGMODE=this._debugMode),lr.PrepareDefinesForFrameBoundValues(re,ae,this,_,!!E,I,Z),this._eventInfo.defines=_,this._eventInfo.mesh=p,this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),lr.PrepareDefinesForAttributes(p,_,!0,!0,!0,this._transparencyMode!==ua.PBRMATERIAL_OPAQUE),this._callbackPluginEventPrepareDefines(this._eventInfo)}forceCompilation(p,_,E){const I={clipPlane:!1,useInstances:!1,...E};this._uniformBufferLayoutBuilt||this.buildUniformLayout(),this._callbackPluginEventGeneric(vx.GetDefineNames,this._eventInfo);const Z=new W1(this._eventInfo.defineNames),re=this._prepareEffect(p,Z,void 0,void 0,I.useInstances,I.clipPlane,p.hasThinInstances);this._onEffectCreatedObservable&&(Uu.effect=re,Uu.subMesh=null,this._onEffectCreatedObservable.notifyObservers(Uu)),re.isReady()?_&&_(this):re.onCompileObservable.add(()=>{_&&_(this)})}buildUniformLayout(){const p=this._uniformBuffer;p.addUniform("vAlbedoInfos",2),p.addUniform("vAmbientInfos",4),p.addUniform("vOpacityInfos",2),p.addUniform("vEmissiveInfos",2),p.addUniform("vLightmapInfos",2),p.addUniform("vReflectivityInfos",3),p.addUniform("vMicroSurfaceSamplerInfos",2),p.addUniform("vReflectionInfos",2),p.addUniform("vReflectionFilteringInfo",2),p.addUniform("vReflectionPosition",3),p.addUniform("vReflectionSize",3),p.addUniform("vBumpInfos",3),p.addUniform("albedoMatrix",16),p.addUniform("ambientMatrix",16),p.addUniform("opacityMatrix",16),p.addUniform("emissiveMatrix",16),p.addUniform("lightmapMatrix",16),p.addUniform("reflectivityMatrix",16),p.addUniform("microSurfaceSamplerMatrix",16),p.addUniform("bumpMatrix",16),p.addUniform("vTangentSpaceParams",2),p.addUniform("reflectionMatrix",16),p.addUniform("vReflectionColor",3),p.addUniform("vAlbedoColor",4),p.addUniform("vLightingIntensity",4),p.addUniform("vReflectionMicrosurfaceInfos",3),p.addUniform("pointSize",1),p.addUniform("vReflectivityColor",4),p.addUniform("vEmissiveColor",3),p.addUniform("vAmbientColor",3),p.addUniform("vDebugMode",2),p.addUniform("vMetallicReflectanceFactors",4),p.addUniform("vMetallicReflectanceInfos",2),p.addUniform("metallicReflectanceMatrix",16),p.addUniform("vReflectanceInfos",2),p.addUniform("reflectanceMatrix",16),p.addUniform("vSphericalL00",3),p.addUniform("vSphericalL1_1",3),p.addUniform("vSphericalL10",3),p.addUniform("vSphericalL11",3),p.addUniform("vSphericalL2_2",3),p.addUniform("vSphericalL2_1",3),p.addUniform("vSphericalL20",3),p.addUniform("vSphericalL21",3),p.addUniform("vSphericalL22",3),p.addUniform("vSphericalX",3),p.addUniform("vSphericalY",3),p.addUniform("vSphericalZ",3),p.addUniform("vSphericalXX_ZZ",3),p.addUniform("vSphericalYY_ZZ",3),p.addUniform("vSphericalZZ",3),p.addUniform("vSphericalXY",3),p.addUniform("vSphericalYZ",3),p.addUniform("vSphericalZX",3),super.buildUniformLayout()}bindForSubMesh(p,_,E){const I=this.getScene(),Z=E.materialDefines;if(!Z)return;const re=E.effect;if(!re)return;this._activeEffect=re,_.getMeshUniformBuffer().bindToEffect(re,"Mesh"),_.transferToEffect(p);const ae=I.getEngine();this._uniformBuffer.bindToEffect(re,"Material"),this.prePassConfiguration.bindForSubMesh(this._activeEffect,I,_,p,this.isFrozen),this._eventInfo.subMesh=E,this._callbackPluginEventHardBindForSubMesh(this._eventInfo),Z.OBJECTSPACE_NORMALMAP&&(p.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const he=this._mustRebind(I,re,E,_.visibility);lr.BindBonesParameters(_,this._activeEffect,this.prePassConfiguration);let _e=null;const ve=this._uniformBuffer;if(he){if(this.bindViewProjection(re),_e=this._getReflectionTexture(),!ve.useUbo||!this.isFrozen||!ve.isSync||E._drawWrapper._forceRebindOnNextCall){if(I.texturesEnabled){if(this._albedoTexture&&Ms.DiffuseTextureEnabled&&(ve.updateFloat2("vAlbedoInfos",this._albedoTexture.coordinatesIndex,this._albedoTexture.level),lr.BindTextureMatrix(this._albedoTexture,ve,"albedo")),this._ambientTexture&&Ms.AmbientTextureEnabled&&(ve.updateFloat4("vAmbientInfos",this._ambientTexture.coordinatesIndex,this._ambientTexture.level,this._ambientTextureStrength,this._ambientTextureImpactOnAnalyticalLights),lr.BindTextureMatrix(this._ambientTexture,ve,"ambient")),this._opacityTexture&&Ms.OpacityTextureEnabled&&(ve.updateFloat2("vOpacityInfos",this._opacityTexture.coordinatesIndex,this._opacityTexture.level),lr.BindTextureMatrix(this._opacityTexture,ve,"opacity")),_e&&Ms.ReflectionTextureEnabled){if(ve.updateMatrix("reflectionMatrix",_e.getReflectionTextureMatrix()),ve.updateFloat2("vReflectionInfos",_e.level,0),_e.boundingBoxSize){const Le=_e;ve.updateVector3("vReflectionPosition",Le.boundingBoxPosition),ve.updateVector3("vReflectionSize",Le.boundingBoxSize)}if(this.realTimeFiltering){const Le=_e.getSize().width;ve.updateFloat2("vReflectionFilteringInfo",Le,$t.Log2(Le))}if(!Z.USEIRRADIANCEMAP){const Le=_e.sphericalPolynomial;if(Z.USESPHERICALFROMREFLECTIONMAP&&Le)if(Z.SPHERICAL_HARMONICS){const ze=Le.preScaledHarmonics;ve.updateVector3("vSphericalL00",ze.l00),ve.updateVector3("vSphericalL1_1",ze.l1_1),ve.updateVector3("vSphericalL10",ze.l10),ve.updateVector3("vSphericalL11",ze.l11),ve.updateVector3("vSphericalL2_2",ze.l2_2),ve.updateVector3("vSphericalL2_1",ze.l2_1),ve.updateVector3("vSphericalL20",ze.l20),ve.updateVector3("vSphericalL21",ze.l21),ve.updateVector3("vSphericalL22",ze.l22)}else ve.updateFloat3("vSphericalX",Le.x.x,Le.x.y,Le.x.z),ve.updateFloat3("vSphericalY",Le.y.x,Le.y.y,Le.y.z),ve.updateFloat3("vSphericalZ",Le.z.x,Le.z.y,Le.z.z),ve.updateFloat3("vSphericalXX_ZZ",Le.xx.x-Le.zz.x,Le.xx.y-Le.zz.y,Le.xx.z-Le.zz.z),ve.updateFloat3("vSphericalYY_ZZ",Le.yy.x-Le.zz.x,Le.yy.y-Le.zz.y,Le.yy.z-Le.zz.z),ve.updateFloat3("vSphericalZZ",Le.zz.x,Le.zz.y,Le.zz.z),ve.updateFloat3("vSphericalXY",Le.xy.x,Le.xy.y,Le.xy.z),ve.updateFloat3("vSphericalYZ",Le.yz.x,Le.yz.y,Le.yz.z),ve.updateFloat3("vSphericalZX",Le.zx.x,Le.zx.y,Le.zx.z)}ve.updateFloat3("vReflectionMicrosurfaceInfos",_e.getSize().width,_e.lodGenerationScale,_e.lodGenerationOffset)}this._emissiveTexture&&Ms.EmissiveTextureEnabled&&(ve.updateFloat2("vEmissiveInfos",this._emissiveTexture.coordinatesIndex,this._emissiveTexture.level),lr.BindTextureMatrix(this._emissiveTexture,ve,"emissive")),this._lightmapTexture&&Ms.LightmapTextureEnabled&&(ve.updateFloat2("vLightmapInfos",this._lightmapTexture.coordinatesIndex,this._lightmapTexture.level),lr.BindTextureMatrix(this._lightmapTexture,ve,"lightmap")),Ms.SpecularTextureEnabled&&(this._metallicTexture?(ve.updateFloat3("vReflectivityInfos",this._metallicTexture.coordinatesIndex,this._metallicTexture.level,this._ambientTextureStrength),lr.BindTextureMatrix(this._metallicTexture,ve,"reflectivity")):this._reflectivityTexture&&(ve.updateFloat3("vReflectivityInfos",this._reflectivityTexture.coordinatesIndex,this._reflectivityTexture.level,1),lr.BindTextureMatrix(this._reflectivityTexture,ve,"reflectivity")),this._metallicReflectanceTexture&&(ve.updateFloat2("vMetallicReflectanceInfos",this._metallicReflectanceTexture.coordinatesIndex,this._metallicReflectanceTexture.level),lr.BindTextureMatrix(this._metallicReflectanceTexture,ve,"metallicReflectance")),this._reflectanceTexture&&Z.REFLECTANCE&&(ve.updateFloat2("vReflectanceInfos",this._reflectanceTexture.coordinatesIndex,this._reflectanceTexture.level),lr.BindTextureMatrix(this._reflectanceTexture,ve,"reflectance")),this._microSurfaceTexture&&(ve.updateFloat2("vMicroSurfaceSamplerInfos",this._microSurfaceTexture.coordinatesIndex,this._microSurfaceTexture.level),lr.BindTextureMatrix(this._microSurfaceTexture,ve,"microSurfaceSampler"))),this._bumpTexture&&ae.getCaps().standardDerivatives&&Ms.BumpTextureEnabled&&!this._disableBumpMap&&(ve.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,this._bumpTexture.level,this._parallaxScaleBias),lr.BindTextureMatrix(this._bumpTexture,ve,"bump"),I._mirroredCameraPosition?ve.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?1:-1,this._invertNormalMapY?1:-1):ve.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?-1:1,this._invertNormalMapY?-1:1))}if(this.pointsCloud&&ve.updateFloat("pointSize",this.pointSize),Z.METALLICWORKFLOW){jn.Color3[0].r=this._metallic===void 0||this._metallic===null?1:this._metallic,jn.Color3[0].g=this._roughness===void 0||this._roughness===null?1:this._roughness,ve.updateColor4("vReflectivityColor",jn.Color3[0],1);const Le=this.subSurface?._indexOfRefraction??1.5,ze=1,He=Math.pow((Le-ze)/(Le+ze),2);this._metallicReflectanceColor.scaleToRef(He*this._metallicF0Factor,jn.Color3[0]);const xt=this._metallicF0Factor;ve.updateColor4("vMetallicReflectanceFactors",jn.Color3[0],xt)}else ve.updateColor4("vReflectivityColor",this._reflectivityColor,this._microSurface);ve.updateColor3("vEmissiveColor",Ms.EmissiveTextureEnabled?this._emissiveColor:Rs.BlackReadOnly),ve.updateColor3("vReflectionColor",this._reflectionColor),!Z.SS_REFRACTION&&this.subSurface?._linkRefractionWithTransparency?ve.updateColor4("vAlbedoColor",this._albedoColor,1):ve.updateColor4("vAlbedoColor",this._albedoColor,this.alpha),this._lightingInfos.x=this._directIntensity,this._lightingInfos.y=this._emissiveIntensity,this._lightingInfos.z=this._environmentIntensity*I.environmentIntensity,this._lightingInfos.w=this._specularIntensity,ve.updateVector4("vLightingIntensity",this._lightingInfos),I.ambientColor.multiplyToRef(this._ambientColor,this._globalAmbientColor),ve.updateColor3("vAmbientColor",this._globalAmbientColor),ve.updateFloat2("vDebugMode",this.debugLimit,this.debugFactor)}I.texturesEnabled&&(this._albedoTexture&&Ms.DiffuseTextureEnabled&&ve.setTexture("albedoSampler",this._albedoTexture),this._ambientTexture&&Ms.AmbientTextureEnabled&&ve.setTexture("ambientSampler",this._ambientTexture),this._opacityTexture&&Ms.OpacityTextureEnabled&&ve.setTexture("opacitySampler",this._opacityTexture),_e&&Ms.ReflectionTextureEnabled&&(Z.LODBASEDMICROSFURACE?ve.setTexture("reflectionSampler",_e):(ve.setTexture("reflectionSampler",_e._lodTextureMid||_e),ve.setTexture("reflectionSamplerLow",_e._lodTextureLow||_e),ve.setTexture("reflectionSamplerHigh",_e._lodTextureHigh||_e)),Z.USEIRRADIANCEMAP&&ve.setTexture("irradianceSampler",_e.irradianceTexture)),Z.ENVIRONMENTBRDF&&ve.setTexture("environmentBrdfSampler",this._environmentBRDFTexture),this._emissiveTexture&&Ms.EmissiveTextureEnabled&&ve.setTexture("emissiveSampler",this._emissiveTexture),this._lightmapTexture&&Ms.LightmapTextureEnabled&&ve.setTexture("lightmapSampler",this._lightmapTexture),Ms.SpecularTextureEnabled&&(this._metallicTexture?ve.setTexture("reflectivitySampler",this._metallicTexture):this._reflectivityTexture&&ve.setTexture("reflectivitySampler",this._reflectivityTexture),this._metallicReflectanceTexture&&ve.setTexture("metallicReflectanceSampler",this._metallicReflectanceTexture),this._reflectanceTexture&&Z.REFLECTANCE&&ve.setTexture("reflectanceSampler",this._reflectanceTexture),this._microSurfaceTexture&&ve.setTexture("microSurfaceSampler",this._microSurfaceTexture)),this._bumpTexture&&ae.getCaps().standardDerivatives&&Ms.BumpTextureEnabled&&!this._disableBumpMap&&ve.setTexture("bumpSampler",this._bumpTexture)),this.getScene().useOrderIndependentTransparency&&this.needAlphaBlendingForMesh(_)&&this.getScene().depthPeelingRenderer.bind(re),this._eventInfo.subMesh=E,this._callbackPluginEventBindForSubMesh(this._eventInfo),Tb(this._activeEffect,this,I),this.bindEyePosition(re)}else I.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0);(he||!this.isFrozen)&&(I.lightsEnabled&&!this._disableLighting&&lr.BindLights(I,_,this._activeEffect,Z,this._maxSimultaneousLights),(I.fogEnabled&&_.applyFog&&I.fogMode!==U0.FOGMODE_NONE||_e||this.subSurface.refractionTexture||_.receiveShadows||Z.PREPASS)&&this.bindView(re),lr.BindFogParameters(I,_,this._activeEffect,!0),Z.NUM_MORPH_INFLUENCERS&&lr.BindMorphTargetParameters(_,this._activeEffect),Z.BAKED_VERTEX_ANIMATION_TEXTURE&&_.bakedVertexAnimationManager?.bind(re,Z.INSTANCES),this._imageProcessingConfiguration.bind(this._activeEffect),lr.BindLogDepth(Z,this._activeEffect,I)),this._afterBind(_,this._activeEffect,E),ve.update()}getAnimatables(){const p=super.getAnimatables();return this._albedoTexture&&this._albedoTexture.animations&&this._albedoTexture.animations.length>0&&p.push(this._albedoTexture),this._ambientTexture&&this._ambientTexture.animations&&this._ambientTexture.animations.length>0&&p.push(this._ambientTexture),this._opacityTexture&&this._opacityTexture.animations&&this._opacityTexture.animations.length>0&&p.push(this._opacityTexture),this._reflectionTexture&&this._reflectionTexture.animations&&this._reflectionTexture.animations.length>0&&p.push(this._reflectionTexture),this._emissiveTexture&&this._emissiveTexture.animations&&this._emissiveTexture.animations.length>0&&p.push(this._emissiveTexture),this._metallicTexture&&this._metallicTexture.animations&&this._metallicTexture.animations.length>0?p.push(this._metallicTexture):this._reflectivityTexture&&this._reflectivityTexture.animations&&this._reflectivityTexture.animations.length>0&&p.push(this._reflectivityTexture),this._bumpTexture&&this._bumpTexture.animations&&this._bumpTexture.animations.length>0&&p.push(this._bumpTexture),this._lightmapTexture&&this._lightmapTexture.animations&&this._lightmapTexture.animations.length>0&&p.push(this._lightmapTexture),this._metallicReflectanceTexture&&this._metallicReflectanceTexture.animations&&this._metallicReflectanceTexture.animations.length>0&&p.push(this._metallicReflectanceTexture),this._reflectanceTexture&&this._reflectanceTexture.animations&&this._reflectanceTexture.animations.length>0&&p.push(this._reflectanceTexture),this._microSurfaceTexture&&this._microSurfaceTexture.animations&&this._microSurfaceTexture.animations.length>0&&p.push(this._microSurfaceTexture),p}_getReflectionTexture(){return this._reflectionTexture?this._reflectionTexture:this.getScene().environmentTexture}getActiveTextures(){const p=super.getActiveTextures();return this._albedoTexture&&p.push(this._albedoTexture),this._ambientTexture&&p.push(this._ambientTexture),this._opacityTexture&&p.push(this._opacityTexture),this._reflectionTexture&&p.push(this._reflectionTexture),this._emissiveTexture&&p.push(this._emissiveTexture),this._reflectivityTexture&&p.push(this._reflectivityTexture),this._metallicTexture&&p.push(this._metallicTexture),this._metallicReflectanceTexture&&p.push(this._metallicReflectanceTexture),this._reflectanceTexture&&p.push(this._reflectanceTexture),this._microSurfaceTexture&&p.push(this._microSurfaceTexture),this._bumpTexture&&p.push(this._bumpTexture),this._lightmapTexture&&p.push(this._lightmapTexture),p}hasTexture(p){return!!(super.hasTexture(p)||this._albedoTexture===p||this._ambientTexture===p||this._opacityTexture===p||this._reflectionTexture===p||this._emissiveTexture===p||this._reflectivityTexture===p||this._metallicTexture===p||this._metallicReflectanceTexture===p||this._reflectanceTexture===p||this._microSurfaceTexture===p||this._bumpTexture===p||this._lightmapTexture===p)}setPrePassRenderer(){if(!this.subSurface?.isScatteringEnabled)return!1;const p=this.getScene().enableSubSurfaceForPrePass();return p&&(p.enabled=!0),!0}dispose(p,_){_&&(this._environmentBRDFTexture&&this.getScene().environmentBRDFTexture!==this._environmentBRDFTexture&&this._environmentBRDFTexture.dispose(),this._albedoTexture?.dispose(),this._ambientTexture?.dispose(),this._opacityTexture?.dispose(),this._reflectionTexture?.dispose(),this._emissiveTexture?.dispose(),this._metallicTexture?.dispose(),this._reflectivityTexture?.dispose(),this._bumpTexture?.dispose(),this._lightmapTexture?.dispose(),this._metallicReflectanceTexture?.dispose(),this._reflectanceTexture?.dispose(),this._microSurfaceTexture?.dispose()),this._renderTargets.dispose(),this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(p,_)}}ua.PBRMATERIAL_OPAQUE=zi.MATERIAL_OPAQUE,ua.PBRMATERIAL_ALPHATEST=zi.MATERIAL_ALPHATEST,ua.PBRMATERIAL_ALPHABLEND=zi.MATERIAL_ALPHABLEND,ua.PBRMATERIAL_ALPHATESTANDBLEND=zi.MATERIAL_ALPHATESTANDBLEND,ua.DEFAULT_AO_ON_ANALYTICAL_LIGHTS=0,ua.LIGHTFALLOFF_PHYSICAL=0,ua.LIGHTFALLOFF_GLTF=1,ua.LIGHTFALLOFF_STANDARD=2,Rt([kM()],ua.prototype,"_imageProcessingConfiguration",void 0),Rt([ws("_markAllSubMeshesAsMiscDirty")],ua.prototype,"debugMode",void 0);class Ys extends ua{get refractionTexture(){return this.subSurface.refractionTexture}set refractionTexture(p){this.subSurface.refractionTexture=p,p?this.subSurface.isRefractionEnabled=!0:this.subSurface.linkRefractionWithTransparency||(this.subSurface.isRefractionEnabled=!1)}get indexOfRefraction(){return this.subSurface.indexOfRefraction}set indexOfRefraction(p){this.subSurface.indexOfRefraction=p}get invertRefractionY(){return this.subSurface.invertRefractionY}set invertRefractionY(p){this.subSurface.invertRefractionY=p}get linkRefractionWithTransparency(){return this.subSurface.linkRefractionWithTransparency}set linkRefractionWithTransparency(p){this.subSurface.linkRefractionWithTransparency=p,p&&(this.subSurface.isRefractionEnabled=!0)}get usePhysicalLightFalloff(){return this._lightFalloff===ua.LIGHTFALLOFF_PHYSICAL}set usePhysicalLightFalloff(p){p!==this.usePhysicalLightFalloff&&(this._markAllSubMeshesAsTexturesDirty(),p?this._lightFalloff=ua.LIGHTFALLOFF_PHYSICAL:this._lightFalloff=ua.LIGHTFALLOFF_STANDARD)}get useGLTFLightFalloff(){return this._lightFalloff===ua.LIGHTFALLOFF_GLTF}set useGLTFLightFalloff(p){p!==this.useGLTFLightFalloff&&(this._markAllSubMeshesAsTexturesDirty(),p?this._lightFalloff=ua.LIGHTFALLOFF_GLTF:this._lightFalloff=ua.LIGHTFALLOFF_STANDARD)}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(p){this._attachImageProcessingConfiguration(p),this._markAllSubMeshesAsTexturesDirty()}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(p){this.imageProcessingConfiguration.colorCurvesEnabled=p}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(p){this.imageProcessingConfiguration.colorGradingEnabled=p}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(p){this._imageProcessingConfiguration.toneMappingEnabled=p}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(p){this._imageProcessingConfiguration.exposure=p}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(p){this._imageProcessingConfiguration.contrast=p}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(p){this._imageProcessingConfiguration.colorGradingTexture=p}get cameraColorCurves(){return this._imageProcessingConfiguration.colorCurves}set cameraColorCurves(p){this._imageProcessingConfiguration.colorCurves=p}constructor(p,_){super(p,_),this.directIntensity=1,this.emissiveIntensity=1,this.environmentIntensity=1,this.specularIntensity=1,this.disableBumpMap=!1,this.ambientTextureStrength=1,this.ambientTextureImpactOnAnalyticalLights=Ys.DEFAULT_AO_ON_ANALYTICAL_LIGHTS,this.metallicF0Factor=1,this.metallicReflectanceColor=Rs.White(),this.useOnlyMetallicFromMetallicReflectanceTexture=!1,this.ambientColor=new Rs(0,0,0),this.albedoColor=new Rs(1,1,1),this.reflectivityColor=new Rs(1,1,1),this.reflectionColor=new Rs(1,1,1),this.emissiveColor=new Rs(0,0,0),this.microSurface=1,this.useLightmapAsShadowmap=!1,this.useAlphaFromAlbedoTexture=!1,this.forceAlphaTest=!1,this.alphaCutOff=.4,this.useSpecularOverAlpha=!0,this.useMicroSurfaceFromReflectivityMapAlpha=!1,this.useRoughnessFromMetallicTextureAlpha=!0,this.useRoughnessFromMetallicTextureGreen=!1,this.useMetallnessFromMetallicTextureBlue=!1,this.useAmbientOcclusionFromMetallicTextureRed=!1,this.useAmbientInGrayScale=!1,this.useAutoMicroSurfaceFromReflectivityMap=!1,this.useRadianceOverAlpha=!0,this.useObjectSpaceNormalMap=!1,this.useParallax=!1,this.useParallaxOcclusion=!1,this.parallaxScaleBias=.05,this.disableLighting=!1,this.forceIrradianceInFragment=!1,this.maxSimultaneousLights=4,this.invertNormalMapX=!1,this.invertNormalMapY=!1,this.twoSidedLighting=!1,this.useAlphaFresnel=!1,this.useLinearAlphaFresnel=!1,this.environmentBRDFTexture=null,this.forceNormalForward=!1,this.enableSpecularAntiAliasing=!1,this.useHorizonOcclusion=!0,this.useRadianceOcclusion=!0,this.unlit=!1,this.applyDecalMapAfterDetailMap=!1,this._environmentBRDFTexture=o_(this.getScene())}getClassName(){return"PBRMaterial"}clone(p,_=!0,E=""){const I=Hr.Clone(()=>new Ys(p,this.getScene()),this,{cloneTexturesOnlyOnce:_});return I.id=p,I.name=p,this.stencil.copyTo(I.stencil),this._clonePlugins(I,E),I}serialize(){const p=super.serialize();return p.customType="BABYLON.PBRMaterial",p}static Parse(p,_,E){const I=Hr.Parse(()=>new Ys(p.name,_),p,_,E);return p.stencil&&I.stencil.parse(p.stencil,_,E),zi._ParsePlugins(p,I,_,E),p.clearCoat&&I.clearCoat.parse(p.clearCoat,_,E),p.anisotropy&&I.anisotropy.parse(p.anisotropy,_,E),p.brdf&&I.brdf.parse(p.brdf,_,E),p.sheen&&I.sheen.parse(p.sheen,_,E),p.subSurface&&I.subSurface.parse(p.subSurface,_,E),p.iridescence&&I.iridescence.parse(p.iridescence,_,E),I}}Ys.PBRMATERIAL_OPAQUE=ua.PBRMATERIAL_OPAQUE,Ys.PBRMATERIAL_ALPHATEST=ua.PBRMATERIAL_ALPHATEST,Ys.PBRMATERIAL_ALPHABLEND=ua.PBRMATERIAL_ALPHABLEND,Ys.PBRMATERIAL_ALPHATESTANDBLEND=ua.PBRMATERIAL_ALPHATESTANDBLEND,Ys.DEFAULT_AO_ON_ANALYTICAL_LIGHTS=ua.DEFAULT_AO_ON_ANALYTICAL_LIGHTS,Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"directIntensity",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"emissiveIntensity",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"environmentIntensity",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"specularIntensity",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"disableBumpMap",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"albedoTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"ambientTexture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"ambientTextureStrength",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"ambientTextureImpactOnAnalyticalLights",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesAndMiscDirty")],Ys.prototype,"opacityTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"reflectionTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"emissiveTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"reflectivityTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"metallicTexture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"metallic",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"roughness",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"metallicF0Factor",void 0),Rt([Ya(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"metallicReflectanceColor",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useOnlyMetallicFromMetallicReflectanceTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"metallicReflectanceTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"reflectanceTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"microSurfaceTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"bumpTexture",void 0),Rt([Hn(),ws("_markAllSubMeshesAsTexturesDirty",null)],Ys.prototype,"lightmapTexture",void 0),Rt([Ya("ambient"),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"ambientColor",void 0),Rt([Ya("albedo"),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"albedoColor",void 0),Rt([Ya("reflectivity"),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"reflectivityColor",void 0),Rt([Ya("reflection"),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"reflectionColor",void 0),Rt([Ya("emissive"),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"emissiveColor",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"microSurface",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useLightmapAsShadowmap",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesAndMiscDirty")],Ys.prototype,"useAlphaFromAlbedoTexture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesAndMiscDirty")],Ys.prototype,"forceAlphaTest",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesAndMiscDirty")],Ys.prototype,"alphaCutOff",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useSpecularOverAlpha",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useMicroSurfaceFromReflectivityMapAlpha",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useRoughnessFromMetallicTextureAlpha",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useRoughnessFromMetallicTextureGreen",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useMetallnessFromMetallicTextureBlue",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useAmbientOcclusionFromMetallicTextureRed",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useAmbientInGrayScale",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useAutoMicroSurfaceFromReflectivityMap",void 0),Rt([Ut()],Ys.prototype,"usePhysicalLightFalloff",null),Rt([Ut()],Ys.prototype,"useGLTFLightFalloff",null),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useRadianceOverAlpha",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useObjectSpaceNormalMap",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useParallax",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useParallaxOcclusion",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"parallaxScaleBias",void 0),Rt([Ut(),ws("_markAllSubMeshesAsLightsDirty")],Ys.prototype,"disableLighting",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"forceIrradianceInFragment",void 0),Rt([Ut(),ws("_markAllSubMeshesAsLightsDirty")],Ys.prototype,"maxSimultaneousLights",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"invertNormalMapX",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"invertNormalMapY",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"twoSidedLighting",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useAlphaFresnel",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useLinearAlphaFresnel",void 0),Rt([ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"environmentBRDFTexture",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"forceNormalForward",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"enableSpecularAntiAliasing",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useHorizonOcclusion",void 0),Rt([Ut(),ws("_markAllSubMeshesAsTexturesDirty")],Ys.prototype,"useRadianceOcclusion",void 0),Rt([Ut(),ws("_markAllSubMeshesAsMiscDirty")],Ys.prototype,"unlit",void 0),Rt([Ut(),ws("_markAllSubMeshesAsMiscDirty")],Ys.prototype,"applyDecalMapAfterDetailMap",void 0),Gs("BABYLON.PBRMaterial",Ys);class cx{get boundingBias(){return this._boundingBias}set boundingBias(p){this._boundingBias?this._boundingBias.copyFrom(p):this._boundingBias=p.clone(),this._updateBoundingInfo(!0,null)}static CreateGeometryForMesh(p){const _=new cx(cx.RandomId(),p.getScene());return _.applyToMesh(p),_}get meshes(){return this._meshes}constructor(p,_,E,I=!1,Z=null){this.delayLoadState=0,this._totalVertices=0,this._isDisposed=!1,this._indexBufferIsUpdatable=!1,this._positionsCache=[],this._parentContainer=null,this.useBoundingInfoFromGeometry=!1,this._scene=_||Mr.LastCreatedScene,this._scene&&(this.id=p,this.uniqueId=this._scene.getUniqueId(),this._engine=this._scene.getEngine(),this._meshes=[],this._vertexBuffers={},this._indices=[],this._updatable=I,E?this.setAllVerticesData(E,I):this._totalVertices=0,this._engine.getCaps().vertexArrayObject&&(this._vertexArrayObjects={}),Z&&(this.applyToMesh(Z),Z.computeWorldMatrix(!0)))}get extend(){return this._extend}getScene(){return this._scene}getEngine(){return this._engine}isReady(){return this.delayLoadState===1||this.delayLoadState===0}get doNotSerialize(){for(let p=0;p<this._meshes.length;p++)if(!this._meshes[p].doNotSerialize)return!1;return!0}_rebuild(){this._vertexArrayObjects&&(this._vertexArrayObjects={}),this._meshes.length!==0&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable,"Geometry_"+this.id+"_IndexBuffer"));const p=new Set;for(const _ in this._vertexBuffers)p.add(this._vertexBuffers[_].getWrapperBuffer());p.forEach(_=>{_._rebuild()})}setAllVerticesData(p,_){p.applyToGeometry(this,_),this._notifyUpdate()}setVerticesData(p,_,E=!1,I){E&&Array.isArray(_)&&(_=new Float32Array(_));const Z=new ut(this._engine,_,p,{updatable:E,postponeInternalCreation:this._meshes.length===0,stride:I,label:"Geometry_"+this.id+"_"+p});this.setVerticesBuffer(Z)}removeVerticesData(p){this._vertexBuffers[p]&&(this._vertexBuffers[p].dispose(),delete this._vertexBuffers[p]),this._vertexArrayObjects&&this._disposeVertexArrayObjects()}setVerticesBuffer(p,_=null,E=!0){const I=p.getKind();this._vertexBuffers[I]&&E&&this._vertexBuffers[I].dispose(),p._buffer&&p._buffer._increaseReferences(),this._vertexBuffers[I]=p;const Z=this._meshes,re=Z.length;if(I===ut.PositionKind){this._totalVertices=_??p._maxVerticesCount,this._updateExtend(p.getFloatData(this._totalVertices)),this._resetPointsArrayCache();const ae=this._extend&&this._extend.minimum||new at(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),he=this._extend&&this._extend.maximum||new at(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);for(let _e=0;_e<re;_e++){const ve=Z[_e];ve.buildBoundingInfo(ae,he),ve._createGlobalSubMesh(ve.isUnIndexed),ve.computeWorldMatrix(!0),ve.synchronizeInstances()}}this._notifyUpdate(I)}updateVerticesDataDirectly(p,_,E,I=!1){const Z=this.getVertexBuffer(p);Z&&(Z.updateDirectly(_,E,I),this._notifyUpdate(p))}updateVerticesData(p,_,E=!1){const I=this.getVertexBuffer(p);I&&(I.update(_),p===ut.PositionKind&&this._updateBoundingInfo(E,_),this._notifyUpdate(p))}_updateBoundingInfo(p,_){if(p&&this._updateExtend(_),this._resetPointsArrayCache(),p){const E=this._meshes;for(const I of E){I.hasBoundingInfo?I.getBoundingInfo().reConstruct(this._extend.minimum,this._extend.maximum):I.buildBoundingInfo(this._extend.minimum,this._extend.maximum);const Z=I.subMeshes;for(const re of Z)re.refreshBoundingInfo()}}}_bind(p,_,E,I){if(!p)return;_===void 0&&(_=this._indexBuffer);const Z=this.getVertexBuffers();if(!Z)return;if(_!=this._indexBuffer||!this._vertexArrayObjects&&!I){this._engine.bindBuffers(Z,_,p,E);return}const re=I||this._vertexArrayObjects;re[p.key]||(re[p.key]=this._engine.recordVertexArrayObject(Z,_,p,E)),this._engine.bindVertexArrayObject(re[p.key],_)}getTotalVertices(){return this.isReady()?this._totalVertices:0}getVerticesData(p,_,E){const I=this.getVertexBuffer(p);return I?I.getFloatData(this._totalVertices,E||_&&this._meshes.length!==1):null}isVertexBufferUpdatable(p){const _=this._vertexBuffers[p];return _?_.isUpdatable():!1}getVertexBuffer(p){return this.isReady()?this._vertexBuffers[p]:null}getVertexBuffers(){return this.isReady()?this._vertexBuffers:null}isVerticesDataPresent(p){return this._vertexBuffers?this._vertexBuffers[p]!==void 0:this._delayInfo?this._delayInfo.indexOf(p)!==-1:!1}getVerticesDataKinds(){const p=[];let _;if(!this._vertexBuffers&&this._delayInfo)for(_ in this._delayInfo)p.push(_);else for(_ in this._vertexBuffers)p.push(_);return p}updateIndices(p,_,E=!1){if(this._indexBuffer)if(!this._indexBufferIsUpdatable)this.setIndices(p,null,!0);else{const I=p.length!==this._indices.length;if(E||(this._indices=p.slice()),this._engine.updateDynamicIndexBuffer(this._indexBuffer,p,_),I)for(const Z of this._meshes)Z._createGlobalSubMesh(!0)}}setIndexBuffer(p,_,E){this._indices=[],this._indexBufferIsUpdatable=!1,this._indexBuffer=p,this._totalVertices=_,this._totalIndices=E,p.is32Bits||(p.is32Bits=this._totalIndices>65535);for(const I of this._meshes)I._createGlobalSubMesh(!0),I.synchronizeInstances();this._notifyUpdate()}setIndices(p,_=null,E=!1){this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indices=p,this._indexBufferIsUpdatable=E,this._meshes.length!==0&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,E,"Geometry_"+this.id+"_IndexBuffer")),_!=null&&(this._totalVertices=_);for(const I of this._meshes)I._createGlobalSubMesh(!0),I.synchronizeInstances();this._notifyUpdate()}getTotalIndices(){return this.isReady()?this._totalIndices!==void 0?this._totalIndices:this._indices.length:0}getIndices(p,_){if(!this.isReady())return null;const E=this._indices;return!_&&(!p||this._meshes.length===1)?E:E.slice()}getIndexBuffer(){return this.isReady()?this._indexBuffer:null}_releaseVertexArrayObject(p=null){!p||!this._vertexArrayObjects||this._vertexArrayObjects[p.key]&&(this._engine.releaseVertexArrayObject(this._vertexArrayObjects[p.key]),delete this._vertexArrayObjects[p.key])}releaseForMesh(p,_){const E=this._meshes,I=E.indexOf(p);I!==-1&&(E.splice(I,1),this._vertexArrayObjects&&p._invalidateInstanceVertexArrayObject(),p._geometry=null,E.length===0&&_&&this.dispose())}applyToMesh(p){if(p._geometry===this)return;const _=p._geometry;_&&_.releaseForMesh(p),this._vertexArrayObjects&&p._invalidateInstanceVertexArrayObject();const E=this._meshes;p._geometry=this,p._internalAbstractMeshDataInfo._positions=null,this._scene.pushGeometry(this),E.push(p),this.isReady()?this._applyToMesh(p):this._boundingInfo&&p.setBoundingInfo(this._boundingInfo)}_updateExtend(p=null){if(this.useBoundingInfoFromGeometry&&this._boundingInfo)this._extend={minimum:this._boundingInfo.minimum.clone(),maximum:this._boundingInfo.maximum.clone()};else{if(!p&&(p=this.getVerticesData(ut.PositionKind),!p))return;this._extend=pb(p,0,this._totalVertices,this.boundingBias,3)}}_applyToMesh(p){const _=this._meshes.length;for(const E in this._vertexBuffers)_===1&&this._vertexBuffers[E].create(),E===ut.PositionKind&&(this._extend||this._updateExtend(),p.buildBoundingInfo(this._extend.minimum,this._extend.maximum),p._createGlobalSubMesh(p.isUnIndexed),p._updateBoundingInfo());_===1&&this._indices&&this._indices.length>0&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable,"Geometry_"+this.id+"_IndexBuffer")),p._syncGeometryWithMorphTargetManager(),p.synchronizeInstances()}_notifyUpdate(p){this.onGeometryUpdated&&this.onGeometryUpdated(this,p),this._vertexArrayObjects&&this._disposeVertexArrayObjects();for(const _ of this._meshes)_._markSubMeshesAsAttributesDirty()}load(p,_){if(this.delayLoadState!==2){if(this.isReady()){_&&_();return}this.delayLoadState=2,this._queueLoad(p,_)}}_queueLoad(p,_){this.delayLoadingFile&&(p.addPendingData(this),p._loadFile(this.delayLoadingFile,E=>{if(!this._delayLoadingFunction)return;this._delayLoadingFunction(JSON.parse(E),this),this.delayLoadState=1,this._delayInfo=[],p.removePendingData(this);const I=this._meshes,Z=I.length;for(let re=0;re<Z;re++)this._applyToMesh(I[re]);_&&_()},void 0,!0))}toLeftHanded(){const p=this.getIndices(!1);if(p!=null&&p.length>0){for(let I=0;I<p.length;I+=3){const Z=p[I+0];p[I+0]=p[I+2],p[I+2]=Z}this.setIndices(p)}const _=this.getVerticesData(ut.PositionKind,!1);if(_!=null&&_.length>0){for(let I=0;I<_.length;I+=3)_[I+2]=-_[I+2];this.setVerticesData(ut.PositionKind,_,!1)}const E=this.getVerticesData(ut.NormalKind,!1);if(E!=null&&E.length>0){for(let I=0;I<E.length;I+=3)E[I+2]=-E[I+2];this.setVerticesData(ut.NormalKind,E,!1)}}_resetPointsArrayCache(){this._positions=null}_generatePointsArray(){if(this._positions)return!0;const p=this.getVerticesData(ut.PositionKind);if(!p||p.length===0)return!1;for(let _=this._positionsCache.length*3,E=this._positionsCache.length;_<p.length;_+=3,++E)this._positionsCache[E]=at.FromArray(p,_);for(let _=0,E=0;_<p.length;_+=3,++E)this._positionsCache[E].set(p[0+_],p[1+_],p[2+_]);return this._positionsCache.length=p.length/3,this._positions=this._positionsCache,!0}isDisposed(){return this._isDisposed}_disposeVertexArrayObjects(){if(this._vertexArrayObjects){for(const E in this._vertexArrayObjects)this._engine.releaseVertexArrayObject(this._vertexArrayObjects[E]);this._vertexArrayObjects={};const p=this._meshes,_=p.length;for(let E=0;E<_;E++)p[E]._invalidateInstanceVertexArrayObject()}}dispose(){const p=this._meshes,_=p.length;let E;for(E=0;E<_;E++)this.releaseForMesh(p[E]);this._meshes.length=0,this._disposeVertexArrayObjects();for(const I in this._vertexBuffers)this._vertexBuffers[I].dispose();if(this._vertexBuffers={},this._totalVertices=0,this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null,this._indices=[],this.delayLoadState=0,this.delayLoadingFile=null,this._delayLoadingFunction=null,this._delayInfo=[],this._boundingInfo=null,this._scene.removeGeometry(this),this._parentContainer){const I=this._parentContainer.geometries.indexOf(this);I>-1&&this._parentContainer.geometries.splice(I,1),this._parentContainer=null}this._isDisposed=!0}copy(p){const _=new Xr;_.indices=[];const E=this.getIndices();if(E)for(let he=0;he<E.length;he++)_.indices.push(E[he]);let I=!1,Z=!1,re;for(re in this._vertexBuffers){const he=this.getVerticesData(re);if(he&&(he instanceof Float32Array?_.set(new Float32Array(he),re):_.set(he.slice(0),re),!Z)){const _e=this.getVertexBuffer(re);_e&&(I=_e.isUpdatable(),Z=!I)}}const ae=new cx(p,this._scene,_,I);ae.delayLoadState=this.delayLoadState,ae.delayLoadingFile=this.delayLoadingFile,ae._delayLoadingFunction=this._delayLoadingFunction;for(re in this._delayInfo)ae._delayInfo=ae._delayInfo||[],ae._delayInfo.push(re);return ae._boundingInfo=new uo(this._extend.minimum,this._extend.maximum),ae}serialize(){const p={};return p.id=this.id,p.uniqueId=this.uniqueId,p.updatable=this._updatable,ri&&ri.HasTags(this)&&(p.tags=ri.GetTags(this)),p}_toNumberArray(p){return Array.isArray(p)?p:Array.prototype.slice.call(p)}clearCachedData(){this._indices=[],this._resetPointsArrayCache();for(const p in this._vertexBuffers)Object.prototype.hasOwnProperty.call(this._vertexBuffers,p)&&(this._vertexBuffers[p]._buffer._data=null)}serializeVerticeData(){const p=this.serialize();return this.isVerticesDataPresent(ut.PositionKind)&&(p.positions=this._toNumberArray(this.getVerticesData(ut.PositionKind)),this.isVertexBufferUpdatable(ut.PositionKind)&&(p.positions._updatable=!0)),this.isVerticesDataPresent(ut.NormalKind)&&(p.normals=this._toNumberArray(this.getVerticesData(ut.NormalKind)),this.isVertexBufferUpdatable(ut.NormalKind)&&(p.normals._updatable=!0)),this.isVerticesDataPresent(ut.TangentKind)&&(p.tangents=this._toNumberArray(this.getVerticesData(ut.TangentKind)),this.isVertexBufferUpdatable(ut.TangentKind)&&(p.tangents._updatable=!0)),this.isVerticesDataPresent(ut.UVKind)&&(p.uvs=this._toNumberArray(this.getVerticesData(ut.UVKind)),this.isVertexBufferUpdatable(ut.UVKind)&&(p.uvs._updatable=!0)),this.isVerticesDataPresent(ut.UV2Kind)&&(p.uvs2=this._toNumberArray(this.getVerticesData(ut.UV2Kind)),this.isVertexBufferUpdatable(ut.UV2Kind)&&(p.uvs2._updatable=!0)),this.isVerticesDataPresent(ut.UV3Kind)&&(p.uvs3=this._toNumberArray(this.getVerticesData(ut.UV3Kind)),this.isVertexBufferUpdatable(ut.UV3Kind)&&(p.uvs3._updatable=!0)),this.isVerticesDataPresent(ut.UV4Kind)&&(p.uvs4=this._toNumberArray(this.getVerticesData(ut.UV4Kind)),this.isVertexBufferUpdatable(ut.UV4Kind)&&(p.uvs4._updatable=!0)),this.isVerticesDataPresent(ut.UV5Kind)&&(p.uvs5=this._toNumberArray(this.getVerticesData(ut.UV5Kind)),this.isVertexBufferUpdatable(ut.UV5Kind)&&(p.uvs5._updatable=!0)),this.isVerticesDataPresent(ut.UV6Kind)&&(p.uvs6=this._toNumberArray(this.getVerticesData(ut.UV6Kind)),this.isVertexBufferUpdatable(ut.UV6Kind)&&(p.uvs6._updatable=!0)),this.isVerticesDataPresent(ut.ColorKind)&&(p.colors=this._toNumberArray(this.getVerticesData(ut.ColorKind)),this.isVertexBufferUpdatable(ut.ColorKind)&&(p.colors._updatable=!0)),this.isVerticesDataPresent(ut.MatricesIndicesKind)&&(p.matricesIndices=this._toNumberArray(this.getVerticesData(ut.MatricesIndicesKind)),p.matricesIndices._isExpanded=!0,this.isVertexBufferUpdatable(ut.MatricesIndicesKind)&&(p.matricesIndices._updatable=!0)),this.isVerticesDataPresent(ut.MatricesWeightsKind)&&(p.matricesWeights=this._toNumberArray(this.getVerticesData(ut.MatricesWeightsKind)),this.isVertexBufferUpdatable(ut.MatricesWeightsKind)&&(p.matricesWeights._updatable=!0)),p.indices=this._toNumberArray(this.getIndices()),p}static ExtractFromMesh(p,_){const E=p._geometry;return E?E.copy(_):null}static RandomId(){return lt.RandomId()}static _GetGeometryByLoadedUniqueId(p,_){for(let E=0;E<_.geometries.length;E++)if(_.geometries[E]._loadedUniqueId===p)return _.geometries[E];return null}static _ImportGeometry(p,_){const E=_.getScene(),I=p.geometryUniqueId,Z=p.geometryId;if(I||Z){const re=I?this._GetGeometryByLoadedUniqueId(I,E):E.getGeometryById(Z);re&&re.applyToMesh(_)}else if(p instanceof ArrayBuffer){const re=_._binaryInfo;if(re.positionsAttrDesc&&re.positionsAttrDesc.count>0){const ae=new Float32Array(p,re.positionsAttrDesc.offset,re.positionsAttrDesc.count);_.setVerticesData(ut.PositionKind,ae,!1)}if(re.normalsAttrDesc&&re.normalsAttrDesc.count>0){const ae=new Float32Array(p,re.normalsAttrDesc.offset,re.normalsAttrDesc.count);_.setVerticesData(ut.NormalKind,ae,!1)}if(re.tangetsAttrDesc&&re.tangetsAttrDesc.count>0){const ae=new Float32Array(p,re.tangetsAttrDesc.offset,re.tangetsAttrDesc.count);_.setVerticesData(ut.TangentKind,ae,!1)}if(re.uvsAttrDesc&&re.uvsAttrDesc.count>0){const ae=new Float32Array(p,re.uvsAttrDesc.offset,re.uvsAttrDesc.count);if(rh.UseOpenGLOrientationForUV)for(let he=1;he<ae.length;he+=2)ae[he]=1-ae[he];_.setVerticesData(ut.UVKind,ae,!1)}if(re.uvs2AttrDesc&&re.uvs2AttrDesc.count>0){const ae=new Float32Array(p,re.uvs2AttrDesc.offset,re.uvs2AttrDesc.count);if(rh.UseOpenGLOrientationForUV)for(let he=1;he<ae.length;he+=2)ae[he]=1-ae[he];_.setVerticesData(ut.UV2Kind,ae,!1)}if(re.uvs3AttrDesc&&re.uvs3AttrDesc.count>0){const ae=new Float32Array(p,re.uvs3AttrDesc.offset,re.uvs3AttrDesc.count);if(rh.UseOpenGLOrientationForUV)for(let he=1;he<ae.length;he+=2)ae[he]=1-ae[he];_.setVerticesData(ut.UV3Kind,ae,!1)}if(re.uvs4AttrDesc&&re.uvs4AttrDesc.count>0){const ae=new Float32Array(p,re.uvs4AttrDesc.offset,re.uvs4AttrDesc.count);if(rh.UseOpenGLOrientationForUV)for(let he=1;he<ae.length;he+=2)ae[he]=1-ae[he];_.setVerticesData(ut.UV4Kind,ae,!1)}if(re.uvs5AttrDesc&&re.uvs5AttrDesc.count>0){const ae=new Float32Array(p,re.uvs5AttrDesc.offset,re.uvs5AttrDesc.count);if(rh.UseOpenGLOrientationForUV)for(let he=1;he<ae.length;he+=2)ae[he]=1-ae[he];_.setVerticesData(ut.UV5Kind,ae,!1)}if(re.uvs6AttrDesc&&re.uvs6AttrDesc.count>0){const ae=new Float32Array(p,re.uvs6AttrDesc.offset,re.uvs6AttrDesc.count);if(rh.UseOpenGLOrientationForUV)for(let he=1;he<ae.length;he+=2)ae[he]=1-ae[he];_.setVerticesData(ut.UV6Kind,ae,!1)}if(re.colorsAttrDesc&&re.colorsAttrDesc.count>0){const ae=new Float32Array(p,re.colorsAttrDesc.offset,re.colorsAttrDesc.count);_.setVerticesData(ut.ColorKind,ae,!1,re.colorsAttrDesc.stride)}if(re.matricesIndicesAttrDesc&&re.matricesIndicesAttrDesc.count>0){const ae=new Int32Array(p,re.matricesIndicesAttrDesc.offset,re.matricesIndicesAttrDesc.count),he=[];for(let _e=0;_e<ae.length;_e++){const ve=ae[_e];he.push(ve&255),he.push((ve&65280)>>8),he.push((ve&16711680)>>16),he.push(ve>>24&255)}_.setVerticesData(ut.MatricesIndicesKind,he,!1)}if(re.matricesIndicesExtraAttrDesc&&re.matricesIndicesExtraAttrDesc.count>0){const ae=new Int32Array(p,re.matricesIndicesExtraAttrDesc.offset,re.matricesIndicesExtraAttrDesc.count),he=[];for(let _e=0;_e<ae.length;_e++){const ve=ae[_e];he.push(ve&255),he.push((ve&65280)>>8),he.push((ve&16711680)>>16),he.push(ve>>24&255)}_.setVerticesData(ut.MatricesIndicesExtraKind,he,!1)}if(re.matricesWeightsAttrDesc&&re.matricesWeightsAttrDesc.count>0){const ae=new Float32Array(p,re.matricesWeightsAttrDesc.offset,re.matricesWeightsAttrDesc.count);_.setVerticesData(ut.MatricesWeightsKind,ae,!1)}if(re.indicesAttrDesc&&re.indicesAttrDesc.count>0){const ae=new Int32Array(p,re.indicesAttrDesc.offset,re.indicesAttrDesc.count);_.setIndices(ae,null)}if(re.subMeshesAttrDesc&&re.subMeshesAttrDesc.count>0){const ae=new Int32Array(p,re.subMeshesAttrDesc.offset,re.subMeshesAttrDesc.count*5);_.subMeshes=[];for(let he=0;he<re.subMeshesAttrDesc.count;he++){const _e=ae[he*5+0],ve=ae[he*5+1],Le=ae[he*5+2],ze=ae[he*5+3],He=ae[he*5+4];l2.AddToMesh(_e,ve,Le,ze,He,_)}}}else if(p.positions&&p.normals&&p.indices){if(_.setVerticesData(ut.PositionKind,p.positions,p.positions._updatable),_.setVerticesData(ut.NormalKind,p.normals,p.normals._updatable),p.tangents&&_.setVerticesData(ut.TangentKind,p.tangents,p.tangents._updatable),p.uvs&&_.setVerticesData(ut.UVKind,p.uvs,p.uvs._updatable),p.uvs2&&_.setVerticesData(ut.UV2Kind,p.uvs2,p.uvs2._updatable),p.uvs3&&_.setVerticesData(ut.UV3Kind,p.uvs3,p.uvs3._updatable),p.uvs4&&_.setVerticesData(ut.UV4Kind,p.uvs4,p.uvs4._updatable),p.uvs5&&_.setVerticesData(ut.UV5Kind,p.uvs5,p.uvs5._updatable),p.uvs6&&_.setVerticesData(ut.UV6Kind,p.uvs6,p.uvs6._updatable),p.colors&&_.setVerticesData(ut.ColorKind,Tr.CheckColors4(p.colors,p.positions.length/3),p.colors._updatable),p.matricesIndices)if(p.matricesIndices._isExpanded)delete p.matricesIndices._isExpanded,_.setVerticesData(ut.MatricesIndicesKind,p.matricesIndices,p.matricesIndices._updatable);else{const re=[];for(let ae=0;ae<p.matricesIndices.length;ae++){const he=p.matricesIndices[ae];re.push(he&255),re.push((he&65280)>>8),re.push((he&16711680)>>16),re.push(he>>24&255)}_.setVerticesData(ut.MatricesIndicesKind,re,p.matricesIndices._updatable)}if(p.matricesIndicesExtra)if(p.matricesIndicesExtra._isExpanded)delete p.matricesIndices._isExpanded,_.setVerticesData(ut.MatricesIndicesExtraKind,p.matricesIndicesExtra,p.matricesIndicesExtra._updatable);else{const re=[];for(let ae=0;ae<p.matricesIndicesExtra.length;ae++){const he=p.matricesIndicesExtra[ae];re.push(he&255),re.push((he&65280)>>8),re.push((he&16711680)>>16),re.push(he>>24&255)}_.setVerticesData(ut.MatricesIndicesExtraKind,re,p.matricesIndicesExtra._updatable)}p.matricesWeights&&(cx._CleanMatricesWeights(p,_),_.setVerticesData(ut.MatricesWeightsKind,p.matricesWeights,p.matricesWeights._updatable)),p.matricesWeightsExtra&&_.setVerticesData(ut.MatricesWeightsExtraKind,p.matricesWeightsExtra,p.matricesWeights._updatable),_.setIndices(p.indices,null)}if(p.subMeshes){_.subMeshes=[];for(let re=0;re<p.subMeshes.length;re++){const ae=p.subMeshes[re];l2.AddToMesh(ae.materialIndex,ae.verticesStart,ae.verticesCount,ae.indexStart,ae.indexCount,_)}}_._shouldGenerateFlatShading&&(_.convertToFlatShadedMesh(),_._shouldGenerateFlatShading=!1),_.computeWorldMatrix(!0),E.onMeshImportedObservable.notifyObservers(_)}static _CleanMatricesWeights(p,_){if(!R0.CleanBoneMatrixWeights)return;let I=0;if(p.skeletonId>-1){const Le=_.getScene().getLastSkeletonById(p.skeletonId);if(!Le)return;I=Le.bones.length}else return;const Z=_.getVerticesData(ut.MatricesIndicesKind),re=_.getVerticesData(ut.MatricesIndicesExtraKind),ae=p.matricesWeights,he=p.matricesWeightsExtra,_e=p.numBoneInfluencer,ve=ae.length;for(let Le=0;Le<ve;Le+=4){let ze=0,He=-1;for(let xt=0;xt<4;xt++){const rt=ae[Le+xt];ze+=rt,rt<.001&&He<0&&(He=xt)}if(he)for(let xt=0;xt<4;xt++){const rt=he[Le+xt];ze+=rt,rt<.001&&He<0&&(He=xt+4)}if((He<0||He>_e-1)&&(He=_e-1),ze>.001){const xt=1/ze;for(let rt=0;rt<4;rt++)ae[Le+rt]*=xt;if(he)for(let rt=0;rt<4;rt++)he[Le+rt]*=xt}else He>=4?(he[Le+He-4]=1-ze,re[Le+He-4]=I):(ae[Le+He]=1-ze,Z[Le+He]=I)}_.setVerticesData(ut.MatricesIndicesKind,Z),p.matricesWeightsExtra&&_.setVerticesData(ut.MatricesIndicesExtraKind,re)}static Parse(p,_,E){const I=new cx(p.id,_,void 0,p.updatable);return I._loadedUniqueId=p.uniqueId,ri&&ri.AddTagsTo(I,p.tags),p.delayLoadingFile?(I.delayLoadState=4,I.delayLoadingFile=E+p.delayLoadingFile,I._boundingInfo=new uo(at.FromArray(p.boundingBoxMinimum),at.FromArray(p.boundingBoxMaximum)),I._delayInfo=[],p.hasUVs&&I._delayInfo.push(ut.UVKind),p.hasUVs2&&I._delayInfo.push(ut.UV2Kind),p.hasUVs3&&I._delayInfo.push(ut.UV3Kind),p.hasUVs4&&I._delayInfo.push(ut.UV4Kind),p.hasUVs5&&I._delayInfo.push(ut.UV5Kind),p.hasUVs6&&I._delayInfo.push(ut.UV6Kind),p.hasColors&&I._delayInfo.push(ut.ColorKind),p.hasMatricesIndices&&I._delayInfo.push(ut.MatricesIndicesKind),p.hasMatricesWeights&&I._delayInfo.push(ut.MatricesWeightsKind),I._delayLoadingFunction=Xr.ImportVertexData):Xr.ImportVertexData(p,I),_.pushGeometry(I,!0),I}}class Gu extends zi{get subMaterials(){return this._subMaterials}set subMaterials(p){this._subMaterials=p,this._hookArray(p)}getChildren(){return this.subMaterials}constructor(p,_){super(p,_,!0),this._waitingSubMaterialsUniqueIds=[],this.getScene().addMultiMaterial(this),this.subMaterials=[],this._storeEffectOnSubMeshes=!0}_hookArray(p){const _=p.push;p.push=(...I)=>{const Z=_.apply(p,I);return this._markAllSubMeshesAsTexturesDirty(),Z};const E=p.splice;p.splice=(I,Z)=>{const re=E.apply(p,[I,Z]);return this._markAllSubMeshesAsTexturesDirty(),re}}getSubMaterial(p){return p<0||p>=this.subMaterials.length?this.getScene().defaultMaterial:this.subMaterials[p]}getActiveTextures(){return super.getActiveTextures().concat(...this.subMaterials.map(p=>p?p.getActiveTextures():[]))}hasTexture(p){if(super.hasTexture(p))return!0;for(let _=0;_<this.subMaterials.length;_++)if(this.subMaterials[_]?.hasTexture(p))return!0;return!1}getClassName(){return"MultiMaterial"}isReadyForSubMesh(p,_,E){for(let I=0;I<this.subMaterials.length;I++){const Z=this.subMaterials[I];if(Z){if(Z._storeEffectOnSubMeshes){if(!Z.isReadyForSubMesh(p,_,E))return!1;continue}if(!Z.isReady(p))return!1}}return!0}clone(p,_){const E=new Gu(p,this.getScene());for(let I=0;I<this.subMaterials.length;I++){let Z=null;const re=this.subMaterials[I];_&&re?Z=re.clone(p+"-"+re.name):Z=this.subMaterials[I],E.subMaterials.push(Z)}return E}serialize(){const p={};p.name=this.name,p.id=this.id,p.uniqueId=this.uniqueId,ri&&(p.tags=ri.GetTags(this)),p.materialsUniqueIds=[],p.materials=[];for(let _=0;_<this.subMaterials.length;_++){const E=this.subMaterials[_];E?(p.materialsUniqueIds.push(E.uniqueId),p.materials.push(E.id)):(p.materialsUniqueIds.push(null),p.materials.push(null))}return p}dispose(p,_,E){const I=this.getScene();if(!I)return;if(E)for(let re=0;re<this.subMaterials.length;re++){const ae=this.subMaterials[re];ae&&ae.dispose(p,_)}const Z=I.multiMaterials.indexOf(this);Z>=0&&I.multiMaterials.splice(Z,1),super.dispose(p,_)}static ParseMultiMaterial(p,_){const E=new Gu(p.name,_);return E.id=p.id,E._loadedUniqueId=p.uniqueId,ri&&ri.AddTagsTo(E,p.tags),p.materialsUniqueIds?E._waitingSubMaterialsUniqueIds=p.materialsUniqueIds:p.materials.forEach(I=>E.subMaterials.push(_.getLastMaterialById(I))),E}}Gs("BABYLON.MultiMaterial",Gu);class xD{constructor(p,_){this.distanceOrScreenCoverage=p,this.mesh=_}}class u5{}class lD{constructor(){this.visibleInstances={},this.batchCache=new X1,this.batchCacheReplacementModeInFrozenMode=new X1,this.instancesBufferSize=32*16*4}}class X1{constructor(){this.mustReturn=!1,this.visibleInstances=new Array,this.renderSelf=[],this.hardwareInstancedRendering=[]}}class hD{constructor(){this.instancesCount=0,this.matrixBuffer=null,this.previousMatrixBuffer=null,this.matrixBufferSize=32*16,this.matrixData=null,this.boundingVectors=[],this.worldMatrices=null}}class cD{constructor(){this._areNormalsFrozen=!1,this._source=null,this.meshMap=null,this._preActivateId=-1,this._LODLevels=new Array,this._useLODScreenCoverage=!1,this._effectiveMaterial=null,this._forcedInstanceCount=0,this._overrideRenderingFillMode=null}}class vr extends kx{static _GetDefaultSideOrientation(p){return p||vr.FRONTSIDE}get useLODScreenCoverage(){return this._internalMeshDataInfo._useLODScreenCoverage}set useLODScreenCoverage(p){this._internalMeshDataInfo._useLODScreenCoverage=p,this._sortLODLevels()}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(p){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==p&&(p&&this._internalMeshDataInfo._sourcePositions&&(this.setVerticesData(ut.PositionKind,this._internalMeshDataInfo._sourcePositions,!0),this._internalMeshDataInfo._sourceNormals&&this.setVerticesData(ut.NormalKind,this._internalMeshDataInfo._sourceNormals,!0),this._internalMeshDataInfo._sourcePositions=null,this._internalMeshDataInfo._sourceNormals=null),this._internalAbstractMeshDataInfo._computeBonesUsingShaders=p,this._markSubMeshesAsAttributesDirty())}get onBeforeRenderObservable(){return this._internalMeshDataInfo._onBeforeRenderObservable||(this._internalMeshDataInfo._onBeforeRenderObservable=new Ri),this._internalMeshDataInfo._onBeforeRenderObservable}get onBeforeBindObservable(){return this._internalMeshDataInfo._onBeforeBindObservable||(this._internalMeshDataInfo._onBeforeBindObservable=new Ri),this._internalMeshDataInfo._onBeforeBindObservable}get onAfterRenderObservable(){return this._internalMeshDataInfo._onAfterRenderObservable||(this._internalMeshDataInfo._onAfterRenderObservable=new Ri),this._internalMeshDataInfo._onAfterRenderObservable}get onBetweenPassObservable(){return this._internalMeshDataInfo._onBetweenPassObservable||(this._internalMeshDataInfo._onBetweenPassObservable=new Ri),this._internalMeshDataInfo._onBetweenPassObservable}get onBeforeDrawObservable(){return this._internalMeshDataInfo._onBeforeDrawObservable||(this._internalMeshDataInfo._onBeforeDrawObservable=new Ri),this._internalMeshDataInfo._onBeforeDrawObservable}set onBeforeDraw(p){this._onBeforeDrawObserver&&this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver),this._onBeforeDrawObserver=this.onBeforeDrawObservable.add(p)}get hasInstances(){return this.instances.length>0}get hasThinInstances(){return(this.forcedInstanceCount||this._thinInstanceDataStorage.instancesCount||0)>0}get forcedInstanceCount(){return this._internalMeshDataInfo._forcedInstanceCount}set forcedInstanceCount(p){this._internalMeshDataInfo._forcedInstanceCount=p}get overrideRenderingFillMode(){return this._internalMeshDataInfo._overrideRenderingFillMode}set overrideRenderingFillMode(p){this._internalMeshDataInfo._overrideRenderingFillMode=p}get source(){return this._internalMeshDataInfo._source}get cloneMeshMap(){return this._internalMeshDataInfo.meshMap}get isUnIndexed(){return this._unIndexed}set isUnIndexed(p){this._unIndexed!==p&&(this._unIndexed=p,this._markSubMeshesAsAttributesDirty())}get worldMatrixInstancedBuffer(){return this._instanceDataStorage.instancesData}get previousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.instancesPreviousData}get manualUpdateOfWorldMatrixInstancedBuffer(){return this._instanceDataStorage.manualUpdate}set manualUpdateOfWorldMatrixInstancedBuffer(p){this._instanceDataStorage.manualUpdate=p}get manualUpdateOfPreviousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.previousManualUpdate}set manualUpdateOfPreviousWorldMatrixInstancedBuffer(p){this._instanceDataStorage.previousManualUpdate=p}get forceWorldMatrixInstancedBufferUpdate(){return this._instanceDataStorage.forceMatrixUpdates}set forceWorldMatrixInstancedBufferUpdate(p){this._instanceDataStorage.forceMatrixUpdates=p}constructor(p,_=null,E=null,I=null,Z,re=!0){if(super(p,_),this._internalMeshDataInfo=new cD,this.delayLoadState=0,this.instances=[],this._creationDataStorage=null,this._geometry=null,this._instanceDataStorage=new lD,this._thinInstanceDataStorage=new hD,this._shouldGenerateFlatShading=!1,this._originalBuilderSideOrientation=vr.DEFAULTSIDE,this.overrideMaterialSideOrientation=null,this.ignoreCameraMaxZ=!1,_=this.getScene(),this._onBeforeDraw=(ae,he,_e)=>{ae&&_e&&(this._uniformBuffer?this.transferToEffect(he):_e.bindOnlyWorldMatrix(he))},I){if(I._geometry&&I._geometry.applyToMesh(this),jo.DeepCopy(I,this,["name","material","skeleton","instances","parent","uniqueId","source","metadata","morphTargetManager","hasInstances","worldMatrixInstancedBuffer","previousWorldMatrixInstancedBuffer","hasLODLevels","geometry","isBlocked","areNormalsFrozen","facetNb","isFacetDataEnabled","lightSources","useBones","isAnInstance","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","cloneMeshMap","hasBoundingInfo","physicsBody","physicsImpostor"],["_poseMatrix"]),this._internalMeshDataInfo._source=I,_.useClonedMeshMap&&(I._internalMeshDataInfo.meshMap||(I._internalMeshDataInfo.meshMap={}),I._internalMeshDataInfo.meshMap[this.uniqueId]=this),this._originalBuilderSideOrientation=I._originalBuilderSideOrientation,this._creationDataStorage=I._creationDataStorage,I._ranges){const ae=I._ranges;for(const he in ae)Object.prototype.hasOwnProperty.call(ae,he)&&ae[he]&&this.createAnimationRange(he,ae[he].from,ae[he].to)}if(I.metadata&&I.metadata.clone?this.metadata=I.metadata.clone():this.metadata=I.metadata,this._internalMetadata=I._internalMetadata,ri&&ri.HasTags(I)&&ri.AddTagsTo(this,ri.GetTags(I,!0)),this.setEnabled(I.isEnabled(!1)),this.parent=I.parent,this.setPivotMatrix(I.getPivotMatrix()),this.id=p+"."+I.id,this.material=I.material,!Z){const ae=I.getDescendants(!0);for(let he=0;he<ae.length;he++){const _e=ae[he];_e.clone&&_e.clone(p+"."+_e.name,this)}}if(I.morphTargetManager&&(this.morphTargetManager=I.morphTargetManager),_.getPhysicsEngine){const ae=_.getPhysicsEngine();if(re&&ae)if(ae.getPluginVersion()===1){const he=ae.getImpostorForPhysicsObject(I);he&&(this.physicsImpostor=he.clone(this))}else ae.getPluginVersion()===2&&I.physicsBody&&I.physicsBody.clone(this)}for(let ae=0;ae<_.particleSystems.length;ae++){const he=_.particleSystems[ae];he.emitter===I&&he.clone(he.name,this)}this.skeleton=I.skeleton,this.refreshBoundingInfo(!0,!0),this.computeWorldMatrix(!0)}E!==null&&(this.parent=E),this._instanceDataStorage.hardwareInstancedRendering=this.getEngine().getCaps().instancedArrays,this._internalMeshDataInfo._onMeshReadyObserverAdded=ae=>{ae.unregisterOnNextCall=!0,this.isReady(!0)?this.onMeshReadyObservable.notifyObservers(this):this._internalMeshDataInfo._checkReadinessObserver||(this._internalMeshDataInfo._checkReadinessObserver=this._scene.onBeforeRenderObservable.add(()=>{this.isReady(!0)&&(this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),this._internalMeshDataInfo._checkReadinessObserver=null,this.onMeshReadyObservable.notifyObservers(this))}))},this.onMeshReadyObservable=new Ri(this._internalMeshDataInfo._onMeshReadyObserverAdded),I&&I.onClonedObservable.notifyObservers(this)}instantiateHierarchy(p=null,_,E){const I=this.getTotalVertices()===0||_&&_.doNotInstantiate&&(_.doNotInstantiate===!0||_.doNotInstantiate(this))?this.clone("Clone of "+(this.name||this.id),p||this.parent,!0):this.createInstance("instance of "+(this.name||this.id));I.parent=p||this.parent,I.position=this.position.clone(),I.scaling=this.scaling.clone(),this.rotationQuaternion?I.rotationQuaternion=this.rotationQuaternion.clone():I.rotation=this.rotation.clone(),E&&E(this,I);for(const Z of this.getChildTransformNodes(!0))Z.getClassName()==="InstancedMesh"&&I.getClassName()==="Mesh"&&Z.sourceMesh===this?Z.instantiateHierarchy(I,{doNotInstantiate:_&&_.doNotInstantiate||!1,newSourcedMesh:I},E):Z.instantiateHierarchy(I,_,E);return I}getClassName(){return"Mesh"}get _isMesh(){return!0}toString(p){let _=super.toString(p);if(_+=", n vertices: "+this.getTotalVertices(),_+=", parent: "+(this._waitingParentId?this._waitingParentId:this.parent?this.parent.name:"NONE"),this.animations)for(let E=0;E<this.animations.length;E++)_+=", animation[0]: "+this.animations[E].toString(p);if(p)if(this._geometry){const E=this.getIndices(),I=this.getVerticesData(ut.PositionKind);I&&E&&(_+=", flat shading: "+(I.length/3===E.length?"YES":"NO"))}else _+=", flat shading: UNKNOWN";return _}_unBindEffect(){super._unBindEffect();for(const p of this.instances)p._unBindEffect()}get hasLODLevels(){return this._internalMeshDataInfo._LODLevels.length>0}getLODLevels(){return this._internalMeshDataInfo._LODLevels}_sortLODLevels(){const p=this._internalMeshDataInfo._useLODScreenCoverage?-1:1;this._internalMeshDataInfo._LODLevels.sort((_,E)=>_.distanceOrScreenCoverage<E.distanceOrScreenCoverage?p:_.distanceOrScreenCoverage>E.distanceOrScreenCoverage?-p:0)}addLODLevel(p,_){if(_&&_._masterMesh)return Ti.Warn("You cannot use a mesh as LOD level twice"),this;const E=new xD(p,_);return this._internalMeshDataInfo._LODLevels.push(E),_&&(_._masterMesh=this),this._sortLODLevels(),this}getLODLevelAtDistance(p){const _=this._internalMeshDataInfo;for(let E=0;E<_._LODLevels.length;E++){const I=_._LODLevels[E];if(I.distanceOrScreenCoverage===p)return I.mesh}return null}removeLODLevel(p){const _=this._internalMeshDataInfo;for(let E=0;E<_._LODLevels.length;E++)_._LODLevels[E].mesh===p&&(_._LODLevels.splice(E,1),p&&(p._masterMesh=null));return this._sortLODLevels(),this}getLOD(p,_){const E=this._internalMeshDataInfo;if(!E._LODLevels||E._LODLevels.length===0)return this;const I=_||this.getBoundingInfo().boundingSphere,Z=p.mode===Wr.ORTHOGRAPHIC_CAMERA?p.minZ:I.centerWorld.subtract(p.globalPosition).length();let re=Z,ae=1;if(E._useLODScreenCoverage){const he=p.screenArea;let _e=I.radiusWorld*p.minZ/Z;_e=_e*_e*Math.PI,re=_e/he,ae=-1}if(ae*E._LODLevels[E._LODLevels.length-1].distanceOrScreenCoverage>ae*re)return this.onLODLevelSelection&&this.onLODLevelSelection(re,this,this),this;for(let he=0;he<E._LODLevels.length;he++){const _e=E._LODLevels[he];if(ae*_e.distanceOrScreenCoverage<ae*re){if(_e.mesh){if(_e.mesh.delayLoadState===4)return _e.mesh._checkDelayState(),this;if(_e.mesh.delayLoadState===2)return this;_e.mesh._preActivate(),_e.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)}return this.onLODLevelSelection&&this.onLODLevelSelection(re,this,_e.mesh),_e.mesh}}return this.onLODLevelSelection&&this.onLODLevelSelection(re,this,this),this}get geometry(){return this._geometry}getTotalVertices(){return this._geometry===null||this._geometry===void 0?0:this._geometry.getTotalVertices()}getVerticesData(p,_,E,I){if(!this._geometry)return null;let Z=I?void 0:this._userInstancedBuffersStorage?.vertexBuffers[p]?.getFloatData(this.instances.length+1,E||_&&this._geometry.meshes.length!==1);return Z||(Z=this._geometry.getVerticesData(p,_,E)),Z}getVertexBuffer(p,_){return this._geometry?(_?void 0:this._userInstancedBuffersStorage?.vertexBuffers[p])??this._geometry.getVertexBuffer(p):null}isVerticesDataPresent(p,_){return this._geometry?!_&&this._userInstancedBuffersStorage?.vertexBuffers[p]!==void 0||this._geometry.isVerticesDataPresent(p):this._delayInfo?this._delayInfo.indexOf(p)!==-1:!1}isVertexBufferUpdatable(p,_){if(!this._geometry)return this._delayInfo?this._delayInfo.indexOf(p)!==-1:!1;if(!_){const E=this._userInstancedBuffersStorage?.vertexBuffers[p];if(E)return E.isUpdatable()}return this._geometry.isVertexBufferUpdatable(p)}getVerticesDataKinds(p){if(!this._geometry){const E=[];return this._delayInfo&&this._delayInfo.forEach(function(I){E.push(I)}),E}const _=this._geometry.getVerticesDataKinds();if(!p&&this._userInstancedBuffersStorage)for(const E in this._userInstancedBuffersStorage.vertexBuffers)_.indexOf(E)===-1&&_.push(E);return _}getTotalIndices(){return this._geometry?this._geometry.getTotalIndices():0}getIndices(p,_){return this._geometry?this._geometry.getIndices(p,_):[]}get isBlocked(){return this._masterMesh!==null&&this._masterMesh!==void 0}isReady(p=!1,_=!1){if(this.delayLoadState===2||!super.isReady(p))return!1;if(!this.subMeshes||this.subMeshes.length===0||!p)return!0;const E=this.getEngine(),I=this.getScene(),Z=_||E.getCaps().instancedArrays&&(this.instances.length>0||this.hasThinInstances);this.computeWorldMatrix();const re=this.material||I.defaultMaterial;if(re){if(re._storeEffectOnSubMeshes)for(const he of this.subMeshes){const _e=he.getMaterial();if(_e){if(_e._storeEffectOnSubMeshes){if(!_e.isReadyForSubMesh(this,he,Z))return!1}else if(!_e.isReady(this,Z))return!1}}else if(!re.isReady(this,Z))return!1}const ae=E.currentRenderPassId;for(const he of this.lightSources){const _e=he.getShadowGenerators();if(!_e)continue;const ve=_e.values();for(let Le=ve.next();Le.done!==!0;Le=ve.next()){const ze=Le.value;if(ze&&(!ze.getShadowMap()?.renderList||ze.getShadowMap()?.renderList&&ze.getShadowMap()?.renderList?.indexOf(this)!==-1)){const xt=ze.getShadowMap().renderPassIds??[E.currentRenderPassId];for(let rt=0;rt<xt.length;++rt){E.currentRenderPassId=xt[rt];for(const Tt of this.subMeshes)if(!ze.isReady(Tt,Z,Tt.getMaterial()?.needAlphaBlendingForMesh(this)??!1))return E.currentRenderPassId=ae,!1}E.currentRenderPassId=ae}}}for(const he of this._internalMeshDataInfo._LODLevels)if(he.mesh&&!he.mesh.isReady(Z))return!1;return!0}get areNormalsFrozen(){return this._internalMeshDataInfo._areNormalsFrozen}freezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!0,this}unfreezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!1,this}set overridenInstanceCount(p){this._instanceDataStorage.overridenInstanceCount=p}_preActivate(){const p=this._internalMeshDataInfo,_=this.getScene().getRenderId();return p._preActivateId===_?this:(p._preActivateId=_,this._instanceDataStorage.visibleInstances=null,this)}_preActivateForIntermediateRendering(p){return this._instanceDataStorage.visibleInstances&&(this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId=p),this}_registerInstanceForRenderId(p,_){return this._instanceDataStorage.visibleInstances||(this._instanceDataStorage.visibleInstances={defaultRenderId:_,selfDefaultRenderId:this._renderId}),this._instanceDataStorage.visibleInstances[_]||(this._instanceDataStorage.previousRenderId!==void 0&&this._instanceDataStorage.isFrozen&&(this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId]=null),this._instanceDataStorage.previousRenderId=_,this._instanceDataStorage.visibleInstances[_]=new Array),this._instanceDataStorage.visibleInstances[_].push(p),this}_afterComputeWorldMatrix(){super._afterComputeWorldMatrix(),this.hasThinInstances&&(this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1))}_postActivate(){this.edgesShareWithInstances&&this.edgesRenderer&&this.edgesRenderer.isEnabled&&this._renderingGroup&&(this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer),this.edgesRenderer.customInstances.push(this.getWorldMatrix()))}refreshBoundingInfo(p=!1,_=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;const E=this.geometry?this.geometry.boundingBias:null;return this._refreshBoundingInfo(this._getPositionData(p,_),E),this}_createGlobalSubMesh(p){const _=this.getTotalVertices();if(!_||!this.getIndices())return null;if(this.subMeshes&&this.subMeshes.length>0){const E=this.getIndices();if(!E)return null;const I=E.length;let Z=!1;if(p)Z=!0;else for(const re of this.subMeshes){if(re.indexStart+re.indexCount>I){Z=!0;break}if(re.verticesStart+re.verticesCount>_){Z=!0;break}}if(!Z)return this.subMeshes[0]}return this.releaseSubMeshes(),new l2(0,0,_,0,this.getTotalIndices(),this)}subdivide(p){if(p<1)return;const _=this.getTotalIndices();let E=_/p|0,I=0;for(;E%3!==0;)E++;this.releaseSubMeshes();for(let Z=0;Z<p&&!(I>=_);Z++)l2.CreateFromIndices(0,I,Z===p-1?_-I:E,this,void 0,!1),I+=E;this.refreshBoundingInfo(),this.synchronizeInstances()}setVerticesData(p,_,E=!1,I){if(this._geometry)this._geometry.setVerticesData(p,_,E,I);else{const Z=new Xr;Z.set(_,p);const re=this.getScene();new cx(cx.RandomId(),re,Z,E,this)}return this}removeVerticesData(p){this._geometry&&this._geometry.removeVerticesData(p)}markVerticesDataAsUpdatable(p,_=!0){const E=this.getVertexBuffer(p);!E||E.isUpdatable()===_||this.setVerticesData(p,this.getVerticesData(p),_)}setVerticesBuffer(p,_=!0){return this._geometry||(this._geometry=cx.CreateGeometryForMesh(this)),this._geometry.setVerticesBuffer(p,null,_),this}updateVerticesData(p,_,E,I){return this._geometry?(I?(this.makeGeometryUnique(),this.updateVerticesData(p,_,E,!1)):this._geometry.updateVerticesData(p,_,E),this):this}updateMeshPositions(p,_=!0){const E=this.getVerticesData(ut.PositionKind);if(!E)return this;if(p(E),this.updateVerticesData(ut.PositionKind,E,!1,!1),_){const I=this.getIndices(),Z=this.getVerticesData(ut.NormalKind);if(!Z)return this;Xr.ComputeNormals(E,I,Z),this.updateVerticesData(ut.NormalKind,Z,!1,!1)}return this}makeGeometryUnique(){if(!this._geometry)return this;if(this._geometry.meshes.length===1)return this;const p=this._geometry,_=this._geometry.copy(cx.RandomId());return p.releaseForMesh(this,!0),_.applyToMesh(this),this}setIndexBuffer(p,_,E){let I=this._geometry;I||(I=new cx(cx.RandomId(),this.getScene(),void 0,void 0,this)),I.setIndexBuffer(p,_,E)}setIndices(p,_=null,E=!1){if(this._geometry)this._geometry.setIndices(p,_,E);else{const I=new Xr;I.indices=p;const Z=this.getScene();new cx(cx.RandomId(),Z,I,E,this)}return this}updateIndices(p,_,E=!1){return this._geometry?(this._geometry.updateIndices(p,_,E),this):this}toLeftHanded(){return this._geometry?(this._geometry.toLeftHanded(),this):this}_bind(p,_,E,I=!0){if(!this._geometry)return this;const Z=this.getScene().getEngine();this.morphTargetManager&&this.morphTargetManager.isUsingTextureForTargets&&this.morphTargetManager._bind(_);let re;if(this._unIndexed)re=null;else switch(this._getRenderingFillMode(E)){case zi.PointFillMode:re=null;break;case zi.WireFrameFillMode:re=p._getLinesIndexBuffer(this.getIndices(),Z);break;default:case zi.TriangleFillMode:re=this._geometry.getIndexBuffer();break}return!I||!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(_,re):this._geometry._bind(_,re,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),this}_draw(p,_,E){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;this._internalMeshDataInfo._onBeforeDrawObservable&&this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);const Z=this.getScene().getEngine();return this._unIndexed||_==zi.PointFillMode?Z.drawArraysType(_,p.verticesStart,p.verticesCount,this.forcedInstanceCount||E):_==zi.WireFrameFillMode?Z.drawElementsType(_,0,p._linesIndexCount,this.forcedInstanceCount||E):Z.drawElementsType(_,p.indexStart,p.indexCount,this.forcedInstanceCount||E),this}registerBeforeRender(p){return this.onBeforeRenderObservable.add(p),this}unregisterBeforeRender(p){return this.onBeforeRenderObservable.removeCallback(p),this}registerAfterRender(p){return this.onAfterRenderObservable.add(p),this}unregisterAfterRender(p){return this.onAfterRenderObservable.removeCallback(p),this}_getInstancesRenderList(p,_=!1){if(this._instanceDataStorage.isFrozen){if(_)return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[p]=!1,this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[p]=!0,this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;if(this._instanceDataStorage.previousBatch)return this._instanceDataStorage.previousBatch}const E=this.getScene(),I=E._isInIntermediateRendering(),Z=I?this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate:this._internalAbstractMeshDataInfo._onlyForInstances,re=this._instanceDataStorage.batchCache;if(re.mustReturn=!1,re.renderSelf[p]=_||!Z&&this.isEnabled()&&this.isVisible,re.visibleInstances[p]=null,this._instanceDataStorage.visibleInstances&&!_){const ae=this._instanceDataStorage.visibleInstances,he=E.getRenderId(),_e=I?ae.intermediateDefaultRenderId:ae.defaultRenderId;re.visibleInstances[p]=ae[he],!re.visibleInstances[p]&&_e&&(re.visibleInstances[p]=ae[_e])}return re.hardwareInstancedRendering[p]=!_&&this._instanceDataStorage.hardwareInstancedRendering&&re.visibleInstances[p]!==null&&re.visibleInstances[p]!==void 0,this._instanceDataStorage.previousBatch=re,re}_renderWithInstances(p,_,E,I,Z){const re=E.visibleInstances[p._id],ae=re?re.length:0,he=this._instanceDataStorage,_e=he.instancesBufferSize;let ve=he.instancesBuffer,Le=he.instancesPreviousBuffer;const He=(ae+1)*16*4;for(;he.instancesBufferSize<He;)he.instancesBufferSize*=2;(!he.instancesData||_e!=he.instancesBufferSize)&&(he.instancesData=new Float32Array(he.instancesBufferSize/4)),(this._scene.needsPreviousWorldMatrices&&!he.instancesPreviousData||_e!=he.instancesBufferSize)&&(he.instancesPreviousData=new Float32Array(he.instancesBufferSize/4));let xt=0,rt=0;const Tt=E.renderSelf[p._id],Lt=!ve||_e!==he.instancesBufferSize||this._scene.needsPreviousWorldMatrices&&!he.instancesPreviousBuffer;if(!this._instanceDataStorage.manualUpdate&&(!he.isFrozen||Lt)){const Nt=this.getWorldMatrix();if(Tt&&(this._scene.needsPreviousWorldMatrices&&(he.masterMeshPreviousWorldMatrix?(he.masterMeshPreviousWorldMatrix.copyToArray(he.instancesPreviousData,xt),he.masterMeshPreviousWorldMatrix.copyFrom(Nt)):(he.masterMeshPreviousWorldMatrix=Nt.clone(),he.masterMeshPreviousWorldMatrix.copyToArray(he.instancesPreviousData,xt))),Nt.copyToArray(he.instancesData,xt),xt+=16,rt++),re){if(vr.INSTANCEDMESH_SORT_TRANSPARENT&&this._scene.activeCamera&&p.getMaterial()?.needAlphaBlendingForMesh(p.getRenderingMesh())){const qt=this._scene.activeCamera.globalPosition;for(let Xt=0;Xt<re.length;Xt++){const zt=re[Xt];zt._distanceToCamera=at.Distance(zt.getBoundingInfo().boundingSphere.centerWorld,qt)}re.sort((Xt,zt)=>Xt._distanceToCamera>zt._distanceToCamera?-1:Xt._distanceToCamera<zt._distanceToCamera?1:0)}for(let qt=0;qt<re.length;qt++){const Xt=re[qt],zt=Xt.getWorldMatrix();zt.copyToArray(he.instancesData,xt),this._scene.needsPreviousWorldMatrices&&(Xt._previousWorldMatrix?(Xt._previousWorldMatrix.copyToArray(he.instancesPreviousData,xt),Xt._previousWorldMatrix.copyFrom(zt)):(Xt._previousWorldMatrix=zt.clone(),Xt._previousWorldMatrix.copyToArray(he.instancesPreviousData,xt))),xt+=16,rt++}}}else rt=(Tt?1:0)+ae;return Lt?(ve&&ve.dispose(),Le&&Le.dispose(),ve=new xu(Z,he.instancesData,!0,16,!1,!0),he.instancesBuffer=ve,this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this._userInstancedBuffersStorage.vertexBuffers.world0=ve.createVertexBuffer("world0",0,4),this._userInstancedBuffersStorage.vertexBuffers.world1=ve.createVertexBuffer("world1",4,4),this._userInstancedBuffersStorage.vertexBuffers.world2=ve.createVertexBuffer("world2",8,4),this._userInstancedBuffersStorage.vertexBuffers.world3=ve.createVertexBuffer("world3",12,4),this._scene.needsPreviousWorldMatrices&&(Le=new xu(Z,he.instancesPreviousData,!0,16,!1,!0),he.instancesPreviousBuffer=Le,this._userInstancedBuffersStorage.vertexBuffers.previousWorld0=Le.createVertexBuffer("previousWorld0",0,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld1=Le.createVertexBuffer("previousWorld1",4,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld2=Le.createVertexBuffer("previousWorld2",8,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld3=Le.createVertexBuffer("previousWorld3",12,4)),this._invalidateInstanceVertexArrayObject()):(!this._instanceDataStorage.isFrozen||this._instanceDataStorage.forceMatrixUpdates)&&(ve.updateDirectly(he.instancesData,0,rt),this._scene.needsPreviousWorldMatrices&&(!this._instanceDataStorage.manualUpdate||this._instanceDataStorage.previousManualUpdate)&&Le.updateDirectly(he.instancesPreviousData,0,rt)),this._processInstancedBuffers(re,Tt),this.getScene()._activeIndices.addCount(p.indexCount*rt,!1),Z._currentDrawContext&&(Z._currentDrawContext.useInstancing=!0),this._bind(p,I,_),this._draw(p,_,rt),this._scene.needsPreviousWorldMatrices&&!Lt&&this._instanceDataStorage.manualUpdate&&(!this._instanceDataStorage.isFrozen||this._instanceDataStorage.forceMatrixUpdates)&&!this._instanceDataStorage.previousManualUpdate&&Le.updateDirectly(he.instancesData,0,rt),Z.unbindInstanceAttributes(),this}_renderWithThinInstances(p,_,E,I){const Z=this._thinInstanceDataStorage?.instancesCount??0;this.getScene()._activeIndices.addCount(p.indexCount*Z,!1),I._currentDrawContext&&(I._currentDrawContext.useInstancing=!0),this._bind(p,E,_),this._draw(p,_,Z),this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&this._thinInstanceDataStorage.matrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData,0,Z):this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",this._thinInstanceDataStorage.matrixData,!1)),I.unbindInstanceAttributes()}_processInstancedBuffers(p,_){}_processRendering(p,_,E,I,Z,re,ae,he){const _e=this.getScene(),ve=_e.getEngine();if(I=this._getRenderingFillMode(I),re&&_.getRenderingMesh().hasThinInstances)return this._renderWithThinInstances(_,I,E,ve),this;if(re)this._renderWithInstances(_,I,Z,E,ve);else{ve._currentDrawContext&&(ve._currentDrawContext.useInstancing=!1);let Le=0;Z.renderSelf[_._id]&&(ae&&ae(!1,p.getWorldMatrix(),he),Le++,this._draw(_,I,this._instanceDataStorage.overridenInstanceCount));const ze=Z.visibleInstances[_._id];if(ze){const He=ze.length;Le+=He;for(let xt=0;xt<He;xt++){const Tt=ze[xt].getWorldMatrix();ae&&ae(!0,Tt,he),this._draw(_,I)}}_e._activeIndices.addCount(_.indexCount*Le,!1)}return this}_rebuild(p=!1){if(this._instanceDataStorage.instancesBuffer&&(p&&this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null),this._userInstancedBuffersStorage){for(const _ in this._userInstancedBuffersStorage.vertexBuffers){const E=this._userInstancedBuffersStorage.vertexBuffers[_];E&&(p&&E.dispose(),this._userInstancedBuffersStorage.vertexBuffers[_]=null)}this._userInstancedBuffersStorage.vertexArrayObjects&&(this._userInstancedBuffersStorage.vertexArrayObjects={})}this._internalMeshDataInfo._effectiveMaterial=null,super._rebuild(p)}_freeze(){if(this.subMeshes){for(let p=0;p<this.subMeshes.length;p++)this._getInstancesRenderList(p);this._internalMeshDataInfo._effectiveMaterial=null,this._instanceDataStorage.isFrozen=!0}}_unFreeze(){this._instanceDataStorage.isFrozen=!1,this._instanceDataStorage.previousBatch=null}renderWithRenderPassId(p,_,E,I,Z=!0){const re=this._scene.getEngine(),ae=re.currentRenderPassId;if(p!==void 0&&(re.currentRenderPassId=p),I)(!Z||Z&&I.isInFrustum(this._scene._frustumPlanes))&&this.render(I,!!_,E);else for(let he=0;he<this.subMeshes.length;he++){const _e=this.subMeshes[he];(!Z||Z&&_e.isInFrustum(this._scene._frustumPlanes))&&this.render(_e,!!_,E)}return p!==void 0&&(re.currentRenderPassId=ae),this}render(p,_,E){const I=this.getScene();this._internalAbstractMeshDataInfo._isActiveIntermediate?this._internalAbstractMeshDataInfo._isActiveIntermediate=!1:this._internalAbstractMeshDataInfo._isActive=!1;const Z=I.activeCameras?.length??0;if((Z>1&&I.activeCamera===I.activeCameras[0]||Z<=1)&&this._checkOcclusionQuery()&&!this._occlusionDataStorage.forceRenderingWhenOccluded)return this;const ae=this._getInstancesRenderList(p._id,!!E);if(ae.mustReturn)return this;if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const he=I.getEngine();let _e=0,ve=null;this.ignoreCameraMaxZ&&I.activeCamera&&!I._isInIntermediateRendering()&&(_e=I.activeCamera.maxZ,ve=I.activeCamera,I.activeCamera.maxZ=0,I.updateTransformMatrix(!0)),this._internalMeshDataInfo._onBeforeRenderObservable&&this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);const Le=p.getRenderingMesh(),ze=ae.hardwareInstancedRendering[p._id]||Le.hasThinInstances||!!this._userInstancedBuffersStorage&&!p.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh,He=this._instanceDataStorage,xt=p.getMaterial();if(!xt)return ve&&(ve.maxZ=_e,I.updateTransformMatrix(!0)),this;if(!He.isFrozen||!this._internalMeshDataInfo._effectiveMaterial||this._internalMeshDataInfo._effectiveMaterial!==xt){if(xt._storeEffectOnSubMeshes){if(!xt.isReadyForSubMesh(this,p,ze))return ve&&(ve.maxZ=_e,I.updateTransformMatrix(!0)),this}else if(!xt.isReady(this,ze))return ve&&(ve.maxZ=_e,I.updateTransformMatrix(!0)),this;this._internalMeshDataInfo._effectiveMaterial=xt}else if(xt._storeEffectOnSubMeshes&&!p._drawWrapper?._wasPreviouslyReady||!xt._storeEffectOnSubMeshes&&!xt._getDrawWrapper()._wasPreviouslyReady)return ve&&(ve.maxZ=_e,I.updateTransformMatrix(!0)),this;_&&he.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);let rt;this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes?rt=p._drawWrapper:rt=this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();const Tt=rt?.effect??null;for(const xi of I._beforeRenderingMeshStage)xi.action(this,p,ae,Tt);if(!rt||!Tt)return ve&&(ve.maxZ=_e,I.updateTransformMatrix(!0)),this;const Lt=E||this;let Nt;if(!He.isFrozen&&(this._internalMeshDataInfo._effectiveMaterial.backFaceCulling||this.overrideMaterialSideOrientation!==null||this._internalMeshDataInfo._effectiveMaterial.twoSidedLighting)){const xi=Lt._getWorldMatrixDeterminant();Nt=this.overrideMaterialSideOrientation,Nt==null&&(Nt=this._internalMeshDataInfo._effectiveMaterial.sideOrientation),xi<0&&(Nt=Nt===zi.ClockWiseSideOrientation?zi.CounterClockWiseSideOrientation:zi.ClockWiseSideOrientation),He.sideOrientation=Nt}else Nt=He.sideOrientation;const qt=this._internalMeshDataInfo._effectiveMaterial._preBind(rt,Nt);this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite&&he.setDepthWrite(!0);const Xt=this._internalMeshDataInfo._effectiveMaterial,zt=Xt.fillMode;this._internalMeshDataInfo._onBeforeBindObservable&&this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this),ze||this._bind(p,Tt,zt,!1);const Gt=Lt.getWorldMatrix();Xt._storeEffectOnSubMeshes?Xt.bindForSubMesh(Gt,this,p):Xt.bind(Gt,this),!Xt.backFaceCulling&&Xt.separateCullingPass&&(he.setState(!0,Xt.zOffset,!1,!qt,Xt.cullBackFaces,Xt.stencil,Xt.zOffsetUnits),this._processRendering(this,p,Tt,zt,ae,ze,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),he.setState(!0,Xt.zOffset,!1,qt,Xt.cullBackFaces,Xt.stencil,Xt.zOffsetUnits),this._internalMeshDataInfo._onBetweenPassObservable&&this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(p)),this._processRendering(this,p,Tt,zt,ae,ze,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),this._internalMeshDataInfo._effectiveMaterial.unbind();for(const xi of I._afterRenderingMeshStage)xi.action(this,p,ae,Tt);return this._internalMeshDataInfo._onAfterRenderObservable&&this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this),ve&&(ve.maxZ=_e,I.updateTransformMatrix(!0)),I.performancePriority===_l.Aggressive&&!He.isFrozen&&this._freeze(),this}cleanMatrixWeights(){this.isVerticesDataPresent(ut.MatricesWeightsKind)&&(this.isVerticesDataPresent(ut.MatricesWeightsExtraKind)?this._normalizeSkinWeightsAndExtra():this._normalizeSkinFourWeights())}_normalizeSkinFourWeights(){const p=this.getVerticesData(ut.MatricesWeightsKind),_=p.length;for(let E=0;E<_;E+=4){const I=p[E]+p[E+1]+p[E+2]+p[E+3];if(I===0)p[E]=1;else{const Z=1/I;p[E]*=Z,p[E+1]*=Z,p[E+2]*=Z,p[E+3]*=Z}}this.setVerticesData(ut.MatricesWeightsKind,p)}_normalizeSkinWeightsAndExtra(){const p=this.getVerticesData(ut.MatricesWeightsExtraKind),_=this.getVerticesData(ut.MatricesWeightsKind),E=_.length;for(let I=0;I<E;I+=4){let Z=_[I]+_[I+1]+_[I+2]+_[I+3];if(Z+=p[I]+p[I+1]+p[I+2]+p[I+3],Z===0)_[I]=1;else{const re=1/Z;_[I]*=re,_[I+1]*=re,_[I+2]*=re,_[I+3]*=re,p[I]*=re,p[I+1]*=re,p[I+2]*=re,p[I+3]*=re}}this.setVerticesData(ut.MatricesWeightsKind,_),this.setVerticesData(ut.MatricesWeightsKind,p)}validateSkinning(){const p=this.getVerticesData(ut.MatricesWeightsExtraKind),_=this.getVerticesData(ut.MatricesWeightsKind);if(_===null||this.skeleton==null)return{skinned:!1,valid:!0,report:"not skinned"};const E=_.length;let I=0,Z=0,re=0,ae=0;const he=p===null?4:8,_e=[];for(let Tt=0;Tt<=he;Tt++)_e[Tt]=0;const ve=.001;for(let Tt=0;Tt<E;Tt+=4){let Lt=_[Tt],Nt=Lt,qt=Nt===0?0:1;for(let Xt=1;Xt<he;Xt++){const zt=Xt<4?_[Tt+Xt]:p[Tt+Xt-4];zt>Lt&&I++,zt!==0&&qt++,Nt+=zt,Lt=zt}if(_e[qt]++,qt>re&&(re=qt),Nt===0)Z++;else{const Xt=1/Nt;let zt=0;for(let Gt=0;Gt<he;Gt++)Gt<4?zt+=Math.abs(_[Tt+Gt]-_[Tt+Gt]*Xt):zt+=Math.abs(p[Tt+Gt-4]-p[Tt+Gt-4]*Xt);zt>ve&&ae++}}const Le=this.skeleton.bones.length,ze=this.getVerticesData(ut.MatricesIndicesKind),He=this.getVerticesData(ut.MatricesIndicesExtraKind);let xt=0;for(let Tt=0;Tt<E;Tt+=4)for(let Lt=0;Lt<he;Lt++){const Nt=Lt<4?ze[Tt+Lt]:He[Tt+Lt-4];(Nt>=Le||Nt<0)&&xt++}const rt="Number of Weights = "+E/4+`
Maximum influences = `+re+`
Missing Weights = `+Z+`
Not Sorted = `+I+`
Not Normalized = `+ae+`
WeightCounts = [`+_e+`]
Number of bones = `+Le+`
Bad Bone Indices = `+xt;return{skinned:!0,valid:Z===0&&ae===0&&xt===0,report:rt}}_checkDelayState(){const p=this.getScene();return this._geometry?this._geometry.load(p):this.delayLoadState===4&&(this.delayLoadState=2,this._queueLoad(p)),this}_queueLoad(p){p.addPendingData(this);const _=this.delayLoadingFile.indexOf(".babylonbinarymeshdata")!==-1;return lt.LoadFile(this.delayLoadingFile,E=>{E instanceof ArrayBuffer?this._delayLoadingFunction(E,this):this._delayLoadingFunction(JSON.parse(E),this),this.instances.forEach(I=>{I.refreshBoundingInfo(),I._syncSubMeshes()}),this.delayLoadState=1,p.removePendingData(this)},()=>{},p.offlineProvider,_),this}isInFrustum(p){return this.delayLoadState===2||!super.isInFrustum(p)?!1:(this._checkDelayState(),!0)}setMaterialById(p){const _=this.getScene().materials;let E;for(E=_.length-1;E>-1;E--)if(_[E].id===p)return this.material=_[E],this;const I=this.getScene().multiMaterials;for(E=I.length-1;E>-1;E--)if(I[E].id===p)return this.material=I[E],this;return this}getAnimatables(){const p=[];return this.material&&p.push(this.material),this.skeleton&&p.push(this.skeleton),p}bakeTransformIntoVertices(p){if(!this.isVerticesDataPresent(ut.PositionKind))return this;const _=this.subMeshes.splice(0);this._resetPointsArrayCache();let E=this.getVerticesData(ut.PositionKind);const I=at.Zero();let Z;for(Z=0;Z<E.length;Z+=3)at.TransformCoordinatesFromFloatsToRef(E[Z],E[Z+1],E[Z+2],p,I).toArray(E,Z);if(this.setVerticesData(ut.PositionKind,E,this.getVertexBuffer(ut.PositionKind).isUpdatable()),this.isVerticesDataPresent(ut.NormalKind)){for(E=this.getVerticesData(ut.NormalKind),Z=0;Z<E.length;Z+=3)at.TransformNormalFromFloatsToRef(E[Z],E[Z+1],E[Z+2],p,I).normalize().toArray(E,Z);this.setVerticesData(ut.NormalKind,E,this.getVertexBuffer(ut.NormalKind).isUpdatable())}return p.determinant()<0&&this.flipFaces(),this.releaseSubMeshes(),this.subMeshes=_,this}bakeCurrentTransformIntoVertices(p=!0){return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)),this.resetLocalMatrix(p),this}get _positions(){return this._internalAbstractMeshDataInfo._positions?this._internalAbstractMeshDataInfo._positions:this._geometry?this._geometry._positions:null}_resetPointsArrayCache(){return this._geometry&&this._geometry._resetPointsArrayCache(),this}_generatePointsArray(){return this._geometry?this._geometry._generatePointsArray():!1}clone(p="",_=null,E,I=!0){return new vr(p,this.getScene(),_,this,E,I)}dispose(p,_=!1){this.morphTargetManager=null,this._geometry&&this._geometry.releaseForMesh(this,!0);const E=this._internalMeshDataInfo;if(E._onBeforeDrawObservable&&E._onBeforeDrawObservable.clear(),E._onBeforeBindObservable&&E._onBeforeBindObservable.clear(),E._onBeforeRenderObservable&&E._onBeforeRenderObservable.clear(),E._onAfterRenderObservable&&E._onAfterRenderObservable.clear(),E._onBetweenPassObservable&&E._onBetweenPassObservable.clear(),this._scene.useClonedMeshMap){if(E.meshMap)for(const I in E.meshMap){const Z=E.meshMap[I];Z&&(Z._internalMeshDataInfo._source=null,E.meshMap[I]=void 0)}E._source&&E._source._internalMeshDataInfo.meshMap&&(E._source._internalMeshDataInfo.meshMap[this.uniqueId]=void 0)}else{const I=this.getScene().meshes;for(const Z of I){const re=Z;re._internalMeshDataInfo&&re._internalMeshDataInfo._source&&re._internalMeshDataInfo._source===this&&(re._internalMeshDataInfo._source=null)}}E._source=null,this._instanceDataStorage.visibleInstances={},this._disposeInstanceSpecificData(),this._disposeThinInstanceSpecificData(),this._internalMeshDataInfo._checkReadinessObserver&&this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),super.dispose(p,_)}_disposeInstanceSpecificData(){}_disposeThinInstanceSpecificData(){}_invalidateInstanceVertexArrayObject(){}applyDisplacementMap(p,_,E,I,Z,re,ae=!1,he){const _e=this.getScene(),ve=Le=>{const ze=Le.width,He=Le.height,rt=this.getEngine().createCanvas(ze,He).getContext("2d");rt.drawImage(Le,0,0);const Tt=rt.getImageData(0,0,ze,He).data;this.applyDisplacementMapFromBuffer(Tt,ze,He,_,E,Z,re,ae),I&&I(this)};return lt.LoadImage(p,ve,he||(()=>{}),_e.offlineProvider),this}applyDisplacementMapFromBuffer(p,_,E,I,Z,re,ae,he=!1){if(!this.isVerticesDataPresent(ut.PositionKind)||!this.isVerticesDataPresent(ut.NormalKind)||!this.isVerticesDataPresent(ut.UVKind))return Ti.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"),this;const _e=this.getVerticesData(ut.PositionKind,!0,!0),ve=this.getVerticesData(ut.NormalKind),Le=this.getVerticesData(ut.UVKind);let ze=at.Zero();const He=at.Zero(),xt=xr.Zero();re=re||xr.Zero(),ae=ae||new xr(1,1);for(let rt=0;rt<_e.length;rt+=3){at.FromArrayToRef(_e,rt,ze),at.FromArrayToRef(ve,rt,He),xr.FromArrayToRef(Le,rt/3*2,xt);const Tt=Math.abs(xt.x*ae.x+re.x%1)*(_-1)%_|0,Lt=Math.abs(xt.y*ae.y+re.y%1)*(E-1)%E|0,Nt=(Tt+Lt*_)*4,qt=p[Nt]/255,Xt=p[Nt+1]/255,zt=p[Nt+2]/255,Gt=qt*.3+Xt*.59+zt*.11;He.normalize(),He.scaleInPlace(I+(Z-I)*Gt),ze=ze.add(He),ze.toArray(_e,rt)}return Xr.ComputeNormals(_e,this.getIndices(),ve),he?(this.setVerticesData(ut.PositionKind,_e),this.setVerticesData(ut.NormalKind,ve),this.setVerticesData(ut.UVKind,Le)):(this.updateVerticesData(ut.PositionKind,_e),this.updateVerticesData(ut.NormalKind,ve)),this}_getFlattenedNormals(p,_){const E=new Float32Array(p.length*3);let I=0;const Z=this.overrideMaterialSideOrientation===(this._scene.useRightHandedSystem?1:0);for(let re=0;re<p.length;re+=3){const ae=at.FromArray(_,p[re]*3),he=at.FromArray(_,p[re+1]*3),_e=at.FromArray(_,p[re+2]*3),ve=ae.subtract(he),Le=_e.subtract(he),ze=at.Normalize(at.Cross(ve,Le));Z&&ze.scaleInPlace(-1);for(let He=0;He<3;He++)E[I++]=ze.x,E[I++]=ze.y,E[I++]=ze.z}return E}_convertToUnIndexedMesh(p=!1){const _=this.getVerticesDataKinds(),E=this.getIndices(),I={},Z=(ae,he)=>{const _e=new Float32Array(E.length*he);let ve=0;for(let Le=0;Le<E.length;Le++)for(let ze=0;ze<he;ze++)_e[ve++]=ae[E[Le]*he+ze];return _e},re=this.geometry?this.subMeshes.slice(0):[];for(const ae of _)I[ae]=this.getVerticesData(ae);for(const ae of _){const he=this.getVertexBuffer(ae),_e=he.getStrideSize();if(p&&ae===ut.NormalKind){const ve=this._getFlattenedNormals(E,I[ut.PositionKind]);this.setVerticesData(ut.NormalKind,ve,he.isUpdatable(),_e)}else this.setVerticesData(ae,Z(I[ae],_e),he.isUpdatable(),_e)}if(this.morphTargetManager){for(let ae=0;ae<this.morphTargetManager.numTargets;ae++){const he=this.morphTargetManager.getTarget(ae),_e=he.getPositions();he.setPositions(Z(_e,3));const ve=he.getNormals();ve&&he.setNormals(p?this._getFlattenedNormals(E,_e):Z(ve,3));const Le=he.getTangents();Le&&he.setTangents(Z(Le,3));const ze=he.getUVs();ze&&he.setUVs(Z(ze,2))}this.morphTargetManager.synchronize()}for(let ae=0;ae<E.length;ae++)E[ae]=ae;this.setIndices(E),this._unIndexed=!0,this.releaseSubMeshes();for(const ae of re)l2.AddToMesh(ae.materialIndex,ae.indexStart,ae.indexCount,ae.indexStart,ae.indexCount,this);return this.synchronizeInstances(),this}convertToFlatShadedMesh(){return this._convertToUnIndexedMesh(!0)}convertToUnIndexedMesh(){return this._convertToUnIndexedMesh()}flipFaces(p=!1){const _=Xr.ExtractFromMesh(this);let E;if(p&&this.isVerticesDataPresent(ut.NormalKind)&&_.normals)for(E=0;E<_.normals.length;E++)_.normals[E]*=-1;if(_.indices){let I;for(E=0;E<_.indices.length;E+=3)I=_.indices[E+1],_.indices[E+1]=_.indices[E+2],_.indices[E+2]=I}return _.applyToMesh(this,this.isVertexBufferUpdatable(ut.PositionKind)),this}increaseVertices(p=1){const _=Xr.ExtractFromMesh(this),E=_.indices&&!Array.isArray(_.indices)&&Array.from?Array.from(_.indices):_.indices,I=_.positions&&!Array.isArray(_.positions)&&Array.from?Array.from(_.positions):_.positions,Z=_.uvs&&!Array.isArray(_.uvs)&&Array.from?Array.from(_.uvs):_.uvs,re=_.normals&&!Array.isArray(_.normals)&&Array.from?Array.from(_.normals):_.normals;if(!E||!I)Ti.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");else{_.indices=E,_.positions=I,Z&&(_.uvs=Z),re&&(_.normals=re);const ae=p+1,he=new Array;for(let zt=0;zt<ae+1;zt++)he[zt]=new Array;let _e,ve;const Le=new at(0,0,0),ze=new at(0,0,0),He=new xr(0,0),xt=new Array,rt=new Array,Tt=new Array;let Lt,Nt=I.length,qt;Z&&(qt=Z.length);let Xt;re&&(Xt=re.length);for(let zt=0;zt<E.length;zt+=3){rt[0]=E[zt],rt[1]=E[zt+1],rt[2]=E[zt+2];for(let Gt=0;Gt<3;Gt++)if(_e=rt[Gt],ve=rt[(Gt+1)%3],Tt[_e]===void 0&&Tt[ve]===void 0?(Tt[_e]=new Array,Tt[ve]=new Array):(Tt[_e]===void 0&&(Tt[_e]=new Array),Tt[ve]===void 0&&(Tt[ve]=new Array)),Tt[_e][ve]===void 0&&Tt[ve][_e]===void 0){Tt[_e][ve]=[],Le.x=(I[3*ve]-I[3*_e])/ae,Le.y=(I[3*ve+1]-I[3*_e+1])/ae,Le.z=(I[3*ve+2]-I[3*_e+2])/ae,re&&(ze.x=(re[3*ve]-re[3*_e])/ae,ze.y=(re[3*ve+1]-re[3*_e+1])/ae,ze.z=(re[3*ve+2]-re[3*_e+2])/ae),Z&&(He.x=(Z[2*ve]-Z[2*_e])/ae,He.y=(Z[2*ve+1]-Z[2*_e+1])/ae),Tt[_e][ve].push(_e);for(let xi=1;xi<ae;xi++)Tt[_e][ve].push(I.length/3),I[Nt++]=I[3*_e]+xi*Le.x,I[Nt++]=I[3*_e+1]+xi*Le.y,I[Nt++]=I[3*_e+2]+xi*Le.z,re&&(re[Xt++]=re[3*_e]+xi*ze.x,re[Xt++]=re[3*_e+1]+xi*ze.y,re[Xt++]=re[3*_e+2]+xi*ze.z),Z&&(Z[qt++]=Z[2*_e]+xi*He.x,Z[qt++]=Z[2*_e+1]+xi*He.y);Tt[_e][ve].push(ve),Tt[ve][_e]=new Array,Lt=Tt[_e][ve].length;for(let xi=0;xi<Lt;xi++)Tt[ve][_e][xi]=Tt[_e][ve][Lt-1-xi]}he[0][0]=E[zt],he[1][0]=Tt[E[zt]][E[zt+1]][1],he[1][1]=Tt[E[zt]][E[zt+2]][1];for(let Gt=2;Gt<ae;Gt++){he[Gt][0]=Tt[E[zt]][E[zt+1]][Gt],he[Gt][Gt]=Tt[E[zt]][E[zt+2]][Gt],Le.x=(I[3*he[Gt][Gt]]-I[3*he[Gt][0]])/Gt,Le.y=(I[3*he[Gt][Gt]+1]-I[3*he[Gt][0]+1])/Gt,Le.z=(I[3*he[Gt][Gt]+2]-I[3*he[Gt][0]+2])/Gt,re&&(ze.x=(re[3*he[Gt][Gt]]-re[3*he[Gt][0]])/Gt,ze.y=(re[3*he[Gt][Gt]+1]-re[3*he[Gt][0]+1])/Gt,ze.z=(re[3*he[Gt][Gt]+2]-re[3*he[Gt][0]+2])/Gt),Z&&(He.x=(Z[2*he[Gt][Gt]]-Z[2*he[Gt][0]])/Gt,He.y=(Z[2*he[Gt][Gt]+1]-Z[2*he[Gt][0]+1])/Gt);for(let xi=1;xi<Gt;xi++)he[Gt][xi]=I.length/3,I[Nt++]=I[3*he[Gt][0]]+xi*Le.x,I[Nt++]=I[3*he[Gt][0]+1]+xi*Le.y,I[Nt++]=I[3*he[Gt][0]+2]+xi*Le.z,re&&(re[Xt++]=re[3*he[Gt][0]]+xi*ze.x,re[Xt++]=re[3*he[Gt][0]+1]+xi*ze.y,re[Xt++]=re[3*he[Gt][0]+2]+xi*ze.z),Z&&(Z[qt++]=Z[2*he[Gt][0]]+xi*He.x,Z[qt++]=Z[2*he[Gt][0]+1]+xi*He.y)}he[ae]=Tt[E[zt+1]][E[zt+2]],xt.push(he[0][0],he[1][0],he[1][1]);for(let Gt=1;Gt<ae;Gt++){let xi;for(xi=0;xi<Gt;xi++)xt.push(he[Gt][xi],he[Gt+1][xi],he[Gt+1][xi+1]),xt.push(he[Gt][xi],he[Gt+1][xi+1],he[Gt][xi+1]);xt.push(he[Gt][xi],he[Gt+1][xi],he[Gt+1][xi+1])}}_.indices=xt,_.applyToMesh(this,this.isVertexBufferUpdatable(ut.PositionKind))}}forceSharedVertices(){const p=Xr.ExtractFromMesh(this),_=p.uvs,E=p.indices,I=p.positions,Z=p.colors,re=p.matricesIndices,ae=p.matricesWeights,he=p.matricesIndicesExtra,_e=p.matricesWeightsExtra;if(E===void 0||I===void 0||E===null||I===null)Ti.Warn("VertexData contains empty entries");else{const ve=new Array,Le=new Array,ze=new Array,He=new Array,xt=new Array,rt=new Array,Tt=new Array,Lt=new Array;let Nt=new Array,qt=0;const Xt={};let zt,Gt;for(let Gi=0;Gi<E.length;Gi+=3){Gt=[E[Gi],E[Gi+1],E[Gi+2]],Nt=[];for(let vs=0;vs<3;vs++){Nt[vs]="";for(let ks=0;ks<3;ks++)Math.abs(I[3*Gt[vs]+ks])<1e-8&&(I[3*Gt[vs]+ks]=0),Nt[vs]+=I[3*Gt[vs]+ks]+"|"}if(!(Nt[0]==Nt[1]||Nt[0]==Nt[2]||Nt[1]==Nt[2]))for(let vs=0;vs<3;vs++){if(zt=Xt[Nt[vs]],zt===void 0){Xt[Nt[vs]]=qt,zt=qt++;for(let ks=0;ks<3;ks++)ve.push(I[3*Gt[vs]+ks]);if(Z!=null)for(let ks=0;ks<4;ks++)He.push(Z[4*Gt[vs]+ks]);if(_!=null)for(let ks=0;ks<2;ks++)ze.push(_[2*Gt[vs]+ks]);if(re!=null)for(let ks=0;ks<4;ks++)xt.push(re[4*Gt[vs]+ks]);if(ae!=null)for(let ks=0;ks<4;ks++)rt.push(ae[4*Gt[vs]+ks]);if(he!=null)for(let ks=0;ks<4;ks++)Tt.push(he[4*Gt[vs]+ks]);if(_e!=null)for(let ks=0;ks<4;ks++)Lt.push(_e[4*Gt[vs]+ks])}Le.push(zt)}}const xi=new Array;Xr.ComputeNormals(ve,Le,xi),p.positions=ve,p.indices=Le,p.normals=xi,_!=null&&(p.uvs=ze),Z!=null&&(p.colors=He),re!=null&&(p.matricesIndices=xt),ae!=null&&(p.matricesWeights=rt),he!=null&&(p.matricesIndicesExtra=Tt),ae!=null&&(p.matricesWeightsExtra=Lt),p.applyToMesh(this,this.isVertexBufferUpdatable(ut.PositionKind))}}static _instancedMeshFactory(p,_){throw ur("InstancedMesh")}static _PhysicsImpostorParser(p,_,E){throw ur("PhysicsImpostor")}createInstance(p){return vr._instancedMeshFactory(p,this)}synchronizeInstances(){for(let p=0;p<this.instances.length;p++)this.instances[p]._syncSubMeshes();return this}optimizeIndices(p){const _=this.getIndices(),E=this.getVerticesData(ut.PositionKind);if(!E||!_)return this;const I=[];for(let re=0;re<E.length;re=re+3)I.push(at.FromArray(E,re));const Z=[];return wi.SyncAsyncForLoop(I.length,40,re=>{const ae=I.length-1-re,he=I[ae];for(let _e=0;_e<ae;++_e){const ve=I[_e];if(he.equals(ve)){Z[ae]=_e;break}}},()=>{for(let ae=0;ae<_.length;++ae)_[ae]=Z[_[ae]]||_[ae];const re=this.subMeshes.slice(0);this.setIndices(_),this.subMeshes=re,p&&p(this)}),this}serialize(p={}){p.name=this.name,p.id=this.id,p.uniqueId=this.uniqueId,p.type=this.getClassName(),ri&&ri.HasTags(this)&&(p.tags=ri.GetTags(this)),p.position=this.position.asArray(),this.rotationQuaternion?p.rotationQuaternion=this.rotationQuaternion.asArray():this.rotation&&(p.rotation=this.rotation.asArray()),p.scaling=this.scaling.asArray(),this._postMultiplyPivotMatrix?p.pivotMatrix=this.getPivotMatrix().asArray():p.localMatrix=this.getPivotMatrix().asArray(),p.isEnabled=this.isEnabled(!1),p.isVisible=this.isVisible,p.infiniteDistance=this.infiniteDistance,p.pickable=this.isPickable,p.receiveShadows=this.receiveShadows,p.billboardMode=this.billboardMode,p.visibility=this.visibility,p.checkCollisions=this.checkCollisions,p.isBlocker=this.isBlocker,p.overrideMaterialSideOrientation=this.overrideMaterialSideOrientation,this.parent&&this.parent._serializeAsParent(p),p.isUnIndexed=this.isUnIndexed;const _=this._geometry;if(_&&this.subMeshes){p.geometryUniqueId=_.uniqueId,p.geometryId=_.id,p.subMeshes=[];for(let E=0;E<this.subMeshes.length;E++){const I=this.subMeshes[E];p.subMeshes.push({materialIndex:I.materialIndex,verticesStart:I.verticesStart,verticesCount:I.verticesCount,indexStart:I.indexStart,indexCount:I.indexCount})}}if(this.material?this.material.doNotSerialize||(p.materialUniqueId=this.material.uniqueId,p.materialId=this.material.id):(this.material=null,p.materialUniqueId=this._scene.defaultMaterial.uniqueId,p.materialId=this._scene.defaultMaterial.id),this.morphTargetManager&&(p.morphTargetManagerId=this.morphTargetManager.uniqueId),this.skeleton&&(p.skeletonId=this.skeleton.id,p.numBoneInfluencers=this.numBoneInfluencers),this.getScene()._getComponent(_r.NAME_PHYSICSENGINE)){const E=this.getPhysicsImpostor();E&&(p.physicsMass=E.getParam("mass"),p.physicsFriction=E.getParam("friction"),p.physicsRestitution=E.getParam("mass"),p.physicsImpostor=E.type)}this.metadata&&(p.metadata=this.metadata),p.instances=[];for(let E=0;E<this.instances.length;E++){const I=this.instances[E];if(I.doNotSerialize)continue;const Z={name:I.name,id:I.id,isEnabled:I.isEnabled(!1),isVisible:I.isVisible,isPickable:I.isPickable,checkCollisions:I.checkCollisions,position:I.position.asArray(),scaling:I.scaling.asArray()};if(I.parent&&I.parent._serializeAsParent(Z),I.rotationQuaternion?Z.rotationQuaternion=I.rotationQuaternion.asArray():I.rotation&&(Z.rotation=I.rotation.asArray()),this.getScene()._getComponent(_r.NAME_PHYSICSENGINE)){const re=I.getPhysicsImpostor();re&&(Z.physicsMass=re.getParam("mass"),Z.physicsFriction=re.getParam("friction"),Z.physicsRestitution=re.getParam("mass"),Z.physicsImpostor=re.type)}I.metadata&&(Z.metadata=I.metadata),I.actionManager&&(Z.actions=I.actionManager.serialize(I.name)),p.instances.push(Z),Hr.AppendSerializedAnimations(I,Z),Z.ranges=I.serializeAnimationRanges()}if(this._thinInstanceDataStorage.instancesCount&&this._thinInstanceDataStorage.matrixData&&(p.thinInstances={instancesCount:this._thinInstanceDataStorage.instancesCount,matrixData:Array.from(this._thinInstanceDataStorage.matrixData),matrixBufferSize:this._thinInstanceDataStorage.matrixBufferSize,enablePicking:this.thinInstanceEnablePicking},this._userThinInstanceBuffersStorage)){const E={data:{},sizes:{},strides:{}};for(const I in this._userThinInstanceBuffersStorage.data)E.data[I]=Array.from(this._userThinInstanceBuffersStorage.data[I]),E.sizes[I]=this._userThinInstanceBuffersStorage.sizes[I],E.strides[I]=this._userThinInstanceBuffersStorage.strides[I];p.thinInstances.userThinInstance=E}return Hr.AppendSerializedAnimations(this,p),p.ranges=this.serializeAnimationRanges(),p.layerMask=this.layerMask,p.alphaIndex=this.alphaIndex,p.hasVertexAlpha=this.hasVertexAlpha,p.overlayAlpha=this.overlayAlpha,p.overlayColor=this.overlayColor.asArray(),p.renderOverlay=this.renderOverlay,p.applyFog=this.applyFog,this.actionManager&&(p.actions=this.actionManager.serialize(this.name)),p}_syncGeometryWithMorphTargetManager(){if(!this.geometry)return;this._markSubMeshesAsAttributesDirty();const p=this._internalAbstractMeshDataInfo._morphTargetManager;if(p&&p.vertexCount){if(p.vertexCount!==this.getTotalVertices()){Ti.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."),this.morphTargetManager=null;return}if(p.isUsingTextureForTargets)return;for(let _=0;_<p.numInfluencers;_++){const E=p.getActiveTarget(_),I=E.getPositions();if(!I){Ti.Error("Invalid morph target. Target must have positions.");return}this.geometry.setVerticesData(ut.PositionKind+_,I,!1,3);const Z=E.getNormals();Z&&this.geometry.setVerticesData(ut.NormalKind+_,Z,!1,3);const re=E.getTangents();re&&this.geometry.setVerticesData(ut.TangentKind+_,re,!1,3);const ae=E.getUVs();ae&&this.geometry.setVerticesData(ut.UVKind+"_"+_,ae,!1,2)}}else{let _=0;for(;this.geometry.isVerticesDataPresent(ut.PositionKind+_);)this.geometry.removeVerticesData(ut.PositionKind+_),this.geometry.isVerticesDataPresent(ut.NormalKind+_)&&this.geometry.removeVerticesData(ut.NormalKind+_),this.geometry.isVerticesDataPresent(ut.TangentKind+_)&&this.geometry.removeVerticesData(ut.TangentKind+_),this.geometry.isVerticesDataPresent(ut.UVKind+_)&&this.geometry.removeVerticesData(ut.UVKind+"_"+_),_++}}static Parse(p,_,E){let I;if(p.type&&p.type==="LinesMesh"?I=vr._LinesMeshParser(p,_):p.type&&p.type==="GroundMesh"?I=vr._GroundMeshParser(p,_):p.type&&p.type==="GoldbergMesh"?I=vr._GoldbergMeshParser(p,_):p.type&&p.type==="GreasedLineMesh"?I=vr._GreasedLineMeshParser(p,_):p.type&&p.type==="TrailMesh"?I=vr._TrailMeshParser(p,_):I=new vr(p.name,_),I.id=p.id,I._waitingParsedUniqueId=p.uniqueId,ri&&ri.AddTagsTo(I,p.tags),I.position=at.FromArray(p.position),p.metadata!==void 0&&(I.metadata=p.metadata),p.rotationQuaternion?I.rotationQuaternion=us.FromArray(p.rotationQuaternion):p.rotation&&(I.rotation=at.FromArray(p.rotation)),I.scaling=at.FromArray(p.scaling),p.localMatrix?I.setPreTransformMatrix(jt.FromArray(p.localMatrix)):p.pivotMatrix&&I.setPivotMatrix(jt.FromArray(p.pivotMatrix)),I.setEnabled(p.isEnabled),I.isVisible=p.isVisible,I.infiniteDistance=p.infiniteDistance,I.showBoundingBox=p.showBoundingBox,I.showSubMeshesBoundingBox=p.showSubMeshesBoundingBox,p.applyFog!==void 0&&(I.applyFog=p.applyFog),p.pickable!==void 0&&(I.isPickable=p.pickable),p.alphaIndex!==void 0&&(I.alphaIndex=p.alphaIndex),I.receiveShadows=p.receiveShadows,p.billboardMode!==void 0&&(I.billboardMode=p.billboardMode),p.visibility!==void 0&&(I.visibility=p.visibility),I.checkCollisions=p.checkCollisions,p.overrideMaterialSideOrientation!==void 0&&(I.overrideMaterialSideOrientation=p.overrideMaterialSideOrientation),p.isBlocker!==void 0&&(I.isBlocker=p.isBlocker),I._shouldGenerateFlatShading=p.useFlatShading,p.freezeWorldMatrix&&(I._waitingData.freezeWorldMatrix=p.freezeWorldMatrix),p.parentId!==void 0&&(I._waitingParentId=p.parentId),p.parentInstanceIndex!==void 0&&(I._waitingParentInstanceIndex=p.parentInstanceIndex),p.actions!==void 0&&(I._waitingData.actions=p.actions),p.overlayAlpha!==void 0&&(I.overlayAlpha=p.overlayAlpha),p.overlayColor!==void 0&&(I.overlayColor=Rs.FromArray(p.overlayColor)),p.renderOverlay!==void 0&&(I.renderOverlay=p.renderOverlay),I.isUnIndexed=!!p.isUnIndexed,I.hasVertexAlpha=p.hasVertexAlpha,p.delayLoadingFile?(I.delayLoadState=4,I.delayLoadingFile=E+p.delayLoadingFile,I.buildBoundingInfo(at.FromArray(p.boundingBoxMinimum),at.FromArray(p.boundingBoxMaximum)),p._binaryInfo&&(I._binaryInfo=p._binaryInfo),I._delayInfo=[],p.hasUVs&&I._delayInfo.push(ut.UVKind),p.hasUVs2&&I._delayInfo.push(ut.UV2Kind),p.hasUVs3&&I._delayInfo.push(ut.UV3Kind),p.hasUVs4&&I._delayInfo.push(ut.UV4Kind),p.hasUVs5&&I._delayInfo.push(ut.UV5Kind),p.hasUVs6&&I._delayInfo.push(ut.UV6Kind),p.hasColors&&I._delayInfo.push(ut.ColorKind),p.hasMatricesIndices&&I._delayInfo.push(ut.MatricesIndicesKind),p.hasMatricesWeights&&I._delayInfo.push(ut.MatricesWeightsKind),I._delayLoadingFunction=cx._ImportGeometry,R0.ForceFullSceneLoadingForIncremental&&I._checkDelayState()):cx._ImportGeometry(p,I),p.materialUniqueId?I._waitingMaterialId=p.materialUniqueId:p.materialId&&(I._waitingMaterialId=p.materialId),p.morphTargetManagerId>-1&&(I.morphTargetManager=_.getMorphTargetManagerById(p.morphTargetManagerId)),p.skeletonId!==void 0&&p.skeletonId!==null&&(I.skeleton=_.getLastSkeletonById(p.skeletonId),p.numBoneInfluencers&&(I.numBoneInfluencers=p.numBoneInfluencers)),p.animations){for(let Z=0;Z<p.animations.length;Z++){const re=p.animations[Z],ae=r0("BABYLON.Animation");ae&&I.animations.push(ae.Parse(re))}Ha.ParseAnimationRanges(I,p,_)}if(p.autoAnimate&&_.beginAnimation(I,p.autoAnimateFrom,p.autoAnimateTo,p.autoAnimateLoop,p.autoAnimateSpeed||1),p.layerMask&&!isNaN(p.layerMask)?I.layerMask=Math.abs(parseInt(p.layerMask)):I.layerMask=268435455,p.physicsImpostor&&vr._PhysicsImpostorParser(_,I,p),p.lodMeshIds&&(I._waitingData.lods={ids:p.lodMeshIds,distances:p.lodDistances?p.lodDistances:null,coverages:p.lodCoverages?p.lodCoverages:null}),p.instances)for(let Z=0;Z<p.instances.length;Z++){const re=p.instances[Z],ae=I.createInstance(re.name);if(re.id&&(ae.id=re.id),ri&&(re.tags?ri.AddTagsTo(ae,re.tags):ri.AddTagsTo(ae,p.tags)),ae.position=at.FromArray(re.position),re.metadata!==void 0&&(ae.metadata=re.metadata),re.parentId!==void 0&&(ae._waitingParentId=re.parentId),re.parentInstanceIndex!==void 0&&(ae._waitingParentInstanceIndex=re.parentInstanceIndex),re.isEnabled!==void 0&&re.isEnabled!==null&&ae.setEnabled(re.isEnabled),re.isVisible!==void 0&&re.isVisible!==null&&(ae.isVisible=re.isVisible),re.isPickable!==void 0&&re.isPickable!==null&&(ae.isPickable=re.isPickable),re.rotationQuaternion?ae.rotationQuaternion=us.FromArray(re.rotationQuaternion):re.rotation&&(ae.rotation=at.FromArray(re.rotation)),ae.scaling=at.FromArray(re.scaling),re.checkCollisions!=null&&re.checkCollisions!=null&&(ae.checkCollisions=re.checkCollisions),re.pickable!=null&&re.pickable!=null&&(ae.isPickable=re.pickable),re.showBoundingBox!=null&&re.showBoundingBox!=null&&(ae.showBoundingBox=re.showBoundingBox),re.showSubMeshesBoundingBox!=null&&re.showSubMeshesBoundingBox!=null&&(ae.showSubMeshesBoundingBox=re.showSubMeshesBoundingBox),re.alphaIndex!=null&&re.showSubMeshesBoundingBox!=null&&(ae.alphaIndex=re.alphaIndex),re.physicsImpostor&&vr._PhysicsImpostorParser(_,ae,re),re.actions!==void 0&&(ae._waitingData.actions=re.actions),re.animations){for(let he=0;he<re.animations.length;he++){const _e=re.animations[he],ve=r0("BABYLON.Animation");ve&&ae.animations.push(ve.Parse(_e))}Ha.ParseAnimationRanges(ae,re,_),re.autoAnimate&&_.beginAnimation(ae,re.autoAnimateFrom,re.autoAnimateTo,re.autoAnimateLoop,re.autoAnimateSpeed||1)}}if(p.thinInstances){const Z=p.thinInstances;if(I.thinInstanceEnablePicking=!!Z.enablePicking,Z.matrixData?(I.thinInstanceSetBuffer("matrix",new Float32Array(Z.matrixData),16,!1),I._thinInstanceDataStorage.matrixBufferSize=Z.matrixBufferSize,I._thinInstanceDataStorage.instancesCount=Z.instancesCount):I._thinInstanceDataStorage.matrixBufferSize=Z.matrixBufferSize,p.thinInstances.userThinInstance){const re=p.thinInstances.userThinInstance;for(const ae in re.data)I.thinInstanceSetBuffer(ae,new Float32Array(re.data[ae]),re.strides[ae],!1),I._userThinInstanceBuffersStorage.sizes[ae]=re.sizes[ae]}}return I}setPositionsForCPUSkinning(){const p=this._internalMeshDataInfo;if(!p._sourcePositions){const _=this.getVerticesData(ut.PositionKind);if(!_)return p._sourcePositions;p._sourcePositions=new Float32Array(_),this.isVertexBufferUpdatable(ut.PositionKind)||this.setVerticesData(ut.PositionKind,_,!0)}return p._sourcePositions}setNormalsForCPUSkinning(){const p=this._internalMeshDataInfo;if(!p._sourceNormals){const _=this.getVerticesData(ut.NormalKind);if(!_)return p._sourceNormals;p._sourceNormals=new Float32Array(_),this.isVertexBufferUpdatable(ut.NormalKind)||this.setVerticesData(ut.NormalKind,_,!0)}return p._sourceNormals}applySkeleton(p){if(!this.geometry)return this;if(this.geometry._softwareSkinningFrameId==this.getScene().getFrameId())return this;if(this.geometry._softwareSkinningFrameId=this.getScene().getFrameId(),!this.isVerticesDataPresent(ut.PositionKind))return this;if(!this.isVerticesDataPresent(ut.MatricesIndicesKind))return this;if(!this.isVerticesDataPresent(ut.MatricesWeightsKind))return this;const _=this.isVerticesDataPresent(ut.NormalKind),E=this._internalMeshDataInfo;if(!E._sourcePositions){const Lt=this.subMeshes.slice();this.setPositionsForCPUSkinning(),this.subMeshes=Lt}_&&!E._sourceNormals&&this.setNormalsForCPUSkinning();let I=this.getVerticesData(ut.PositionKind);if(!I)return this;I instanceof Float32Array||(I=new Float32Array(I));let Z=this.getVerticesData(ut.NormalKind);if(_){if(!Z)return this;Z instanceof Float32Array||(Z=new Float32Array(Z))}const re=this.getVerticesData(ut.MatricesIndicesKind),ae=this.getVerticesData(ut.MatricesWeightsKind);if(!ae||!re)return this;const he=this.numBoneInfluencers>4,_e=he?this.getVerticesData(ut.MatricesIndicesExtraKind):null,ve=he?this.getVerticesData(ut.MatricesWeightsExtraKind):null,Le=p.getTransformMatrices(this),ze=at.Zero(),He=new jt,xt=new jt;let rt=0,Tt;for(let Lt=0;Lt<I.length;Lt+=3,rt+=4){let Nt;for(Tt=0;Tt<4;Tt++)Nt=ae[rt+Tt],Nt>0&&(jt.FromFloat32ArrayToRefScaled(Le,Math.floor(re[rt+Tt]*16),Nt,xt),He.addToSelf(xt));if(he)for(Tt=0;Tt<4;Tt++)Nt=ve[rt+Tt],Nt>0&&(jt.FromFloat32ArrayToRefScaled(Le,Math.floor(_e[rt+Tt]*16),Nt,xt),He.addToSelf(xt));at.TransformCoordinatesFromFloatsToRef(E._sourcePositions[Lt],E._sourcePositions[Lt+1],E._sourcePositions[Lt+2],He,ze),ze.toArray(I,Lt),_&&(at.TransformNormalFromFloatsToRef(E._sourceNormals[Lt],E._sourceNormals[Lt+1],E._sourceNormals[Lt+2],He,ze),ze.toArray(Z,Lt)),He.reset()}return this.updateVerticesData(ut.PositionKind,I),_&&this.updateVerticesData(ut.NormalKind,Z),this}static MinMax(p){let _=null,E=null;return p.forEach(function(I){const re=I.getBoundingInfo().boundingBox;!_||!E?(_=re.minimumWorld,E=re.maximumWorld):(_.minimizeInPlace(re.minimumWorld),E.maximizeInPlace(re.maximumWorld))}),!_||!E?{min:at.Zero(),max:at.Zero()}:{min:_,max:E}}static Center(p){const _=p instanceof Array?vr.MinMax(p):p;return at.Center(_.min,_.max)}static MergeMeshes(p,_=!0,E,I,Z,re){return $g(vr._MergeMeshesCoroutine(p,_,E,I,Z,re,!1))}static MergeMeshesAsync(p,_=!0,E,I,Z,re){return Wb(vr._MergeMeshesCoroutine(p,_,E,I,Z,re,!0),TO())}static*_MergeMeshesCoroutine(p,_=!0,E,I,Z,re,ae){if(p=p.filter(Boolean),p.length===0)return null;let he;if(!E){let xi=0;for(he=0;he<p.length;he++)if(xi+=p[he].getTotalVertices(),xi>=65536)return Ti.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"),null}re&&(Z=!1);const _e=new Array,ve=new Array,Le=new Array,ze=p[0].overrideMaterialSideOrientation;for(he=0;he<p.length;he++){const xi=p[he];if(xi.isAnInstance)return Ti.Warn("Cannot merge instance meshes."),null;if(ze!==xi.overrideMaterialSideOrientation)return Ti.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values."),null;if(Z&&Le.push(xi.getTotalIndices()),re)if(xi.material){const Gi=xi.material;if(Gi instanceof Gu){for(let vs=0;vs<Gi.subMaterials.length;vs++)_e.indexOf(Gi.subMaterials[vs])<0&&_e.push(Gi.subMaterials[vs]);for(let vs=0;vs<xi.subMeshes.length;vs++)ve.push(_e.indexOf(Gi.subMaterials[xi.subMeshes[vs].materialIndex])),Le.push(xi.subMeshes[vs].indexCount)}else{_e.indexOf(Gi)<0&&_e.push(Gi);for(let vs=0;vs<xi.subMeshes.length;vs++)ve.push(_e.indexOf(Gi)),Le.push(xi.subMeshes[vs].indexCount)}}else for(let Gi=0;Gi<xi.subMeshes.length;Gi++)ve.push(0),Le.push(xi.subMeshes[Gi].indexCount)}const He=p[0],xt=xi=>{const Gi=xi.computeWorldMatrix(!0);return{vertexData:Xr.ExtractFromMesh(xi,!1,!1),transform:Gi}},{vertexData:rt,transform:Tt}=xt(He);ae&&(yield);const Lt=new Array(p.length-1);for(let xi=1;xi<p.length;xi++)Lt[xi-1]=xt(p[xi]),ae&&(yield);const Nt=rt._mergeCoroutine(Tt,Lt,E,ae,!_);let qt=Nt.next();for(;!qt.done;)ae&&(yield),qt=Nt.next();const Xt=qt.value;I||(I=new vr(He.name+"_merged",He.getScene()));const zt=Xt._applyToCoroutine(I,void 0,ae);let Gt=zt.next();for(;!Gt.done;)ae&&(yield),Gt=zt.next();if(I.checkCollisions=He.checkCollisions,I.overrideMaterialSideOrientation=He.overrideMaterialSideOrientation,_)for(he=0;he<p.length;he++)p[he].dispose();if(Z||re){I.releaseSubMeshes(),he=0;let xi=0;for(;he<Le.length;)l2.CreateFromIndices(0,xi,Le[he],I,void 0,!1),xi+=Le[he],he++;for(const Gi of I.subMeshes)Gi.refreshBoundingInfo();I.computeWorldMatrix(!0)}if(re){const xi=new Gu(He.name+"_merged",He.getScene());xi.subMaterials=_e;for(let Gi=0;Gi<I.subMeshes.length;Gi++)I.subMeshes[Gi].materialIndex=ve[Gi];I.material=xi}else I.material=He.material;return I}addInstance(p){p._indexInSourceMeshInstanceArray=this.instances.length,this.instances.push(p)}removeInstance(p){const _=p._indexInSourceMeshInstanceArray;if(_!=-1){if(_!==this.instances.length-1){const E=this.instances[this.instances.length-1];this.instances[_]=E,E._indexInSourceMeshInstanceArray=_}p._indexInSourceMeshInstanceArray=-1,this.instances.pop()}}_shouldConvertRHS(){return this.overrideMaterialSideOrientation===zi.CounterClockWiseSideOrientation}_getRenderingFillMode(p){const _=this.getScene();return _.forcePointsCloud?zi.PointFillMode:_.forceWireframe?zi.WireFrameFillMode:this.overrideRenderingFillMode??p}setMaterialByID(p){return this.setMaterialById(p)}static CreateRibbon(p,_,E,I,Z,re,ae,he,_e){throw new Error("Import MeshBuilder to populate this function")}static CreateDisc(p,_,E,I,Z,re){throw new Error("Import MeshBuilder to populate this function")}static CreateBox(p,_,E,I,Z){throw new Error("Import MeshBuilder to populate this function")}static CreateSphere(p,_,E,I,Z,re){throw new Error("Import MeshBuilder to populate this function")}static CreateHemisphere(p,_,E,I){throw new Error("Import MeshBuilder to populate this function")}static CreateCylinder(p,_,E,I,Z,re,ae,he,_e){throw new Error("Import MeshBuilder to populate this function")}static CreateTorus(p,_,E,I,Z,re,ae){throw new Error("Import MeshBuilder to populate this function")}static CreateTorusKnot(p,_,E,I,Z,re,ae,he,_e,ve){throw new Error("Import MeshBuilder to populate this function")}static CreateLines(p,_,E,I,Z){throw new Error("Import MeshBuilder to populate this function")}static CreateDashedLines(p,_,E,I,Z,re,ae,he){throw new Error("Import MeshBuilder to populate this function")}static CreatePolygon(p,_,E,I,Z,re,ae){throw new Error("Import MeshBuilder to populate this function")}static ExtrudePolygon(p,_,E,I,Z,re,ae,he){throw new Error("Import MeshBuilder to populate this function")}static ExtrudeShape(p,_,E,I,Z,re,ae,he,_e,ve){throw new Error("Import MeshBuilder to populate this function")}static ExtrudeShapeCustom(p,_,E,I,Z,re,ae,he,_e,ve,Le,ze){throw new Error("Import MeshBuilder to populate this function")}static CreateLathe(p,_,E,I,Z,re,ae){throw new Error("Import MeshBuilder to populate this function")}static CreatePlane(p,_,E,I,Z){throw new Error("Import MeshBuilder to populate this function")}static CreateGround(p,_,E,I,Z,re){throw new Error("Import MeshBuilder to populate this function")}static CreateTiledGround(p,_,E,I,Z,re,ae,he,_e){throw new Error("Import MeshBuilder to populate this function")}static CreateGroundFromHeightMap(p,_,E,I,Z,re,ae,he,_e,ve,Le){throw new Error("Import MeshBuilder to populate this function")}static CreateTube(p,_,E,I,Z,re,ae,he,_e,ve){throw new Error("Import MeshBuilder to populate this function")}static CreatePolyhedron(p,_,E){throw new Error("Import MeshBuilder to populate this function")}static CreateIcoSphere(p,_,E){throw new Error("Import MeshBuilder to populate this function")}static CreateDecal(p,_,E,I,Z,re){throw new Error("Import MeshBuilder to populate this function")}static CreateCapsule(p,_,E){throw new Error("Import MeshBuilder to populate this function")}static ExtendToGoldberg(p){throw new Error("Import MeshBuilder to populate this function")}}vr.FRONTSIDE=Xr.FRONTSIDE,vr.BACKSIDE=Xr.BACKSIDE,vr.DOUBLESIDE=Xr.DOUBLESIDE,vr.DEFAULTSIDE=Xr.DEFAULTSIDE,vr.NO_CAP=0,vr.CAP_START=1,vr.CAP_END=2,vr.CAP_ALL=3,vr.NO_FLIP=0,vr.FLIP_TILE=1,vr.ROTATE_TILE=2,vr.FLIP_ROW=3,vr.ROTATE_ROW=4,vr.FLIP_N_ROTATE_TILE=5,vr.FLIP_N_ROTATE_ROW=6,vr.CENTER=0,vr.LEFT=1,vr.RIGHT=2,vr.TOP=3,vr.BOTTOM=4,vr.INSTANCEDMESH_SORT_TRANSPARENT=!1,vr._GroundMeshParser=(pe,p)=>{throw ur("GroundMesh")},vr._GoldbergMeshParser=(pe,p)=>{throw ur("GoldbergMesh")},vr._LinesMeshParser=(pe,p)=>{throw ur("LinesMesh")},vr._GreasedLineMeshParser=(pe,p)=>{throw ur("GreasedLineMesh")},vr._GreasedLineRibbonMeshParser=(pe,p)=>{throw ur("GreasedLineRibbonMesh")},vr._TrailMeshParser=(pe,p)=>{throw ur("TrailMesh")},Gs("BABYLON.Mesh",vr);class Kc{get influence(){return this._influence}set influence(p){if(this._influence===p)return;const _=this._influence;this._influence=p,this.onInfluenceChanged.hasObservers()&&this.onInfluenceChanged.notifyObservers(_===0||p===0)}get animationPropertiesOverride(){return!this._animationPropertiesOverride&&this._scene?this._scene.animationPropertiesOverride:this._animationPropertiesOverride}set animationPropertiesOverride(p){this._animationPropertiesOverride=p}constructor(p,_=0,E=null){this.name=p,this.animations=[],this._positions=null,this._normals=null,this._tangents=null,this._uvs=null,this._uniqueId=0,this.onInfluenceChanged=new Ri,this._onDataLayoutChanged=new Ri,this._animationPropertiesOverride=null,this._scene=E||Mr.LastCreatedScene,this.influence=_,this._scene&&(this._uniqueId=this._scene.getUniqueId())}get uniqueId(){return this._uniqueId}get hasPositions(){return!!this._positions}get hasNormals(){return!!this._normals}get hasTangents(){return!!this._tangents}get hasUVs(){return!!this._uvs}setPositions(p){const _=this.hasPositions;this._positions=p,_!==this.hasPositions&&this._onDataLayoutChanged.notifyObservers(void 0)}getPositions(){return this._positions}setNormals(p){const _=this.hasNormals;this._normals=p,_!==this.hasNormals&&this._onDataLayoutChanged.notifyObservers(void 0)}getNormals(){return this._normals}setTangents(p){const _=this.hasTangents;this._tangents=p,_!==this.hasTangents&&this._onDataLayoutChanged.notifyObservers(void 0)}getTangents(){return this._tangents}setUVs(p){const _=this.hasUVs;this._uvs=p,_!==this.hasUVs&&this._onDataLayoutChanged.notifyObservers(void 0)}getUVs(){return this._uvs}clone(){const p=Hr.Clone(()=>new Kc(this.name,this.influence,this._scene),this);return p._positions=this._positions,p._normals=this._normals,p._tangents=this._tangents,p._uvs=this._uvs,p}serialize(){const p={};return p.name=this.name,p.influence=this.influence,p.positions=Array.prototype.slice.call(this.getPositions()),this.id!=null&&(p.id=this.id),this.hasNormals&&(p.normals=Array.prototype.slice.call(this.getNormals())),this.hasTangents&&(p.tangents=Array.prototype.slice.call(this.getTangents())),this.hasUVs&&(p.uvs=Array.prototype.slice.call(this.getUVs())),Hr.AppendSerializedAnimations(this,p),p}getClassName(){return"MorphTarget"}static Parse(p,_){const E=new Kc(p.name,p.influence);if(E.setPositions(p.positions),p.id!=null&&(E.id=p.id),p.normals&&E.setNormals(p.normals),p.tangents&&E.setTangents(p.tangents),p.uvs&&E.setUVs(p.uvs),p.animations){for(let I=0;I<p.animations.length;I++){const Z=p.animations[I],re=r0("BABYLON.Animation");re&&E.animations.push(re.Parse(Z))}p.autoAnimate&&_&&_.beginAnimation(E,p.autoAnimateFrom,p.autoAnimateTo,p.autoAnimateLoop,p.autoAnimateSpeed||1)}return E}static FromMesh(p,_,E){_||(_=p.name);const I=new Kc(_,E,p.getScene());return I.setPositions(p.getVerticesData(ut.PositionKind)),p.isVerticesDataPresent(ut.NormalKind)&&I.setNormals(p.getVerticesData(ut.NormalKind)),p.isVerticesDataPresent(ut.TangentKind)&&I.setTangents(p.getVerticesData(ut.TangentKind)),p.isVerticesDataPresent(ut.UVKind)&&I.setUVs(p.getVerticesData(ut.UVKind)),I}}Rt([Ut()],Kc.prototype,"id",void 0);class u_ extends Ki{get depth(){return this._depth}constructor(p,_,E,I,Z,re,ae=!0,he=!1,_e=Ki.TRILINEAR_SAMPLINGMODE,ve=0,Le){super(null,re,!ae,he),this.format=Z,this._texture=re.getEngine().createRawTexture2DArray(p,_,E,I,Z,ae,he,_e,null,ve,Le),this._depth=I,this.is2DArray=!0}update(p){this._texture&&this._getEngine().updateRawTexture2DArray(this._texture,p,this._texture.format,this._texture.invertY,null,this._texture.type)}static CreateRGBATexture(p,_,E,I,Z,re=!0,ae=!1,he=3,_e=0){return new u_(p,_,E,I,5,Z,re,ae,he,_e)}}class $h{set areUpdatesFrozen(p){p?this._blockCounter++:(this._blockCounter--,this._blockCounter<=0&&(this._blockCounter=0,this._syncActiveTargets(!0)))}get areUpdatesFrozen(){return this._blockCounter>0}constructor(p=null){if(this._targets=new Array,this._targetInfluenceChangedObservers=new Array,this._targetDataLayoutChangedObservers=new Array,this._activeTargets=new ct(16),this._supportsNormals=!1,this._supportsTangents=!1,this._supportsUVs=!1,this._vertexCount=0,this._textureVertexStride=0,this._textureWidth=0,this._textureHeight=1,this._uniqueId=0,this._tempInfluences=new Array,this._canUseTextureForTargets=!1,this._blockCounter=0,this._parentContainer=null,this.optimizeInfluencers=!0,this.enableNormalMorphing=!0,this.enableTangentMorphing=!0,this.enableUVMorphing=!0,this._numMaxInfluencers=0,this._useTextureToStoreTargets=!0,p||(p=Mr.LastCreatedScene),this._scene=p,this._scene){this._scene.addMorphTargetManager(this),this._uniqueId=this._scene.getUniqueId();const _=this._scene.getEngine().getCaps();this._canUseTextureForTargets=_.canUseGLVertexID&&_.textureFloat&&_.maxVertexTextureImageUnits>0&&_.texture2DArrayMaxLayerCount>1}}get numMaxInfluencers(){return this._numMaxInfluencers}set numMaxInfluencers(p){this._numMaxInfluencers!==p&&(this._numMaxInfluencers=p,this._syncActiveTargets(!0))}get uniqueId(){return this._uniqueId}get vertexCount(){return this._vertexCount}get supportsNormals(){return this._supportsNormals&&this.enableNormalMorphing}get supportsTangents(){return this._supportsTangents&&this.enableTangentMorphing}get supportsUVs(){return this._supportsUVs&&this.enableUVMorphing}get numTargets(){return this._targets.length}get numInfluencers(){return this._activeTargets.length}get influences(){return this._influences}get useTextureToStoreTargets(){return this._useTextureToStoreTargets}set useTextureToStoreTargets(p){this._useTextureToStoreTargets=p}get isUsingTextureForTargets(){return $h.EnableTextureStorage&&this.useTextureToStoreTargets&&this._canUseTextureForTargets&&!this._scene?.getEngine().getCaps().disableMorphTargetTexture}getActiveTarget(p){return this._activeTargets.data[p]}getTarget(p){return this._targets[p]}addTarget(p){this._targets.push(p),this._targetInfluenceChangedObservers.push(p.onInfluenceChanged.add(_=>{this._syncActiveTargets(_)})),this._targetDataLayoutChangedObservers.push(p._onDataLayoutChanged.add(()=>{this._syncActiveTargets(!0)})),this._syncActiveTargets(!0)}removeTarget(p){const _=this._targets.indexOf(p);_>=0&&(this._targets.splice(_,1),p.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(_,1)[0]),p._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(_,1)[0]),this._syncActiveTargets(!0)),this._scene&&this._scene.stopAnimation(p)}_bind(p){p.setFloat3("morphTargetTextureInfo",this._textureVertexStride,this._textureWidth,this._textureHeight),p.setFloatArray("morphTargetTextureIndices",this._morphTargetTextureIndices),p.setTexture("morphTargets",this._targetStoreTexture),p.setInt("morphTargetCount",this.numInfluencers)}clone(){const p=new $h(this._scene);for(const _ of this._targets)p.addTarget(_.clone());return p.enableNormalMorphing=this.enableNormalMorphing,p.enableTangentMorphing=this.enableTangentMorphing,p.enableUVMorphing=this.enableUVMorphing,p}serialize(){const p={};p.id=this.uniqueId,p.targets=[];for(const _ of this._targets)p.targets.push(_.serialize());return p}_syncActiveTargets(p){if(this.areUpdatesFrozen)return;let _=0;this._activeTargets.reset(),this._supportsNormals=!0,this._supportsTangents=!0,this._supportsUVs=!0,this._vertexCount=0,this._scene&&this._targets.length>this._scene.getEngine().getCaps().texture2DArrayMaxLayerCount&&(this.useTextureToStoreTargets=!1),(!this._morphTargetTextureIndices||this._morphTargetTextureIndices.length!==this._targets.length)&&(this._morphTargetTextureIndices=new Float32Array(this._targets.length));let E=-1;for(const I of this._targets){if(E++,I.influence===0&&this.optimizeInfluencers)continue;if(this._activeTargets.length>=$h.MaxActiveMorphTargetsInVertexAttributeMode&&!this.isUsingTextureForTargets)break;this._activeTargets.push(I),this._morphTargetTextureIndices[_]=E,this._tempInfluences[_++]=I.influence,this._supportsNormals=this._supportsNormals&&I.hasNormals,this._supportsTangents=this._supportsTangents&&I.hasTangents,this._supportsUVs=this._supportsUVs&&I.hasUVs;const Z=I.getPositions();if(Z){const re=Z.length/3;if(this._vertexCount===0)this._vertexCount=re;else if(this._vertexCount!==re){Ti.Error("Incompatible target. Targets must all have the same vertices count.");return}}}this._morphTargetTextureIndices.length!==_&&(this._morphTargetTextureIndices=this._morphTargetTextureIndices.slice(0,_)),(!this._influences||this._influences.length!==_)&&(this._influences=new Float32Array(_));for(let I=0;I<_;I++)this._influences[I]=this._tempInfluences[I];p&&this.synchronize()}synchronize(){if(!(!this._scene||this.areUpdatesFrozen)){if(this.isUsingTextureForTargets&&(this._vertexCount||this.numMaxInfluencers>0)){this._textureVertexStride=1,this._supportsNormals&&this._textureVertexStride++,this._supportsTangents&&this._textureVertexStride++,this._supportsUVs&&this._textureVertexStride++,this._textureWidth=this._vertexCount*this._textureVertexStride||1,this._textureHeight=1;const p=this._scene.getEngine().getCaps().maxTextureSize;this._textureWidth>p&&(this._textureHeight=Math.ceil(this._textureWidth/p),this._textureWidth=p);let _=!0;if(this._targetStoreTexture){const E=this._targetStoreTexture.getSize();E.width===this._textureWidth&&E.height===this._textureHeight&&this._targetStoreTexture.depth===this._targets.length&&(_=!1)}if(_){this._targetStoreTexture&&this._targetStoreTexture.dispose();const E=this._targets.length,I=new Float32Array(E*this._textureWidth*this._textureHeight*4);let Z=0;for(let re=0;re<E;re++){const ae=this._targets[re],he=ae.getPositions(),_e=ae.getNormals(),ve=ae.getUVs(),Le=ae.getTangents();if(!he){re===0&&Ti.Error("Invalid morph target. Target must have positions.");return}Z=re*this._textureWidth*this._textureHeight*4;for(let ze=0;ze<this._vertexCount;ze++)I[Z]=he[ze*3],I[Z+1]=he[ze*3+1],I[Z+2]=he[ze*3+2],Z+=4,this._supportsNormals&&_e&&(I[Z]=_e[ze*3],I[Z+1]=_e[ze*3+1],I[Z+2]=_e[ze*3+2],Z+=4),this._supportsUVs&&ve&&(I[Z]=ve[ze*2],I[Z+1]=ve[ze*2+1],Z+=4),this._supportsTangents&&Le&&(I[Z]=Le[ze*3],I[Z+1]=Le[ze*3+1],I[Z+2]=Le[ze*3+2],Z+=4)}this._targetStoreTexture=u_.CreateRGBATexture(I,this._textureWidth,this._textureHeight,E,this._scene,!1,!1,1,1)}}for(const p of this._scene.meshes)p.morphTargetManager===this&&p._syncGeometryWithMorphTargetManager()}}dispose(){if(this._targetStoreTexture&&this._targetStoreTexture.dispose(),this._targetStoreTexture=null,this._scene){if(this._scene.removeMorphTargetManager(this),this._parentContainer){const p=this._parentContainer.morphTargetManagers.indexOf(this);p>-1&&this._parentContainer.morphTargetManagers.splice(p,1),this._parentContainer=null}for(const p of this._targets)this._scene.stopAnimation(p)}}static Parse(p,_){const E=new $h(_);E._uniqueId=p.id;for(const I of p.targets)E.addTarget(Kc.Parse(I,_));return E}}$h.EnableTextureStorage=!0,$h.MaxActiveMorphTargetsInVertexAttributeMode=8,vr._instancedMeshFactory=(pe,p)=>{const _=new Y1(pe,p);if(p.instancedBuffers){_.instancedBuffers={};for(const E in p.instancedBuffers)_.instancedBuffers[E]=p.instancedBuffers[E]}return _};class Y1 extends kx{constructor(p,_){super(p,_.getScene()),this._indexInSourceMeshInstanceArray=-1,this._distanceToCamera=0,_.addInstance(this),this._sourceMesh=_,this._unIndexed=_._unIndexed,this.position.copyFrom(_.position),this.rotation.copyFrom(_.rotation),this.scaling.copyFrom(_.scaling),_.rotationQuaternion&&(this.rotationQuaternion=_.rotationQuaternion.clone()),this.animations=_.animations.slice();for(const E of _.getAnimationRanges())E!=null&&this.createAnimationRange(E.name,E.from,E.to);this.infiniteDistance=_.infiniteDistance,this.setPivotMatrix(_.getPivotMatrix()),this.refreshBoundingInfo(!0,!0),this._syncSubMeshes()}getClassName(){return"InstancedMesh"}get lightSources(){return this._sourceMesh._lightSources}_resyncLightSources(){}_resyncLightSource(){}_removeLightSource(){}get receiveShadows(){return this._sourceMesh.receiveShadows}set receiveShadows(p){this._sourceMesh?.receiveShadows!==p&&lt.Warn("Setting receiveShadows on an instanced mesh has no effect")}get material(){return this._sourceMesh.material}set material(p){this._sourceMesh?.material!==p&&lt.Warn("Setting material on an instanced mesh has no effect")}get visibility(){return this._sourceMesh.visibility}set visibility(p){this._sourceMesh?.visibility!==p&&lt.Warn("Setting visibility on an instanced mesh has no effect")}get skeleton(){return this._sourceMesh.skeleton}set skeleton(p){this._sourceMesh?.skeleton!==p&&lt.Warn("Setting skeleton on an instanced mesh has no effect")}get renderingGroupId(){return this._sourceMesh.renderingGroupId}set renderingGroupId(p){!this._sourceMesh||p===this._sourceMesh.renderingGroupId||Ti.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")}getTotalVertices(){return this._sourceMesh?this._sourceMesh.getTotalVertices():0}getTotalIndices(){return this._sourceMesh.getTotalIndices()}get sourceMesh(){return this._sourceMesh}createInstance(p){return this._sourceMesh.createInstance(p)}isReady(p=!1){return this._sourceMesh.isReady(p,!0)}getVerticesData(p,_,E){return this._sourceMesh.getVerticesData(p,_,E)}setVerticesData(p,_,E,I){return this.sourceMesh&&this.sourceMesh.setVerticesData(p,_,E,I),this.sourceMesh}updateVerticesData(p,_,E,I){return this.sourceMesh&&this.sourceMesh.updateVerticesData(p,_,E,I),this.sourceMesh}setIndices(p,_=null){return this.sourceMesh&&this.sourceMesh.setIndices(p,_),this.sourceMesh}isVerticesDataPresent(p){return this._sourceMesh.isVerticesDataPresent(p)}getIndices(){return this._sourceMesh.getIndices()}get _positions(){return this._sourceMesh._positions}refreshBoundingInfo(p=!1,_=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;const E=this._sourceMesh.geometry?this._sourceMesh.geometry.boundingBias:null;return this._refreshBoundingInfo(this._sourceMesh._getPositionData(p,_),E),this}_preActivate(){return this._currentLOD&&this._currentLOD._preActivate(),this}_activate(p,_){if(super._activate(p,_),this._sourceMesh.subMeshes||Ti.Warn("Instances should only be created for meshes with geometry."),this._currentLOD){if(this._currentLOD._getWorldMatrixDeterminant()>=0!=this._getWorldMatrixDeterminant()>=0)return this._internalAbstractMeshDataInfo._actAsRegularMesh=!0,!0;if(this._internalAbstractMeshDataInfo._actAsRegularMesh=!1,this._currentLOD._registerInstanceForRenderId(this,p),_){if(!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!0,!0}else if(!this._currentLOD._internalAbstractMeshDataInfo._isActive)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances=!0,!0}return!1}_postActivate(){this._sourceMesh.edgesShareWithInstances&&this._sourceMesh._edgesRenderer&&this._sourceMesh._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup?(this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer),this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())):this._edgesRenderer&&this._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup&&this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)}getWorldMatrix(){if(this._currentLOD&&this._currentLOD.billboardMode!==Gr.BILLBOARDMODE_NONE&&this._currentLOD._masterMesh!==this){this._billboardWorldMatrix||(this._billboardWorldMatrix=new jt);const p=this._currentLOD._masterMesh;return this._currentLOD._masterMesh=this,ui.Vector3[7].copyFrom(this._currentLOD.position),this._currentLOD.position.set(0,0,0),this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)),this._currentLOD.position.copyFrom(ui.Vector3[7]),this._currentLOD._masterMesh=p,this._billboardWorldMatrix}return super.getWorldMatrix()}get isAnInstance(){return!0}getLOD(p){if(!p)return this;const _=this.sourceMesh.getLODLevels();if(!_||_.length===0)this._currentLOD=this.sourceMesh;else{const E=this.getBoundingInfo();this._currentLOD=this.sourceMesh.getLOD(p,E.boundingSphere)}return this._currentLOD}_preActivateForIntermediateRendering(p){return this.sourceMesh._preActivateForIntermediateRendering(p)}_syncSubMeshes(){if(this.releaseSubMeshes(),this._sourceMesh.subMeshes)for(let p=0;p<this._sourceMesh.subMeshes.length;p++)this._sourceMesh.subMeshes[p].clone(this,this._sourceMesh);return this}_generatePointsArray(){return this._sourceMesh._generatePointsArray()}_updateBoundingInfo(){return this.hasBoundingInfo?this.getBoundingInfo().update(this.worldMatrixFromCache):this.buildBoundingInfo(this.absolutePosition,this.absolutePosition,this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}clone(p,_=null,E,I){const Z=(I||this._sourceMesh).createInstance(p);if(jo.DeepCopy(this,Z,["name","subMeshes","uniqueId","parent","lightSources","receiveShadows","material","visibility","skeleton","sourceMesh","isAnInstance","facetNb","isFacetDataEnabled","isBlocked","useBones","hasInstances","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","hasBoundingInfo"],[]),this.refreshBoundingInfo(),_&&(Z.parent=_),!E)for(let re=0;re<this.getScene().meshes.length;re++){const ae=this.getScene().meshes[re];ae.parent===this&&ae.clone(ae.name,Z)}return Z.computeWorldMatrix(!0),this.onClonedObservable.notifyObservers(Z),Z}dispose(p,_=!1){this._sourceMesh.removeInstance(this),super.dispose(p,_)}_serializeAsParent(p){super._serializeAsParent(p),p.parentId=this._sourceMesh.uniqueId,p.parentInstanceIndex=this._indexInSourceMeshInstanceArray}instantiateHierarchy(p=null,_,E){const I=this.clone("Clone of "+(this.name||this.id),p||this.parent,!0,_&&_.newSourcedMesh);I&&E&&E(this,I);for(const Z of this.getChildTransformNodes(!0))Z.instantiateHierarchy(I,_,E);return I}}vr.prototype.registerInstancedBuffer=function(pe,p){if(this._userInstancedBuffersStorage?.vertexBuffers[pe]?.dispose(),!this.instancedBuffers){this.instancedBuffers={};for(const _ of this.instances)_.instancedBuffers={}}this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this.instancedBuffers[pe]=null,this._userInstancedBuffersStorage.strides[pe]=p,this._userInstancedBuffersStorage.sizes[pe]=p*32,this._userInstancedBuffersStorage.data[pe]=new Float32Array(this._userInstancedBuffersStorage.sizes[pe]),this._userInstancedBuffersStorage.vertexBuffers[pe]=new ut(this.getEngine(),this._userInstancedBuffersStorage.data[pe],pe,!0,!1,p,!0);for(const _ of this.instances)_.instancedBuffers[pe]=null;this._invalidateInstanceVertexArrayObject(),this._markSubMeshesAsAttributesDirty()},vr.prototype._processInstancedBuffers=function(pe,p){const _=pe?pe.length:0;for(const E in this.instancedBuffers){let I=this._userInstancedBuffersStorage.sizes[E];const Z=this._userInstancedBuffersStorage.strides[E],re=(_+1)*Z;for(;I<re;)I*=2;this._userInstancedBuffersStorage.data[E].length!=I&&(this._userInstancedBuffersStorage.data[E]=new Float32Array(I),this._userInstancedBuffersStorage.sizes[E]=I,this._userInstancedBuffersStorage.vertexBuffers[E]&&(this._userInstancedBuffersStorage.vertexBuffers[E].dispose(),this._userInstancedBuffersStorage.vertexBuffers[E]=null));const ae=this._userInstancedBuffersStorage.data[E];let he=0;if(p){const _e=this.instancedBuffers[E];_e.toArray?_e.toArray(ae,he):_e.copyToArray?_e.copyToArray(ae,he):ae[he]=_e,he+=Z}for(let _e=0;_e<_;_e++){const Le=pe[_e].instancedBuffers[E];Le.toArray?Le.toArray(ae,he):Le.copyToArray?Le.copyToArray(ae,he):ae[he]=Le,he+=Z}this._userInstancedBuffersStorage.vertexBuffers[E]?this._userInstancedBuffersStorage.vertexBuffers[E].updateDirectly(ae,0):(this._userInstancedBuffersStorage.vertexBuffers[E]=new ut(this.getEngine(),this._userInstancedBuffersStorage.data[E],E,!0,!1,Z,!0),this._invalidateInstanceVertexArrayObject())}},vr.prototype._invalidateInstanceVertexArrayObject=function(){if(!(!this._userInstancedBuffersStorage||this._userInstancedBuffersStorage.vertexArrayObjects===void 0)){for(const pe in this._userInstancedBuffersStorage.vertexArrayObjects)this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[pe]);this._userInstancedBuffersStorage.vertexArrayObjects={}}},vr.prototype._disposeInstanceSpecificData=function(){for(this._instanceDataStorage.instancesBuffer&&(this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null);this.instances.length;)this.instances[0].dispose();for(const pe in this.instancedBuffers)this._userInstancedBuffersStorage.vertexBuffers[pe]&&this._userInstancedBuffersStorage.vertexBuffers[pe].dispose();this._invalidateInstanceVertexArrayObject(),this.instancedBuffers={}};class uD extends wo{}class pD{constructor(){this.rootNodes=[],this.skeletons=[],this.animationGroups=[]}dispose(){this.rootNodes.slice(0).forEach(p=>{p.dispose()}),this.rootNodes.length=0,this.skeletons.slice(0).forEach(p=>{p.dispose()}),this.skeletons.length=0,this.animationGroups.slice(0).forEach(p=>{p.dispose()}),this.animationGroups.length=0}}class _D extends wo{constructor(p){super(),this._wasAddedToScene=!1,p=p||Mr.LastCreatedScene,p&&(this.scene=p,this.sounds=[],this.effectLayers=[],this.layers=[],this.lensFlareSystems=[],this.proceduralTextures=[],this.reflectionProbes=[],p.onDisposeObservable.add(()=>{this._wasAddedToScene||this.dispose()}),this._onContextRestoredObserver=p.getEngine().onContextRestoredObservable.add(()=>{for(const _ of this.geometries)_._rebuild();for(const _ of this.meshes)_._rebuild();for(const _ of this.particleSystems)_.rebuild();for(const _ of this.textures)_._rebuild()}))}_topologicalSort(p){const _=new Map;for(const ae of p)_.set(ae.uniqueId,ae);const E={dependsOn:new Map,dependedBy:new Map};for(const ae of p){const he=ae.uniqueId;E.dependsOn.set(he,new Set),E.dependedBy.set(he,new Set)}for(const ae of p){const he=ae.uniqueId,_e=E.dependsOn.get(he);if(ae instanceof Y1){const Le=ae.sourceMesh;_.has(Le.uniqueId)&&(_e.add(Le.uniqueId),E.dependedBy.get(Le.uniqueId).add(he))}const ve=E.dependedBy.get(he);for(const Le of ae.getDescendants()){const ze=Le.uniqueId;_.has(ze)&&(ve.add(ze),E.dependsOn.get(ze).add(he))}}const I=[],Z=[];for(const ae of p){const he=ae.uniqueId;E.dependsOn.get(he).size===0&&(Z.push(ae),_.delete(he))}const re=Z;for(;re.length>0;){const ae=re.shift();I.push(ae);const he=E.dependedBy.get(ae.uniqueId);for(const _e of Array.from(he.values())){const ve=E.dependsOn.get(_e);ve.delete(ae.uniqueId),ve.size===0&&_.get(_e)&&(re.push(_.get(_e)),_.delete(_e))}}return _.size>0&&(Ti.Error("SceneSerializer._topologicalSort: There were unvisited nodes:"),_.forEach(ae=>Ti.Error(ae.name))),I}_addNodeAndDescendantsToList(p,_,E,I){if(!(!E||I&&!I(E)||_.has(E.uniqueId))){p.push(E),_.add(E.uniqueId);for(const Z of E.getDescendants(!0))this._addNodeAndDescendantsToList(p,_,Z,I)}}_isNodeInContainer(p){return p instanceof vr&&this.meshes.indexOf(p)!==-1||p instanceof Gr&&this.transformNodes.indexOf(p)!==-1||p instanceof un&&this.lights.indexOf(p)!==-1||p instanceof Wr&&this.cameras.indexOf(p)!==-1}_isValidHierarchy(){for(const p of this.meshes)if(p.parent&&!this._isNodeInContainer(p.parent))return Ti.Warn(`Node ${p.name} has a parent that is not in the container.`),!1;for(const p of this.transformNodes)if(p.parent&&!this._isNodeInContainer(p.parent))return Ti.Warn(`Node ${p.name} has a parent that is not in the container.`),!1;for(const p of this.lights)if(p.parent&&!this._isNodeInContainer(p.parent))return Ti.Warn(`Node ${p.name} has a parent that is not in the container.`),!1;for(const p of this.cameras)if(p.parent&&!this._isNodeInContainer(p.parent))return Ti.Warn(`Node ${p.name} has a parent that is not in the container.`),!1;return!0}instantiateModelsToScene(p,_=!1,E){this._isValidHierarchy()||lt.Warn("SceneSerializer.InstantiateModelsToScene: The Asset Container hierarchy is not valid.");const I={},Z={},re=new pD,ae=[],he=[],_e={doNotInstantiate:!0,...E},ve=(rt,Tt)=>{if(I[rt.uniqueId]=Tt.uniqueId,Z[Tt.uniqueId]=Tt,p&&(Tt.name=p(rt.name)),Tt instanceof vr){const Lt=Tt;if(Lt.morphTargetManager){const Nt=rt.morphTargetManager;Lt.morphTargetManager=Nt.clone();for(let qt=0;qt<Nt.numTargets;qt++){const Xt=Nt.getTarget(qt),zt=Lt.morphTargetManager.getTarget(qt);I[Xt.uniqueId]=zt.uniqueId,Z[zt.uniqueId]=zt}}}},Le=[],ze=new Set;for(const rt of this.transformNodes)rt.parent===null&&this._addNodeAndDescendantsToList(Le,ze,rt,_e.predicate);for(const rt of this.meshes)rt.parent===null&&this._addNodeAndDescendantsToList(Le,ze,rt,_e.predicate);const He=this._topologicalSort(Le),xt=(rt,Tt)=>{if(ve(rt,Tt),rt.parent){const Lt=I[rt.parent.uniqueId],Nt=Z[Lt];Nt?Tt.parent=Nt:Tt.parent=rt.parent}if(Tt.position&&rt.position&&Tt.position.copyFrom(rt.position),Tt.rotationQuaternion&&rt.rotationQuaternion&&Tt.rotationQuaternion.copyFrom(rt.rotationQuaternion),Tt.rotation&&rt.rotation&&Tt.rotation.copyFrom(rt.rotation),Tt.scaling&&rt.scaling&&Tt.scaling.copyFrom(rt.scaling),Tt.material){const Lt=Tt;if(Lt.material)if(_){const Nt=rt.material;if(he.indexOf(Nt)===-1){let qt=Nt.clone(p?p(Nt.name):"Clone of "+Nt.name);if(he.push(Nt),I[Nt.uniqueId]=qt.uniqueId,Z[qt.uniqueId]=qt,Nt.getClassName()==="MultiMaterial"){const Xt=Nt;for(const zt of Xt.subMaterials)zt&&(qt=zt.clone(p?p(zt.name):"Clone of "+zt.name),he.push(zt),I[zt.uniqueId]=qt.uniqueId,Z[qt.uniqueId]=qt);Xt.subMaterials=Xt.subMaterials.map(zt=>zt&&Z[I[zt.uniqueId]])}}Lt.getClassName()!=="InstancedMesh"&&(Lt.material=Z[I[Nt.uniqueId]])}else Lt.material.getClassName()==="MultiMaterial"?this.scene.multiMaterials.indexOf(Lt.material)===-1&&this.scene.addMultiMaterial(Lt.material):this.scene.materials.indexOf(Lt.material)===-1&&this.scene.addMaterial(Lt.material)}Tt.parent===null&&re.rootNodes.push(Tt)};return He.forEach(rt=>{if(rt.getClassName()==="InstancedMesh"){const Tt=rt,Lt=Tt.sourceMesh,Nt=I[Lt.uniqueId],Xt=(typeof Nt=="number"?Z[Nt]:Lt).createInstance(Tt.name);xt(Tt,Xt)}else{let Tt=!0;rt.getClassName()==="TransformNode"||rt.getClassName()==="Node"||rt.skeleton||!rt.getTotalVertices||rt.getTotalVertices()===0?Tt=!1:_e.doNotInstantiate&&(typeof _e.doNotInstantiate=="function"?Tt=!_e.doNotInstantiate(rt):Tt=!_e.doNotInstantiate);const Lt=Tt?rt.createInstance(`instance of ${rt.name}`):rt.clone(`Clone of ${rt.name}`,null,!0);if(!Lt)throw new Error(`Could not clone or instantiate node on Asset Container ${rt.name}`);xt(rt,Lt)}}),this.skeletons.forEach(rt=>{if(_e.predicate&&!_e.predicate(rt))return;const Tt=rt.clone(p?p(rt.name):"Clone of "+rt.name);for(const Lt of this.meshes)if(Lt.skeleton===rt&&!Lt.isAnInstance){const Nt=Z[I[Lt.uniqueId]];if(!Nt||Nt.isAnInstance||(Nt.skeleton=Tt,ae.indexOf(Tt)!==-1))continue;ae.push(Tt);for(const qt of Tt.bones)qt._linkedTransformNode&&(qt._linkedTransformNode=Z[I[qt._linkedTransformNode.uniqueId]])}re.skeletons.push(Tt)}),this.animationGroups.forEach(rt=>{if(_e.predicate&&!_e.predicate(rt))return;const Tt=rt.clone(p?p(rt.name):"Clone of "+rt.name,Lt=>Z[I[Lt.uniqueId]]||Lt);re.animationGroups.push(Tt)}),re}addAllToScene(){if(!this._wasAddedToScene){this._isValidHierarchy()||lt.Warn("SceneSerializer.addAllToScene: The Asset Container hierarchy is not valid."),this._wasAddedToScene=!0,this.addToScene(null),this.environmentTexture&&(this.scene.environmentTexture=this.environmentTexture);for(const p of this.scene._serializableComponents)p.addFromContainer(this);this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null}}addToScene(p=null){const _=[];this.cameras.forEach(E=>{p&&!p(E)||(this.scene.addCamera(E),_.push(E))}),this.lights.forEach(E=>{p&&!p(E)||(this.scene.addLight(E),_.push(E))}),this.meshes.forEach(E=>{p&&!p(E)||(this.scene.addMesh(E),_.push(E))}),this.skeletons.forEach(E=>{p&&!p(E)||this.scene.addSkeleton(E)}),this.animations.forEach(E=>{p&&!p(E)||this.scene.addAnimation(E)}),this.animationGroups.forEach(E=>{p&&!p(E)||this.scene.addAnimationGroup(E)}),this.multiMaterials.forEach(E=>{p&&!p(E)||this.scene.addMultiMaterial(E)}),this.materials.forEach(E=>{p&&!p(E)||this.scene.addMaterial(E)}),this.morphTargetManagers.forEach(E=>{p&&!p(E)||this.scene.addMorphTargetManager(E)}),this.geometries.forEach(E=>{p&&!p(E)||this.scene.addGeometry(E)}),this.transformNodes.forEach(E=>{p&&!p(E)||(this.scene.addTransformNode(E),_.push(E))}),this.actionManagers.forEach(E=>{p&&!p(E)||this.scene.addActionManager(E)}),this.textures.forEach(E=>{p&&!p(E)||this.scene.addTexture(E)}),this.reflectionProbes.forEach(E=>{p&&!p(E)||this.scene.addReflectionProbe(E)});for(const E of _)E.parent&&this.scene.getNodes().indexOf(E.parent)===-1&&(E.setParent?E.setParent(null):E.parent=null)}removeAllFromScene(){this._isValidHierarchy()||lt.Warn("SceneSerializer.removeAllFromScene: The Asset Container hierarchy is not valid."),this._wasAddedToScene=!1,this.removeFromScene(null),this.environmentTexture===this.scene.environmentTexture&&(this.scene.environmentTexture=null);for(const p of this.scene._serializableComponents)p.removeFromContainer(this)}removeFromScene(p=null){this.cameras.forEach(_=>{p&&!p(_)||this.scene.removeCamera(_)}),this.lights.forEach(_=>{p&&!p(_)||this.scene.removeLight(_)}),this.meshes.forEach(_=>{p&&!p(_)||this.scene.removeMesh(_,!0)}),this.skeletons.forEach(_=>{p&&!p(_)||this.scene.removeSkeleton(_)}),this.animations.forEach(_=>{p&&!p(_)||this.scene.removeAnimation(_)}),this.animationGroups.forEach(_=>{p&&!p(_)||this.scene.removeAnimationGroup(_)}),this.multiMaterials.forEach(_=>{p&&!p(_)||this.scene.removeMultiMaterial(_)}),this.materials.forEach(_=>{p&&!p(_)||this.scene.removeMaterial(_)}),this.morphTargetManagers.forEach(_=>{p&&!p(_)||this.scene.removeMorphTargetManager(_)}),this.geometries.forEach(_=>{p&&!p(_)||this.scene.removeGeometry(_)}),this.transformNodes.forEach(_=>{p&&!p(_)||this.scene.removeTransformNode(_)}),this.actionManagers.forEach(_=>{p&&!p(_)||this.scene.removeActionManager(_)}),this.textures.forEach(_=>{p&&!p(_)||this.scene.removeTexture(_)}),this.reflectionProbes.forEach(_=>{p&&!p(_)||this.scene.removeReflectionProbe(_)})}dispose(){this.cameras.slice(0).forEach(p=>{p.dispose()}),this.cameras.length=0,this.lights.slice(0).forEach(p=>{p.dispose()}),this.lights.length=0,this.meshes.slice(0).forEach(p=>{p.dispose()}),this.meshes.length=0,this.skeletons.slice(0).forEach(p=>{p.dispose()}),this.skeletons.length=0,this.animationGroups.slice(0).forEach(p=>{p.dispose()}),this.animationGroups.length=0,this.multiMaterials.slice(0).forEach(p=>{p.dispose()}),this.multiMaterials.length=0,this.materials.slice(0).forEach(p=>{p.dispose()}),this.materials.length=0,this.geometries.slice(0).forEach(p=>{p.dispose()}),this.geometries.length=0,this.transformNodes.slice(0).forEach(p=>{p.dispose()}),this.transformNodes.length=0,this.actionManagers.slice(0).forEach(p=>{p.dispose()}),this.actionManagers.length=0,this.textures.slice(0).forEach(p=>{p.dispose()}),this.textures.length=0,this.reflectionProbes.slice(0).forEach(p=>{p.dispose()}),this.reflectionProbes.length=0,this.morphTargetManagers.slice(0).forEach(p=>{p.dispose()}),this.morphTargetManagers.length=0,this.environmentTexture&&(this.environmentTexture.dispose(),this.environmentTexture=null);for(const p of this.scene._serializableComponents)p.removeFromContainer(this,!0);this._onContextRestoredObserver&&(this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)}_moveAssets(p,_,E){if(!(!p||!_))for(const I of p){let Z=!0;if(E){for(const re of E)if(I===re){Z=!1;break}}Z&&(_.push(I),I._parentContainer=this)}}moveAllFromScene(p){this._wasAddedToScene=!1,p===void 0&&(p=new uD);for(const _ in this)Object.prototype.hasOwnProperty.call(this,_)&&(this[_]=this[_]||(_==="_environmentTexture"?null:[]),this._moveAssets(this.scene[_],this[_],p[_]));this.environmentTexture=this.scene.environmentTexture,this.removeAllFromScene()}createRootMesh(){const p=new vr("assetContainerRootMesh",this.scene);return this.meshes.forEach(_=>{_.parent||p.addChild(_)}),this.meshes.unshift(p),p}mergeAnimationsTo(p=Mr.LastCreatedScene,_,E=null){if(!p)return Ti.Error("No scene available to merge animations to"),[];const I=E||(ae=>{let he=null;const _e=ae.animations.length?ae.animations[0].targetProperty:"",ve=ae.name.split(".").join("").split("_primitive")[0];switch(_e){case"position":case"rotationQuaternion":he=p.getTransformNodeByName(ae.name)||p.getTransformNodeByName(ve);break;case"influence":he=p.getMorphTargetByName(ae.name)||p.getMorphTargetByName(ve);break;default:he=p.getNodeByName(ae.name)||p.getNodeByName(ve)}return he});this.getNodes().forEach(ae=>{const he=I(ae);if(he!==null){for(const _e of ae.animations){const ve=he.animations.filter(Le=>Le.targetProperty===_e.targetProperty);for(const Le of ve){const ze=he.animations.indexOf(Le,0);ze>-1&&he.animations.splice(ze,1)}}he.animations=he.animations.concat(ae.animations)}});const re=[];return this.animationGroups.slice().forEach(ae=>{re.push(ae.clone(ae.name,I)),ae.animatables.forEach(he=>{he.stop()})}),_.forEach(ae=>{const he=I(ae.target);he&&(p.beginAnimation(he,ae.fromFrame,ae.toFrame,ae.loopAnimation,ae.speedRatio,ae.onAnimationEnd?ae.onAnimationEnd:void 0,void 0,!0,void 0,ae.onAnimationLoop?ae.onAnimationLoop:void 0),p.stopAnimation(ae.target))}),re}populateRootNodes(){this.rootNodes.length=0,this.meshes.forEach(p=>{!p.parent&&this.rootNodes.indexOf(p)===-1&&this.rootNodes.push(p)}),this.transformNodes.forEach(p=>{!p.parent&&this.rootNodes.indexOf(p)===-1&&this.rootNodes.push(p)}),this.lights.forEach(p=>{!p.parent&&this.rootNodes.indexOf(p)===-1&&this.rootNodes.push(p)}),this.cameras.forEach(p=>{!p.parent&&this.rootNodes.indexOf(p)===-1&&this.rootNodes.push(p)})}addAllAssetsToContainer(p){if(!p)return;const _=[],E=new Set;for(_.push(p);_.length>0;){const I=_.pop();if(I instanceof vr?(I.geometry&&this.geometries.indexOf(I.geometry)===-1&&this.geometries.push(I.geometry),this.meshes.push(I)):I instanceof Gr?this.transformNodes.push(I):I instanceof un?this.lights.push(I):I instanceof Wr&&this.cameras.push(I),I instanceof kx){if(I.material&&this.materials.indexOf(I.material)===-1){this.materials.push(I.material);for(const Z of I.material.getActiveTextures())this.textures.indexOf(Z)===-1&&this.textures.push(Z)}I.skeleton&&this.skeletons.indexOf(I.skeleton)===-1&&this.skeletons.push(I.skeleton),I.morphTargetManager&&this.morphTargetManagers.indexOf(I.morphTargetManager)===-1&&this.morphTargetManagers.push(I.morphTargetManager)}for(const Z of I.getChildren())E.has(Z)||_.push(Z);E.add(I)}this.populateRootNodes()}}class lg{constructor(p){this.byteOffset=0,this.buffer=p}loadAsync(p){return this.buffer.readAsync(this.byteOffset,p).then(_=>{this._dataView=new DataView(_.buffer,_.byteOffset,_.byteLength),this._dataByteOffset=0})}readUint32(){const p=this._dataView.getUint32(this._dataByteOffset,!0);return this._dataByteOffset+=4,this.byteOffset+=4,p}readUint8Array(p){const _=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._dataByteOffset,p);return this._dataByteOffset+=p,this.byteOffset+=p,_}readString(p){return Lh(this.readUint8Array(p))}skipBytes(p){this._dataByteOffset+=p,this.byteOffset+=p}}function d_(pe,p,_,E){const I={externalResourceFunction:E};return _&&(I.uri=p==="file:"?_:p+_),ArrayBuffer.isView(pe)?GLTFValidator.validateBytes(pe,I):GLTFValidator.validateString(pe,I)}function TD(){const pe=[];onmessage=p=>{const _=p.data;switch(_.id){case"init":{importScripts(_.url);break}case"validate":{d_(_.data,_.rootUrl,_.fileName,E=>new Promise((I,Z)=>{const re=pe.length;pe.push({resolve:I,reject:Z}),postMessage({id:"getExternalResource",index:re,uri:E})})).then(E=>{postMessage({id:"validate.resolve",value:E})},E=>{postMessage({id:"validate.reject",reason:E})});break}case"getExternalResource.resolve":{pe[_.index].resolve(_.value);break}case"getExternalResource.reject":{pe[_.index].reject(_.reason);break}}}}class K1{static ValidateAsync(p,_,E,I){return typeof Worker=="function"?new Promise((Z,re)=>{const ae=`${d_}(${TD})()`,he=URL.createObjectURL(new Blob([ae],{type:"application/javascript"})),_e=new Worker(he),ve=ze=>{_e.removeEventListener("error",ve),_e.removeEventListener("message",Le),re(ze)},Le=ze=>{const He=ze.data;switch(He.id){case"getExternalResource":{I(He.uri).then(xt=>{_e.postMessage({id:"getExternalResource.resolve",index:He.index,value:xt},[xt])},xt=>{_e.postMessage({id:"getExternalResource.reject",index:He.index,reason:xt})});break}case"validate.resolve":{_e.removeEventListener("error",ve),_e.removeEventListener("message",Le),Z(He.value),_e.terminate();break}case"validate.reject":_e.removeEventListener("error",ve),_e.removeEventListener("message",Le),re(He.reason),_e.terminate()}};if(_e.addEventListener("error",ve),_e.addEventListener("message",Le),_e.postMessage({id:"init",url:lt.GetBabylonScriptURL(this.Configuration.url)}),ArrayBuffer.isView(p)){const ze=p.slice();_e.postMessage({id:"validate",data:ze,rootUrl:_,fileName:E},[ze.buffer])}else _e.postMessage({id:"validate",data:p,rootUrl:_,fileName:E})}):(this._LoadScriptPromise||(this._LoadScriptPromise=lt.LoadBabylonScriptAsync(this.Configuration.url)),this._LoadScriptPromise.then(()=>d_(p,_,E,I)))}}K1.Configuration={url:`${lt._DefaultCdnUrl}/gltf_validator.js`};function j1(pe,p,_){try{return Promise.resolve(new Uint8Array(pe,p,_))}catch(E){return Promise.reject(E)}}function vD(pe,p,_){try{if(p<0||p>=pe.byteLength)throw new RangeError("Offset is out of range.");if(p+_>pe.byteLength)throw new RangeError("Length is out of range.");return Promise.resolve(new Uint8Array(pe.buffer,pe.byteOffset+p,_))}catch(E){return Promise.reject(E)}}var $p;(function(pe){pe[pe.AUTO=0]="AUTO",pe[pe.FORCE_RIGHT_HANDED=1]="FORCE_RIGHT_HANDED"})($p||($p={}));var zu;(function(pe){pe[pe.NONE=0]="NONE",pe[pe.FIRST=1]="FIRST",pe[pe.ALL=2]="ALL"})(zu||(zu={}));var po;(function(pe){pe[pe.LOADING=0]="LOADING",pe[pe.READY=1]="READY",pe[pe.COMPLETE=2]="COMPLETE"})(po||(po={}));class G0{constructor(){this.onParsedObservable=new Ri,this.coordinateSystemMode=$p.AUTO,this.animationStartMode=zu.FIRST,this.compileMaterials=!1,this.useClipPlane=!1,this.compileShadowGenerators=!1,this.transparencyAsCoverage=!1,this.useRangeRequests=!1,this.createInstances=!0,this.alwaysComputeBoundingBox=!1,this.loadAllMaterials=!1,this.loadOnlyMaterials=!1,this.skipMaterials=!1,this.useSRGBBuffers=!0,this.targetFps=60,this.alwaysComputeSkeletonRootNode=!1,this.preprocessUrlAsync=p=>Promise.resolve(p),this.onMeshLoadedObservable=new Ri,this.onSkinLoadedObservable=new Ri,this.onTextureLoadedObservable=new Ri,this.onMaterialLoadedObservable=new Ri,this.onCameraLoadedObservable=new Ri,this.onCompleteObservable=new Ri,this.onErrorObservable=new Ri,this.onDisposeObservable=new Ri,this.onExtensionLoadedObservable=new Ri,this.validate=!1,this.onValidatedObservable=new Ri,this._loader=null,this._state=null,this._requests=new Array,this.name="gltf",this.extensions={".gltf":{isBinary:!1},".glb":{isBinary:!0}},this.onLoaderStateChangedObservable=new Ri,this._logIndentLevel=0,this._loggingEnabled=!1,this._log=this._logDisabled,this._capturePerformanceCounters=!1,this._startPerformanceCounter=this._startPerformanceCounterDisabled,this._endPerformanceCounter=this._endPerformanceCounterDisabled}set onParsed(p){this._onParsedObserver&&this.onParsedObservable.remove(this._onParsedObserver),this._onParsedObserver=this.onParsedObservable.add(p)}set onMeshLoaded(p){this._onMeshLoadedObserver&&this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver),this._onMeshLoadedObserver=this.onMeshLoadedObservable.add(p)}set onTextureLoaded(p){this._onTextureLoadedObserver&&this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver),this._onTextureLoadedObserver=this.onTextureLoadedObservable.add(p)}set onMaterialLoaded(p){this._onMaterialLoadedObserver&&this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver),this._onMaterialLoadedObserver=this.onMaterialLoadedObservable.add(p)}set onCameraLoaded(p){this._onCameraLoadedObserver&&this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver),this._onCameraLoadedObserver=this.onCameraLoadedObservable.add(p)}set onComplete(p){this._onCompleteObserver&&this.onCompleteObservable.remove(this._onCompleteObserver),this._onCompleteObserver=this.onCompleteObservable.add(p)}set onError(p){this._onErrorObserver&&this.onErrorObservable.remove(this._onErrorObserver),this._onErrorObserver=this.onErrorObservable.add(p)}set onDispose(p){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(p)}set onExtensionLoaded(p){this._onExtensionLoadedObserver&&this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver),this._onExtensionLoadedObserver=this.onExtensionLoadedObservable.add(p)}get loggingEnabled(){return this._loggingEnabled}set loggingEnabled(p){this._loggingEnabled!==p&&(this._loggingEnabled=p,this._loggingEnabled?this._log=this._logEnabled:this._log=this._logDisabled)}get capturePerformanceCounters(){return this._capturePerformanceCounters}set capturePerformanceCounters(p){this._capturePerformanceCounters!==p&&(this._capturePerformanceCounters=p,this._capturePerformanceCounters?(this._startPerformanceCounter=this._startPerformanceCounterEnabled,this._endPerformanceCounter=this._endPerformanceCounterEnabled):(this._startPerformanceCounter=this._startPerformanceCounterDisabled,this._endPerformanceCounter=this._endPerformanceCounterDisabled))}set onValidated(p){this._onValidatedObserver&&this.onValidatedObservable.remove(this._onValidatedObserver),this._onValidatedObserver=this.onValidatedObservable.add(p)}dispose(){this._loader&&(this._loader.dispose(),this._loader=null);for(const p of this._requests)p.abort();this._requests.length=0,delete this._progressCallback,this.preprocessUrlAsync=p=>Promise.resolve(p),this.onMeshLoadedObservable.clear(),this.onSkinLoadedObservable.clear(),this.onTextureLoadedObservable.clear(),this.onMaterialLoadedObservable.clear(),this.onCameraLoadedObservable.clear(),this.onCompleteObservable.clear(),this.onExtensionLoadedObservable.clear(),this.onDisposeObservable.notifyObservers(void 0),this.onDisposeObservable.clear()}loadFile(p,_,E,I,Z,re,ae,he){if(ArrayBuffer.isView(_))return this._loadBinary(p,_,E,I,ae,he),null;this._progressCallback=Z;const _e=_.name||lt.GetFilename(_);if(re){if(this.useRangeRequests){this.validate&&Ti.Warn("glTF validation is not supported when range requests are enabled");const ve={abort:()=>{},onCompleteObservable:new Ri},Le={readAsync:(ze,He)=>new Promise((xt,rt)=>{this._loadFile(p,_,Tt=>{xt(new Uint8Array(Tt))},!0,Tt=>{rt(Tt)},Tt=>{Tt.setRequestHeader("Range",`bytes=${ze}-${ze+He-1}`)})}),byteLength:0};return this._unpackBinaryAsync(new lg(Le)).then(ze=>{ve.onCompleteObservable.notifyObservers(ve),I(ze)},ae?ze=>ae(void 0,ze):void 0),ve}return this._loadFile(p,_,ve=>{this._validate(p,new Uint8Array(ve,0,ve.byteLength),E,_e),this._unpackBinaryAsync(new lg({readAsync:(Le,ze)=>j1(ve,Le,ze),byteLength:ve.byteLength})).then(Le=>{I(Le)},ae?Le=>ae(void 0,Le):void 0)},!0,ae)}else return this._loadFile(p,_,ve=>{this._validate(p,ve,E,_e),I({json:this._parseJson(ve)})},!1,ae)}_loadBinary(p,_,E,I,Z,re){this._validate(p,new Uint8Array(_.buffer,_.byteOffset,_.byteLength),E,re),this._unpackBinaryAsync(new lg({readAsync:(ae,he)=>vD(_,ae,he),byteLength:_.byteLength})).then(ae=>{I(ae)},Z?ae=>Z(void 0,ae):void 0)}importMeshAsync(p,_,E,I,Z,re){return Promise.resolve().then(()=>(this.onParsedObservable.notifyObservers(E),this.onParsedObservable.clear(),this._log(`Loading ${re||""}`),this._loader=this._getLoader(E),this._loader.importMeshAsync(p,_,null,E,I,Z,re)))}loadAsync(p,_,E,I,Z){return Promise.resolve().then(()=>(this.onParsedObservable.notifyObservers(_),this.onParsedObservable.clear(),this._log(`Loading ${Z||""}`),this._loader=this._getLoader(_),this._loader.loadAsync(p,_,E,I,Z)))}loadAssetContainerAsync(p,_,E,I,Z){return Promise.resolve().then(()=>{this.onParsedObservable.notifyObservers(_),this.onParsedObservable.clear(),this._log(`Loading ${Z||""}`),this._loader=this._getLoader(_);const re=new _D(p),ae=[];this.onMaterialLoadedObservable.add(Le=>{ae.push(Le)});const he=[];this.onTextureLoadedObservable.add(Le=>{he.push(Le)});const _e=[];this.onCameraLoadedObservable.add(Le=>{_e.push(Le)});const ve=[];return this.onMeshLoadedObservable.add(Le=>{Le.morphTargetManager&&ve.push(Le.morphTargetManager)}),this._loader.importMeshAsync(null,p,re,_,E,I,Z).then(Le=>(Array.prototype.push.apply(re.geometries,Le.geometries),Array.prototype.push.apply(re.meshes,Le.meshes),Array.prototype.push.apply(re.particleSystems,Le.particleSystems),Array.prototype.push.apply(re.skeletons,Le.skeletons),Array.prototype.push.apply(re.animationGroups,Le.animationGroups),Array.prototype.push.apply(re.materials,ae),Array.prototype.push.apply(re.textures,he),Array.prototype.push.apply(re.lights,Le.lights),Array.prototype.push.apply(re.transformNodes,Le.transformNodes),Array.prototype.push.apply(re.cameras,_e),Array.prototype.push.apply(re.morphTargetManagers,ve),re))})}canDirectLoad(p){return p.indexOf("asset")!==-1&&p.indexOf("version")!==-1||p.startsWith("data:base64,"+G0._MagicBase64Encoded)||p.startsWith("data:;base64,"+G0._MagicBase64Encoded)||p.startsWith("data:application/octet-stream;base64,"+G0._MagicBase64Encoded)||p.startsWith("data:model/gltf-binary;base64,"+G0._MagicBase64Encoded)}directLoad(p,_){if(_.startsWith("base64,"+G0._MagicBase64Encoded)||_.startsWith(";base64,"+G0._MagicBase64Encoded)||_.startsWith("application/octet-stream;base64,"+G0._MagicBase64Encoded)||_.startsWith("model/gltf-binary;base64,"+G0._MagicBase64Encoded)){const E=M2(_);return this._validate(p,new Uint8Array(E,0,E.byteLength)),this._unpackBinaryAsync(new lg({readAsync:(I,Z)=>j1(E,I,Z),byteLength:E.byteLength}))}return this._validate(p,_),Promise.resolve({json:this._parseJson(_)})}createPlugin(){return new G0}get loaderState(){return this._state}whenCompleteAsync(){return new Promise((p,_)=>{this.onCompleteObservable.addOnce(()=>{p()}),this.onErrorObservable.addOnce(E=>{_(E)})})}_setState(p){this._state!==p&&(this._state=p,this.onLoaderStateChangedObservable.notifyObservers(this._state),this._log(po[this._state]))}_loadFile(p,_,E,I,Z,re){const ae=p._loadFile(_,E,he=>{this._onProgress(he,ae)},!0,I,Z,re);return ae.onCompleteObservable.add(he=>{this._requests.splice(this._requests.indexOf(he),1)}),this._requests.push(ae),ae}_onProgress(p,_){if(!this._progressCallback)return;_._lengthComputable=p.lengthComputable,_._loaded=p.loaded,_._total=p.total;let E=!0,I=0,Z=0;for(const re of this._requests){if(re._lengthComputable===void 0||re._loaded===void 0||re._total===void 0)return;E=E&&re._lengthComputable,I+=re._loaded,Z+=re._total}this._progressCallback({lengthComputable:E,loaded:I,total:E?Z:0})}_validate(p,_,E="",I=""){this.validate&&(this._startPerformanceCounter("Validate JSON"),K1.ValidateAsync(_,E,I,Z=>this.preprocessUrlAsync(E+Z).then(re=>p._loadFileAsync(re,void 0,!0,!0).then(ae=>new Uint8Array(ae,0,ae.byteLength)))).then(Z=>{this._endPerformanceCounter("Validate JSON"),this.onValidatedObservable.notifyObservers(Z),this.onValidatedObservable.clear()},Z=>{this._endPerformanceCounter("Validate JSON"),lt.Warn(`Failed to validate: ${Z.message}`),this.onValidatedObservable.clear()}))}_getLoader(p){const _=p.json.asset||{};this._log(`Asset version: ${_.version}`),_.minVersion&&this._log(`Asset minimum version: ${_.minVersion}`),_.generator&&this._log(`Asset generator: ${_.generator}`);const E=G0._parseVersion(_.version);if(!E)throw new Error("Invalid version: "+_.version);if(_.minVersion!==void 0){const re=G0._parseVersion(_.minVersion);if(!re)throw new Error("Invalid minimum version: "+_.minVersion);if(G0._compareVersion(re,{major:2,minor:0})>0)throw new Error("Incompatible minimum version: "+_.minVersion)}const Z={1:G0._CreateGLTF1Loader,2:G0._CreateGLTF2Loader}[E.major];if(!Z)throw new Error("Unsupported version: "+_.version);return Z(this)}_parseJson(p){this._startPerformanceCounter("Parse JSON"),this._log(`JSON length: ${p.length}`);const _=JSON.parse(p);return this._endPerformanceCounter("Parse JSON"),_}_unpackBinaryAsync(p){return this._startPerformanceCounter("Unpack Binary"),p.loadAsync(20).then(()=>{const _={Magic:1179937895},E=p.readUint32();if(E!==_.Magic)throw new Hx("Unexpected magic: "+E,Wx.GLTFLoaderUnexpectedMagicError);const I=p.readUint32();this.loggingEnabled&&this._log(`Binary version: ${I}`);const Z=p.readUint32();!this.useRangeRequests&&Z!==p.buffer.byteLength&&Ti.Warn(`Length in header does not match actual data length: ${Z} != ${p.buffer.byteLength}`);let re;switch(I){case 1:{re=this._unpackBinaryV1Async(p,Z);break}case 2:{re=this._unpackBinaryV2Async(p,Z);break}default:throw new Error("Unsupported version: "+I)}return this._endPerformanceCounter("Unpack Binary"),re})}_unpackBinaryV1Async(p,_){const E={JSON:0},I=p.readUint32(),Z=p.readUint32();if(Z!==E.JSON)throw new Error(`Unexpected content format: ${Z}`);const re=_-p.byteOffset,ae={json:this._parseJson(p.readString(I)),bin:null};if(re!==0){const he=p.byteOffset;ae.bin={readAsync:(_e,ve)=>p.buffer.readAsync(he+_e,ve),byteLength:re}}return Promise.resolve(ae)}_unpackBinaryV2Async(p,_){const E={JSON:1313821514,BIN:5130562},I=p.readUint32();if(p.readUint32()!==E.JSON)throw new Error("First chunk format is not JSON");return p.byteOffset+I===_?p.loadAsync(I).then(()=>({json:this._parseJson(p.readString(I)),bin:null})):p.loadAsync(I+8).then(()=>{const re={json:this._parseJson(p.readString(I)),bin:null},ae=()=>{const he=p.readUint32();switch(p.readUint32()){case E.JSON:throw new Error("Unexpected JSON chunk");case E.BIN:{const ve=p.byteOffset;re.bin={readAsync:(Le,ze)=>p.buffer.readAsync(ve+Le,ze),byteLength:he},p.skipBytes(he);break}default:{p.skipBytes(he);break}}return p.byteOffset!==_?p.loadAsync(8).then(ae):Promise.resolve(re)};return ae()})}static _parseVersion(p){if(p==="1.0"||p==="1.0.1")return{major:1,minor:0};const _=(p+"").match(/^(\d+)\.(\d+)/);return _?{major:parseInt(_[1]),minor:parseInt(_[2])}:null}static _compareVersion(p,_){return p.major>_.major?1:p.major<_.major?-1:p.minor>_.minor?1:p.minor<_.minor?-1:0}_logOpen(p){this._log(p),this._logIndentLevel++}_logClose(){--this._logIndentLevel}_logEnabled(p){const _=G0._logSpaces.substr(0,this._logIndentLevel*2);Ti.Log(`${_}${p}`)}_logDisabled(p){}_startPerformanceCounterEnabled(p){lt.StartPerformanceCounter(p)}_startPerformanceCounterDisabled(p){}_endPerformanceCounterEnabled(p){lt.EndPerformanceCounter(p)}_endPerformanceCounterDisabled(p){}}G0.IncrementalLoading=!0,G0.HomogeneousCoordinates=!1,G0._MagicBase64Encoded="Z2xURg",G0._logSpaces="                                ",wn&&wn.RegisterPlugin(new G0);function q1(pe,p,_,E){return at.FromArray(p,_).scaleInPlace(E)}function RD(pe,p,_,E){return us.FromArray(p,_).scaleInPlace(E)}function MD(pe,p,_,E){const I=new Array(pe._numMorphTargets);for(let Z=0;Z<I.length;Z++)I[Z]=p[_++]*E;return I}class rm{constructor(p,_,E,I){this.type=p,this.name=_,this.getValue=E,this.getStride=I}_buildAnimation(p,_,E){const I=new Li(p,this.name,_,this.type);return I.setKeys(E),I}}class f_ extends rm{buildAnimations(p,_,E,I,Z){Z(p._babylonTransformNode,this._buildAnimation(_,E,I))}}class wD extends rm{buildAnimations(p,_,E,I,Z){if(p._numMorphTargets)for(let re=0;re<p._numMorphTargets;re++){const ae=new Li(`${_}_${re}`,this.name,E,this.type);if(ae.setKeys(I.map(he=>({frame:he.frame,inTangent:he.inTangent?he.inTangent[re]:void 0,value:he.value[re],outTangent:he.outTangent?he.outTangent[re]:void 0,interpolation:he.interpolation}))),p._primitiveBabylonMeshes){for(const he of p._primitiveBabylonMeshes)if(he.morphTargetManager){const _e=he.morphTargetManager.getTarget(re),ve=ae.clone();_e.animations.push(ve),Z(_e,ve)}}}}}const nm={translation:[new f_(Li.ANIMATIONTYPE_VECTOR3,"position",q1,()=>3)],rotation:[new f_(Li.ANIMATIONTYPE_QUATERNION,"rotationQuaternion",RD,()=>4)],scale:[new f_(Li.ANIMATIONTYPE_VECTOR3,"scaling",q1,()=>3)],weights:[new wD(Li.ANIMATIONTYPE_FLOAT,"influence",MD,pe=>pe._numMorphTargets)]};function $1(...pe){const p=_=>_&&typeof _=="object";return pe.reduce((_,E)=>(Object.keys(E).forEach(I=>{const Z=_[I],re=E[I];Array.isArray(Z)&&Array.isArray(re)?_[I]=Z.concat(...re):p(Z)&&p(re)?_[I]=$1(Z,re):_[I]=re}),_),{})}class kr{static Get(p,_,E){if(!_||E==null||!_[E])throw new Error(`${p}: Failed to find index (${E})`);return _[E]}static TryGet(p,_){return!p||_==null||!p[_]?null:p[_]}static Assign(p){if(p)for(let _=0;_<p.length;_++)p[_].index=_}}class js{static RegisterExtension(p,_){js.UnregisterExtension(p)&&Ti.Warn(`Extension with the name '${p}' already exists`),js._RegisteredExtensions[p]={factory:_}}static UnregisterExtension(p){return js._RegisteredExtensions[p]?(delete js._RegisteredExtensions[p],!0):!1}get gltf(){if(!this._gltf)throw new Error("glTF JSON is not available");return this._gltf}get bin(){return this._bin}get parent(){return this._parent}get babylonScene(){if(!this._babylonScene)throw new Error("Scene is not available");return this._babylonScene}get rootBabylonMesh(){return this._rootBabylonMesh}get rootUrl(){return this._rootUrl}constructor(p){this._completePromises=new Array,this._assetContainer=null,this._babylonLights=[],this._disableInstancedMesh=0,this._allMaterialsDirtyRequired=!1,this._extensions=new Array,this._disposed=!1,this._rootUrl=null,this._fileName=null,this._uniqueRootUrl=null,this._bin=null,this._rootBabylonMesh=null,this._defaultBabylonMaterialData={},this._postSceneLoadActions=new Array,this._parent=p}dispose(){this._disposed||(this._disposed=!0,this._completePromises.length=0,this._extensions.forEach(p=>p.dispose&&p.dispose()),this._extensions.length=0,this._gltf=null,this._bin=null,this._babylonScene=null,this._rootBabylonMesh=null,this._defaultBabylonMaterialData={},this._postSceneLoadActions.length=0,this._parent.dispose())}importMeshAsync(p,_,E,I,Z,re,ae=""){return Promise.resolve().then(()=>{this._babylonScene=_,this._assetContainer=E,this._loadData(I);let he=null;if(p){const _e={};if(this._gltf.nodes)for(const Le of this._gltf.nodes)Le.name&&(_e[Le.name]=Le.index);he=(p instanceof Array?p:[p]).map(Le=>{const ze=_e[Le];if(ze===void 0)throw new Error(`Failed to find node '${Le}'`);return ze})}return this._loadAsync(Z,ae,he,()=>({meshes:this._getMeshes(),particleSystems:[],skeletons:this._getSkeletons(),animationGroups:this._getAnimationGroups(),lights:this._babylonLights,transformNodes:this._getTransformNodes(),geometries:this._getGeometries()}))})}loadAsync(p,_,E,I,Z=""){return Promise.resolve().then(()=>(this._babylonScene=p,this._loadData(_),this._loadAsync(E,Z,null,()=>{})))}_loadAsync(p,_,E,I){return Promise.resolve().then(()=>{this._rootUrl=p,this._uniqueRootUrl=!p.startsWith("file:")&&_?p:`${p}${Date.now()}/`,this._fileName=_,this._allMaterialsDirtyRequired=!1,this._loadExtensions(),this._checkExtensions();const Z=`${po[po.LOADING]} => ${po[po.READY]}`,re=`${po[po.LOADING]} => ${po[po.COMPLETE]}`;this._parent._startPerformanceCounter(Z),this._parent._startPerformanceCounter(re),this._parent._setState(po.LOADING),this._extensionsOnLoading();const ae=new Array,he=this._babylonScene.blockMaterialDirtyMechanism;if(this._babylonScene.blockMaterialDirtyMechanism=!0,!this.parent.loadOnlyMaterials){if(E)ae.push(this.loadSceneAsync("/nodes",{nodes:E,index:-1}));else if(this._gltf.scene!=null||this._gltf.scenes&&this._gltf.scenes[0]){const ve=kr.Get("/scene",this._gltf.scenes,this._gltf.scene||0);ae.push(this.loadSceneAsync(`/scenes/${ve.index}`,ve))}}if(!this.parent.skipMaterials&&this.parent.loadAllMaterials&&this._gltf.materials)for(let ve=0;ve<this._gltf.materials.length;++ve){const Le=this._gltf.materials[ve],ze="/materials/"+ve,He=zi.TriangleFillMode;ae.push(this._loadMaterialAsync(ze,Le,null,He,()=>{}))}return this._allMaterialsDirtyRequired?this._babylonScene.blockMaterialDirtyMechanism=he:this._babylonScene._forceBlockMaterialDirtyMechanism(he),this._parent.compileMaterials&&ae.push(this._compileMaterialsAsync()),this._parent.compileShadowGenerators&&ae.push(this._compileShadowGeneratorsAsync()),Promise.all(ae).then(()=>(this._rootBabylonMesh&&this._rootBabylonMesh!==this._parent.customRootNode&&this._rootBabylonMesh.setEnabled(!0),this._extensionsOnReady(),this._parent._setState(po.READY),this._startAnimations(),I())).then(ve=>(this._parent._endPerformanceCounter(Z),lt.SetImmediate(()=>{this._disposed||Promise.all(this._completePromises).then(()=>{this._parent._endPerformanceCounter(re),this._parent._setState(po.COMPLETE),this._parent.onCompleteObservable.notifyObservers(void 0),this._parent.onCompleteObservable.clear(),this.dispose()},Le=>{this._parent.onErrorObservable.notifyObservers(Le),this._parent.onErrorObservable.clear(),this.dispose()})}),ve))}).catch(Z=>{throw this._disposed||(this._parent.onErrorObservable.notifyObservers(Z),this._parent.onErrorObservable.clear(),this.dispose()),Z})}_loadData(p){if(this._gltf=p.json,this._setupData(),p.bin){const _=this._gltf.buffers;if(_&&_[0]&&!_[0].uri){const E=_[0];(E.byteLength<p.bin.byteLength-3||E.byteLength>p.bin.byteLength)&&Ti.Warn(`Binary buffer length (${E.byteLength}) from JSON does not match chunk length (${p.bin.byteLength})`),this._bin=p.bin}else Ti.Warn("Unexpected BIN chunk")}}_setupData(){if(kr.Assign(this._gltf.accessors),kr.Assign(this._gltf.animations),kr.Assign(this._gltf.buffers),kr.Assign(this._gltf.bufferViews),kr.Assign(this._gltf.cameras),kr.Assign(this._gltf.images),kr.Assign(this._gltf.materials),kr.Assign(this._gltf.meshes),kr.Assign(this._gltf.nodes),kr.Assign(this._gltf.samplers),kr.Assign(this._gltf.scenes),kr.Assign(this._gltf.skins),kr.Assign(this._gltf.textures),this._gltf.nodes){const p={};for(const E of this._gltf.nodes)if(E.children)for(const I of E.children)p[I]=E.index;const _=this._createRootNode();for(const E of this._gltf.nodes){const I=p[E.index];E.parent=I===void 0?_:this._gltf.nodes[I]}}}_loadExtensions(){for(const p in js._RegisteredExtensions){const _=js._RegisteredExtensions[p].factory(this);_.name!==p&&Ti.Warn(`The name of the glTF loader extension instance does not match the registered name: ${_.name} !== ${p}`),this._extensions.push(_),this._parent.onExtensionLoadedObservable.notifyObservers(_)}this._extensions.sort((p,_)=>(p.order||Number.MAX_VALUE)-(_.order||Number.MAX_VALUE)),this._parent.onExtensionLoadedObservable.clear()}_checkExtensions(){if(this._gltf.extensionsRequired){for(const p of this._gltf.extensionsRequired)if(!this._extensions.some(E=>E.name===p&&E.enabled))throw new Error(`Required extension ${p} is not available`)}}_createRootNode(){if(this._parent.customRootNode!==void 0)return this._rootBabylonMesh=this._parent.customRootNode,{_babylonTransformNode:this._rootBabylonMesh===null?void 0:this._rootBabylonMesh,index:-1};this._babylonScene._blockEntityCollection=!!this._assetContainer;const p=new vr("__root__",this._babylonScene);this._rootBabylonMesh=p,this._rootBabylonMesh._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,this._rootBabylonMesh.setEnabled(!1);const _={_babylonTransformNode:this._rootBabylonMesh,index:-1};switch(this._parent.coordinateSystemMode){case $p.AUTO:{this._babylonScene.useRightHandedSystem||(_.rotation=[0,1,0,0],_.scale=[1,1,-1],js._LoadTransform(_,this._rootBabylonMesh));break}case $p.FORCE_RIGHT_HANDED:{this._babylonScene.useRightHandedSystem=!0;break}default:throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`)}return this._parent.onMeshLoadedObservable.notifyObservers(p),_}loadSceneAsync(p,_){const E=this._extensionsLoadSceneAsync(p,_);if(E)return E;const I=new Array;if(this.logOpen(`${p} ${_.name||""}`),_.nodes)for(const Z of _.nodes){const re=kr.Get(`${p}/nodes/${Z}`,this._gltf.nodes,Z);I.push(this.loadNodeAsync(`/nodes/${re.index}`,re,ae=>{ae.parent=this._rootBabylonMesh}))}for(const Z of this._postSceneLoadActions)Z();return I.push(this._loadAnimationsAsync()),this.logClose(),Promise.all(I).then(()=>{})}_forEachPrimitive(p,_){if(p._primitiveBabylonMeshes)for(const E of p._primitiveBabylonMeshes)_(E)}_getGeometries(){const p=[],_=this._gltf.nodes;if(_)for(const E of _)this._forEachPrimitive(E,I=>{const Z=I.geometry;Z&&p.indexOf(Z)===-1&&p.push(Z)});return p}_getMeshes(){const p=[];this._rootBabylonMesh instanceof kx&&p.push(this._rootBabylonMesh);const _=this._gltf.nodes;if(_)for(const E of _)this._forEachPrimitive(E,I=>{p.push(I)});return p}_getTransformNodes(){const p=[],_=this._gltf.nodes;if(_)for(const E of _)E._babylonTransformNode&&E._babylonTransformNode.getClassName()==="TransformNode"&&p.push(E._babylonTransformNode),E._babylonTransformNodeForSkin&&p.push(E._babylonTransformNodeForSkin);return p}_getSkeletons(){const p=[],_=this._gltf.skins;if(_)for(const E of _)E._data&&p.push(E._data.babylonSkeleton);return p}_getAnimationGroups(){const p=[],_=this._gltf.animations;if(_)for(const E of _)E._babylonAnimationGroup&&p.push(E._babylonAnimationGroup);return p}_startAnimations(){switch(this._parent.animationStartMode){case zu.NONE:break;case zu.FIRST:{const p=this._getAnimationGroups();p.length!==0&&p[0].start(!0);break}case zu.ALL:{const p=this._getAnimationGroups();for(const _ of p)_.start(!0);break}default:{Ti.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);return}}}loadNodeAsync(p,_,E=()=>{}){const I=this._extensionsLoadNodeAsync(p,_,E);if(I)return I;if(_._babylonTransformNode)throw new Error(`${p}: Invalid recursive node hierarchy`);const Z=new Array;this.logOpen(`${p} ${_.name||""}`);const re=ae=>{if(js.AddPointerMetadata(ae,p),js._LoadTransform(_,ae),_.camera!=null){const he=kr.Get(`${p}/camera`,this._gltf.cameras,_.camera);Z.push(this.loadCameraAsync(`/cameras/${he.index}`,he,_e=>{_e.parent=ae}))}if(_.children)for(const he of _.children){const _e=kr.Get(`${p}/children/${he}`,this._gltf.nodes,he);Z.push(this.loadNodeAsync(`/nodes/${_e.index}`,_e,ve=>{ve.parent=ae}))}E(ae)};if(_.mesh==null||_.skin!=null){const ae=_.name||`node${_.index}`;this._babylonScene._blockEntityCollection=!!this._assetContainer;const he=new Gr(ae,this._babylonScene);he._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,_.mesh==null?_._babylonTransformNode=he:_._babylonTransformNodeForSkin=he,re(he)}if(_.mesh!=null)if(_.skin==null){const ae=kr.Get(`${p}/mesh`,this._gltf.meshes,_.mesh);Z.push(this._loadMeshAsync(`/meshes/${ae.index}`,_,ae,re))}else{const ae=kr.Get(`${p}/mesh`,this._gltf.meshes,_.mesh);Z.push(this._loadMeshAsync(`/meshes/${ae.index}`,_,ae,he=>{const _e=_._babylonTransformNodeForSkin;he.metadata=$1(_e.metadata,he.metadata||{});const ve=kr.Get(`${p}/skin`,this._gltf.skins,_.skin);Z.push(this._loadSkinAsync(`/skins/${ve.index}`,_,ve,Le=>{this._forEachPrimitive(_,ze=>{ze.skeleton=Le}),this._postSceneLoadActions.push(()=>{if(ve.skeleton!=null){const ze=kr.Get(`/skins/${ve.index}/skeleton`,this._gltf.nodes,ve.skeleton).parent;_.index===ze.index?he.parent=_e.parent:he.parent=ze._babylonTransformNode}else he.parent=this._rootBabylonMesh;this._parent.onSkinLoadedObservable.notifyObservers({node:_e,skinnedNode:he})})}))}))}return this.logClose(),Promise.all(Z).then(()=>(this._forEachPrimitive(_,ae=>{ae.geometry&&ae.geometry.useBoundingInfoFromGeometry?ae._updateBoundingInfo():ae.refreshBoundingInfo(!0)}),_._babylonTransformNode))}_loadMeshAsync(p,_,E,I){const Z=E.primitives;if(!Z||!Z.length)throw new Error(`${p}: Primitives are missing`);Z[0].index==null&&kr.Assign(Z);const re=new Array;this.logOpen(`${p} ${E.name||""}`);const ae=_.name||`node${_.index}`;if(Z.length===1){const he=E.primitives[0];re.push(this._loadMeshPrimitiveAsync(`${p}/primitives/${he.index}`,ae,_,E,he,_e=>{_._babylonTransformNode=_e,_._primitiveBabylonMeshes=[_e]}))}else{this._babylonScene._blockEntityCollection=!!this._assetContainer,_._babylonTransformNode=new Gr(ae,this._babylonScene),_._babylonTransformNode._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,_._primitiveBabylonMeshes=[];for(const he of Z)re.push(this._loadMeshPrimitiveAsync(`${p}/primitives/${he.index}`,`${ae}_primitive${he.index}`,_,E,he,_e=>{_e.parent=_._babylonTransformNode,_._primitiveBabylonMeshes.push(_e)}))}return I(_._babylonTransformNode),this.logClose(),Promise.all(re).then(()=>_._babylonTransformNode)}_loadMeshPrimitiveAsync(p,_,E,I,Z,re){const ae=this._extensionsLoadMeshPrimitiveAsync(p,_,E,I,Z,re);if(ae)return ae;this.logOpen(`${p}`);const he=this._disableInstancedMesh===0&&this._parent.createInstances&&E.skin==null&&!I.primitives[0].targets;let _e,ve;if(he&&Z._instanceData)this._babylonScene._blockEntityCollection=!!this._assetContainer,_e=Z._instanceData.babylonSourceMesh.createInstance(_),_e._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,ve=Z._instanceData.promise;else{const Le=new Array;this._babylonScene._blockEntityCollection=!!this._assetContainer;const ze=new vr(_,this._babylonScene);ze._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,ze.overrideMaterialSideOrientation=this._babylonScene.useRightHandedSystem?zi.CounterClockWiseSideOrientation:zi.ClockWiseSideOrientation,this._createMorphTargets(p,E,I,Z,ze),Le.push(this._loadVertexDataAsync(p,Z,ze).then(xt=>this._loadMorphTargetsAsync(p,Z,ze,xt).then(()=>{this._disposed||(this._babylonScene._blockEntityCollection=!!this._assetContainer,xt.applyToMesh(ze),xt._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1)})));const He=js._GetDrawMode(p,Z.mode);if(Z.material==null){let xt=this._defaultBabylonMaterialData[He];xt||(xt=this._createDefaultMaterial("__GLTFLoader._default",He),this._parent.onMaterialLoadedObservable.notifyObservers(xt),this._defaultBabylonMaterialData[He]=xt),ze.material=xt}else if(!this.parent.skipMaterials){const xt=kr.Get(`${p}/material`,this._gltf.materials,Z.material);Le.push(this._loadMaterialAsync(`/materials/${xt.index}`,xt,ze,He,rt=>{ze.material=rt}))}ve=Promise.all(Le),he&&(Z._instanceData={babylonSourceMesh:ze,promise:ve}),_e=ze}return js.AddPointerMetadata(_e,p),this._parent.onMeshLoadedObservable.notifyObservers(_e),re(_e),this.logClose(),ve.then(()=>_e)}_loadVertexDataAsync(p,_,E){const I=this._extensionsLoadVertexDataAsync(p,_,E);if(I)return I;const Z=_.attributes;if(!Z)throw new Error(`${p}: Attributes are missing`);const re=new Array,ae=new cx(E.name,this._babylonScene);if(_.indices==null)E.isUnIndexed=!0;else{const _e=kr.Get(`${p}/indices`,this._gltf.accessors,_.indices);re.push(this._loadIndicesAccessorAsync(`/accessors/${_e.index}`,_e).then(ve=>{ae.setIndices(ve)}))}const he=(_e,ve,Le)=>{if(Z[_e]==null)return;E._delayInfo=E._delayInfo||[],E._delayInfo.indexOf(ve)===-1&&E._delayInfo.push(ve);const ze=kr.Get(`${p}/attributes/${_e}`,this._gltf.accessors,Z[_e]);re.push(this._loadVertexAccessorAsync(`/accessors/${ze.index}`,ze,ve).then(He=>{if(He.getKind()===ut.PositionKind&&!this.parent.alwaysComputeBoundingBox&&!E.skeleton&&ze.min&&ze.max){const xt=ui.Vector3[0].copyFromFloats(...ze.min),rt=ui.Vector3[1].copyFromFloats(...ze.max);if(ze.normalized&&ze.componentType!==5126){let Tt=1;switch(ze.componentType){case 5120:Tt=127;break;case 5121:Tt=255;break;case 5122:Tt=32767;break;case 5123:Tt=65535;break}const Lt=1/Tt;xt.scaleInPlace(Lt),rt.scaleInPlace(Lt)}ae._boundingInfo=new uo(xt,rt),ae.useBoundingInfoFromGeometry=!0}ae.setVerticesBuffer(He,ze.count)})),ve==ut.MatricesIndicesExtraKind&&(E.numBoneInfluencers=8),Le&&Le(ze)};return he("POSITION",ut.PositionKind),he("NORMAL",ut.NormalKind),he("TANGENT",ut.TangentKind),he("TEXCOORD_0",ut.UVKind),he("TEXCOORD_1",ut.UV2Kind),he("TEXCOORD_2",ut.UV3Kind),he("TEXCOORD_3",ut.UV4Kind),he("TEXCOORD_4",ut.UV5Kind),he("TEXCOORD_5",ut.UV6Kind),he("JOINTS_0",ut.MatricesIndicesKind),he("WEIGHTS_0",ut.MatricesWeightsKind),he("JOINTS_1",ut.MatricesIndicesExtraKind),he("WEIGHTS_1",ut.MatricesWeightsExtraKind),he("COLOR_0",ut.ColorKind,_e=>{_e.type==="VEC4"&&(E.hasVertexAlpha=!0)}),Promise.all(re).then(()=>ae)}_createMorphTargets(p,_,E,I,Z){if(!I.targets)return;if(_._numMorphTargets==null)_._numMorphTargets=I.targets.length;else if(I.targets.length!==_._numMorphTargets)throw new Error(`${p}: Primitives do not have the same number of targets`);const re=E.extras?E.extras.targetNames:null;this._babylonScene._blockEntityCollection=!!this._assetContainer,Z.morphTargetManager=new $h(this._babylonScene),Z.morphTargetManager._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,Z.morphTargetManager.areUpdatesFrozen=!0;for(let ae=0;ae<I.targets.length;ae++){const he=_.weights?_.weights[ae]:E.weights?E.weights[ae]:0,_e=re?re[ae]:`morphTarget${ae}`;Z.morphTargetManager.addTarget(new Kc(_e,he,Z.getScene()))}}_loadMorphTargetsAsync(p,_,E,I){if(!_.targets)return Promise.resolve();const Z=new Array,re=E.morphTargetManager;for(let ae=0;ae<re.numTargets;ae++){const he=re.getTarget(ae);Z.push(this._loadMorphTargetVertexDataAsync(`${p}/targets/${ae}`,I,_.targets[ae],he))}return Promise.all(Z).then(()=>{re.areUpdatesFrozen=!1})}_loadMorphTargetVertexDataAsync(p,_,E,I){const Z=new Array,re=(ae,he,_e)=>{if(E[ae]==null)return;const ve=_.getVertexBuffer(he);if(!ve)return;const Le=kr.Get(`${p}/${ae}`,this._gltf.accessors,E[ae]);Z.push(this._loadFloatAccessorAsync(`/accessors/${Le.index}`,Le).then(ze=>{_e(ve,ze)}))};return re("POSITION",ut.PositionKind,(ae,he)=>{const _e=new Float32Array(he.length);ae.forEach(he.length,(ve,Le)=>{_e[Le]=he[Le]+ve}),I.setPositions(_e)}),re("NORMAL",ut.NormalKind,(ae,he)=>{const _e=new Float32Array(he.length);ae.forEach(_e.length,(ve,Le)=>{_e[Le]=he[Le]+ve}),I.setNormals(_e)}),re("TANGENT",ut.TangentKind,(ae,he)=>{const _e=new Float32Array(he.length/3*4);let ve=0;ae.forEach(he.length/3*4,(Le,ze)=>{(ze+1)%4!==0&&(_e[ve]=he[ve]+Le,ve++)}),I.setTangents(_e)}),Promise.all(Z).then(()=>{})}static _LoadTransform(p,_){if(p.skin!=null)return;let E=at.Zero(),I=us.Identity(),Z=at.One();p.matrix?jt.FromArray(p.matrix).decompose(Z,I,E):(p.translation&&(E=at.FromArray(p.translation)),p.rotation&&(I=us.FromArray(p.rotation)),p.scale&&(Z=at.FromArray(p.scale))),_.position=E,_.rotationQuaternion=I,_.scaling=Z}_loadSkinAsync(p,_,E,I){const Z=this._extensionsLoadSkinAsync(p,_,E);if(Z)return Z;if(E._data)return I(E._data.babylonSkeleton),E._data.promise;const re=`skeleton${E.index}`;this._babylonScene._blockEntityCollection=!!this._assetContainer;const ae=new xg(E.name||re,re,this._babylonScene);ae._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,this._loadBones(p,E,ae);const he=this._loadSkinInverseBindMatricesDataAsync(p,E).then(_e=>{this._updateBoneMatrices(ae,_e)});return E._data={babylonSkeleton:ae,promise:he},I(ae),he}_loadBones(p,_,E){if(_.skeleton==null||this._parent.alwaysComputeSkeletonRootNode){const Z=this._findSkeletonRootNode(`${p}/joints`,_.joints);if(Z)if(_.skeleton===void 0)_.skeleton=Z.index;else{const re=(he,_e)=>{for(;_e.parent;_e=_e.parent)if(_e.parent===he)return!0;return!1},ae=kr.Get(`${p}/skeleton`,this._gltf.nodes,_.skeleton);ae!==Z&&!re(ae,Z)&&(Ti.Warn(`${p}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`),_.skeleton=Z.index)}else Ti.Warn(`${p}: Failed to find common root`)}const I={};for(const Z of _.joints){const re=kr.Get(`${p}/joints/${Z}`,this._gltf.nodes,Z);this._loadBone(re,_,E,I)}}_findSkeletonRootNode(p,_){if(_.length===0)return null;const E={};for(const Z of _){const re=[];let ae=kr.Get(`${p}/${Z}`,this._gltf.nodes,Z);for(;ae.index!==-1;)re.unshift(ae),ae=ae.parent;E[Z]=re}let I=null;for(let Z=0;;++Z){let re=E[_[0]];if(Z>=re.length)return I;const ae=re[Z];for(let he=1;he<_.length;++he)if(re=E[_[he]],Z>=re.length||ae!==re[Z])return I;I=ae}}_loadBone(p,_,E,I){let Z=I[p.index];if(Z)return Z;let re=null;p.index!==_.skeleton&&(p.parent&&p.parent.index!==-1?re=this._loadBone(p.parent,_,E,I):_.skeleton!==void 0&&Ti.Warn(`/skins/${_.index}/skeleton: Skeleton node is not a common root`));const ae=_.joints.indexOf(p.index);return Z=new ca(p.name||`joint${p.index}`,E,re,this._getNodeMatrix(p),null,null,ae),I[p.index]=Z,this._postSceneLoadActions.push(()=>{Z.linkTransformNode(p._babylonTransformNode)}),Z}_loadSkinInverseBindMatricesDataAsync(p,_){if(_.inverseBindMatrices==null)return Promise.resolve(null);const E=kr.Get(`${p}/inverseBindMatrices`,this._gltf.accessors,_.inverseBindMatrices);return this._loadFloatAccessorAsync(`/accessors/${E.index}`,E)}_updateBoneMatrices(p,_){for(const E of p.bones){const I=jt.Identity(),Z=E._index;_&&Z!==-1&&(jt.FromArrayToRef(_,Z*16,I),I.invertToRef(I));const re=E.getParent();re&&I.multiplyToRef(re.getAbsoluteInverseBindMatrix(),I),E.updateMatrix(I,!1,!1),E._updateAbsoluteBindMatrices(void 0,!1)}}_getNodeMatrix(p){return p.matrix?jt.FromArray(p.matrix):jt.Compose(p.scale?at.FromArray(p.scale):at.One(),p.rotation?us.FromArray(p.rotation):us.Identity(),p.translation?at.FromArray(p.translation):at.Zero())}loadCameraAsync(p,_,E=()=>{}){const I=this._extensionsLoadCameraAsync(p,_,E);if(I)return I;const Z=new Array;this.logOpen(`${p} ${_.name||""}`),this._babylonScene._blockEntityCollection=!!this._assetContainer;const re=new cu(_.name||`camera${_.index}`,at.Zero(),this._babylonScene,!1);switch(re._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,re.ignoreParentScaling=!0,_._babylonCamera=re,re.rotation.set(0,Math.PI,0),_.type){case"perspective":{const ae=_.perspective;if(!ae)throw new Error(`${p}: Camera perspective properties are missing`);re.fov=ae.yfov,re.minZ=ae.znear,re.maxZ=ae.zfar||0;break}case"orthographic":{if(!_.orthographic)throw new Error(`${p}: Camera orthographic properties are missing`);re.mode=Wr.ORTHOGRAPHIC_CAMERA,re.orthoLeft=-_.orthographic.xmag,re.orthoRight=_.orthographic.xmag,re.orthoBottom=-_.orthographic.ymag,re.orthoTop=_.orthographic.ymag,re.minZ=_.orthographic.znear,re.maxZ=_.orthographic.zfar;break}default:throw new Error(`${p}: Invalid camera type (${_.type})`)}return js.AddPointerMetadata(re,p),this._parent.onCameraLoadedObservable.notifyObservers(re),E(re),this.logClose(),Promise.all(Z).then(()=>re)}_loadAnimationsAsync(){const p=this._gltf.animations;if(!p)return Promise.resolve();const _=new Array;for(let E=0;E<p.length;E++){const I=p[E];_.push(this.loadAnimationAsync(`/animations/${I.index}`,I).then(Z=>{Z.targetedAnimations.length===0&&Z.dispose()}))}return Promise.all(_).then(()=>{})}loadAnimationAsync(p,_){const E=this._extensionsLoadAnimationAsync(p,_);if(E)return E;this._babylonScene._blockEntityCollection=!!this._assetContainer;const I=new xh(_.name||`animation${_.index}`,this._babylonScene);I._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,_._babylonAnimationGroup=I;const Z=new Array;kr.Assign(_.channels),kr.Assign(_.samplers);for(const re of _.channels)Z.push(this._loadAnimationChannelAsync(`${p}/channels/${re.index}`,p,_,re,(ae,he)=>{ae.animations=ae.animations||[],ae.animations.push(he),I.addTargetedAnimation(he,ae)}));return Promise.all(Z).then(()=>(I.normalize(0),I))}_loadAnimationChannelAsync(p,_,E,I,Z){const re=this._extensionsLoadAnimationChannelAsync(p,_,E,I,Z);if(re)return re;if(I.target.node==null)return Promise.resolve();const ae=kr.Get(`${p}/target/node`,this._gltf.nodes,I.target.node);if(I.target.path==="weights"&&!ae._numMorphTargets||I.target.path!=="weights"&&!ae._babylonTransformNode)return Promise.resolve();let he;switch(I.target.path){case"translation":{he=nm.translation;break}case"rotation":{he=nm.rotation;break}case"scale":{he=nm.scale;break}case"weights":{he=nm.weights;break}default:throw new Error(`${p}/target/path: Invalid value (${I.target.path})`)}const _e={object:ae,info:he};return this._loadAnimationChannelFromTargetInfoAsync(p,_,E,I,_e,Z)}_loadAnimationChannelFromTargetInfoAsync(p,_,E,I,Z,re){const ae=this.parent.targetFps,he=1/ae,_e=kr.Get(`${p}/sampler`,E.samplers,I.sampler);return this._loadAnimationSamplerAsync(`${_}/samplers/${I.sampler}`,_e).then(ve=>{let Le=0;const ze=Z.object,He=Z.info;for(const xt of He){const rt=xt.getStride(ze),Tt=ve.input,Lt=ve.output,Nt=new Array(Tt.length);let qt=0;switch(ve.interpolation){case"STEP":{for(let Xt=0;Xt<Tt.length;Xt++){const zt=xt.getValue(ze,Lt,qt,1);qt+=rt,Nt[Xt]={frame:Tt[Xt]*ae,value:zt,interpolation:ag.STEP}}break}case"CUBICSPLINE":{for(let Xt=0;Xt<Tt.length;Xt++){const zt=xt.getValue(ze,Lt,qt,he);qt+=rt;const Gt=xt.getValue(ze,Lt,qt,1);qt+=rt;const xi=xt.getValue(ze,Lt,qt,he);qt+=rt,Nt[Xt]={frame:Tt[Xt]*ae,inTangent:zt,value:Gt,outTangent:xi}}break}case"LINEAR":{for(let Xt=0;Xt<Tt.length;Xt++){const zt=xt.getValue(ze,Lt,qt,1);qt+=rt,Nt[Xt]={frame:Tt[Xt]*ae,value:zt}}break}}if(qt>0){const Xt=`${E.name||`animation${E.index}`}_channel${I.index}_${Le}`;xt.buildAnimations(ze,Xt,ae,Nt,(zt,Gt)=>{++Le,re(zt,Gt)})}}})}_loadAnimationSamplerAsync(p,_){if(_._data)return _._data;const E=_.interpolation||"LINEAR";switch(E){case"STEP":case"LINEAR":case"CUBICSPLINE":break;default:throw new Error(`${p}/interpolation: Invalid value (${_.interpolation})`)}const I=kr.Get(`${p}/input`,this._gltf.accessors,_.input),Z=kr.Get(`${p}/output`,this._gltf.accessors,_.output);return _._data=Promise.all([this._loadFloatAccessorAsync(`/accessors/${I.index}`,I),this._loadFloatAccessorAsync(`/accessors/${Z.index}`,Z)]).then(([re,ae])=>({input:re,interpolation:E,output:ae})),_._data}loadBufferAsync(p,_,E,I){const Z=this._extensionsLoadBufferAsync(p,_,E,I);if(Z)return Z;if(!_._data)if(_.uri)_._data=this.loadUriAsync(`${p}/uri`,_,_.uri);else{if(!this._bin)throw new Error(`${p}: Uri is missing or the binary glTF is missing its binary chunk`);_._data=this._bin.readAsync(0,_.byteLength)}return _._data.then(re=>{try{return new Uint8Array(re.buffer,re.byteOffset+E,I)}catch(ae){throw new Error(`${p}: ${ae.message}`)}})}loadBufferViewAsync(p,_){const E=this._extensionsLoadBufferViewAsync(p,_);if(E)return E;if(_._data)return _._data;const I=kr.Get(`${p}/buffer`,this._gltf.buffers,_.buffer);return _._data=this.loadBufferAsync(`/buffers/${I.index}`,I,_.byteOffset||0,_.byteLength),_._data}_loadAccessorAsync(p,_,E){if(_._data)return _._data;const I=js._GetNumComponents(p,_.type),Z=I*ut.GetTypeByteLength(_.componentType),re=I*_.count;if(_.bufferView==null)_._data=Promise.resolve(new E(re));else{const ae=kr.Get(`${p}/bufferView`,this._gltf.bufferViews,_.bufferView);_._data=this.loadBufferViewAsync(`/bufferViews/${ae.index}`,ae).then(he=>{if(_.componentType===5126&&!_.normalized&&(!ae.byteStride||ae.byteStride===Z))return js._GetTypedArray(p,_.componentType,he,_.byteOffset,re);{const _e=new E(re);return ut.ForEach(he,_.byteOffset||0,ae.byteStride||Z,I,_.componentType,_e.length,_.normalized||!1,(ve,Le)=>{_e[Le]=ve}),_e}})}if(_.sparse){const ae=_.sparse;_._data=_._data.then(he=>{const _e=he,ve=kr.Get(`${p}/sparse/indices/bufferView`,this._gltf.bufferViews,ae.indices.bufferView),Le=kr.Get(`${p}/sparse/values/bufferView`,this._gltf.bufferViews,ae.values.bufferView);return Promise.all([this.loadBufferViewAsync(`/bufferViews/${ve.index}`,ve),this.loadBufferViewAsync(`/bufferViews/${Le.index}`,Le)]).then(([ze,He])=>{const xt=js._GetTypedArray(`${p}/sparse/indices`,ae.indices.componentType,ze,ae.indices.byteOffset,ae.count),rt=I*ae.count;let Tt;if(_.componentType===5126&&!_.normalized)Tt=js._GetTypedArray(`${p}/sparse/values`,_.componentType,He,ae.values.byteOffset,rt);else{const Nt=js._GetTypedArray(`${p}/sparse/values`,_.componentType,He,ae.values.byteOffset,rt);Tt=new E(rt),ut.ForEach(Nt,0,Z,I,_.componentType,Tt.length,_.normalized||!1,(qt,Xt)=>{Tt[Xt]=qt})}let Lt=0;for(let Nt=0;Nt<xt.length;Nt++){let qt=xt[Nt]*I;for(let Xt=0;Xt<I;Xt++)_e[qt++]=Tt[Lt++]}return _e})})}return _._data}_loadFloatAccessorAsync(p,_){return this._loadAccessorAsync(p,_,Float32Array)}_loadIndicesAccessorAsync(p,_){if(_.type!=="SCALAR")throw new Error(`${p}/type: Invalid value ${_.type}`);if(_.componentType!==5121&&_.componentType!==5123&&_.componentType!==5125)throw new Error(`${p}/componentType: Invalid value ${_.componentType}`);if(_._data)return _._data;if(_.sparse){const E=js._GetTypedArrayConstructor(`${p}/componentType`,_.componentType);_._data=this._loadAccessorAsync(p,_,E)}else{const E=kr.Get(`${p}/bufferView`,this._gltf.bufferViews,_.bufferView);_._data=this.loadBufferViewAsync(`/bufferViews/${E.index}`,E).then(I=>js._GetTypedArray(p,_.componentType,I,_.byteOffset,_.count))}return _._data}_loadVertexBufferViewAsync(p){if(p._babylonBuffer)return p._babylonBuffer;const _=this._babylonScene.getEngine();return p._babylonBuffer=this.loadBufferViewAsync(`/bufferViews/${p.index}`,p).then(E=>new xu(_,E,!1)),p._babylonBuffer}_loadVertexAccessorAsync(p,_,E){if(_._babylonVertexBuffer?.[E])return _._babylonVertexBuffer[E];_._babylonVertexBuffer||(_._babylonVertexBuffer={});const I=this._babylonScene.getEngine();if(_.sparse||_.bufferView==null)_._babylonVertexBuffer[E]=this._loadFloatAccessorAsync(p,_).then(Z=>new ut(I,Z,E,!1));else if(E===ut.MatricesIndicesKind||E===ut.MatricesIndicesExtraKind)_._babylonVertexBuffer[E]=this._loadFloatAccessorAsync(p,_).then(Z=>new ut(I,Z,E,!1));else{const Z=kr.Get(`${p}/bufferView`,this._gltf.bufferViews,_.bufferView);_._babylonVertexBuffer[E]=this._loadVertexBufferViewAsync(Z).then(re=>{const ae=js._GetNumComponents(p,_.type);return new ut(I,re,E,!1,void 0,Z.byteStride,void 0,_.byteOffset,ae,_.componentType,_.normalized,!0,void 0,!0)})}return _._babylonVertexBuffer[E]}_loadMaterialMetallicRoughnessPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const I=new Array;return _&&(_.baseColorFactor?(E.albedoColor=Rs.FromArray(_.baseColorFactor),E.alpha=_.baseColorFactor[3]):E.albedoColor=Rs.White(),E.metallic=_.metallicFactor==null?1:_.metallicFactor,E.roughness=_.roughnessFactor==null?1:_.roughnessFactor,_.baseColorTexture&&I.push(this.loadTextureInfoAsync(`${p}/baseColorTexture`,_.baseColorTexture,Z=>{Z.name=`${E.name} (Base Color)`,E.albedoTexture=Z})),_.metallicRoughnessTexture&&(_.metallicRoughnessTexture.nonColorData=!0,I.push(this.loadTextureInfoAsync(`${p}/metallicRoughnessTexture`,_.metallicRoughnessTexture,Z=>{Z.name=`${E.name} (Metallic Roughness)`,E.metallicTexture=Z})),E.useMetallnessFromMetallicTextureBlue=!0,E.useRoughnessFromMetallicTextureGreen=!0,E.useRoughnessFromMetallicTextureAlpha=!1)),Promise.all(I).then(()=>{})}_loadMaterialAsync(p,_,E,I,Z=()=>{}){const re=this._extensionsLoadMaterialAsync(p,_,E,I,Z);if(re)return re;_._data=_._data||{};let ae=_._data[I];if(!ae){this.logOpen(`${p} ${_.name||""}`);const he=this.createMaterial(p,_,I);ae={babylonMaterial:he,babylonMeshes:[],promise:this.loadMaterialPropertiesAsync(p,_,he)},_._data[I]=ae,js.AddPointerMetadata(he,p),this._parent.onMaterialLoadedObservable.notifyObservers(he),this.logClose()}return E&&(ae.babylonMeshes.push(E),E.onDisposeObservable.addOnce(()=>{const he=ae.babylonMeshes.indexOf(E);he!==-1&&ae.babylonMeshes.splice(he,1)})),Z(ae.babylonMaterial),ae.promise.then(()=>ae.babylonMaterial)}_createDefaultMaterial(p,_){this._babylonScene._blockEntityCollection=!!this._assetContainer;const E=new Ys(p,this._babylonScene);return E._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,E.fillMode=_,E.enableSpecularAntiAliasing=!0,E.useRadianceOverAlpha=!this._parent.transparencyAsCoverage,E.useSpecularOverAlpha=!this._parent.transparencyAsCoverage,E.transparencyMode=Ys.PBRMATERIAL_OPAQUE,E.metallic=1,E.roughness=1,E}createMaterial(p,_,E){const I=this._extensionsCreateMaterial(p,_,E);if(I)return I;const Z=_.name||`material${_.index}`;return this._createDefaultMaterial(Z,E)}loadMaterialPropertiesAsync(p,_,E){const I=this._extensionsLoadMaterialPropertiesAsync(p,_,E);if(I)return I;const Z=new Array;return Z.push(this.loadMaterialBasePropertiesAsync(p,_,E)),_.pbrMetallicRoughness&&Z.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${p}/pbrMetallicRoughness`,_.pbrMetallicRoughness,E)),this.loadMaterialAlphaProperties(p,_,E),Promise.all(Z).then(()=>{})}loadMaterialBasePropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const I=new Array;return E.emissiveColor=_.emissiveFactor?Rs.FromArray(_.emissiveFactor):new Rs(0,0,0),_.doubleSided&&(E.backFaceCulling=!1,E.twoSidedLighting=!0),_.normalTexture&&(_.normalTexture.nonColorData=!0,I.push(this.loadTextureInfoAsync(`${p}/normalTexture`,_.normalTexture,Z=>{Z.name=`${E.name} (Normal)`,E.bumpTexture=Z})),E.invertNormalMapX=!this._babylonScene.useRightHandedSystem,E.invertNormalMapY=this._babylonScene.useRightHandedSystem,_.normalTexture.scale!=null&&E.bumpTexture&&(E.bumpTexture.level=_.normalTexture.scale),E.forceIrradianceInFragment=!0),_.occlusionTexture&&(_.occlusionTexture.nonColorData=!0,I.push(this.loadTextureInfoAsync(`${p}/occlusionTexture`,_.occlusionTexture,Z=>{Z.name=`${E.name} (Occlusion)`,E.ambientTexture=Z})),E.useAmbientInGrayScale=!0,_.occlusionTexture.strength!=null&&(E.ambientTextureStrength=_.occlusionTexture.strength)),_.emissiveTexture&&I.push(this.loadTextureInfoAsync(`${p}/emissiveTexture`,_.emissiveTexture,Z=>{Z.name=`${E.name} (Emissive)`,E.emissiveTexture=Z})),Promise.all(I).then(()=>{})}loadMaterialAlphaProperties(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);switch(_.alphaMode||"OPAQUE"){case"OPAQUE":{E.transparencyMode=Ys.PBRMATERIAL_OPAQUE,E.alpha=1;break}case"MASK":{E.transparencyMode=Ys.PBRMATERIAL_ALPHATEST,E.alphaCutOff=_.alphaCutoff==null?.5:_.alphaCutoff,E.albedoTexture&&(E.albedoTexture.hasAlpha=!0);break}case"BLEND":{E.transparencyMode=Ys.PBRMATERIAL_ALPHABLEND,E.albedoTexture&&(E.albedoTexture.hasAlpha=!0,E.useAlphaFromAlbedoTexture=!0);break}default:throw new Error(`${p}/alphaMode: Invalid value (${_.alphaMode})`)}}loadTextureInfoAsync(p,_,E=()=>{}){const I=this._extensionsLoadTextureInfoAsync(p,_,E);if(I)return I;if(this.logOpen(`${p}`),_.texCoord>=6)throw new Error(`${p}/texCoord: Invalid value (${_.texCoord})`);const Z=kr.Get(`${p}/index`,this._gltf.textures,_.index);Z._textureInfo=_;const re=this._loadTextureAsync(`/textures/${_.index}`,Z,ae=>{ae.coordinatesIndex=_.texCoord||0,js.AddPointerMetadata(ae,p),this._parent.onTextureLoadedObservable.notifyObservers(ae),E(ae)});return this.logClose(),re}_loadTextureAsync(p,_,E=()=>{}){const I=this._extensionsLoadTextureAsync(p,_,E);if(I)return I;this.logOpen(`${p} ${_.name||""}`);const Z=_.sampler==null?js.DefaultSampler:kr.Get(`${p}/sampler`,this._gltf.samplers,_.sampler),re=kr.Get(`${p}/source`,this._gltf.images,_.source),ae=this._createTextureAsync(p,Z,re,E,void 0,!_._textureInfo.nonColorData);return this.logClose(),ae}_createTextureAsync(p,_,E,I=()=>{},Z,re){const ae=this._loadSampler(`/samplers/${_.index}`,_),he=new Array,_e=new qp;this._babylonScene._blockEntityCollection=!!this._assetContainer;const ve={noMipmap:ae.noMipMaps,invertY:!1,samplingMode:ae.samplingMode,onLoad:()=>{this._disposed||_e.resolve()},onError:(ze,He)=>{this._disposed||_e.reject(new Error(`${p}: ${He&&He.message?He.message:ze||"Failed to load texture"}`))},mimeType:E.mimeType,loaderOptions:Z,useSRGBBuffer:!!re&&this._parent.useSRGBBuffers},Le=new Ki(null,this._babylonScene,ve);return Le._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,he.push(_e.promise),he.push(this.loadImageAsync(`/images/${E.index}`,E).then(ze=>{const He=E.uri||`${this._fileName}#image${E.index}`,xt=`data:${this._uniqueRootUrl}${He}`;Le.updateURL(xt,ze)})),Le.wrapU=ae.wrapU,Le.wrapV=ae.wrapV,I(Le),Promise.all(he).then(()=>Le)}_loadSampler(p,_){return _._data||(_._data={noMipMaps:_.minFilter===9728||_.minFilter===9729,samplingMode:js._GetTextureSamplingMode(p,_),wrapU:js._GetTextureWrapMode(`${p}/wrapS`,_.wrapS),wrapV:js._GetTextureWrapMode(`${p}/wrapT`,_.wrapT)}),_._data}loadImageAsync(p,_){if(!_._data){if(this.logOpen(`${p} ${_.name||""}`),_.uri)_._data=this.loadUriAsync(`${p}/uri`,_,_.uri);else{const E=kr.Get(`${p}/bufferView`,this._gltf.bufferViews,_.bufferView);_._data=this.loadBufferViewAsync(`/bufferViews/${E.index}`,E)}this.logClose()}return _._data}loadUriAsync(p,_,E){const I=this._extensionsLoadUriAsync(p,_,E);if(I)return I;if(!js._ValidateUri(E))throw new Error(`${p}: '${E}' is invalid`);if(R2(E)){const Z=new Uint8Array(M2(E));return this.log(`${p}: Decoded ${E.substr(0,64)}... (${Z.length} bytes)`),Promise.resolve(Z)}return this.log(`${p}: Loading ${E}`),this._parent.preprocessUrlAsync(this._rootUrl+E).then(Z=>new Promise((re,ae)=>{this._parent._loadFile(this._babylonScene,Z,he=>{this._disposed||(this.log(`${p}: Loaded ${E} (${he.byteLength} bytes)`),re(new Uint8Array(he)))},!0,he=>{ae(new _2(`${p}: Failed to load '${E}'${he?": "+he.status+" "+he.statusText:""}`,he))})}))}static AddPointerMetadata(p,_){p.metadata=p.metadata||{};const E=p._internalMetadata=p._internalMetadata||{},I=E.gltf=E.gltf||{};(I.pointers=I.pointers||[]).push(_)}static _GetTextureWrapMode(p,_){switch(_=_??10497,_){case 33071:return Ki.CLAMP_ADDRESSMODE;case 33648:return Ki.MIRROR_ADDRESSMODE;case 10497:return Ki.WRAP_ADDRESSMODE;default:return Ti.Warn(`${p}: Invalid value (${_})`),Ki.WRAP_ADDRESSMODE}}static _GetTextureSamplingMode(p,_){const E=_.magFilter==null?9729:_.magFilter,I=_.minFilter==null?9987:_.minFilter;if(E===9729)switch(I){case 9728:return Ki.LINEAR_NEAREST;case 9729:return Ki.LINEAR_LINEAR;case 9984:return Ki.LINEAR_NEAREST_MIPNEAREST;case 9985:return Ki.LINEAR_LINEAR_MIPNEAREST;case 9986:return Ki.LINEAR_NEAREST_MIPLINEAR;case 9987:return Ki.LINEAR_LINEAR_MIPLINEAR;default:return Ti.Warn(`${p}/minFilter: Invalid value (${I})`),Ki.LINEAR_LINEAR_MIPLINEAR}else switch(E!==9728&&Ti.Warn(`${p}/magFilter: Invalid value (${E})`),I){case 9728:return Ki.NEAREST_NEAREST;case 9729:return Ki.NEAREST_LINEAR;case 9984:return Ki.NEAREST_NEAREST_MIPNEAREST;case 9985:return Ki.NEAREST_LINEAR_MIPNEAREST;case 9986:return Ki.NEAREST_NEAREST_MIPLINEAR;case 9987:return Ki.NEAREST_LINEAR_MIPLINEAR;default:return Ti.Warn(`${p}/minFilter: Invalid value (${I})`),Ki.NEAREST_NEAREST_MIPNEAREST}}static _GetTypedArrayConstructor(p,_){switch(_){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:throw new Error(`${p}: Invalid component type ${_}`)}}static _GetTypedArray(p,_,E,I,Z){const re=E.buffer;I=E.byteOffset+(I||0);const ae=js._GetTypedArrayConstructor(`${p}/componentType`,_),he=ut.GetTypeByteLength(_);return I%he!==0?(Ti.Warn(`${p}: Copying buffer as byte offset (${I}) is not a multiple of component type byte length (${he})`),new ae(re.slice(I,I+Z*he),0)):new ae(re,I,Z)}static _GetNumComponents(p,_){switch(_){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4;case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16}throw new Error(`${p}: Invalid type (${_})`)}static _ValidateUri(p){return lt.IsBase64(p)||p.indexOf("..")===-1}static _GetDrawMode(p,_){switch(_==null&&(_=4),_){case 0:return zi.PointListDrawMode;case 1:return zi.LineListDrawMode;case 2:return zi.LineLoopDrawMode;case 3:return zi.LineStripDrawMode;case 4:return zi.TriangleFillMode;case 5:return zi.TriangleStripDrawMode;case 6:return zi.TriangleFanDrawMode}throw new Error(`${p}: Invalid mesh primitive mode (${_})`)}_compileMaterialsAsync(){this._parent._startPerformanceCounter("Compile materials");const p=new Array;if(this._gltf.materials){for(const _ of this._gltf.materials)if(_._data)for(const E in _._data){const I=_._data[E];for(const Z of I.babylonMeshes){Z.computeWorldMatrix(!0);const re=I.babylonMaterial;p.push(re.forceCompilationAsync(Z)),p.push(re.forceCompilationAsync(Z,{useInstances:!0})),this._parent.useClipPlane&&(p.push(re.forceCompilationAsync(Z,{clipPlane:!0})),p.push(re.forceCompilationAsync(Z,{clipPlane:!0,useInstances:!0})))}}}return Promise.all(p).then(()=>{this._parent._endPerformanceCounter("Compile materials")})}_compileShadowGeneratorsAsync(){this._parent._startPerformanceCounter("Compile shadow generators");const p=new Array,_=this._babylonScene.lights;for(const E of _){const I=E.getShadowGenerator();I&&p.push(I.forceCompilationAsync())}return Promise.all(p).then(()=>{this._parent._endPerformanceCounter("Compile shadow generators")})}_forEachExtensions(p){for(const _ of this._extensions)_.enabled&&p(_)}_applyExtensions(p,_,E){for(const I of this._extensions)if(I.enabled){const Z=`${I.name}.${_}`,re=p;re._activeLoaderExtensionFunctions=re._activeLoaderExtensionFunctions||{};const ae=re._activeLoaderExtensionFunctions;if(!ae[Z]){ae[Z]=!0;try{const he=E(I);if(he)return he}finally{delete ae[Z]}}}return null}_extensionsOnLoading(){this._forEachExtensions(p=>p.onLoading&&p.onLoading())}_extensionsOnReady(){this._forEachExtensions(p=>p.onReady&&p.onReady())}_extensionsLoadSceneAsync(p,_){return this._applyExtensions(_,"loadScene",E=>E.loadSceneAsync&&E.loadSceneAsync(p,_))}_extensionsLoadNodeAsync(p,_,E){return this._applyExtensions(_,"loadNode",I=>I.loadNodeAsync&&I.loadNodeAsync(p,_,E))}_extensionsLoadCameraAsync(p,_,E){return this._applyExtensions(_,"loadCamera",I=>I.loadCameraAsync&&I.loadCameraAsync(p,_,E))}_extensionsLoadVertexDataAsync(p,_,E){return this._applyExtensions(_,"loadVertexData",I=>I._loadVertexDataAsync&&I._loadVertexDataAsync(p,_,E))}_extensionsLoadMeshPrimitiveAsync(p,_,E,I,Z,re){return this._applyExtensions(Z,"loadMeshPrimitive",ae=>ae._loadMeshPrimitiveAsync&&ae._loadMeshPrimitiveAsync(p,_,E,I,Z,re))}_extensionsLoadMaterialAsync(p,_,E,I,Z){return this._applyExtensions(_,"loadMaterial",re=>re._loadMaterialAsync&&re._loadMaterialAsync(p,_,E,I,Z))}_extensionsCreateMaterial(p,_,E){return this._applyExtensions(_,"createMaterial",I=>I.createMaterial&&I.createMaterial(p,_,E))}_extensionsLoadMaterialPropertiesAsync(p,_,E){return this._applyExtensions(_,"loadMaterialProperties",I=>I.loadMaterialPropertiesAsync&&I.loadMaterialPropertiesAsync(p,_,E))}_extensionsLoadTextureInfoAsync(p,_,E){return this._applyExtensions(_,"loadTextureInfo",I=>I.loadTextureInfoAsync&&I.loadTextureInfoAsync(p,_,E))}_extensionsLoadTextureAsync(p,_,E){return this._applyExtensions(_,"loadTexture",I=>I._loadTextureAsync&&I._loadTextureAsync(p,_,E))}_extensionsLoadAnimationAsync(p,_){return this._applyExtensions(_,"loadAnimation",E=>E.loadAnimationAsync&&E.loadAnimationAsync(p,_))}_extensionsLoadAnimationChannelAsync(p,_,E,I,Z){return this._applyExtensions(E,"loadAnimationChannel",re=>re._loadAnimationChannelAsync&&re._loadAnimationChannelAsync(p,_,E,I,Z))}_extensionsLoadSkinAsync(p,_,E){return this._applyExtensions(E,"loadSkin",I=>I._loadSkinAsync&&I._loadSkinAsync(p,_,E))}_extensionsLoadUriAsync(p,_,E){return this._applyExtensions(_,"loadUri",I=>I._loadUriAsync&&I._loadUriAsync(p,_,E))}_extensionsLoadBufferViewAsync(p,_){return this._applyExtensions(_,"loadBufferView",E=>E.loadBufferViewAsync&&E.loadBufferViewAsync(p,_))}_extensionsLoadBufferAsync(p,_,E,I){return this._applyExtensions(_,"loadBuffer",Z=>Z.loadBufferAsync&&Z.loadBufferAsync(p,_,E,I))}static LoadExtensionAsync(p,_,E,I){if(!_.extensions)return null;const re=_.extensions[E];return re?I(`${p}/extensions/${E}`,re):null}static LoadExtraAsync(p,_,E,I){if(!_.extras)return null;const re=_.extras[E];return re?I(`${p}/extras/${E}`,re):null}isExtensionUsed(p){return!!this._gltf.extensionsUsed&&this._gltf.extensionsUsed.indexOf(p)!==-1}logOpen(p){this._parent._logOpen(p)}logClose(){this._parent._logClose()}log(p){this._parent._log(p)}startPerformanceCounter(p){this._parent._startPerformanceCounter(p)}endPerformanceCounter(p){this._parent._endPerformanceCounter(p)}}js._RegisteredExtensions={},js.DefaultSampler={index:-1},G0._CreateGLTF2Loader=pe=>new js(pe);class p_ extends Rx{constructor(p,_,E,I=5,Z=0,re=!1,ae=!1,he=3,_e=null){super("",p),this._texture=p.getEngine().createRawCubeTexture(_,E,I,Z,re,ae,he,_e)}update(p,_,E,I,Z=null){this._texture.getEngine().updateRawCubeTexture(this._texture,p,_,E,I,Z)}updateRGBDAsync(p,_=null,E=.8,I=0){return RN(this._texture,p,_,E,I).then(()=>{})}clone(){return Hr.Clone(()=>{const p=this.getScene(),_=this._texture,E=new p_(p,_._bufferViewArray,_.width,_.format,_.type,_.generateMipMaps,_.invertY,_.samplingMode,_._compression);return _.source===kn.CubeRawRGBD&&E.updateRGBDAsync(_._bufferViewArrayArray,_._sphericalPolynomial,_._lodGenerationScale,_._lodGenerationOffset),E},this)}}const m_="EXT_lights_image_based";class LD{constructor(p){this.name=m_,this._loader=p,this.enabled=this._loader.isExtensionUsed(m_)}dispose(){this._loader=null,delete this._lights}onLoading(){const p=this._loader.gltf.extensions;if(p&&p[this.name]){const _=p[this.name];this._lights=_.lights}}loadSceneAsync(p,_){return js.LoadExtensionAsync(p,_,this.name,(E,I)=>{this._loader._allMaterialsDirtyRequired=!0;const Z=new Array;Z.push(this._loader.loadSceneAsync(p,_)),this._loader.logOpen(`${E}`);const re=kr.Get(`${E}/light`,this._lights,I.light);return Z.push(this._loadLightAsync(`/extensions/${this.name}/lights/${I.light}`,re).then(ae=>{this._loader.babylonScene.environmentTexture=ae})),this._loader.logClose(),Promise.all(Z).then(()=>{})})}_loadLightAsync(p,_){if(!_._loaded){const E=new Array;this._loader.logOpen(`${p}`);const I=new Array(_.specularImages.length);for(let Z=0;Z<_.specularImages.length;Z++){const re=_.specularImages[Z];I[Z]=new Array(re.length);for(let ae=0;ae<re.length;ae++){const he=`${p}/specularImages/${Z}/${ae}`;this._loader.logOpen(`${he}`);const _e=re[ae],ve=kr.Get(he,this._loader.gltf.images,_e);E.push(this._loader.loadImageAsync(`/images/${_e}`,ve).then(Le=>{I[Z][ae]=Le})),this._loader.logClose()}}this._loader.logClose(),_._loaded=Promise.all(E).then(()=>{const Z=new p_(this._loader.babylonScene,null,_.specularImageSize);if(Z.name=_.name||"environment",_._babylonTexture=Z,_.intensity!=null&&(Z.level=_.intensity),_.rotation){let _e=us.FromArray(_.rotation);this._loader.babylonScene.useRightHandedSystem||(_e=us.Inverse(_e)),jt.FromQuaternionToRef(_e,Z.getReflectionTextureMatrix())}if(!_.irradianceCoefficients)throw new Error(`${p}: Irradiance coefficients are missing`);const re=Ru.FromArray(_.irradianceCoefficients);re.scaleInPlace(_.intensity),re.convertIrradianceToLambertianRadiance();const ae=Mu.FromHarmonics(re),he=(I.length-1)/$t.Log2(_.specularImageSize);return Z.updateRGBDAsync(I,ae,he)})}return _._loaded.then(()=>_._babylonTexture)}}js.RegisterExtension(m_,pe=>new LD(pe)),vr.prototype.thinInstanceAdd=function(pe,p=!0){if(!this.getScene().getEngine().getCaps().instancedArrays)return Ti.Error("Thin Instances are not supported on this device as Instanced Array extension not supported"),-1;this._thinInstanceUpdateBufferSize("matrix",Array.isArray(pe)?pe.length:1);const _=this._thinInstanceDataStorage.instancesCount;if(Array.isArray(pe))for(let E=0;E<pe.length;++E)this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,pe[E],E===pe.length-1&&p);else this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,pe,p);return _},vr.prototype.thinInstanceAddSelf=function(pe=!0){return this.thinInstanceAdd(jt.IdentityReadOnly,pe)},vr.prototype.thinInstanceRegisterAttribute=function(pe,p){pe===ut.ColorKind&&(pe=ut.ColorInstanceKind),this.removeVerticesData(pe),this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.strides[pe]=p,this._userThinInstanceBuffersStorage.sizes[pe]=p*Math.max(32,this._thinInstanceDataStorage.instancesCount),this._userThinInstanceBuffersStorage.data[pe]=new Float32Array(this._userThinInstanceBuffersStorage.sizes[pe]),this._userThinInstanceBuffersStorage.vertexBuffers[pe]=new ut(this.getEngine(),this._userThinInstanceBuffersStorage.data[pe],pe,!0,!1,p,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[pe])},vr.prototype.thinInstanceSetMatrixAt=function(pe,p,_=!0){if(!this._thinInstanceDataStorage.matrixData||pe>=this._thinInstanceDataStorage.instancesCount)return!1;const E=this._thinInstanceDataStorage.matrixData;return p.copyToArray(E,pe*16),this._thinInstanceDataStorage.worldMatrices&&(this._thinInstanceDataStorage.worldMatrices[pe]=p),_&&(this.thinInstanceBufferUpdated("matrix"),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)),!0},vr.prototype.thinInstanceSetAttributeAt=function(pe,p,_,E=!0){return pe===ut.ColorKind&&(pe=ut.ColorInstanceKind),!this._userThinInstanceBuffersStorage||!this._userThinInstanceBuffersStorage.data[pe]||p>=this._thinInstanceDataStorage.instancesCount?!1:(this._thinInstanceUpdateBufferSize(pe,0),this._userThinInstanceBuffersStorage.data[pe].set(_,p*this._userThinInstanceBuffersStorage.strides[pe]),E&&this.thinInstanceBufferUpdated(pe),!0)},Object.defineProperty(vr.prototype,"thinInstanceCount",{get:function(){return this._thinInstanceDataStorage.instancesCount},set:function(pe){const p=this._thinInstanceDataStorage.matrixData??this.source?._thinInstanceDataStorage.matrixData,_=p?p.length/16:0;pe<=_&&(this._thinInstanceDataStorage.instancesCount=pe)},enumerable:!0,configurable:!0}),vr.prototype._thinInstanceCreateMatrixBuffer=function(pe,p,_=!0){pe===ut.ColorKind&&(pe=ut.ColorInstanceKind);const E=new xu(this.getEngine(),p,!_,16,!1,!0);for(let I=0;I<4;I++)this.setVerticesBuffer(E.createVertexBuffer(pe+I,I*4,4));return E},vr.prototype.thinInstanceSetBuffer=function(pe,p,_=0,E=!0){_=_||16,pe==="matrix"?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=null,this._thinInstanceDataStorage.matrixBufferSize=p?p.length:32*_,this._thinInstanceDataStorage.matrixData=p,this._thinInstanceDataStorage.worldMatrices=null,p!==null?(this._thinInstanceDataStorage.instancesCount=p.length/_,this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",p,E),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)):(this._thinInstanceDataStorage.instancesCount=0,this.doNotSyncBoundingInfo||this.refreshBoundingInfo())):pe==="previousMatrix"?(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=null,this._thinInstanceDataStorage.previousMatrixData=p,p!==null&&(this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",p,E))):(pe===ut.ColorKind&&(pe=ut.ColorInstanceKind),p===null?this._userThinInstanceBuffersStorage?.data[pe]&&(this.removeVerticesData(pe),delete this._userThinInstanceBuffersStorage.data[pe],delete this._userThinInstanceBuffersStorage.strides[pe],delete this._userThinInstanceBuffersStorage.sizes[pe],delete this._userThinInstanceBuffersStorage.vertexBuffers[pe]):(this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.data[pe]=p,this._userThinInstanceBuffersStorage.strides[pe]=_,this._userThinInstanceBuffersStorage.sizes[pe]=p.length,this._userThinInstanceBuffersStorage.vertexBuffers[pe]=new ut(this.getEngine(),p,pe,!E,!1,_,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[pe])))},vr.prototype.thinInstanceBufferUpdated=function(pe){pe==="matrix"?this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData,0,this._thinInstanceDataStorage.instancesCount):pe==="previousMatrix"?this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData,0,this._thinInstanceDataStorage.instancesCount):(pe===ut.ColorKind&&(pe=ut.ColorInstanceKind),this._userThinInstanceBuffersStorage?.vertexBuffers[pe]&&this._userThinInstanceBuffersStorage.vertexBuffers[pe].updateDirectly(this._userThinInstanceBuffersStorage.data[pe],0))},vr.prototype.thinInstancePartialBufferUpdate=function(pe,p,_){pe==="matrix"?this._thinInstanceDataStorage.matrixBuffer&&this._thinInstanceDataStorage.matrixBuffer.updateDirectly(p,_):(pe===ut.ColorKind&&(pe=ut.ColorInstanceKind),this._userThinInstanceBuffersStorage?.vertexBuffers[pe]&&this._userThinInstanceBuffersStorage.vertexBuffers[pe].updateDirectly(p,_))},vr.prototype.thinInstanceGetWorldMatrices=function(){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return[];const pe=this._thinInstanceDataStorage.matrixData;if(!this._thinInstanceDataStorage.worldMatrices){this._thinInstanceDataStorage.worldMatrices=[];for(let p=0;p<this._thinInstanceDataStorage.instancesCount;++p)this._thinInstanceDataStorage.worldMatrices[p]=jt.FromArray(pe,p*16)}return this._thinInstanceDataStorage.worldMatrices},vr.prototype.thinInstanceRefreshBoundingInfo=function(pe=!1,p=!1,_=!1){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return;const E=this._thinInstanceDataStorage.boundingVectors;if(pe||!this.rawBoundingInfo){E.length=0,this.refreshBoundingInfo(p,_);const re=this.getBoundingInfo();this.rawBoundingInfo=new uo(re.minimum,re.maximum)}const I=this.getBoundingInfo(),Z=this._thinInstanceDataStorage.matrixData;if(E.length===0)for(let re=0;re<I.boundingBox.vectors.length;++re)E.push(I.boundingBox.vectors[re].clone());ui.Vector3[0].setAll(Number.POSITIVE_INFINITY),ui.Vector3[1].setAll(Number.NEGATIVE_INFINITY);for(let re=0;re<this._thinInstanceDataStorage.instancesCount;++re){jt.FromArrayToRef(Z,re*16,ui.Matrix[0]);for(let ae=0;ae<E.length;++ae)at.TransformCoordinatesToRef(E[ae],ui.Matrix[0],ui.Vector3[2]),ui.Vector3[0].minimizeInPlace(ui.Vector3[2]),ui.Vector3[1].maximizeInPlace(ui.Vector3[2])}I.reConstruct(ui.Vector3[0],ui.Vector3[1]),this._updateBoundingInfo()},vr.prototype._thinInstanceUpdateBufferSize=function(pe,p=1){pe===ut.ColorKind&&(pe=ut.ColorInstanceKind);const _=pe==="matrix";if(!_&&(!this._userThinInstanceBuffersStorage||!this._userThinInstanceBuffersStorage.strides[pe]))return;const E=_?16:this._userThinInstanceBuffersStorage.strides[pe],I=_?this._thinInstanceDataStorage.matrixBufferSize:this._userThinInstanceBuffersStorage.sizes[pe];let Z=_?this._thinInstanceDataStorage.matrixData:this._userThinInstanceBuffersStorage.data[pe];const re=(this._thinInstanceDataStorage.instancesCount+p)*E;let ae=I;for(;ae<re;)ae*=2;if(!Z||I!=ae){if(!Z)Z=new Float32Array(ae);else{const he=new Float32Array(ae);he.set(Z,0),Z=he}_?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",Z,!1),this._thinInstanceDataStorage.matrixData=Z,this._thinInstanceDataStorage.matrixBufferSize=ae,this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",Z,!1))):(this._userThinInstanceBuffersStorage.vertexBuffers[pe]?.dispose(),this._userThinInstanceBuffersStorage.data[pe]=Z,this._userThinInstanceBuffersStorage.sizes[pe]=ae,this._userThinInstanceBuffersStorage.vertexBuffers[pe]=new ut(this.getEngine(),Z,pe,!0,!1,E,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[pe]))}},vr.prototype._thinInstanceInitializeUserStorage=function(){this._userThinInstanceBuffersStorage||(this._userThinInstanceBuffersStorage={data:{},sizes:{},vertexBuffers:{},strides:{}})},vr.prototype._disposeThinInstanceSpecificData=function(){this._thinInstanceDataStorage?.matrixBuffer&&(this._thinInstanceDataStorage.matrixBuffer.dispose(),this._thinInstanceDataStorage.matrixBuffer=null)};const g_="EXT_mesh_gpu_instancing";class kD{constructor(p){this.name=g_,this._loader=p,this.enabled=this._loader.isExtensionUsed(g_)}dispose(){this._loader=null}loadNodeAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{this._loader._disableInstancedMesh++;const re=this._loader.loadNodeAsync(`/nodes/${_.index}`,_,E);if(this._loader._disableInstancedMesh--,!_._primitiveBabylonMeshes)return re;const ae=new Array;let he=0;const _e=ve=>{if(Z.attributes[ve]==null){ae.push(Promise.resolve(null));return}const Le=kr.Get(`${I}/attributes/${ve}`,this._loader.gltf.accessors,Z.attributes[ve]);if(ae.push(this._loader._loadFloatAccessorAsync(`/accessors/${Le.bufferView}`,Le)),he===0)he=Le.count;else if(he!==Le.count)throw new Error(`${I}/attributes: Instance buffer accessors do not have the same count.`)};return _e("TRANSLATION"),_e("ROTATION"),_e("SCALE"),re.then(ve=>Promise.all(ae).then(([Le,ze,He])=>{const xt=new Float32Array(he*16);ui.Vector3[0].copyFromFloats(0,0,0),ui.Quaternion[0].copyFromFloats(0,0,0,1),ui.Vector3[1].copyFromFloats(1,1,1);for(let rt=0;rt<he;++rt)Le&&at.FromArrayToRef(Le,rt*3,ui.Vector3[0]),ze&&us.FromArrayToRef(ze,rt*4,ui.Quaternion[0]),He&&at.FromArrayToRef(He,rt*3,ui.Vector3[1]),jt.ComposeToRef(ui.Vector3[1],ui.Quaternion[0],ui.Vector3[0],ui.Matrix[0]),ui.Matrix[0].copyToArray(xt,rt*16);for(const rt of _._primitiveBabylonMeshes)rt.thinInstanceSetBuffer("matrix",xt,16,!0);return ve}))})}}js.RegisterExtension(g_,pe=>new kD(pe));class lh{static get Default(){return lh._Default||(lh._Default=new lh),lh._Default}constructor(){const p=lh.Configuration.decoder;this._decoderModulePromise=lt.LoadBabylonScriptAsync(p.url).then(()=>MeshoptDecoder.ready)}dispose(){delete this._decoderModulePromise}decodeGltfBufferAsync(p,_,E,I,Z){return this._decoderModulePromise.then(()=>{const re=new Uint8Array(_*E);return MeshoptDecoder.decodeGltfBuffer(re,_,E,p,I,Z),re})}}lh.Configuration={decoder:{url:`${lt._DefaultCdnUrl}/meshopt_decoder.js`}},lh._Default=null;const __="EXT_meshopt_compression";class UD{constructor(p){this.name=__,this.enabled=p.isExtensionUsed(__),this._loader=p}dispose(){this._loader=null}loadBufferViewAsync(p,_){return js.LoadExtensionAsync(p,_,this.name,(E,I)=>{const Z=_;if(Z._meshOptData)return Z._meshOptData;const re=kr.Get(`${p}/buffer`,this._loader.gltf.buffers,I.buffer);return Z._meshOptData=this._loader.loadBufferAsync(`/buffers/${re.index}`,re,I.byteOffset||0,I.byteLength).then(ae=>lh.Default.decodeGltfBufferAsync(ae,I.count,I.byteStride,I.mode,I.filter)),Z._meshOptData})}}js.RegisterExtension(__,pe=>new UD(pe));const y_="EXT_texture_webp";class GD{constructor(p){this.name=y_,this._loader=p,this.enabled=p.isExtensionUsed(y_)}dispose(){this._loader=null}_loadTextureAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=_.sampler==null?js.DefaultSampler:kr.Get(`${p}/sampler`,this._loader.gltf.samplers,_.sampler),ae=kr.Get(`${I}/source`,this._loader.gltf.images,Z.source);return this._loader._createTextureAsync(p,re,ae,he=>{E(he)},void 0,!_._textureInfo.nonColorData)})}}js.RegisterExtension(y_,pe=>new GD(pe));class zD{constructor(p){this._pendingActions=new Array,this._workerInfos=p.map(_=>({workerPromise:Promise.resolve(_),idle:!0}))}dispose(){for(const p of this._workerInfos)p.workerPromise.then(_=>{_.terminate()});this._workerInfos.length=0,this._pendingActions.length=0}push(p){this._executeOnIdleWorker(p)||this._pendingActions.push(p)}_executeOnIdleWorker(p){for(const _ of this._workerInfos)if(_.idle)return this._execute(_,p),!0;return!1}_execute(p,_){p.idle=!1,p.workerPromise.then(E=>{_(E,()=>{const I=this._pendingActions.shift();I?this._execute(p,I):p.idle=!0})})}}class hg extends zD{constructor(p,_,E=hg.DefaultOptions){super([]),this._maxWorkers=p,this._createWorkerAsync=_,this._options=E}push(p){if(!this._executeOnIdleWorker(p))if(this._workerInfos.length<this._maxWorkers){const _={workerPromise:this._createWorkerAsync(),idle:!1};this._workerInfos.push(_),this._execute(_,p)}else this._pendingActions.push(p)}_execute(p,_){p.timeoutId&&(clearTimeout(p.timeoutId),delete p.timeoutId),super._execute(p,(E,I)=>{_(E,()=>{I(),p.idle&&(p.timeoutId=setTimeout(()=>{p.workerPromise.then(re=>{re.terminate()});const Z=this._workerInfos.indexOf(p);Z!==-1&&this._workerInfos.splice(Z,1)},this._options.idleTimeElapsedBeforeRelease))})})}}hg.DefaultOptions={idleTimeElapsedBeforeRelease:1e3};function WD(pe){return new Promise(p=>{DracoDecoderModule({wasmBinary:pe}).then(_=>{p({module:_})})})}function b_(pe,p,_,E,I){let Z=null,re=null,ae=null;try{Z=new pe.Decoder,re=new pe.DecoderBuffer,re.Init(p,p.byteLength);let he;const _e=Z.GetEncodedGeometryType(re);switch(_e){case pe.TRIANGULAR_MESH:{const ze=new pe.Mesh;if(he=Z.DecodeBufferToMesh(re,ze),!he.ok()||ze.ptr===0)throw new Error(he.error_msg());const xt=ze.num_faces()*3,rt=xt*4,Tt=pe._malloc(rt);try{Z.GetTrianglesUInt32Array(ze,rt,Tt);const Lt=new Uint32Array(xt);Lt.set(new Uint32Array(pe.HEAPF32.buffer,Tt,xt)),E(Lt)}finally{pe._free(Tt)}ae=ze;break}case pe.POINT_CLOUD:{const ze=new pe.PointCloud;if(he=Z.DecodeBufferToPointCloud(re,ze),!he.ok()||!ze.ptr)throw new Error(he.error_msg());ae=ze;break}default:throw new Error(`Invalid geometry type ${_e}`)}const ve=ae.num_points(),Le=(ze,He,xt,rt)=>{const Tt=rt.data_type(),Lt=rt.num_components(),Nt=rt.normalized(),qt=rt.byte_stride(),Xt=rt.byte_offset(),Gt={[pe.DT_FLOAT32]:{typedArrayConstructor:Float32Array,heap:pe.HEAPF32},[pe.DT_INT8]:{typedArrayConstructor:Int8Array,heap:pe.HEAP8},[pe.DT_INT16]:{typedArrayConstructor:Int16Array,heap:pe.HEAP16},[pe.DT_INT32]:{typedArrayConstructor:Int32Array,heap:pe.HEAP32},[pe.DT_UINT8]:{typedArrayConstructor:Uint8Array,heap:pe.HEAPU8},[pe.DT_UINT16]:{typedArrayConstructor:Uint16Array,heap:pe.HEAPU16},[pe.DT_UINT32]:{typedArrayConstructor:Uint32Array,heap:pe.HEAPU32}}[Tt];if(!Gt)throw new Error(`Invalid data type ${Tt}`);const xi=ve*Lt,Gi=xi*Gt.typedArrayConstructor.BYTES_PER_ELEMENT,vs=pe._malloc(Gi);try{ze.GetAttributeDataArrayForAllPoints(He,rt,Tt,Gi,vs);const ks=new Gt.typedArrayConstructor(Gt.heap.buffer,vs,xi);I(xt,ks.slice(),Lt,Xt,qt,Nt)}finally{pe._free(vs)}};if(_)for(const ze in _){const He=_[ze],xt=Z.GetAttributeByUniqueId(ae,He);Le(Z,ae,ze,xt)}else{const ze={position:pe.POSITION,normal:pe.NORMAL,color:pe.COLOR,uv:pe.TEX_COORD};for(const He in ze){const xt=Z.GetAttributeId(ae,ze[He]);if(xt!==-1){const rt=Z.GetAttribute(ae,xt);Le(Z,ae,He,rt)}}}return ve}finally{ae&&pe.destroy(ae),re&&pe.destroy(re),Z&&pe.destroy(Z)}}function HD(){let pe;onmessage=p=>{const _=p.data;switch(_.id){case"init":{const E=_.decoder;E.url&&(importScripts(E.url),pe=DracoDecoderModule({wasmBinary:E.wasmBinary})),postMessage({id:"initDone"});break}case"decodeMesh":{if(!pe)throw new Error("Draco decoder module is not available");pe.then(E=>{const I=b_(E,_.dataView,_.attributes,Z=>{postMessage({id:"indices",data:Z},[Z.buffer])},(Z,re,ae,he,_e,ve)=>{postMessage({id:"attribute",kind:Z,data:re,size:ae,byteOffset:he,byteStride:_e,normalized:ve},[re.buffer])});postMessage({id:"decodeMeshDone",totalVertices:I})});break}}}}class _o{static get DecoderAvailable(){const p=_o.Configuration.decoder;return!!(p.wasmUrl&&p.wasmBinaryUrl&&typeof WebAssembly=="object"||p.fallbackUrl)}static GetDefaultNumWorkers(){return typeof navigator!="object"||!navigator.hardwareConcurrency?1:Math.min(Math.floor(navigator.hardwareConcurrency*.5),4)}static get Default(){return _o._Default||(_o._Default=new _o),_o._Default}constructor(p=_o.DefaultNumWorkers){const _=_o.Configuration.decoder,E=_.wasmUrl&&_.wasmBinaryUrl&&typeof WebAssembly=="object"?{url:lt.GetBabylonScriptURL(_.wasmUrl,!0),wasmBinaryPromise:lt.LoadFileAsync(lt.GetBabylonScriptURL(_.wasmBinaryUrl,!0))}:{url:lt.GetBabylonScriptURL(_.fallbackUrl),wasmBinaryPromise:Promise.resolve(void 0)};p&&typeof Worker=="function"&&typeof URL=="function"?this._workerPoolPromise=E.wasmBinaryPromise.then(I=>{const Z=`${b_}(${HD})()`,re=URL.createObjectURL(new Blob([Z],{type:"application/javascript"}));return new hg(p,()=>new Promise((ae,he)=>{const _e=new Worker(re),ve=ze=>{_e.removeEventListener("error",ve),_e.removeEventListener("message",Le),he(ze)},Le=ze=>{ze.data.id==="initDone"&&(_e.removeEventListener("error",ve),_e.removeEventListener("message",Le),ae(_e))};_e.addEventListener("error",ve),_e.addEventListener("message",Le),_e.postMessage({id:"init",decoder:{url:E.url,wasmBinary:I}})}))}):this._decoderModulePromise=E.wasmBinaryPromise.then(I=>{if(!E.url)throw new Error("Draco decoder module is not available");return lt.LoadBabylonScriptAsync(E.url).then(()=>WD(I))})}dispose(){this._workerPoolPromise&&this._workerPoolPromise.then(p=>{p.dispose()}),delete this._workerPoolPromise,delete this._decoderModulePromise}whenReadyAsync(){return this._workerPoolPromise?this._workerPoolPromise.then(()=>{}):this._decoderModulePromise?this._decoderModulePromise.then(()=>{}):Promise.resolve()}_decodeMeshAsync(p,_,E){const I=p instanceof ArrayBuffer?new Int8Array(p):new Int8Array(p.buffer,p.byteOffset,p.byteLength),Z=(re,ae)=>E&&E[re]!==void 0?(ae!==E[re]&&Ti.Warn(`Normalized flag from Draco data (${ae}) does not match normalized flag from glTF accessor (${E[re]}). Using flag from glTF accessor.`),E[re]):ae;if(this._workerPoolPromise)return this._workerPoolPromise.then(re=>new Promise((ae,he)=>{re.push((_e,ve)=>{let Le=null;const ze=[],He=Tt=>{_e.removeEventListener("error",He),_e.removeEventListener("message",xt),he(Tt),ve()},xt=Tt=>{const Lt=Tt.data;switch(Lt.id){case"decodeMeshDone":{_e.removeEventListener("error",He),_e.removeEventListener("message",xt),ae({indices:Le,attributes:ze,totalVertices:Lt.totalVertices}),ve();break}case"indices":{Le=Lt.data;break}case"attribute":{ze.push({kind:Lt.kind,data:Lt.data,size:Lt.size,byteOffset:Lt.byteOffset,byteStride:Lt.byteStride,normalized:Z(Lt.kind,Lt.normalized)});break}}};_e.addEventListener("error",He),_e.addEventListener("message",xt);const rt=I.slice();_e.postMessage({id:"decodeMesh",dataView:rt,attributes:_},[rt.buffer])})}));if(this._decoderModulePromise)return this._decoderModulePromise.then(re=>{let ae=null;const he=[],_e=b_(re.module,I,_,ve=>{ae=ve},(ve,Le,ze,He,xt,rt)=>{he.push({kind:ve,data:Le,size:ze,byteOffset:He,byteStride:xt,normalized:rt})});return{indices:ae,attributes:he,totalVertices:_e}});throw new Error("Draco decoder module is not available")}decodeMeshToGeometryAsync(p,_,E,I){return this._decodeMeshAsync(E,I).then(Z=>{const re=new cx(p,_);Z.indices&&re.setIndices(Z.indices);for(const ae of Z.attributes)re.setVerticesBuffer(new ut(_.getEngine(),ae.data,ae.kind,!1,void 0,ae.byteStride,void 0,ae.byteOffset,ae.size,void 0,ae.normalized,!0),Z.totalVertices);return re})}_decodeMeshToGeometryForGltfAsync(p,_,E,I,Z){return this._decodeMeshAsync(E,I,Z).then(re=>{const ae=new cx(p,_);re.indices&&ae.setIndices(re.indices);for(const he of re.attributes)ae.setVerticesBuffer(new ut(_.getEngine(),he.data,he.kind,!1,void 0,he.byteStride,void 0,he.byteOffset,he.size,void 0,he.normalized,!0),re.totalVertices);return ae})}decodeMeshAsync(p,_){return this._decodeMeshAsync(p,_).then(E=>{const I=new Xr;E.indices&&(I.indices=E.indices);for(const Z of E.attributes){const re=ut.GetFloatData(Z.data,Z.size,ut.GetDataType(Z.data),Z.byteOffset,Z.byteStride,Z.normalized,E.totalVertices);I.set(re,Z.kind)}return I})}}_o.Configuration={decoder:{wasmUrl:`${lt._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,wasmBinaryUrl:`${lt._DefaultCdnUrl}/draco_decoder_gltf.wasm`,fallbackUrl:`${lt._DefaultCdnUrl}/draco_decoder_gltf.js`}},_o.DefaultNumWorkers=_o.GetDefaultNumWorkers(),_o._Default=null;const E_="KHR_draco_mesh_compression";class XD{constructor(p){this.name=E_,this.useNormalizedFlagFromAccessor=!0,this._loader=p,this.enabled=_o.DecoderAvailable&&this._loader.isExtensionUsed(E_)}dispose(){delete this.dracoCompression,this._loader=null}_loadVertexDataAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{if(_.mode!=null&&_.mode!==4&&_.mode!==5)throw new Error(`${p}: Unsupported mode ${_.mode}`);const re={},ae={},he=(ve,Le)=>{const ze=Z.attributes[ve];if(ze!=null&&(E._delayInfo=E._delayInfo||[],E._delayInfo.indexOf(Le)===-1&&E._delayInfo.push(Le),re[Le]=ze,this.useNormalizedFlagFromAccessor)){const He=kr.TryGet(this._loader.gltf.accessors,_.attributes[ve]);He&&(ae[Le]=He.normalized||!1)}};he("POSITION",ut.PositionKind),he("NORMAL",ut.NormalKind),he("TANGENT",ut.TangentKind),he("TEXCOORD_0",ut.UVKind),he("TEXCOORD_1",ut.UV2Kind),he("TEXCOORD_2",ut.UV3Kind),he("TEXCOORD_3",ut.UV4Kind),he("TEXCOORD_4",ut.UV5Kind),he("TEXCOORD_5",ut.UV6Kind),he("JOINTS_0",ut.MatricesIndicesKind),he("WEIGHTS_0",ut.MatricesWeightsKind),he("COLOR_0",ut.ColorKind);const _e=kr.Get(I,this._loader.gltf.bufferViews,Z.bufferView);return _e._dracoBabylonGeometry||(_e._dracoBabylonGeometry=this._loader.loadBufferViewAsync(`/bufferViews/${_e.index}`,_e).then(ve=>(this.dracoCompression||_o.Default)._decodeMeshToGeometryForGltfAsync(E.name,this._loader.babylonScene,ve,re,ae).catch(ze=>{throw new Error(`${p}: ${ze.message}`)}))),_e._dracoBabylonGeometry})}}js.RegisterExtension(E_,pe=>new XD(pe)),Ha.AddNodeConstructor("Light_Type_0",(pe,p)=>()=>new T_(pe,at.Zero(),p));class T_ extends Xc{get shadowAngle(){return this._shadowAngle}set shadowAngle(p){this._shadowAngle=p,this.forceProjectionMatrixCompute()}get direction(){return this._direction}set direction(p){const _=this.needCube();if(this._direction=p,this.needCube()!==_&&this._shadowGenerators){const E=this._shadowGenerators.values();for(let I=E.next();I.done!==!0;I=E.next())I.value.recreateShadowMap()}}constructor(p,_,E){super(p,E),this._shadowAngle=Math.PI/2,this.position=_}getClassName(){return"PointLight"}getTypeID(){return un.LIGHTTYPEID_POINTLIGHT}needCube(){return!this.direction}getShadowDirection(p){if(this.direction)return super.getShadowDirection(p);switch(p){case 0:return new at(1,0,0);case 1:return new at(-1,0,0);case 2:return new at(0,-1,0);case 3:return new at(0,1,0);case 4:return new at(0,0,1);case 5:return new at(0,0,-1)}return at.Zero()}_setDefaultShadowProjectionMatrix(p,_,E){const I=this.getScene().activeCamera;if(!I)return;const Z=this.shadowMinZ!==void 0?this.shadowMinZ:I.minZ,re=this.shadowMaxZ!==void 0?this.shadowMaxZ:I.maxZ,ae=this.getScene().getEngine().useReverseDepthBuffer;jt.PerspectiveFovLHToRef(this.shadowAngle,1,ae?re:Z,ae?Z:re,p,!0,this._scene.getEngine().isNDCHalfZRange,void 0,ae)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(p,_){return this.computeTransformedInformation()?this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z,0,_):this._uniformBuffer.updateFloat4("vLightData",this.position.x,this.position.y,this.position.z,0,_),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,0,0,_),this}transferToNodeMaterialEffect(p,_){return this.computeTransformedInformation()?p.setFloat3(_,this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z):p.setFloat3(_,this.position.x,this.position.y,this.position.z),this}prepareLightSpecificDefines(p,_){p["POINTLIGHT"+_]=!0}}Rt([Ut()],T_.prototype,"shadowAngle",null),Ha.AddNodeConstructor("Light_Type_2",(pe,p)=>()=>new Wo(pe,at.Zero(),at.Zero(),0,0,p));class Wo extends Xc{get angle(){return this._angle}set angle(p){this._angle=p,this._cosHalfAngle=Math.cos(p*.5),this._projectionTextureProjectionLightDirty=!0,this.forceProjectionMatrixCompute(),this._computeAngleValues()}get innerAngle(){return this._innerAngle}set innerAngle(p){this._innerAngle=p,this._computeAngleValues()}get shadowAngleScale(){return this._shadowAngleScale}set shadowAngleScale(p){this._shadowAngleScale=p,this.forceProjectionMatrixCompute()}get projectionTextureMatrix(){return this._projectionTextureMatrix}get projectionTextureLightNear(){return this._projectionTextureLightNear}set projectionTextureLightNear(p){this._projectionTextureLightNear=p,this._projectionTextureProjectionLightDirty=!0}get projectionTextureLightFar(){return this._projectionTextureLightFar}set projectionTextureLightFar(p){this._projectionTextureLightFar=p,this._projectionTextureProjectionLightDirty=!0}get projectionTextureUpDirection(){return this._projectionTextureUpDirection}set projectionTextureUpDirection(p){this._projectionTextureUpDirection=p,this._projectionTextureProjectionLightDirty=!0}get projectionTexture(){return this._projectionTexture}set projectionTexture(p){this._projectionTexture!==p&&(this._projectionTexture=p,this._projectionTextureDirty=!0,this._projectionTexture&&!this._projectionTexture.isReady()&&(Wo._IsProceduralTexture(this._projectionTexture)?this._projectionTexture.getEffect().executeWhenCompiled(()=>{this._markMeshesAsLightDirty()}):Wo._IsTexture(this._projectionTexture)&&this._projectionTexture.onLoadObservable.addOnce(()=>{this._markMeshesAsLightDirty()})))}static _IsProceduralTexture(p){return p.onGeneratedObservable!==void 0}static _IsTexture(p){return p.onLoadObservable!==void 0}get projectionTextureProjectionLightMatrix(){return this._projectionTextureProjectionLightMatrix}set projectionTextureProjectionLightMatrix(p){this._projectionTextureProjectionLightMatrix=p,this._projectionTextureProjectionLightDirty=!1,this._projectionTextureDirty=!0}constructor(p,_,E,I,Z,re){super(p,re),this._innerAngle=0,this._projectionTextureMatrix=jt.Zero(),this._projectionTextureLightNear=1e-6,this._projectionTextureLightFar=1e3,this._projectionTextureUpDirection=at.Up(),this._projectionTextureViewLightDirty=!0,this._projectionTextureProjectionLightDirty=!0,this._projectionTextureDirty=!0,this._projectionTextureViewTargetVector=at.Zero(),this._projectionTextureViewLightMatrix=jt.Zero(),this._projectionTextureProjectionLightMatrix=jt.Zero(),this._projectionTextureScalingMatrix=jt.FromValues(.5,0,0,0,0,.5,0,0,0,0,.5,0,.5,.5,.5,1),this.position=_,this.direction=E,this.angle=I,this.exponent=Z}getClassName(){return"SpotLight"}getTypeID(){return un.LIGHTTYPEID_SPOTLIGHT}_setDirection(p){super._setDirection(p),this._projectionTextureViewLightDirty=!0}_setPosition(p){super._setPosition(p),this._projectionTextureViewLightDirty=!0}_setDefaultShadowProjectionMatrix(p,_,E){const I=this.getScene().activeCamera;if(!I)return;this._shadowAngleScale=this._shadowAngleScale||1;const Z=this._shadowAngleScale*this._angle,re=this.shadowMinZ!==void 0?this.shadowMinZ:I.minZ,ae=this.shadowMaxZ!==void 0?this.shadowMaxZ:I.maxZ,he=this.getScene().getEngine().useReverseDepthBuffer;jt.PerspectiveFovLHToRef(Z,1,he?ae:re,he?re:ae,p,!0,this._scene.getEngine().isNDCHalfZRange,void 0,he)}_computeProjectionTextureViewLightMatrix(){this._projectionTextureViewLightDirty=!1,this._projectionTextureDirty=!0,this.getAbsolutePosition().addToRef(this.getShadowDirection(),this._projectionTextureViewTargetVector),jt.LookAtLHToRef(this.getAbsolutePosition(),this._projectionTextureViewTargetVector,this._projectionTextureUpDirection,this._projectionTextureViewLightMatrix)}_computeProjectionTextureProjectionLightMatrix(){this._projectionTextureProjectionLightDirty=!1,this._projectionTextureDirty=!0;const p=this.projectionTextureLightFar,_=this.projectionTextureLightNear,E=p/(p-_),I=-E*_,Z=1/Math.tan(this._angle/2),re=1;jt.FromValuesToRef(Z/re,0,0,0,0,Z,0,0,0,0,E,1,0,0,I,0,this._projectionTextureProjectionLightMatrix)}_computeProjectionTextureMatrix(){if(this._projectionTextureDirty=!1,this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix,this._projectionTextureMatrix),this._projectionTexture instanceof Ki){const p=this._projectionTexture.uScale/2,_=this._projectionTexture.vScale/2;jt.FromValuesToRef(p,0,0,0,0,_,0,0,0,0,.5,0,.5,.5,.5,1,this._projectionTextureScalingMatrix)}this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix,this._projectionTextureMatrix)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightDirection",3),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}_computeAngleValues(){this._lightAngleScale=1/Math.max(.001,Math.cos(this._innerAngle*.5)-this._cosHalfAngle),this._lightAngleOffset=-this._cosHalfAngle*this._lightAngleScale}transferTexturesToEffect(p,_){return this.projectionTexture&&this.projectionTexture.isReady()&&(this._projectionTextureViewLightDirty&&this._computeProjectionTextureViewLightMatrix(),this._projectionTextureProjectionLightDirty&&this._computeProjectionTextureProjectionLightMatrix(),this._projectionTextureDirty&&this._computeProjectionTextureMatrix(),p.setMatrix("textureProjectionMatrix"+_,this._projectionTextureMatrix),p.setTexture("projectionLightSampler"+_,this.projectionTexture)),this}transferToEffect(p,_){let E;return this.computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z,this.exponent,_),E=at.Normalize(this.transformedDirection)):(this._uniformBuffer.updateFloat4("vLightData",this.position.x,this.position.y,this.position.z,this.exponent,_),E=at.Normalize(this.direction)),this._uniformBuffer.updateFloat4("vLightDirection",E.x,E.y,E.z,this._cosHalfAngle,_),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,this._lightAngleScale,this._lightAngleOffset,_),this}transferToNodeMaterialEffect(p,_){let E;return this.computeTransformedInformation()?E=at.Normalize(this.transformedDirection):E=at.Normalize(this.direction),this.getScene().useRightHandedSystem?p.setFloat3(_,-E.x,-E.y,-E.z):p.setFloat3(_,E.x,E.y,E.z),this}dispose(){super.dispose(),this._projectionTexture&&this._projectionTexture.dispose()}getDepthMinZ(p){const _=this._scene.getEngine(),E=this.shadowMinZ!==void 0?this.shadowMinZ:p.minZ;return _.useReverseDepthBuffer&&_.isNDCHalfZRange?E:this._scene.getEngine().isNDCHalfZRange?0:E}getDepthMaxZ(p){const _=this._scene.getEngine(),E=this.shadowMaxZ!==void 0?this.shadowMaxZ:p.maxZ;return _.useReverseDepthBuffer&&_.isNDCHalfZRange?0:E}prepareLightSpecificDefines(p,_){p["SPOTLIGHT"+_]=!0,p["PROJECTEDLIGHTTEXTURE"+_]=!!(this.projectionTexture&&this.projectionTexture.isReady())}}Rt([Ut()],Wo.prototype,"angle",null),Rt([Ut()],Wo.prototype,"innerAngle",null),Rt([Ut()],Wo.prototype,"shadowAngleScale",null),Rt([Ut()],Wo.prototype,"exponent",void 0),Rt([Ut()],Wo.prototype,"projectionTextureLightNear",null),Rt([Ut()],Wo.prototype,"projectionTextureLightFar",null),Rt([Ut()],Wo.prototype,"projectionTextureUpDirection",null),Rt([Hn("projectedLightTexture")],Wo.prototype,"_projectionTexture",void 0);const v_="KHR_lights_punctual";class YD{constructor(p){this.name=v_,this._loader=p,this.enabled=this._loader.isExtensionUsed(v_)}dispose(){this._loader=null,delete this._lights}onLoading(){const p=this._loader.gltf.extensions;if(p&&p[this.name]){const _=p[this.name];this._lights=_.lights,kr.Assign(this._lights)}}loadNodeAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>(this._loader._allMaterialsDirtyRequired=!0,this._loader.loadNodeAsync(p,_,re=>{let ae;const he=kr.Get(I,this._lights,Z.light),_e=he.name||re.name;switch(this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer,he.type){case"directional":{const ve=new W2(_e,at.Backward(),this._loader.babylonScene);ve.position.setAll(0),ae=ve;break}case"point":{ae=new T_(_e,at.Zero(),this._loader.babylonScene);break}case"spot":{const ve=new Wo(_e,at.Zero(),at.Backward(),0,1,this._loader.babylonScene);ve.angle=(he.spot&&he.spot.outerConeAngle||Math.PI/4)*2,ve.innerAngle=(he.spot&&he.spot.innerConeAngle||0)*2,ae=ve;break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${I}: Invalid light type (${he.type})`)}ae._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,he._babylonLight=ae,ae.falloffType=un.FALLOFF_GLTF,ae.diffuse=he.color?Rs.FromArray(he.color):Rs.White(),ae.intensity=he.intensity==null?1:he.intensity,ae.range=he.range==null?Number.MAX_VALUE:he.range,ae.parent=re,this._loader._babylonLights.push(ae),js.AddPointerMetadata(ae,I),E(re)})))}}js.RegisterExtension(v_,pe=>new YD(pe));const A_="KHR_materials_pbrSpecularGlossiness";class KD{constructor(p){this.name=A_,this.order=200,this._loader=p,this.enabled=this._loader.isExtensionUsed(A_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialBasePropertiesAsync(p,_,E)),re.push(this._loadSpecularGlossinessPropertiesAsync(I,Z,E)),this._loader.loadMaterialAlphaProperties(p,_,E),Promise.all(re).then(()=>{})})}_loadSpecularGlossinessPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const I=new Array;return E.metallic=null,E.roughness=null,_.diffuseFactor?(E.albedoColor=Rs.FromArray(_.diffuseFactor),E.alpha=_.diffuseFactor[3]):E.albedoColor=Rs.White(),E.reflectivityColor=_.specularFactor?Rs.FromArray(_.specularFactor):Rs.White(),E.microSurface=_.glossinessFactor==null?1:_.glossinessFactor,_.diffuseTexture&&I.push(this._loader.loadTextureInfoAsync(`${p}/diffuseTexture`,_.diffuseTexture,Z=>{Z.name=`${E.name} (Diffuse)`,E.albedoTexture=Z})),_.specularGlossinessTexture&&(I.push(this._loader.loadTextureInfoAsync(`${p}/specularGlossinessTexture`,_.specularGlossinessTexture,Z=>{Z.name=`${E.name} (Specular Glossiness)`,E.reflectivityTexture=Z,E.reflectivityTexture.hasAlpha=!0})),E.useMicroSurfaceFromReflectivityMapAlpha=!0),Promise.all(I).then(()=>{})}}js.RegisterExtension(A_,pe=>new KD(pe));const S_="KHR_materials_unlit";class jD{constructor(p){this.name=S_,this.order=210,this._loader=p,this.enabled=this._loader.isExtensionUsed(S_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,()=>this._loadUnlitPropertiesAsync(p,_,E))}_loadUnlitPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const I=new Array;E.unlit=!0;const Z=_.pbrMetallicRoughness;return Z&&(Z.baseColorFactor?(E.albedoColor=Rs.FromArray(Z.baseColorFactor),E.alpha=Z.baseColorFactor[3]):E.albedoColor=Rs.White(),Z.baseColorTexture&&I.push(this._loader.loadTextureInfoAsync(`${p}/baseColorTexture`,Z.baseColorTexture,re=>{re.name=`${E.name} (Base Color)`,E.albedoTexture=re}))),_.doubleSided&&(E.backFaceCulling=!1,E.twoSidedLighting=!0),this._loader.loadMaterialAlphaProperties(p,_,E),Promise.all(I).then(()=>{})}}js.RegisterExtension(S_,pe=>new jD(pe));const C_="KHR_materials_clearcoat";class qD{constructor(p){this.name=C_,this.order=190,this._loader=p,this.enabled=this._loader.isExtensionUsed(C_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),re.push(this._loadClearCoatPropertiesAsync(I,Z,E)),Promise.all(re).then(()=>{})})}_loadClearCoatPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const I=new Array;return E.clearCoat.isEnabled=!0,E.clearCoat.useRoughnessFromMainTexture=!1,E.clearCoat.remapF0OnInterfaceChange=!1,_.clearcoatFactor!=null?E.clearCoat.intensity=_.clearcoatFactor:E.clearCoat.intensity=0,_.clearcoatTexture&&I.push(this._loader.loadTextureInfoAsync(`${p}/clearcoatTexture`,_.clearcoatTexture,Z=>{Z.name=`${E.name} (ClearCoat Intensity)`,E.clearCoat.texture=Z})),_.clearcoatRoughnessFactor!=null?E.clearCoat.roughness=_.clearcoatRoughnessFactor:E.clearCoat.roughness=0,_.clearcoatRoughnessTexture&&(_.clearcoatRoughnessTexture.nonColorData=!0,I.push(this._loader.loadTextureInfoAsync(`${p}/clearcoatRoughnessTexture`,_.clearcoatRoughnessTexture,Z=>{Z.name=`${E.name} (ClearCoat Roughness)`,E.clearCoat.textureRoughness=Z}))),_.clearcoatNormalTexture&&(_.clearcoatNormalTexture.nonColorData=!0,I.push(this._loader.loadTextureInfoAsync(`${p}/clearcoatNormalTexture`,_.clearcoatNormalTexture,Z=>{Z.name=`${E.name} (ClearCoat Normal)`,E.clearCoat.bumpTexture=Z})),E.invertNormalMapX=!E.getScene().useRightHandedSystem,E.invertNormalMapY=E.getScene().useRightHandedSystem,_.clearcoatNormalTexture.scale!=null&&(E.clearCoat.bumpTexture.level=_.clearcoatNormalTexture.scale)),Promise.all(I).then(()=>{})}}js.RegisterExtension(C_,pe=>new qD(pe));const R_="KHR_materials_iridescence";class $D{constructor(p){this.name=R_,this.order=195,this._loader=p,this.enabled=this._loader.isExtensionUsed(R_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),re.push(this._loadIridescencePropertiesAsync(I,Z,E)),Promise.all(re).then(()=>{})})}_loadIridescencePropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const I=new Array;return E.iridescence.isEnabled=!0,E.iridescence.intensity=_.iridescenceFactor??0,E.iridescence.indexOfRefraction=_.iridescenceIor??_.iridescenceIOR??1.3,E.iridescence.minimumThickness=_.iridescenceThicknessMinimum??100,E.iridescence.maximumThickness=_.iridescenceThicknessMaximum??400,_.iridescenceTexture&&I.push(this._loader.loadTextureInfoAsync(`${p}/iridescenceTexture`,_.iridescenceTexture,Z=>{Z.name=`${E.name} (Iridescence Intensity)`,E.iridescence.texture=Z})),_.iridescenceThicknessTexture&&I.push(this._loader.loadTextureInfoAsync(`${p}/iridescenceThicknessTexture`,_.iridescenceThicknessTexture,Z=>{Z.name=`${E.name} (Iridescence Thickness)`,E.iridescence.thicknessTexture=Z})),Promise.all(I).then(()=>{})}}js.RegisterExtension(R_,pe=>new $D(pe));const I_="KHR_materials_anisotropy";class rF{constructor(p){this.name=I_,this.order=195,this._loader=p,this.enabled=this._loader.isExtensionUsed(I_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),re.push(this._loadIridescencePropertiesAsync(I,Z,E)),Promise.all(re).then(()=>{})})}_loadIridescencePropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const I=new Array;return E.anisotropy.isEnabled=!0,E.anisotropy.intensity=_.anisotropyStrength??0,E.anisotropy.angle=_.anisotropyRotation??0,_.anisotropyTexture&&I.push(this._loader.loadTextureInfoAsync(`${p}/anisotropyTexture`,_.anisotropyTexture,Z=>{Z.name=`${E.name} (Anisotropy Intensity)`,E.anisotropy.texture=Z})),Promise.all(I).then(()=>{})}}js.RegisterExtension(I_,pe=>new rF(pe));const M_="KHR_materials_emissive_strength";class nF{constructor(p){this.name=M_,this.order=170,this._loader=p,this.enabled=this._loader.isExtensionUsed(M_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>this._loader.loadMaterialPropertiesAsync(p,_,E).then(()=>{this._loadEmissiveProperties(I,Z,E)}))}_loadEmissiveProperties(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);_.emissiveStrength!==void 0&&E.emissiveColor.scaleToRef(_.emissiveStrength,E.emissiveColor)}}js.RegisterExtension(M_,pe=>new nF(pe));const O_="KHR_materials_sheen";class aF{constructor(p){this.name=O_,this.order=190,this._loader=p,this.enabled=this._loader.isExtensionUsed(O_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),re.push(this._loadSheenPropertiesAsync(I,Z,E)),Promise.all(re).then(()=>{})})}_loadSheenPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const I=new Array;return E.sheen.isEnabled=!0,E.sheen.intensity=1,_.sheenColorFactor!=null?E.sheen.color=Rs.FromArray(_.sheenColorFactor):E.sheen.color=Rs.Black(),_.sheenColorTexture&&I.push(this._loader.loadTextureInfoAsync(`${p}/sheenColorTexture`,_.sheenColorTexture,Z=>{Z.name=`${E.name} (Sheen Color)`,E.sheen.texture=Z})),_.sheenRoughnessFactor!==void 0?E.sheen.roughness=_.sheenRoughnessFactor:E.sheen.roughness=0,_.sheenRoughnessTexture&&(_.sheenRoughnessTexture.nonColorData=!0,I.push(this._loader.loadTextureInfoAsync(`${p}/sheenRoughnessTexture`,_.sheenRoughnessTexture,Z=>{Z.name=`${E.name} (Sheen Roughness)`,E.sheen.textureRoughness=Z}))),E.sheen.albedoScaling=!0,E.sheen.useRoughnessFromMainTexture=!1,Promise.all(I).then(()=>{})}}js.RegisterExtension(O_,pe=>new aF(pe));const P_="KHR_materials_specular";class xF{constructor(p){this.name=P_,this.order=190,this._loader=p,this.enabled=this._loader.isExtensionUsed(P_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),re.push(this._loadSpecularPropertiesAsync(I,Z,E)),Promise.all(re).then(()=>{})})}_loadSpecularPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const I=new Array;return _.specularFactor!==void 0&&(E.metallicF0Factor=_.specularFactor),_.specularColorFactor!==void 0&&(E.metallicReflectanceColor=Rs.FromArray(_.specularColorFactor)),_.specularTexture&&(_.specularTexture.nonColorData=!0,I.push(this._loader.loadTextureInfoAsync(`${p}/specularTexture`,_.specularTexture,Z=>{Z.name=`${E.name} (Specular F0 Strength)`,E.metallicReflectanceTexture=Z,E.useOnlyMetallicFromMetallicReflectanceTexture=!0}))),_.specularColorTexture&&I.push(this._loader.loadTextureInfoAsync(`${p}/specularColorTexture`,_.specularColorTexture,Z=>{Z.name=`${E.name} (Specular F0 Color)`,E.reflectanceTexture=Z})),Promise.all(I).then(()=>{})}}js.RegisterExtension(P_,pe=>new xF(pe));const w_="KHR_materials_ior";class cg{constructor(p){this.name=w_,this.order=180,this._loader=p,this.enabled=this._loader.isExtensionUsed(w_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),re.push(this._loadIorPropertiesAsync(I,Z,E)),Promise.all(re).then(()=>{})})}_loadIorPropertiesAsync(p,_,E){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);return _.ior!==void 0?E.indexOfRefraction=_.ior:E.indexOfRefraction=cg._DEFAULT_IOR,Promise.resolve()}}cg._DEFAULT_IOR=1.5,js.RegisterExtension(w_,pe=>new cg(pe));const io="KHR_materials_variants";class rc{constructor(p){this.name=io,this._loader=p,this.enabled=this._loader.isExtensionUsed(io)}dispose(){this._loader=null}static GetAvailableVariants(p){const _=this._GetExtensionMetadata(p);return _?Object.keys(_.variants):[]}getAvailableVariants(p){return rc.GetAvailableVariants(p)}static SelectVariant(p,_){const E=this._GetExtensionMetadata(p);if(!E)throw new Error(`Cannot select variant on a glTF mesh that does not have the ${io} extension`);const I=Z=>{const re=E.variants[Z];if(re)for(const ae of re)ae.mesh.material=ae.material};if(_ instanceof Array)for(const Z of _)I(Z);else I(_);E.lastSelected=_}selectVariant(p,_){rc.SelectVariant(p,_)}static Reset(p){const _=this._GetExtensionMetadata(p);if(!_)throw new Error(`Cannot reset on a glTF mesh that does not have the ${io} extension`);for(const E of _.original)E.mesh.material=E.material;_.lastSelected=null}reset(p){rc.Reset(p)}static GetLastSelectedVariant(p){const _=this._GetExtensionMetadata(p);if(!_)throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${io} extension`);return _.lastSelected}getLastSelectedVariant(p){return rc.GetLastSelectedVariant(p)}static _GetExtensionMetadata(p){return p?._internalMetadata?.gltf?.[io]||null}onLoading(){const p=this._loader.gltf.extensions;if(p&&p[this.name]){const _=p[this.name];this._variants=_.variants}}_loadMeshPrimitiveAsync(p,_,E,I,Z,re){return js.LoadExtensionAsync(p,Z,this.name,(ae,he)=>{const _e=new Array;return _e.push(this._loader._loadMeshPrimitiveAsync(p,_,E,I,Z,ve=>{if(re(ve),ve instanceof vr){const Le=js._GetDrawMode(p,Z.mode),ze=this._loader.rootBabylonMesh,He=ze?ze._internalMetadata=ze._internalMetadata||{}:{},xt=He.gltf=He.gltf||{},rt=xt[io]=xt[io]||{lastSelected:null,original:[],variants:{}};rt.original.push({mesh:ve,material:ve.material});for(let Tt=0;Tt<he.mappings.length;++Tt){const Lt=he.mappings[Tt],Nt=kr.Get(`${ae}/mappings/${Tt}/material`,this._loader.gltf.materials,Lt.material);_e.push(this._loader._loadMaterialAsync(`#/materials/${Lt.material}`,Nt,ve,Le,qt=>{for(let Xt=0;Xt<Lt.variants.length;++Xt){const zt=Lt.variants[Xt],Gt=kr.Get(`/extensions/${io}/variants/${zt}`,this._variants,zt);rt.variants[Gt.name]=rt.variants[Gt.name]||[],rt.variants[Gt.name].push({mesh:ve,material:qt}),ve.onClonedObservable.add(xi=>{const Gi=xi;let vs=null,ks=Gi;do{if(ks=ks.parent,!ks)return;vs=rc._GetExtensionMetadata(ks)}while(vs===null);if(ze&&vs===rc._GetExtensionMetadata(ze)){ks._internalMetadata={};for(const Ur in ze._internalMetadata)ks._internalMetadata[Ur]=ze._internalMetadata[Ur];ks._internalMetadata.gltf=[];for(const Ur in ze._internalMetadata.gltf)ks._internalMetadata.gltf[Ur]=ze._internalMetadata.gltf[Ur];ks._internalMetadata.gltf[io]={lastSelected:null,original:[],variants:{}};for(const Ur of vs.original)ks._internalMetadata.gltf[io].original.push({mesh:Ur.mesh,material:Ur.material});for(const Ur in vs.variants)if(Object.prototype.hasOwnProperty.call(vs.variants,Ur)){ks._internalMetadata.gltf[io].variants[Ur]=[];for(const hn of vs.variants[Ur])ks._internalMetadata.gltf[io].variants[Ur].push({mesh:hn.mesh,material:hn.material})}vs=ks._internalMetadata.gltf[io]}for(const Ur of vs.original)Ur.mesh===ve&&(Ur.mesh=Gi);for(const Ur of vs.variants[Gt.name])Ur.mesh===ve&&(Ur.mesh=Gi)})}}))}}})),Promise.all(_e).then(([ve])=>ve)})}}js.RegisterExtension(io,pe=>new rc(pe));class Qt{}Qt.ALPHA_DISABLE=0,Qt.ALPHA_ADD=1,Qt.ALPHA_COMBINE=2,Qt.ALPHA_SUBTRACT=3,Qt.ALPHA_MULTIPLY=4,Qt.ALPHA_MAXIMIZED=5,Qt.ALPHA_ONEONE=6,Qt.ALPHA_PREMULTIPLIED=7,Qt.ALPHA_PREMULTIPLIED_PORTERDUFF=8,Qt.ALPHA_INTERPOLATE=9,Qt.ALPHA_SCREENMODE=10,Qt.ALPHA_ONEONE_ONEONE=11,Qt.ALPHA_ALPHATOCOLOR=12,Qt.ALPHA_REVERSEONEMINUS=13,Qt.ALPHA_SRC_DSTONEMINUSSRCALPHA=14,Qt.ALPHA_ONEONE_ONEZERO=15,Qt.ALPHA_EXCLUSION=16,Qt.ALPHA_LAYER_ACCUMULATE=17,Qt.ALPHA_EQUATION_ADD=0,Qt.ALPHA_EQUATION_SUBSTRACT=1,Qt.ALPHA_EQUATION_REVERSE_SUBTRACT=2,Qt.ALPHA_EQUATION_MAX=3,Qt.ALPHA_EQUATION_MIN=4,Qt.ALPHA_EQUATION_DARKEN=5,Qt.DELAYLOADSTATE_NONE=0,Qt.DELAYLOADSTATE_LOADED=1,Qt.DELAYLOADSTATE_LOADING=2,Qt.DELAYLOADSTATE_NOTLOADED=4,Qt.NEVER=512,Qt.ALWAYS=519,Qt.LESS=513,Qt.EQUAL=514,Qt.LEQUAL=515,Qt.GREATER=516,Qt.GEQUAL=518,Qt.NOTEQUAL=517,Qt.KEEP=7680,Qt.ZERO=0,Qt.REPLACE=7681,Qt.INCR=7682,Qt.DECR=7683,Qt.INVERT=5386,Qt.INCR_WRAP=34055,Qt.DECR_WRAP=34056,Qt.TEXTURE_CLAMP_ADDRESSMODE=0,Qt.TEXTURE_WRAP_ADDRESSMODE=1,Qt.TEXTURE_MIRROR_ADDRESSMODE=2,Qt.TEXTURE_CREATIONFLAG_STORAGE=1,Qt.TEXTUREFORMAT_ALPHA=0,Qt.TEXTUREFORMAT_LUMINANCE=1,Qt.TEXTUREFORMAT_LUMINANCE_ALPHA=2,Qt.TEXTUREFORMAT_RGB=4,Qt.TEXTUREFORMAT_RGBA=5,Qt.TEXTUREFORMAT_RED=6,Qt.TEXTUREFORMAT_R=6,Qt.TEXTUREFORMAT_RG=7,Qt.TEXTUREFORMAT_RED_INTEGER=8,Qt.TEXTUREFORMAT_R_INTEGER=8,Qt.TEXTUREFORMAT_RG_INTEGER=9,Qt.TEXTUREFORMAT_RGB_INTEGER=10,Qt.TEXTUREFORMAT_RGBA_INTEGER=11,Qt.TEXTUREFORMAT_BGRA=12,Qt.TEXTUREFORMAT_DEPTH24_STENCIL8=13,Qt.TEXTUREFORMAT_DEPTH32_FLOAT=14,Qt.TEXTUREFORMAT_DEPTH16=15,Qt.TEXTUREFORMAT_DEPTH24=16,Qt.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8=17,Qt.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8=18,Qt.TEXTUREFORMAT_STENCIL8=19,Qt.TEXTUREFORMAT_UNDEFINED=4294967295,Qt.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM=36492,Qt.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM=36493,Qt.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT=36495,Qt.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT=36494,Qt.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5=33779,Qt.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=35919,Qt.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3=33778,Qt.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT=35918,Qt.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1=33777,Qt.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1=33776,Qt.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=35917,Qt.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT=35916,Qt.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4=37808,Qt.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=37840,Qt.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL=36196,Qt.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2=37492,Qt.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2=37493,Qt.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2=37494,Qt.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2=37495,Qt.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC=37496,Qt.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=37497,Qt.TEXTURETYPE_UNSIGNED_BYTE=0,Qt.TEXTURETYPE_UNSIGNED_INT=0,Qt.TEXTURETYPE_FLOAT=1,Qt.TEXTURETYPE_HALF_FLOAT=2,Qt.TEXTURETYPE_BYTE=3,Qt.TEXTURETYPE_SHORT=4,Qt.TEXTURETYPE_UNSIGNED_SHORT=5,Qt.TEXTURETYPE_INT=6,Qt.TEXTURETYPE_UNSIGNED_INTEGER=7,Qt.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4=8,Qt.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1=9,Qt.TEXTURETYPE_UNSIGNED_SHORT_5_6_5=10,Qt.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV=11,Qt.TEXTURETYPE_UNSIGNED_INT_24_8=12,Qt.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV=13,Qt.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV=14,Qt.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV=15,Qt.TEXTURETYPE_UNDEFINED=16,Qt.TEXTURE_2D=3553,Qt.TEXTURE_2D_ARRAY=35866,Qt.TEXTURE_CUBE_MAP=34067,Qt.TEXTURE_CUBE_MAP_ARRAY=3735928559,Qt.TEXTURE_3D=32879,Qt.TEXTURE_NEAREST_SAMPLINGMODE=1,Qt.TEXTURE_NEAREST_NEAREST=1,Qt.TEXTURE_BILINEAR_SAMPLINGMODE=2,Qt.TEXTURE_LINEAR_LINEAR=2,Qt.TEXTURE_TRILINEAR_SAMPLINGMODE=3,Qt.TEXTURE_LINEAR_LINEAR_MIPLINEAR=3,Qt.TEXTURE_NEAREST_NEAREST_MIPNEAREST=4,Qt.TEXTURE_NEAREST_LINEAR_MIPNEAREST=5,Qt.TEXTURE_NEAREST_LINEAR_MIPLINEAR=6,Qt.TEXTURE_NEAREST_LINEAR=7,Qt.TEXTURE_NEAREST_NEAREST_MIPLINEAR=8,Qt.TEXTURE_LINEAR_NEAREST_MIPNEAREST=9,Qt.TEXTURE_LINEAR_NEAREST_MIPLINEAR=10,Qt.TEXTURE_LINEAR_LINEAR_MIPNEAREST=11,Qt.TEXTURE_LINEAR_NEAREST=12,Qt.TEXTURE_EXPLICIT_MODE=0,Qt.TEXTURE_SPHERICAL_MODE=1,Qt.TEXTURE_PLANAR_MODE=2,Qt.TEXTURE_CUBIC_MODE=3,Qt.TEXTURE_PROJECTION_MODE=4,Qt.TEXTURE_SKYBOX_MODE=5,Qt.TEXTURE_INVCUBIC_MODE=6,Qt.TEXTURE_EQUIRECTANGULAR_MODE=7,Qt.TEXTURE_FIXED_EQUIRECTANGULAR_MODE=8,Qt.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9,Qt.TEXTURE_FILTERING_QUALITY_OFFLINE=4096,Qt.TEXTURE_FILTERING_QUALITY_HIGH=64,Qt.TEXTURE_FILTERING_QUALITY_MEDIUM=16,Qt.TEXTURE_FILTERING_QUALITY_LOW=8,Qt.SCALEMODE_FLOOR=1,Qt.SCALEMODE_NEAREST=2,Qt.SCALEMODE_CEILING=3,Qt.MATERIAL_TextureDirtyFlag=1,Qt.MATERIAL_LightDirtyFlag=2,Qt.MATERIAL_FresnelDirtyFlag=4,Qt.MATERIAL_AttributesDirtyFlag=8,Qt.MATERIAL_MiscDirtyFlag=16,Qt.MATERIAL_PrePassDirtyFlag=32,Qt.MATERIAL_AllDirtyFlag=63,Qt.MATERIAL_TriangleFillMode=0,Qt.MATERIAL_WireFrameFillMode=1,Qt.MATERIAL_PointFillMode=2,Qt.MATERIAL_PointListDrawMode=3,Qt.MATERIAL_LineListDrawMode=4,Qt.MATERIAL_LineLoopDrawMode=5,Qt.MATERIAL_LineStripDrawMode=6,Qt.MATERIAL_TriangleStripDrawMode=7,Qt.MATERIAL_TriangleFanDrawMode=8,Qt.MATERIAL_ClockWiseSideOrientation=0,Qt.MATERIAL_CounterClockWiseSideOrientation=1,Qt.ACTION_NothingTrigger=0,Qt.ACTION_OnPickTrigger=1,Qt.ACTION_OnLeftPickTrigger=2,Qt.ACTION_OnRightPickTrigger=3,Qt.ACTION_OnCenterPickTrigger=4,Qt.ACTION_OnPickDownTrigger=5,Qt.ACTION_OnDoublePickTrigger=6,Qt.ACTION_OnPickUpTrigger=7,Qt.ACTION_OnPickOutTrigger=16,Qt.ACTION_OnLongPressTrigger=8,Qt.ACTION_OnPointerOverTrigger=9,Qt.ACTION_OnPointerOutTrigger=10,Qt.ACTION_OnEveryFrameTrigger=11,Qt.ACTION_OnIntersectionEnterTrigger=12,Qt.ACTION_OnIntersectionExitTrigger=13,Qt.ACTION_OnKeyDownTrigger=14,Qt.ACTION_OnKeyUpTrigger=15,Qt.PARTICLES_BILLBOARDMODE_Y=2,Qt.PARTICLES_BILLBOARDMODE_ALL=7,Qt.PARTICLES_BILLBOARDMODE_STRETCHED=8,Qt.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL=9,Qt.MESHES_CULLINGSTRATEGY_STANDARD=0,Qt.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY=1,Qt.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION=2,Qt.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY=3,Qt.SCENELOADER_NO_LOGGING=0,Qt.SCENELOADER_MINIMAL_LOGGING=1,Qt.SCENELOADER_SUMMARY_LOGGING=2,Qt.SCENELOADER_DETAILED_LOGGING=3,Qt.PREPASS_IRRADIANCE_TEXTURE_TYPE=0,Qt.PREPASS_POSITION_TEXTURE_TYPE=1,Qt.PREPASS_VELOCITY_TEXTURE_TYPE=2,Qt.PREPASS_REFLECTIVITY_TEXTURE_TYPE=3,Qt.PREPASS_COLOR_TEXTURE_TYPE=4,Qt.PREPASS_DEPTH_TEXTURE_TYPE=5,Qt.PREPASS_NORMAL_TEXTURE_TYPE=6,Qt.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE=7,Qt.BUFFER_CREATIONFLAG_READ=1,Qt.BUFFER_CREATIONFLAG_WRITE=2,Qt.BUFFER_CREATIONFLAG_READWRITE=3,Qt.BUFFER_CREATIONFLAG_UNIFORM=4,Qt.BUFFER_CREATIONFLAG_VERTEX=8,Qt.BUFFER_CREATIONFLAG_INDEX=16,Qt.BUFFER_CREATIONFLAG_STORAGE=32,Qt.RENDERPASS_MAIN=0,Qt.INPUT_ALT_KEY=18,Qt.INPUT_CTRL_KEY=17,Qt.INPUT_META_KEY1=91,Qt.INPUT_META_KEY2=92,Qt.INPUT_META_KEY3=93,Qt.INPUT_SHIFT_KEY=16,Qt.SNAPSHOTRENDERING_STANDARD=0,Qt.SNAPSHOTRENDERING_FAST=1,Qt.PERSPECTIVE_CAMERA=0,Qt.ORTHOGRAPHIC_CAMERA=1,Qt.FOVMODE_VERTICAL_FIXED=0,Qt.FOVMODE_HORIZONTAL_FIXED=1,Qt.RIG_MODE_NONE=0,Qt.RIG_MODE_STEREOSCOPIC_ANAGLYPH=10,Qt.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL=11,Qt.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED=12,Qt.RIG_MODE_STEREOSCOPIC_OVERUNDER=13,Qt.RIG_MODE_STEREOSCOPIC_INTERLACED=14,Qt.RIG_MODE_VR=20,Qt.RIG_MODE_CUSTOM=22,Qt.MAX_SUPPORTED_UV_SETS=6,Qt.GL_ALPHA_EQUATION_ADD=32774,Qt.GL_ALPHA_EQUATION_MIN=32775,Qt.GL_ALPHA_EQUATION_MAX=32776,Qt.GL_ALPHA_EQUATION_SUBTRACT=32778,Qt.GL_ALPHA_EQUATION_REVERSE_SUBTRACT=32779,Qt.GL_ALPHA_FUNCTION_SRC=768,Qt.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR=769,Qt.GL_ALPHA_FUNCTION_SRC_ALPHA=770,Qt.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA=771,Qt.GL_ALPHA_FUNCTION_DST_ALPHA=772,Qt.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA=773,Qt.GL_ALPHA_FUNCTION_DST_COLOR=774,Qt.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR=775,Qt.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED=776,Qt.GL_ALPHA_FUNCTION_CONSTANT_COLOR=32769,Qt.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR=32770,Qt.GL_ALPHA_FUNCTION_CONSTANT_ALPHA=32771,Qt.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA=32772,Qt.SnippetUrl="https://snippet.babylonjs.com";class N_{static _GetDefaultOptions(){return{renderSize:1024,samples:4,lodGenerationScale:1,lodGenerationOffset:-4,renderTargetTextureType:Qt.TEXTURETYPE_HALF_FLOAT,generateMipmaps:!0}}constructor(p,_){this._opaqueRenderTarget=null,this._opaqueMeshesCache=[],this._transparentMeshesCache=[],this._materialObservers={},this._options={...N_._GetDefaultOptions(),...p},this._scene=_,this._scene._transmissionHelper=this,this.onErrorObservable=new Ri,this._scene.onDisposeObservable.addOnce(()=>{this.dispose()}),this._parseScene(),this._setupRenderTargets()}updateOptions(p){if(!Object.keys(p).filter(Z=>this._options[Z]!==p[Z]).length)return;const E={...this._options,...p},I=this._options;this._options=E,E.renderSize!==I.renderSize||E.renderTargetTextureType!==I.renderTargetTextureType||E.generateMipmaps!==I.generateMipmaps||!this._opaqueRenderTarget?this._setupRenderTargets():(this._opaqueRenderTarget.samples=E.samples,this._opaqueRenderTarget.lodGenerationScale=E.lodGenerationScale,this._opaqueRenderTarget.lodGenerationOffset=E.lodGenerationOffset)}getOpaqueTarget(){return this._opaqueRenderTarget}_shouldRenderAsTransmission(p){return p?!!(p instanceof Ys&&p.subSurface.isRefractionEnabled):!1}_addMesh(p){this._materialObservers[p.uniqueId]=p.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this)),lt.SetImmediate(()=>{this._shouldRenderAsTransmission(p.material)?(p.material.refractionTexture=this._opaqueRenderTarget,this._transparentMeshesCache.indexOf(p)===-1&&this._transparentMeshesCache.push(p)):this._opaqueMeshesCache.indexOf(p)===-1&&this._opaqueMeshesCache.push(p)})}_removeMesh(p){p.onMaterialChangedObservable.remove(this._materialObservers[p.uniqueId]),delete this._materialObservers[p.uniqueId];let _=this._transparentMeshesCache.indexOf(p);_!==-1&&this._transparentMeshesCache.splice(_,1),_=this._opaqueMeshesCache.indexOf(p),_!==-1&&this._opaqueMeshesCache.splice(_,1)}_parseScene(){this._scene.meshes.forEach(this._addMesh.bind(this)),this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this)),this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this))}_onMeshMaterialChanged(p){const _=this._transparentMeshesCache.indexOf(p),E=this._opaqueMeshesCache.indexOf(p);this._shouldRenderAsTransmission(p.material)?(p.material instanceof Ys&&(p.material.subSurface.refractionTexture=this._opaqueRenderTarget),E!==-1?(this._opaqueMeshesCache.splice(E,1),this._transparentMeshesCache.push(p)):_===-1&&this._transparentMeshesCache.push(p)):_!==-1?(this._transparentMeshesCache.splice(_,1),this._opaqueMeshesCache.push(p)):E===-1&&this._opaqueMeshesCache.push(p)}_isRenderTargetValid(){return this._opaqueRenderTarget?.getInternalTexture()!==null}_setupRenderTargets(){this._opaqueRenderTarget&&this._opaqueRenderTarget.dispose(),this._opaqueRenderTarget=new z2("opaqueSceneTexture",this._options.renderSize,this._scene,this._options.generateMipmaps,void 0,this._options.renderTargetTextureType),this._opaqueRenderTarget.ignoreCameraViewport=!0,this._opaqueRenderTarget.renderList=this._opaqueMeshesCache,this._opaqueRenderTarget.clearColor=this._options.clearColor?.clone()??this._scene.clearColor.clone(),this._opaqueRenderTarget.gammaSpace=!1,this._opaqueRenderTarget.lodGenerationScale=this._options.lodGenerationScale,this._opaqueRenderTarget.lodGenerationOffset=this._options.lodGenerationOffset,this._opaqueRenderTarget.samples=this._options.samples,this._opaqueRenderTarget.renderSprites=!0,this._opaqueRenderTarget.renderParticles=!0;let p,_;this._opaqueRenderTarget.onBeforeBindObservable.add(E=>{_=this._scene.environmentIntensity,this._scene.environmentIntensity=1,p=this._scene.imageProcessingConfiguration.applyByPostProcess,this._options.clearColor?E.clearColor.copyFrom(this._options.clearColor):this._scene.clearColor.toLinearSpaceToRef(E.clearColor,this._scene.getEngine().useExactSrgbConversions),this._scene.imageProcessingConfiguration._applyByPostProcess=!0}),this._opaqueRenderTarget.onAfterUnbindObservable.add(()=>{this._scene.environmentIntensity=_,this._scene.imageProcessingConfiguration._applyByPostProcess=p}),this._transparentMeshesCache.forEach(E=>{this._shouldRenderAsTransmission(E.material)&&(E.material.refractionTexture=this._opaqueRenderTarget)})}dispose(){this._scene._transmissionHelper=void 0,this._opaqueRenderTarget&&(this._opaqueRenderTarget.dispose(),this._opaqueRenderTarget=null),this._transparentMeshesCache=[],this._opaqueMeshesCache=[]}}const D_="KHR_materials_transmission";class lF{constructor(p){this.name=D_,this.order=175,this._loader=p,this.enabled=this._loader.isExtensionUsed(D_),this.enabled&&(p.parent.transparencyAsCoverage=!0)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialBasePropertiesAsync(p,_,E)),re.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),re.push(this._loadTransparentPropertiesAsync(I,_,E,Z)),Promise.all(re).then(()=>{})})}_loadTransparentPropertiesAsync(p,_,E,I){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const Z=E;if(Z.subSurface.isRefractionEnabled=!0,Z.subSurface.volumeIndexOfRefraction=1,Z.subSurface.useAlbedoToTintRefraction=!0,I.transmissionFactor!==void 0){Z.subSurface.refractionIntensity=I.transmissionFactor;const re=Z.getScene();Z.subSurface.refractionIntensity&&!re._transmissionHelper?new N_({},Z.getScene()):Z.subSurface.refractionIntensity&&!re._transmissionHelper?._isRenderTargetValid()&&re._transmissionHelper?._setupRenderTargets()}else return Z.subSurface.refractionIntensity=0,Z.subSurface.isRefractionEnabled=!1,Promise.resolve();return Z.subSurface.minimumThickness=0,Z.subSurface.maximumThickness=0,I.transmissionTexture?(I.transmissionTexture.nonColorData=!0,this._loader.loadTextureInfoAsync(`${p}/transmissionTexture`,I.transmissionTexture,void 0).then(re=>{Z.subSurface.refractionIntensityTexture=re,Z.subSurface.useGltfStyleTextures=!0})):Promise.resolve()}}js.RegisterExtension(D_,pe=>new lF(pe));const F_="KHR_materials_translucency";class hF{constructor(p){this.name=F_,this.order=174,this._loader=p,this.enabled=this._loader.isExtensionUsed(F_),this.enabled&&(p.parent.transparencyAsCoverage=!0)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialBasePropertiesAsync(p,_,E)),re.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),re.push(this._loadTranslucentPropertiesAsync(I,_,E,Z)),Promise.all(re).then(()=>{})})}_loadTranslucentPropertiesAsync(p,_,E,I){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);const Z=E;if(Z.subSurface.isTranslucencyEnabled=!0,Z.subSurface.volumeIndexOfRefraction=1,Z.subSurface.minimumThickness=0,Z.subSurface.maximumThickness=0,Z.subSurface.useAlbedoToTintTranslucency=!0,I.translucencyFactor!==void 0)Z.subSurface.translucencyIntensity=I.translucencyFactor;else return Z.subSurface.translucencyIntensity=0,Z.subSurface.isTranslucencyEnabled=!1,Promise.resolve();return I.translucencyTexture?(I.translucencyTexture.nonColorData=!0,this._loader.loadTextureInfoAsync(`${p}/translucencyTexture`,I.translucencyTexture).then(re=>{Z.subSurface.translucencyIntensityTexture=re})):Promise.resolve()}}js.RegisterExtension(F_,pe=>new hF(pe));const L_="KHR_materials_volume";class cF{constructor(p){this.name=L_,this.order=173,this._loader=p,this.enabled=this._loader.isExtensionUsed(L_),this.enabled&&this._loader._disableInstancedMesh++}dispose(){this.enabled&&this._loader._disableInstancedMesh--,this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialBasePropertiesAsync(p,_,E)),re.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),re.push(this._loadVolumePropertiesAsync(I,_,E,Z)),Promise.all(re).then(()=>{})})}_loadVolumePropertiesAsync(p,_,E,I){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);if(!E.subSurface.isRefractionEnabled&&!E.subSurface.isTranslucencyEnabled||!I.thicknessFactor)return Promise.resolve();E.subSurface.volumeIndexOfRefraction=E.indexOfRefraction;const Z=I.attenuationDistance!==void 0?I.attenuationDistance:Number.MAX_VALUE;return E.subSurface.tintColorAtDistance=Z,I.attenuationColor!==void 0&&I.attenuationColor.length==3&&E.subSurface.tintColor.copyFromFloats(I.attenuationColor[0],I.attenuationColor[1],I.attenuationColor[2]),E.subSurface.minimumThickness=0,E.subSurface.maximumThickness=I.thicknessFactor,E.subSurface.useThicknessAsDepth=!0,I.thicknessTexture?(I.thicknessTexture.nonColorData=!0,this._loader.loadTextureInfoAsync(`${p}/thicknessTexture`,I.thicknessTexture).then(re=>{E.subSurface.thicknessTexture=re,E.subSurface.useGltfStyleTextures=!0})):Promise.resolve()}}js.RegisterExtension(L_,pe=>new cF(pe));const B_="KHR_materials_dispersion";class uF{constructor(p){this.name=B_,this.order=174,this._loader=p,this.enabled=this._loader.isExtensionUsed(B_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return re.push(this._loader.loadMaterialBasePropertiesAsync(p,_,E)),re.push(this._loader.loadMaterialPropertiesAsync(p,_,E)),re.push(this._loadDispersionPropertiesAsync(I,_,E,Z)),Promise.all(re).then(()=>{})})}_loadDispersionPropertiesAsync(p,_,E,I){if(!(E instanceof Ys))throw new Error(`${p}: Material type not supported`);return!E.subSurface.isRefractionEnabled||!I.dispersion||(E.subSurface.isDispersionEnabled=!0,E.subSurface.dispersion=I.dispersion),Promise.resolve()}}js.RegisterExtension(B_,pe=>new uF(pe));const k_="KHR_mesh_quantization";class pF{constructor(p){this.name=k_,this.enabled=p.isExtensionUsed(k_)}dispose(){}}js.RegisterExtension(k_,pe=>new pF(pe));const U_="KHR_texture_basisu";class _F{constructor(p){this.name=U_,this._loader=p,this.enabled=p.isExtensionUsed(U_)}dispose(){this._loader=null}_loadTextureAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=_.sampler==null?js.DefaultSampler:kr.Get(`${p}/sampler`,this._loader.gltf.samplers,_.sampler),ae=kr.Get(`${I}/source`,this._loader.gltf.images,Z.source);return this._loader._createTextureAsync(p,re,ae,he=>{E(he)},_._textureInfo.nonColorData?{useRGBAIfASTCBC7NotAvailableWhenUASTC:!0}:void 0,!_._textureInfo.nonColorData)})}}js.RegisterExtension(U_,pe=>new _F(pe));const V_="KHR_texture_transform";class TF{constructor(p){this.name=V_,this._loader=p,this.enabled=this._loader.isExtensionUsed(V_)}dispose(){this._loader=null}loadTextureInfoAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>this._loader.loadTextureInfoAsync(p,_,re=>{if(!(re instanceof Ki))throw new Error(`${I}: Texture type not supported`);Z.offset&&(re.uOffset=Z.offset[0],re.vOffset=Z.offset[1]),re.uRotationCenter=0,re.vRotationCenter=0,Z.rotation&&(re.wAng=-Z.rotation),Z.scale&&(re.uScale=Z.scale[0],re.vScale=Z.scale[1]),Z.texCoord!=null&&(re.coordinatesIndex=Z.texCoord),E(re)}))}}js.RegisterExtension(V_,pe=>new TF(pe));const G_="KHR_xmp_json_ld";class vF{constructor(p){this.name=G_,this.order=100,this._loader=p,this.enabled=this._loader.isExtensionUsed(G_)}dispose(){this._loader=null}onLoading(){if(this._loader.rootBabylonMesh===null)return;const p=this._loader.gltf.extensions?.KHR_xmp_json_ld,_=this._loader.gltf.asset?.extensions?.KHR_xmp_json_ld;if(p&&_){const E=+_.packet;p.packets&&E<p.packets.length&&(this._loader.rootBabylonMesh.metadata=this._loader.rootBabylonMesh.metadata||{},this._loader.rootBabylonMesh.metadata.xmp=p.packets[E])}}}js.RegisterExtension(G_,pe=>new vF(pe));function Wu(pe,p,_,E){return Rs.FromArray(p,_).scale(E)}function RF(pe,p,_,E){return p[_+3]*E}function La(pe,p,_,E){return p[_]*E}function z_(pe,p,_,E){return-p[_]*E}function ug(pe,p,_,E){return p[_+1]*E}function rM(pe,p,_,E){return p[_]*E*2}function W_(pe){return{scale:[new pa(Li.ANIMATIONTYPE_FLOAT,`${pe}.uScale`,La,()=>2),new pa(Li.ANIMATIONTYPE_FLOAT,`${pe}.vScale`,ug,()=>2)],offset:[new pa(Li.ANIMATIONTYPE_FLOAT,`${pe}.uOffset`,La,()=>2),new pa(Li.ANIMATIONTYPE_FLOAT,`${pe}.vOffset`,ug,()=>2)],rotation:[new pa(Li.ANIMATIONTYPE_FLOAT,`${pe}.wAng`,z_,()=>1)]}}class hh extends rm{buildAnimations(p,_,E,I,Z){Z(p._babylonCamera,this._buildAnimation(_,E,I))}}class pa extends rm{buildAnimations(p,_,E,I,Z){for(const re in p._data)Z(p._data[re].babylonMaterial,this._buildAnimation(_,E,I))}}class am extends rm{buildAnimations(p,_,E,I,Z){Z(p._babylonLight,this._buildAnimation(_,E,I))}}const MF={__array__:{__target__:!0,...nm}},wF={__array__:{__target__:!0,orthographic:{xmag:[new hh(Li.ANIMATIONTYPE_FLOAT,"orthoLeft",z_,()=>1),new hh(Li.ANIMATIONTYPE_FLOAT,"orthoRight",ug,()=>1)],ymag:[new hh(Li.ANIMATIONTYPE_FLOAT,"orthoBottom",z_,()=>1),new hh(Li.ANIMATIONTYPE_FLOAT,"orthoTop",ug,()=>1)],zfar:[new hh(Li.ANIMATIONTYPE_FLOAT,"maxZ",La,()=>1)],znear:[new hh(Li.ANIMATIONTYPE_FLOAT,"minZ",La,()=>1)]},perspective:{yfov:[new hh(Li.ANIMATIONTYPE_FLOAT,"fov",La,()=>1)],zfar:[new hh(Li.ANIMATIONTYPE_FLOAT,"maxZ",La,()=>1)],znear:[new hh(Li.ANIMATIONTYPE_FLOAT,"minZ",La,()=>1)]}}},LF={__array__:{__target__:!0,pbrMetallicRoughness:{baseColorFactor:[new pa(Li.ANIMATIONTYPE_COLOR3,"albedoColor",Wu,()=>4),new pa(Li.ANIMATIONTYPE_FLOAT,"alpha",RF,()=>4)],metallicFactor:[new pa(Li.ANIMATIONTYPE_FLOAT,"metallic",La,()=>1)],roughnessFactor:[new pa(Li.ANIMATIONTYPE_FLOAT,"roughness",La,()=>1)],baseColorTexture:{extensions:{KHR_texture_transform:W_("albedoTexture")}}},emissiveFactor:[new pa(Li.ANIMATIONTYPE_COLOR3,"emissiveColor",Wu,()=>3)],normalTexture:{scale:[new pa(Li.ANIMATIONTYPE_FLOAT,"bumpTexture.level",La,()=>1)]},occlusionTexture:{strength:[new pa(Li.ANIMATIONTYPE_FLOAT,"ambientTextureStrength",La,()=>1)],extensions:{KHR_texture_transform:W_("ambientTexture")}},emissiveTexture:{extensions:{KHR_texture_transform:W_("emissiveTexture")}},extensions:{KHR_materials_ior:{ior:[new pa(Li.ANIMATIONTYPE_FLOAT,"indexOfRefraction",La,()=>1)]},KHR_materials_clearcoat:{clearcoatFactor:[new pa(Li.ANIMATIONTYPE_FLOAT,"clearCoat.intensity",La,()=>1)],clearcoatRoughnessFactor:[new pa(Li.ANIMATIONTYPE_FLOAT,"clearCoat.roughness",La,()=>1)]},KHR_materials_sheen:{sheenColorFactor:[new pa(Li.ANIMATIONTYPE_COLOR3,"sheen.color",Wu,()=>3)],sheenRoughnessFactor:[new pa(Li.ANIMATIONTYPE_FLOAT,"sheen.roughness",La,()=>1)]},KHR_materials_specular:{specularFactor:[new pa(Li.ANIMATIONTYPE_FLOAT,"metallicF0Factor",La,()=>1)],specularColorFactor:[new pa(Li.ANIMATIONTYPE_COLOR3,"metallicReflectanceColor",Wu,()=>3)]},KHR_materials_emissive_strength:{emissiveStrength:[new pa(Li.ANIMATIONTYPE_FLOAT,"emissiveIntensity",La,()=>1)]},KHR_materials_transmission:{transmissionFactor:[new pa(Li.ANIMATIONTYPE_FLOAT,"subSurface.refractionIntensity",La,()=>1)]},KHR_materials_volume:{attenuationColor:[new pa(Li.ANIMATIONTYPE_COLOR3,"subSurface.tintColor",Wu,()=>3)],attenuationDistance:[new pa(Li.ANIMATIONTYPE_FLOAT,"subSurface.tintColorAtDistance",La,()=>1)],thicknessFactor:[new pa(Li.ANIMATIONTYPE_FLOAT,"subSurface.maximumThickness",La,()=>1)]},KHR_materials_dispersion:{dispersion:[new pa(Li.ANIMATIONTYPE_FLOAT,"subSurface.dispersion",La,()=>1)]},KHR_materials_iridescence:{iridescenceFactor:[new pa(Li.ANIMATIONTYPE_FLOAT,"iridescence.intensity",La,()=>1)],iridescenceIor:[new pa(Li.ANIMATIONTYPE_FLOAT,"iridescence.indexOfRefraction",La,()=>1)],iridescenceThicknessMinimum:[new pa(Li.ANIMATIONTYPE_FLOAT,"iridescence.minimumThickness",La,()=>1)],iridescenceThicknessMaximum:[new pa(Li.ANIMATIONTYPE_FLOAT,"iridescence.maximumThickness",La,()=>1)]},KHR_materials_anisotropy:{anisotropyStrength:[new pa(Li.ANIMATIONTYPE_FLOAT,"anisotropy.intensity",La,()=>1)],anisotropyRotation:[new pa(Li.ANIMATIONTYPE_FLOAT,"anisotropy.angle",La,()=>1)]}}}},kF={KHR_lights_punctual:{lights:{__array__:{__target__:!0,color:[new am(Li.ANIMATIONTYPE_COLOR3,"diffuse",Wu,()=>3)],intensity:[new am(Li.ANIMATIONTYPE_FLOAT,"intensity",La,()=>1)],range:[new am(Li.ANIMATIONTYPE_FLOAT,"range",La,()=>1)],spot:{innerConeAngle:[new am(Li.ANIMATIONTYPE_FLOAT,"innerAngle",rM,()=>1)],outerConeAngle:[new am(Li.ANIMATIONTYPE_FLOAT,"angle",rM,()=>1)]}}}}},UF={nodes:MF,materials:LF,cameras:wF,extensions:kF};class nM{constructor(p,_){this._gltf=p,this._infoTree=_}convert(p){let _=this._gltf,E=this._infoTree,I;if(!p.startsWith("/"))throw new Error("Path must start with a /");const Z=p.split("/");Z.shift();for(const re of Z){if(E.__array__)E=E.__array__;else if(E=E[re],!E)throw new Error(`Path ${p} is invalid`);if(_===void 0)throw new Error(`Path ${p} is invalid`);_=_[re],E.__target__&&(I=_)}return{object:I,info:E}}}const H_="KHR_animation_pointer";class GF extends nM{constructor(p){super(p,UF)}}class zF{constructor(p){this.name=H_,this._loader=p,this._pathToObjectConverter=new GF(this._loader.gltf)}get enabled(){return this._loader.isExtensionUsed(H_)}dispose(){this._loader=null,delete this._pathToObjectConverter}_loadAnimationChannelAsync(p,_,E,I,Z){const re=I.target.extensions?.KHR_animation_pointer;if(!re||!this._pathToObjectConverter)return null;I.target.path!=="pointer"&&Ti.Warn(`${p}/target/path: Value (${I.target.path}) must be (pointer) when using the ${this.name} extension`),I.target.node!=null&&Ti.Warn(`${p}/target/node: Value (${I.target.node}) must not be present when using the ${this.name} extension`);const ae=`${p}/extensions/${this.name}`,he=re.pointer;if(!he)throw new Error(`${ae}: Pointer is missing`);try{const _e=this._pathToObjectConverter.convert(he);return this._loader._loadAnimationChannelFromTargetInfoAsync(p,_,E,I,_e,Z)}catch{return Ti.Warn(`${ae}/pointer: Invalid pointer (${he}) skipped`),null}}}js.RegisterExtension(H_,pe=>new zF(pe));class X_{constructor(p,_,E){this.frame=p,this.action=_,this.onlyOnce=E,this.isDone=!1}_clone(){return new X_(this.frame,this.action,this.onlyOnce)}}class jc{get loop(){return this._loop}set loop(p){p!==this._loop&&(this._loop=p,this.updateOptions({loop:p}))}get currentTime(){if(this._htmlAudioElement)return this._htmlAudioElement.currentTime;if(ci.audioEngine?.audioContext&&(this.isPlaying||this.isPaused)){const p=this.isPaused?0:ci.audioEngine.audioContext.currentTime-this._startTime;return this._currentTime+p}return 0}get spatialSound(){return this._spatialSound}set spatialSound(p){if(p==this._spatialSound)return;const _=this.isPlaying;this.pause(),p?(this._spatialSound=p,this._updateSpatialParameters()):this._disableSpatialSound(),_&&this.play()}constructor(p,_,E,I=null,Z){if(this.autoplay=!1,this._loop=!1,this.useCustomAttenuation=!1,this.isPlaying=!1,this.isPaused=!1,this.refDistance=1,this.rolloffFactor=1,this.maxDistance=100,this.distanceModel="linear",this.metadata=null,this.onEndedObservable=new Ri,this._spatialSound=!1,this._panningModel="equalpower",this._playbackRate=1,this._streaming=!1,this._startTime=0,this._currentTime=0,this._position=at.Zero(),this._localDirection=new at(1,0,0),this._volume=1,this._isReadyToPlay=!1,this._isDirectional=!1,this._coneInnerAngle=360,this._coneOuterAngle=360,this._coneOuterGain=0,this._isOutputConnected=!1,this._urlType="Unknown",this.name=p,E=E||Mr.LastCreatedScene,!!E)if(this._scene=E,jc._SceneComponentInitialization(E),this._readyToPlayCallback=I,this._customAttenuationFunction=(re,ae,he,_e,ve)=>ae<he?re*(1-ae/he):0,Z&&(this.autoplay=Z.autoplay||!1,this._loop=Z.loop||!1,Z.volume!==void 0&&(this._volume=Z.volume),this._spatialSound=Z.spatialSound??!1,this.maxDistance=Z.maxDistance??100,this.useCustomAttenuation=Z.useCustomAttenuation??!1,this.rolloffFactor=Z.rolloffFactor||1,this.refDistance=Z.refDistance||1,this.distanceModel=Z.distanceModel||"linear",this._playbackRate=Z.playbackRate||1,this._streaming=Z.streaming??!1,this._length=Z.length,this._offset=Z.offset),ci.audioEngine?.canUseWebAudio&&ci.audioEngine.audioContext){this._soundGain=ci.audioEngine.audioContext.createGain(),this._soundGain.gain.value=this._volume,this._inputAudioNode=this._soundGain,this._outputAudioNode=this._soundGain,this._spatialSound&&this._createSpatialParameters(),this._scene.mainSoundTrack.addSound(this);let re=!0;if(_)try{typeof _=="string"?(this._urlType="String",this._url=_):_ instanceof ArrayBuffer?this._urlType="ArrayBuffer":_ instanceof HTMLMediaElement?this._urlType="MediaElement":_ instanceof MediaStream?this._urlType="MediaStream":_ instanceof AudioBuffer?this._urlType="AudioBuffer":Array.isArray(_)&&(this._urlType="Array");let ae=[],he=!1;switch(this._urlType){case"MediaElement":this._streaming=!0,this._isReadyToPlay=!0,this._streamingSource=ci.audioEngine.audioContext.createMediaElementSource(_),this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback();break;case"MediaStream":this._streaming=!0,this._isReadyToPlay=!0,this._streamingSource=ci.audioEngine.audioContext.createMediaStreamSource(_),this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback();break;case"ArrayBuffer":_.byteLength>0&&(he=!0,this._soundLoaded(_));break;case"AudioBuffer":this._audioBufferLoaded(_);break;case"String":ae.push(_);case"Array":ae.length===0&&(ae=_);for(let _e=0;_e<ae.length;_e++){const ve=ae[_e];if(he=Z&&Z.skipCodecCheck||ve.indexOf(".mp3",ve.length-4)!==-1&&ci.audioEngine.isMP3supported||ve.indexOf(".ogg",ve.length-4)!==-1&&ci.audioEngine.isOGGsupported||ve.indexOf(".wav",ve.length-4)!==-1||ve.indexOf(".m4a",ve.length-4)!==-1||ve.indexOf(".mp4",ve.length-4)!==-1||ve.indexOf("blob:")!==-1,he){this._streaming?(this._htmlAudioElement=new Audio(ve),this._htmlAudioElement.controls=!1,this._htmlAudioElement.loop=this.loop,lt.SetCorsBehavior(ve,this._htmlAudioElement),this._htmlAudioElement.preload="auto",this._htmlAudioElement.addEventListener("canplaythrough",()=>{this._isReadyToPlay=!0,this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback()}),document.body.appendChild(this._htmlAudioElement),this._htmlAudioElement.load()):this._scene._loadFile(ve,Le=>{this._soundLoaded(Le)},void 0,!0,!0,Le=>{Le&&Ti.Error("XHR "+Le.status+" error on: "+ve+"."),Ti.Error("Sound creation aborted."),this._scene.mainSoundTrack.removeSound(this)});break}}break;default:re=!1;break}re?he||(this._isReadyToPlay=!0,this._readyToPlayCallback&&setTimeout(()=>{this._readyToPlayCallback&&this._readyToPlayCallback()},1e3)):Ti.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.")}catch{Ti.Error("Unexpected error. Sound creation aborted."),this._scene.mainSoundTrack.removeSound(this)}}else this._scene.mainSoundTrack.addSound(this),ci.audioEngine&&!ci.audioEngine.WarnedWebAudioUnsupported&&(Ti.Error("Web Audio is not supported by your browser."),ci.audioEngine.WarnedWebAudioUnsupported=!0),this._readyToPlayCallback&&setTimeout(()=>{this._readyToPlayCallback&&this._readyToPlayCallback()},1e3)}dispose(){ci.audioEngine?.canUseWebAudio&&(this.isPlaying&&this.stop(),this._isReadyToPlay=!1,this.soundTrackId===-1?this._scene.mainSoundTrack.removeSound(this):this._scene.soundTracks&&this._scene.soundTracks[this.soundTrackId].removeSound(this),this._soundGain&&(this._soundGain.disconnect(),this._soundGain=null),this._soundPanner&&(this._soundPanner.disconnect(),this._soundPanner=null),this._soundSource&&(this._soundSource.disconnect(),this._soundSource=null),this._audioBuffer=null,this._htmlAudioElement&&(this._htmlAudioElement.pause(),this._htmlAudioElement.src="",document.body.removeChild(this._htmlAudioElement)),this._streamingSource&&this._streamingSource.disconnect(),this._connectedTransformNode&&this._registerFunc&&(this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc),this._connectedTransformNode=null),this._clearTimeoutsAndObservers())}isReady(){return this._isReadyToPlay}getClassName(){return"Sound"}_audioBufferLoaded(p){ci.audioEngine?.audioContext&&(this._audioBuffer=p,this._isReadyToPlay=!0,this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback())}_soundLoaded(p){ci.audioEngine?.audioContext&&ci.audioEngine.audioContext.decodeAudioData(p,_=>{this._audioBufferLoaded(_)},_=>{Ti.Error("Error while decoding audio data for: "+this.name+" / Error: "+_)})}setAudioBuffer(p){ci.audioEngine?.canUseWebAudio&&(this._audioBuffer=p,this._isReadyToPlay=!0)}updateOptions(p){p&&(this.loop=p.loop??this.loop,this.maxDistance=p.maxDistance??this.maxDistance,this.useCustomAttenuation=p.useCustomAttenuation??this.useCustomAttenuation,this.rolloffFactor=p.rolloffFactor??this.rolloffFactor,this.refDistance=p.refDistance??this.refDistance,this.distanceModel=p.distanceModel??this.distanceModel,this._playbackRate=p.playbackRate??this._playbackRate,this._length=p.length??void 0,this.spatialSound=p.spatialSound??this._spatialSound,this._setOffset(p.offset??void 0),this.setVolume(p.volume??this._volume),this._updateSpatialParameters(),this.isPlaying&&(this._streaming&&this._htmlAudioElement?(this._htmlAudioElement.playbackRate=this._playbackRate,this._htmlAudioElement.loop!==this.loop&&(this._htmlAudioElement.loop=this.loop)):this._soundSource&&(this._soundSource.playbackRate.value=this._playbackRate,this._soundSource.loop!==this.loop&&(this._soundSource.loop=this.loop),this._offset!==void 0&&this._soundSource.loopStart!==this._offset&&(this._soundSource.loopStart=this._offset),this._length!==void 0&&this._length!==this._soundSource.loopEnd&&(this._soundSource.loopEnd=(this._offset|0)+this._length))))}_createSpatialParameters(){ci.audioEngine?.canUseWebAudio&&ci.audioEngine.audioContext&&(this._scene.headphone&&(this._panningModel="HRTF"),this._soundPanner=this._soundPanner??ci.audioEngine.audioContext.createPanner(),this._soundPanner&&this._outputAudioNode&&(this._updateSpatialParameters(),this._soundPanner.connect(this._outputAudioNode),this._inputAudioNode=this._soundPanner))}_disableSpatialSound(){this._spatialSound&&(this._inputAudioNode=this._soundGain,this._soundPanner?.disconnect(),this._soundPanner=null,this._spatialSound=!1)}_updateSpatialParameters(){this._spatialSound&&(this._soundPanner?this.useCustomAttenuation?(this._soundPanner.distanceModel="linear",this._soundPanner.maxDistance=Number.MAX_VALUE,this._soundPanner.refDistance=1,this._soundPanner.rolloffFactor=1,this._soundPanner.panningModel=this._panningModel):(this._soundPanner.distanceModel=this.distanceModel,this._soundPanner.maxDistance=this.maxDistance,this._soundPanner.refDistance=this.refDistance,this._soundPanner.rolloffFactor=this.rolloffFactor,this._soundPanner.panningModel=this._panningModel):this._createSpatialParameters())}switchPanningModelToHRTF(){this._panningModel="HRTF",this._switchPanningModel()}switchPanningModelToEqualPower(){this._panningModel="equalpower",this._switchPanningModel()}_switchPanningModel(){ci.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&(this._soundPanner.panningModel=this._panningModel)}connectToSoundTrackAudioNode(p){ci.audioEngine?.canUseWebAudio&&this._outputAudioNode&&(this._isOutputConnected&&this._outputAudioNode.disconnect(),this._outputAudioNode.connect(p),this._isOutputConnected=!0)}setDirectionalCone(p,_,E){if(_<p){Ti.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=p,this._coneOuterAngle=_,this._coneOuterGain=E,this._isDirectional=!0,this.isPlaying&&this.loop&&(this.stop(),this.play(0,this._offset,this._length))}get directionalConeInnerAngle(){return this._coneInnerAngle}set directionalConeInnerAngle(p){if(p!=this._coneInnerAngle){if(this._coneOuterAngle<p){Ti.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=p,ci.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&(this._soundPanner.coneInnerAngle=this._coneInnerAngle)}}get directionalConeOuterAngle(){return this._coneOuterAngle}set directionalConeOuterAngle(p){if(p!=this._coneOuterAngle){if(p<this._coneInnerAngle){Ti.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneOuterAngle=p,ci.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&(this._soundPanner.coneOuterAngle=this._coneOuterAngle)}}setPosition(p){p.equals(this._position)||(this._position.copyFrom(p),ci.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&!isNaN(this._position.x)&&!isNaN(this._position.y)&&!isNaN(this._position.z)&&(this._soundPanner.positionX.value=this._position.x,this._soundPanner.positionY.value=this._position.y,this._soundPanner.positionZ.value=this._position.z))}setLocalDirectionToMesh(p){this._localDirection=p,ci.audioEngine?.canUseWebAudio&&this._connectedTransformNode&&this.isPlaying&&this._updateDirection()}_updateDirection(){if(!this._connectedTransformNode||!this._soundPanner)return;const p=this._connectedTransformNode.getWorldMatrix(),_=at.TransformNormal(this._localDirection,p);_.normalize(),this._soundPanner.orientationX.value=_.x,this._soundPanner.orientationY.value=_.y,this._soundPanner.orientationZ.value=_.z}updateDistanceFromListener(){if(ci.audioEngine?.canUseWebAudio&&this._connectedTransformNode&&this.useCustomAttenuation&&this._soundGain&&this._scene.activeCamera){const p=this._scene.audioListenerPositionProvider?this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length():this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);this._soundGain.gain.value=this._customAttenuationFunction(this._volume,p,this.maxDistance,this.refDistance,this.rolloffFactor)}}setAttenuationFunction(p){this._customAttenuationFunction=p}play(p,_,E){if(this._isReadyToPlay&&this._scene.audioEnabled&&ci.audioEngine?.audioContext)try{this._clearTimeoutsAndObservers();let I=p?ci.audioEngine?.audioContext.currentTime+p:ci.audioEngine?.audioContext.currentTime;if((!this._soundSource||!this._streamingSource)&&this._spatialSound&&this._soundPanner&&(!isNaN(this._position.x)&&!isNaN(this._position.y)&&!isNaN(this._position.z)&&(this._soundPanner.positionX.value=this._position.x,this._soundPanner.positionY.value=this._position.y,this._soundPanner.positionZ.value=this._position.z),this._isDirectional&&(this._soundPanner.coneInnerAngle=this._coneInnerAngle,this._soundPanner.coneOuterAngle=this._coneOuterAngle,this._soundPanner.coneOuterGain=this._coneOuterGain,this._connectedTransformNode?this._updateDirection():this._soundPanner.setOrientation(this._localDirection.x,this._localDirection.y,this._localDirection.z))),this._streaming){if(this._streamingSource||(this._streamingSource=ci.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement),this._htmlAudioElement.onended=()=>{this._onended()},this._htmlAudioElement.playbackRate=this._playbackRate),this._streamingSource.disconnect(),this._inputAudioNode&&this._streamingSource.connect(this._inputAudioNode),this._htmlAudioElement){const Z=()=>{if(ci.audioEngine?.unlocked){const re=this._htmlAudioElement.play();re!==void 0&&re.catch(()=>{ci.audioEngine?.lock(),(this.loop||this.autoplay)&&(this._audioUnlockedObserver=ci.audioEngine?.onAudioUnlockedObservable.addOnce(()=>{Z()}))})}else(this.loop||this.autoplay)&&(this._audioUnlockedObserver=ci.audioEngine?.onAudioUnlockedObservable.addOnce(()=>{Z()}))};Z()}}else{const Z=()=>{if(ci.audioEngine?.audioContext){if(E=E||this._length,_!==void 0&&this._setOffset(_),this._soundSource){const re=this._soundSource;re.onended=()=>{re.disconnect()}}if(this._soundSource=ci.audioEngine?.audioContext.createBufferSource(),this._soundSource&&this._inputAudioNode){this._soundSource.buffer=this._audioBuffer,this._soundSource.connect(this._inputAudioNode),this._soundSource.loop=this.loop,_!==void 0&&(this._soundSource.loopStart=_),E!==void 0&&(this._soundSource.loopEnd=(_|0)+E),this._soundSource.playbackRate.value=this._playbackRate,this._soundSource.onended=()=>{this._onended()},I=p?ci.audioEngine?.audioContext.currentTime+p:ci.audioEngine.audioContext.currentTime;const re=((this.isPaused?this.currentTime:0)+(this._offset??0))%this._soundSource.buffer.duration;this._soundSource.start(I,re,this.loop?void 0:E)}}};ci.audioEngine?.audioContext.state==="suspended"?this._tryToPlayTimeout=setTimeout(()=>{ci.audioEngine?.audioContext.state==="suspended"?(ci.audioEngine.lock(),(this.loop||this.autoplay)&&(this._audioUnlockedObserver=ci.audioEngine.onAudioUnlockedObservable.addOnce(()=>{Z()}))):Z()},500):Z()}this._startTime=I,this.isPlaying=!0,this.isPaused=!1}catch(I){Ti.Error("Error while trying to play audio: "+this.name+", "+I.message)}}_onended(){this.isPlaying=!1,this._startTime=0,this._currentTime=0,this.onended&&this.onended(),this.onEndedObservable.notifyObservers(this)}stop(p){if(this.isPlaying)if(this._clearTimeoutsAndObservers(),this._streaming)this._htmlAudioElement?(this._htmlAudioElement.pause(),this._htmlAudioElement.currentTime>0&&(this._htmlAudioElement.currentTime=0)):this._streamingSource.disconnect(),this.isPlaying=!1;else if(ci.audioEngine?.audioContext&&this._soundSource){const _=p?ci.audioEngine.audioContext.currentTime+p:void 0;this._soundSource.onended=()=>{this.isPlaying=!1,this.isPaused=!1,this._startTime=0,this._currentTime=0,this._soundSource&&(this._soundSource.onended=()=>{}),this._onended()},this._soundSource.stop(_)}else this.isPlaying=!1;else this.isPaused&&(this.isPaused=!1,this._startTime=0,this._currentTime=0)}pause(){this.isPlaying&&(this._clearTimeoutsAndObservers(),this._streaming?(this._htmlAudioElement?this._htmlAudioElement.pause():this._streamingSource.disconnect(),this.isPlaying=!1,this.isPaused=!0):ci.audioEngine?.audioContext&&this._soundSource&&(this._soundSource.onended=()=>{},this._soundSource.stop(),this.isPlaying=!1,this.isPaused=!0,this._currentTime+=ci.audioEngine.audioContext.currentTime-this._startTime))}setVolume(p,_){ci.audioEngine?.canUseWebAudio&&this._soundGain&&(_&&ci.audioEngine.audioContext?(this._soundGain.gain.cancelScheduledValues(ci.audioEngine.audioContext.currentTime),this._soundGain.gain.setValueAtTime(this._soundGain.gain.value,ci.audioEngine.audioContext.currentTime),this._soundGain.gain.linearRampToValueAtTime(p,ci.audioEngine.audioContext.currentTime+_)):this._soundGain.gain.value=p),this._volume=p}setPlaybackRate(p){this._playbackRate=p,this.isPlaying&&(this._streaming&&this._htmlAudioElement?this._htmlAudioElement.playbackRate=this._playbackRate:this._soundSource&&(this._soundSource.playbackRate.value=this._playbackRate))}getPlaybackRate(){return this._playbackRate}getVolume(){return this._volume}attachToMesh(p){this._connectedTransformNode&&this._registerFunc&&(this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc),this._registerFunc=null),this._connectedTransformNode=p,this._spatialSound||(this._spatialSound=!0,this._createSpatialParameters(),this.isPlaying&&this.loop&&(this.stop(),this.play(0,this._offset,this._length))),this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode),this._registerFunc=_=>this._onRegisterAfterWorldMatrixUpdate(_),this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc)}detachFromMesh(){this._connectedTransformNode&&this._registerFunc&&(this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc),this._registerFunc=null,this._connectedTransformNode=null)}_onRegisterAfterWorldMatrixUpdate(p){if(!p.getBoundingInfo)this.setPosition(p.absolutePosition);else{const E=p.getBoundingInfo();this.setPosition(E.boundingSphere.centerWorld)}ci.audioEngine?.canUseWebAudio&&this._isDirectional&&this.isPlaying&&this._updateDirection()}clone(){if(this._streaming)return null;{const p=()=>{this._isReadyToPlay?(E._audioBuffer=this.getAudioBuffer(),E._isReadyToPlay=!0,E.autoplay&&E.play(0,this._offset,this._length)):setTimeout(p,300)},_={autoplay:this.autoplay,loop:this.loop,volume:this._volume,spatialSound:this._spatialSound,maxDistance:this.maxDistance,useCustomAttenuation:this.useCustomAttenuation,rolloffFactor:this.rolloffFactor,refDistance:this.refDistance,distanceModel:this.distanceModel},E=new jc(this.name+"_cloned",new ArrayBuffer(0),this._scene,null,_);return this.useCustomAttenuation&&E.setAttenuationFunction(this._customAttenuationFunction),E.setPosition(this._position),E.setPlaybackRate(this._playbackRate),p(),E}}getAudioBuffer(){return this._audioBuffer}getSoundSource(){return this._soundSource}getSoundGain(){return this._soundGain}serialize(){const p={name:this.name,url:this._url,autoplay:this.autoplay,loop:this.loop,volume:this._volume,spatialSound:this._spatialSound,maxDistance:this.maxDistance,rolloffFactor:this.rolloffFactor,refDistance:this.refDistance,distanceModel:this.distanceModel,playbackRate:this._playbackRate,panningModel:this._panningModel,soundTrackId:this.soundTrackId,metadata:this.metadata};return this._spatialSound&&(this._connectedTransformNode&&(p.connectedMeshId=this._connectedTransformNode.id),p.position=this._position.asArray(),p.refDistance=this.refDistance,p.distanceModel=this.distanceModel,p.isDirectional=this._isDirectional,p.localDirectionToMesh=this._localDirection.asArray(),p.coneInnerAngle=this._coneInnerAngle,p.coneOuterAngle=this._coneOuterAngle,p.coneOuterGain=this._coneOuterGain),p}static Parse(p,_,E,I){const Z=p.name;let re;p.url?re=E+p.url:re=E+Z;const ae={autoplay:p.autoplay,loop:p.loop,volume:p.volume,spatialSound:p.spatialSound,maxDistance:p.maxDistance,rolloffFactor:p.rolloffFactor,refDistance:p.refDistance,distanceModel:p.distanceModel,playbackRate:p.playbackRate};let he;if(!I)he=new jc(Z,re,_,()=>{_.removePendingData(he)},ae),_.addPendingData(he);else{const _e=()=>{I._isReadyToPlay?(he._audioBuffer=I.getAudioBuffer(),he._isReadyToPlay=!0,he.autoplay&&he.play(0,he._offset,he._length)):setTimeout(_e,300)};he=new jc(Z,new ArrayBuffer(0),_,null,ae),_e()}if(p.position){const _e=at.FromArray(p.position);he.setPosition(_e)}if(p.isDirectional&&(he.setDirectionalCone(p.coneInnerAngle||360,p.coneOuterAngle||360,p.coneOuterGain||0),p.localDirectionToMesh)){const _e=at.FromArray(p.localDirectionToMesh);he.setLocalDirectionToMesh(_e)}if(p.connectedMeshId){const _e=_.getMeshById(p.connectedMeshId);_e&&he.attachToMesh(_e)}return p.metadata&&(he.metadata=p.metadata),he}_setOffset(p){this._offset!==p&&(this.isPaused&&(this.stop(),this.isPaused=!1),this._offset=p)}_clearTimeoutsAndObservers(){this._tryToPlayTimeout&&(clearTimeout(this._tryToPlayTimeout),this._tryToPlayTimeout=null),this._audioUnlockedObserver&&(ci.audioEngine?.onAudioUnlockedObservable.remove(this._audioUnlockedObserver),this._audioUnlockedObserver=null)}}jc._SceneComponentInitialization=pe=>{throw ur("AudioSceneComponent")};class WF{constructor(p,_,E){if(this.loop=!1,this._coneInnerAngle=360,this._coneOuterAngle=360,this._volume=1,this.isPlaying=!1,this.isPaused=!1,this._sounds=[],this._weights=[],_.length!==E.length)throw new Error("Sounds length does not equal weights length");this.loop=p,this._weights=E;let I=0;for(const re of E)I+=re;const Z=I>0?1/I:0;for(let re=0;re<this._weights.length;re++)this._weights[re]*=Z;this._sounds=_;for(const re of this._sounds)re.onEndedObservable.add(()=>{this._onended()})}get directionalConeInnerAngle(){return this._coneInnerAngle}set directionalConeInnerAngle(p){if(p!==this._coneInnerAngle){if(this._coneOuterAngle<p){Ti.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=p;for(const _ of this._sounds)_.directionalConeInnerAngle=p}}get directionalConeOuterAngle(){return this._coneOuterAngle}set directionalConeOuterAngle(p){if(p!==this._coneOuterAngle){if(p<this._coneInnerAngle){Ti.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneOuterAngle=p;for(const _ of this._sounds)_.directionalConeOuterAngle=p}}get volume(){return this._volume}set volume(p){if(p!==this._volume)for(const _ of this._sounds)_.setVolume(p)}_onended(){this._currentIndex!==void 0&&(this._sounds[this._currentIndex].autoplay=!1),this.loop&&this.isPlaying?this.play():this.isPlaying=!1}pause(){this.isPaused=!0,this._currentIndex!==void 0&&this._sounds[this._currentIndex].pause()}stop(){this.isPlaying=!1,this._currentIndex!==void 0&&this._sounds[this._currentIndex].stop()}play(p){if(!this.isPaused){this.stop();const E=Math.random();let I=0;for(let Z=0;Z<this._weights.length;Z++)if(I+=this._weights[Z],E<=I){this._currentIndex=Z;break}}const _=this._sounds[this._currentIndex];_.isReady()?_.play(0,this.isPaused?void 0:p):_.autoplay=!0,this.isPlaying=!0,this.isPaused=!1}}const Y_="MSFT_audio_emitter";class HF{constructor(p){this.name=Y_,this._loader=p,this.enabled=this._loader.isExtensionUsed(Y_)}dispose(){this._loader=null,this._clips=null,this._emitters=null}onLoading(){const p=this._loader.gltf.extensions;if(p&&p[this.name]){const _=p[this.name];this._clips=_.clips,this._emitters=_.emitters,kr.Assign(this._clips),kr.Assign(this._emitters)}}loadSceneAsync(p,_){return js.LoadExtensionAsync(p,_,this.name,(E,I)=>{const Z=new Array;Z.push(this._loader.loadSceneAsync(p,_));for(const re of I.emitters){const ae=kr.Get(`${E}/emitters`,this._emitters,re);if(ae.refDistance!=null||ae.maxDistance!=null||ae.rolloffFactor!=null||ae.distanceModel!=null||ae.innerAngle!=null||ae.outerAngle!=null)throw new Error(`${E}: Direction or Distance properties are not allowed on emitters attached to a scene`);Z.push(this._loadEmitterAsync(`${E}/emitters/${ae.index}`,ae))}return Promise.all(Z).then(()=>{})})}loadNodeAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{const re=new Array;return this._loader.loadNodeAsync(I,_,ae=>{for(const he of Z.emitters){const _e=kr.Get(`${I}/emitters`,this._emitters,he);re.push(this._loadEmitterAsync(`${I}/emitters/${_e.index}`,_e).then(()=>{for(const ve of _e._babylonSounds)ve.attachToMesh(ae),(_e.innerAngle!=null||_e.outerAngle!=null)&&(ve.setLocalDirectionToMesh(at.Forward()),ve.setDirectionalCone(2*lt.ToDegrees(_e.innerAngle==null?Math.PI:_e.innerAngle),2*lt.ToDegrees(_e.outerAngle==null?Math.PI:_e.outerAngle),0))}))}E(ae)}).then(ae=>Promise.all(re).then(()=>ae))})}loadAnimationAsync(p,_){return js.LoadExtensionAsync(p,_,this.name,(E,I)=>this._loader.loadAnimationAsync(p,_).then(Z=>{const re=new Array;kr.Assign(I.events);for(const ae of I.events)re.push(this._loadAnimationEventAsync(`${E}/events/${ae.index}`,p,_,ae,Z));return Promise.all(re).then(()=>Z)}))}_loadClipAsync(p,_){if(_._objectURL)return _._objectURL;let E;if(_.uri)E=this._loader.loadUriAsync(p,_,_.uri);else{const I=kr.Get(`${p}/bufferView`,this._loader.gltf.bufferViews,_.bufferView);E=this._loader.loadBufferViewAsync(`/bufferViews/${I.index}`,I)}return _._objectURL=E.then(I=>URL.createObjectURL(new Blob([I],{type:_.mimeType}))),_._objectURL}_loadEmitterAsync(p,_){if(_._babylonSounds=_._babylonSounds||[],!_._babylonData){const E=new Array,I=_.name||`emitter${_.index}`,Z={loop:!1,autoplay:!1,volume:_.volume==null?1:_.volume};for(let ae=0;ae<_.clips.length;ae++){const he=`/extensions/${this.name}/clips`,_e=kr.Get(he,this._clips,_.clips[ae].clip);E.push(this._loadClipAsync(`${he}/${_.clips[ae].clip}`,_e).then(ve=>{const Le=_._babylonSounds[ae]=new jc(I,ve,this._loader.babylonScene,null,Z);Le.refDistance=_.refDistance||1,Le.maxDistance=_.maxDistance||256,Le.rolloffFactor=_.rolloffFactor||1,Le.distanceModel=_.distanceModel||"exponential"}))}const re=Promise.all(E).then(()=>{const ae=_.clips.map(_e=>_e.weight||1),he=new WF(_.loop||!1,_._babylonSounds,ae);_.innerAngle&&(he.directionalConeInnerAngle=2*lt.ToDegrees(_.innerAngle)),_.outerAngle&&(he.directionalConeOuterAngle=2*lt.ToDegrees(_.outerAngle)),_.volume&&(he.volume=_.volume),_._babylonData.sound=he});_._babylonData={loaded:re}}return _._babylonData.loaded}_getEventAction(p,_,E,I,Z){switch(E){case"play":return re=>{const ae=(Z||0)+(re-I);_.play(ae)};case"stop":return()=>{_.stop()};case"pause":return()=>{_.pause()};default:throw new Error(`${p}: Unsupported action ${E}`)}}_loadAnimationEventAsync(p,_,E,I,Z){if(Z.targetedAnimations.length==0)return Promise.resolve();const re=Z.targetedAnimations[0],ae=I.emitter,he=kr.Get(`/extensions/${this.name}/emitters`,this._emitters,ae);return this._loadEmitterAsync(p,he).then(()=>{const _e=he._babylonData.sound;if(_e){const ve=new X_(I.time,this._getEventAction(p,_e,I.action,I.time,I.startOffset));re.animation.addEvent(ve),Z.onAnimationGroupEndObservable.add(()=>{_e.stop()}),Z.onAnimationGroupPauseObservable.add(()=>{_e.pause()})}})}}js.RegisterExtension(Y_,pe=>new HF(pe));const K_="MSFT_lod";class XF{constructor(p){this.name=K_,this.order=100,this.maxLODsToLoad=10,this.onNodeLODsLoadedObservable=new Ri,this.onMaterialLODsLoadedObservable=new Ri,this._bufferLODs=new Array,this._nodeIndexLOD=null,this._nodeSignalLODs=new Array,this._nodePromiseLODs=new Array,this._nodeBufferLODs=new Array,this._materialIndexLOD=null,this._materialSignalLODs=new Array,this._materialPromiseLODs=new Array,this._materialBufferLODs=new Array,this._loader=p,this.enabled=this._loader.isExtensionUsed(K_)}dispose(){this._loader=null,this._nodeIndexLOD=null,this._nodeSignalLODs.length=0,this._nodePromiseLODs.length=0,this._nodeBufferLODs.length=0,this._materialIndexLOD=null,this._materialSignalLODs.length=0,this._materialPromiseLODs.length=0,this._materialBufferLODs.length=0,this.onMaterialLODsLoadedObservable.clear(),this.onNodeLODsLoadedObservable.clear()}onReady(){for(let p=0;p<this._nodePromiseLODs.length;p++){const _=Promise.all(this._nodePromiseLODs[p]).then(()=>{p!==0&&(this._loader.endPerformanceCounter(`Node LOD ${p}`),this._loader.log(`Loaded node LOD ${p}`)),this.onNodeLODsLoadedObservable.notifyObservers(p),p!==this._nodePromiseLODs.length-1&&(this._loader.startPerformanceCounter(`Node LOD ${p+1}`),this._loadBufferLOD(this._nodeBufferLODs,p+1),this._nodeSignalLODs[p]&&this._nodeSignalLODs[p].resolve())});this._loader._completePromises.push(_)}for(let p=0;p<this._materialPromiseLODs.length;p++){const _=Promise.all(this._materialPromiseLODs[p]).then(()=>{p!==0&&(this._loader.endPerformanceCounter(`Material LOD ${p}`),this._loader.log(`Loaded material LOD ${p}`)),this.onMaterialLODsLoadedObservable.notifyObservers(p),p!==this._materialPromiseLODs.length-1&&(this._loader.startPerformanceCounter(`Material LOD ${p+1}`),this._loadBufferLOD(this._materialBufferLODs,p+1),this._materialSignalLODs[p]&&this._materialSignalLODs[p].resolve())});this._loader._completePromises.push(_)}}loadSceneAsync(p,_){const E=this._loader.loadSceneAsync(p,_);return this._loadBufferLOD(this._bufferLODs,0),E}loadNodeAsync(p,_,E){return js.LoadExtensionAsync(p,_,this.name,(I,Z)=>{let re;const ae=this._getLODs(I,_,this._loader.gltf.nodes,Z.ids);this._loader.logOpen(`${I}`);for(let he=0;he<ae.length;he++){const _e=ae[he];he!==0&&(this._nodeIndexLOD=he,this._nodeSignalLODs[he]=this._nodeSignalLODs[he]||new qp);const ve=ze=>{E(ze),ze.setEnabled(!1)},Le=this._loader.loadNodeAsync(`/nodes/${_e.index}`,_e,ve).then(ze=>{if(he!==0){const He=ae[he-1];He._babylonTransformNode&&(this._disposeTransformNode(He._babylonTransformNode),delete He._babylonTransformNode)}return ze.setEnabled(!0),ze});this._nodePromiseLODs[he]=this._nodePromiseLODs[he]||[],he===0?re=Le:(this._nodeIndexLOD=null,this._nodePromiseLODs[he].push(Le))}return this._loader.logClose(),re})}_loadMaterialAsync(p,_,E,I,Z){return this._nodeIndexLOD?null:js.LoadExtensionAsync(p,_,this.name,(re,ae)=>{let he;const _e=this._getLODs(re,_,this._loader.gltf.materials,ae.ids);this._loader.logOpen(`${re}`);for(let ve=0;ve<_e.length;ve++){const Le=_e[ve];ve!==0&&(this._materialIndexLOD=ve);const ze=this._loader._loadMaterialAsync(`/materials/${Le.index}`,Le,E,I,He=>{ve===0&&Z(He)}).then(He=>{if(ve!==0){Z(He);const xt=_e[ve-1]._data;xt[I]&&(this._disposeMaterials([xt[I].babylonMaterial]),delete xt[I])}return He});this._materialPromiseLODs[ve]=this._materialPromiseLODs[ve]||[],ve===0?he=ze:(this._materialIndexLOD=null,this._materialPromiseLODs[ve].push(ze))}return this._loader.logClose(),he})}_loadUriAsync(p,_,E){if(this._nodeIndexLOD!==null){this._loader.log("deferred");const I=this._nodeIndexLOD-1;return this._nodeSignalLODs[I]=this._nodeSignalLODs[I]||new qp,this._nodeSignalLODs[this._nodeIndexLOD-1].promise.then(()=>this._loader.loadUriAsync(p,_,E))}else if(this._materialIndexLOD!==null){this._loader.log("deferred");const I=this._materialIndexLOD-1;return this._materialSignalLODs[I]=this._materialSignalLODs[I]||new qp,this._materialSignalLODs[I].promise.then(()=>this._loader.loadUriAsync(p,_,E))}return null}loadBufferAsync(p,_,E,I){if(this._loader.parent.useRangeRequests&&!_.uri){if(!this._loader.bin)throw new Error(`${p}: Uri is missing or the binary glTF is missing its binary chunk`);const Z=(re,ae)=>{const he=E,_e=he+I-1;let ve=re[ae];return ve?(ve.start=Math.min(ve.start,he),ve.end=Math.max(ve.end,_e)):(ve={start:he,end:_e,loaded:new qp},re[ae]=ve),ve.loaded.promise.then(Le=>new Uint8Array(Le.buffer,Le.byteOffset+E-ve.start,I))};return this._loader.log("deferred"),this._nodeIndexLOD!==null?Z(this._nodeBufferLODs,this._nodeIndexLOD):this._materialIndexLOD!==null?Z(this._materialBufferLODs,this._materialIndexLOD):Z(this._bufferLODs,0)}return null}_loadBufferLOD(p,_){const E=p[_];E&&(this._loader.log(`Loading buffer range [${E.start}-${E.end}]`),this._loader.bin.readAsync(E.start,E.end-E.start+1).then(I=>{E.loaded.resolve(I)},I=>{E.loaded.reject(I)}))}_getLODs(p,_,E,I){if(this.maxLODsToLoad<=0)throw new Error("maxLODsToLoad must be greater than zero");const Z=[];for(let re=I.length-1;re>=0;re--)if(Z.push(kr.Get(`${p}/ids/${I[re]}`,E,I[re])),Z.length===this.maxLODsToLoad)return Z;return Z.push(_),Z}_disposeTransformNode(p){const _=[],E=p.material;E&&_.push(E);for(const Z of p.getChildMeshes())Z.material&&_.push(Z.material);p.dispose();const I=_.filter(Z=>this._loader.babylonScene.meshes.every(re=>re.material!=Z));this._disposeMaterials(I)}_disposeMaterials(p){const _={};for(const E of p){for(const I of E.getActiveTextures())_[I.uniqueId]=I;E.dispose()}for(const E in _)for(const I of this._loader.babylonScene.materials)I.hasTexture(_[E])&&delete _[E];for(const E in _)_[E].dispose()}}js.RegisterExtension(K_,pe=>new XF(pe));const j_="MSFT_minecraftMesh";class YF{constructor(p){this.name=j_,this._loader=p,this.enabled=this._loader.isExtensionUsed(j_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtraAsync(p,_,this.name,(I,Z)=>{if(Z){if(!(E instanceof Ys))throw new Error(`${I}: Material type not supported`);const re=this._loader.loadMaterialPropertiesAsync(p,_,E);return E.needAlphaBlending()&&(E.forceDepthWrite=!0,E.separateCullingPass=!0),E.backFaceCulling=E.forceDepthWrite,E.twoSidedLighting=!0,re}return null})}}js.RegisterExtension(j_,pe=>new YF(pe));const q_="MSFT_sRGBFactors";class KF{constructor(p){this.name=q_,this._loader=p,this.enabled=this._loader.isExtensionUsed(q_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(p,_,E){return js.LoadExtraAsync(p,_,this.name,(I,Z)=>{if(Z){if(!(E instanceof Ys))throw new Error(`${I}: Material type not supported`);const re=this._loader.loadMaterialPropertiesAsync(p,_,E),ae=E.getScene().getEngine().useExactSrgbConversions;return E.albedoTexture||E.albedoColor.toLinearSpaceToRef(E.albedoColor,ae),E.reflectivityTexture||E.reflectivityColor.toLinearSpaceToRef(E.reflectivityColor,ae),re}return null})}}js.RegisterExtension(q_,pe=>new KF(pe));var To;(function(pe){pe[pe.Input=0]="Input",pe[pe.Output=1]="Output"})(To||(To={}));class Q_{constructor(p,_,E){this._ownerBlock=E,this._connectedPoint=[],this.uniqueId=Y0(),this.connectedPointIds=[],this.name=p,this._connectionType=_}get connectionType(){return this._connectionType}_isSingularConnection(){return!0}isConnected(){return this._connectedPoint.length>0}connectTo(p){if(this._connectionType===p._connectionType)throw new Error(`Cannot connect two points of type ${this.connectionType}`);if(this._isSingularConnection()&&this._connectedPoint.length>0||p._isSingularConnection()&&p._connectedPoint.length>0)throw new Error("Max number of connections for point reached");this._connectedPoint.push(p),p._connectedPoint.push(this)}serialize(p={}){p.uniqueId=this.uniqueId,p.name=this.name,p._connectionType=this._connectionType,p.connectedPointIds=[],p.className=this.getClassName();for(const _ of this._connectedPoint)p.connectedPointIds.push(_.uniqueId)}getClassName(){return"FGConnection"}deserialize(p){this.uniqueId=p.uniqueId,this.name=p.name,this._connectionType=p._connectionType,this.connectedPointIds=p.connectedPointIds}static Parse(p={},_){const E=lt.Instantiate(p.className),I=new E(p.name,p._connectionType,_);return I.deserialize(p),I}}class qa{constructor(p){this.value=this._toInt(p)}_toInt(p){return p|0}add(p){return new qa(this.value+p.value)}subtract(p){return new qa(this.value-p.value)}multiply(p){return new qa(Math.imul(this.value,p.value))}divide(p){return new qa(this.value/p.value)}getClassName(){return qa.ClassName}equals(p){return this.value===p.value}static Parse(p){return new qa(p.value)}}qa.ClassName="FlowGraphInteger",Gs("FlowGraphInteger",qa);class ro{constructor(p,_){this.typeName=p,this.defaultValue=_}serialize(p){p.typeName=this.typeName,p.defaultValue=this.defaultValue}static Parse(p){return new ro(p.typeName,p.defaultValue)}}const zs=new ro("any",void 0),jF=new ro("string",""),M0=new ro("number",0),ch=new ro("boolean",!1),Z_=new ro("Vector2",xr.Zero()),qc=new ro("Vector3",at.Zero()),qF=new ro("Vector4",Lr.Zero()),nc=new ro("Matrix",jt.Identity()),$F=new ro("Color3",Rs.Black()),rL=new ro("Color4",new Tr(0,0,0,0)),nL=new ro("Quaternion",us.Identity()),Xa=new ro("FlowGraphInteger",new qa(0));function p5(pe){switch(typeof pe){case"string":return jF;case"number":return M0;case"boolean":return ch;case"object":return pe instanceof Vector2?Z_:pe instanceof Vector3?qc:pe instanceof Vector4?qF:pe instanceof Color3?$F:pe instanceof Color4?rL:pe instanceof Quaternion?nL:pe instanceof FlowGraphInteger?Xa:zs;default:return zs}}class J_ extends Q_{constructor(p,_,E,I){super(p,_,E),this.richType=I}_isSingularConnection(){return this.connectionType===To.Input}setValue(p,_){_._setConnectionValue(this,p)}connectTo(p){super.connectTo(p)}_getValueOrDefault(p){return p._hasConnectionValue(this)?p._getConnectionValue(this):this.richType.defaultValue}getValue(p){return this.connectionType===To.Output?(p._notifyExecuteNode(this._ownerBlock),this._ownerBlock._updateOutputs(p),this._getValueOrDefault(p)):this.isConnected()?this._connectedPoint[0].getValue(p):this._getValueOrDefault(p)}getClassName(){return"FGDataConnection"}serialize(p={}){super.serialize(p),p.richType={},this.richType.serialize(p.richType)}static Parse(p,_){const E=Q_.Parse(p,_);return E.richType=ro.Parse(p.richType),E}}Gs("FGDataConnection",J_);function aM(pe){return pe==="Mesh"||pe==="AbstractMesh"||pe==="GroundMesh"||pe==="InstanceMesh"||pe==="LinesMesh"||pe==="GoldbergMesh"||pe==="GreasedLineMesh"||pe==="TrailMesh"}function xM(pe){return pe==="Vector2"||pe==="Vector3"||pe==="Vector4"||pe==="Quaternion"||pe==="Color3"||pe==="Color4"}function aL(pe,p){if(pe==="Vector2")return xr.FromArray(p);if(pe==="Vector3")return at.FromArray(p);if(pe==="Vector4")return Lr.FromArray(p);if(pe==="Quaternion")return us.FromArray(p);if(pe==="Color3")return new Rs(p[0],p[1],p[2]);if(pe==="Color4")return new Tr(p[0],p[1],p[2],p[3]);throw new Error(`Unknown vector class name ${pe}`)}function lM(pe,p,_){const E=p?.getClassName?.()??"";aM(E)?_[pe]={name:p.name,className:E}:xM(E)?_[pe]={value:p.asArray(),className:E}:_[pe]=p}function pg(pe,p,_){const E=p[pe];let I;const Z=E?.className;return aM(Z)?I=_.getMeshByName(E.name):xM(Z)?I=aL(Z,E.value):Z==="Matrix"?I=jt.FromArray(E.value):Z===qa.ClassName?I=qa.Parse(E):E&&E.value!==void 0?I=E.value:I=E,I}function xL(pe){return pe==="FGSetPropertyBlock"||pe==="FGGetPropertyBlock"||pe==="FGPlayAnimationBlock"||pe==="FGMeshPickEventBlock"}class xm{constructor(p){this.config=p,this.uniqueId=Y0(),this.name=this.config?.name??this.getClassName(),this.dataInputs=[],this.dataOutputs=[]}_updateOutputs(p){}registerDataInput(p,_){const E=new J_(p,To.Input,this,_);return this.dataInputs.push(E),E}registerDataOutput(p,_){const E=new J_(p,To.Output,this,_);return this.dataOutputs.push(E),E}getDataInput(p){return this.dataInputs.find(_=>_.name===p)}getDataOutput(p){return this.dataOutputs.find(_=>_.name===p)}serialize(p={},_=lM){p.uniqueId=this.uniqueId,p.config={},this.config&&(p.config.name=this.config.name),p.dataInputs=[],p.dataOutputs=[],p.className=this.getClassName();for(const E of this.dataInputs){const I={};E.serialize(I),p.dataInputs.push(I)}for(const E of this.dataOutputs){const I={};E.serialize(I),p.dataOutputs.push(I)}}getClassName(){return"FGBlock"}static Parse(p,_){const E=lt.Instantiate(p.className),I={},Z=_.valueParseFunction??pg;if(p.config)for(const ae in p.config)I[ae]=Z(ae,p.config,_.scene);xL(p.className)&&(I.pathConverter=_.pathConverter);const re=new E(I);re.uniqueId=p.uniqueId;for(let ae=0;ae<p.dataInputs.length;ae++){const he=re.getDataInput(p.dataInputs[ae].name);if(he)he.deserialize(p.dataInputs[ae]);else throw new Error("Could not find data input with name "+p.dataInputs[ae].name+" in block "+p.className)}for(let ae=0;ae<p.dataOutputs.length;ae++){const he=re.getDataOutput(p.dataOutputs[ae].name);if(he)he.deserialize(p.dataOutputs[ae]);else throw new Error("Could not find data output with name "+p.dataOutputs[ae].name+" in block "+p.className)}return re.metadata=p.metadata,re.deserialize&&re.deserialize(p),re}}class $_ extends Q_{_isSingularConnection(){return this.connectionType===To.Output}_activateSignal(p){this.connectionType===To.Input?(p._notifyExecuteNode(this._ownerBlock),this._ownerBlock._execute(p,this),p._increaseExecutionId()):this._connectedPoint[0]?._activateSignal(p)}}Gs("FlowGraphSignalConnection",$_);class Hu extends xm{constructor(p){super(p),this.signalInputs=[],this.signalOutputs=[],this.in=this._registerSignalInput("in")}_registerSignalInput(p){const _=new $_(p,To.Input,this);return this.signalInputs.push(_),_}_registerSignalOutput(p){const _=new $_(p,To.Output,this);return this.signalOutputs.push(_),_}getSignalInput(p){return this.signalInputs.find(_=>_.name===p)}getSignalOutput(p){return this.signalOutputs.find(_=>_.name===p)}serialize(p={}){super.serialize(p),p.signalInputs=[],p.signalOutputs=[];for(const _ of this.signalInputs){const E={};_.serialize(E),p.signalInputs.push(E)}for(const _ of this.signalOutputs){const E={};_.serialize(E),p.signalOutputs.push(E)}}deserialize(p){for(let _=0;_<p.signalInputs.length;_++){const E=this.getSignalInput(p.signalInputs[_].name);if(E)E.deserialize(p.signalInputs[_]);else throw new Error("Could not find signal input with name "+p.signalInputs[_].name+" in block "+p.className)}for(let _=0;_<p.signalOutputs.length;_++){const E=this.getSignalOutput(p.signalOutputs[_].name);if(E)E.deserialize(p.signalOutputs[_]);else throw new Error("Could not find signal output with name "+p.signalOutputs[_].name+" in block "+p.className)}}getClassName(){return"FGExecutionBlock"}}class hM extends Hu{constructor(p){super(p),this.out=this._registerSignalOutput("out"),this.done=this._registerSignalOutput("done")}_startPendingTasks(p){this._preparePendingTasks(p),p._addPendingBlock(this)}}class lm extends hM{_execute(p){p._notifyExecuteNode(this),this.out._activateSignal(p)}}class ry{constructor(p){this.uniqueId=Y0(),this._userVariables={},this._executionVariables={},this._connectionValues={},this._pendingBlocks=[],this._executionId=0,this.onNodeExecutedObservable=new Ri,this._configuration=p}hasVariable(p){return p in this._userVariables}setVariable(p,_){this._userVariables[p]=_}getVariable(p){return this._userVariables[p]}get userVariables(){return this._userVariables}_getUniqueIdPrefixedName(p,_){return`${p.uniqueId}_${_}`}_setExecutionVariable(p,_,E){this._executionVariables[this._getUniqueIdPrefixedName(p,_)]=E}_getExecutionVariable(p,_,E){return this._hasExecutionVariable(p,_)?this._executionVariables[this._getUniqueIdPrefixedName(p,_)]:E}_deleteExecutionVariable(p,_){delete this._executionVariables[this._getUniqueIdPrefixedName(p,_)]}_hasExecutionVariable(p,_){return this._getUniqueIdPrefixedName(p,_)in this._executionVariables}_hasConnectionValue(p){return p.uniqueId in this._connectionValues}_setConnectionValue(p,_){this._connectionValues[p.uniqueId]=_}_getConnectionValue(p){return this._connectionValues[p.uniqueId]}get configuration(){return this._configuration}_addPendingBlock(p){this._pendingBlocks.push(p)}_removePendingBlock(p){const _=this._pendingBlocks.indexOf(p);_!==-1&&this._pendingBlocks.splice(_,1)}_clearPendingBlocks(){for(const p of this._pendingBlocks)p._cancelPendingTasks(this);this._pendingBlocks.length=0}_notifyExecuteNode(p){this.onNodeExecutedObservable.notifyObservers(p)}_increaseExecutionId(){this._executionId++}get executionId(){return this._executionId}serialize(p={},_=lM){p.uniqueId=this.uniqueId,p._userVariables={};for(const E in this._userVariables)_(E,this._userVariables[E],p._userVariables);p._connectionValues={};for(const E in this._connectionValues)_(E,this._connectionValues[E],p._connectionValues)}getClassName(){return"FGContext"}static Parse(p,_){const E=_.graph.createContext(),I=_.valueParseFunction??pg;E.uniqueId=p.uniqueId;for(const Z in p._userVariables){const re=I(Z,p._userVariables,E._configuration.scene);E._userVariables[Z]=re}for(const Z in p._connectionValues){const re=I(Z,p._connectionValues,E._configuration.scene);E._connectionValues[Z]=re}return E}}Rt([Ut()],ry.prototype,"uniqueId",void 0);function ny(pe,p){return!!(pe.parent&&(pe.parent===p||ny(pe.parent,p)))}class Xu extends lm{constructor(p){super(p),this.config=p}_getReferencedMesh(){const p=this.config.pathConverter.convert(this.config.path),_=p.info.getObject(p.object);if(!_||!(_ instanceof kx))throw new Error("Mesh pick event block requires a valid mesh");return _}_preparePendingTasks(p){let _=p._getExecutionVariable(this,"meshPickObserver");if(!_){const E=this._getReferencedMesh();p._setExecutionVariable(this,"mesh",E),_=E.getScene().onPointerObservable.add(Z=>{Z.type===zr.POINTERPICK&&Z.pickInfo?.pickedMesh&&(Z.pickInfo?.pickedMesh===E||ny(Z.pickInfo?.pickedMesh,E))&&this._execute(p)});const I=E.onDisposeObservable.add(()=>this._onDispose);p._setExecutionVariable(this,"meshPickObserver",_),p._setExecutionVariable(this,"meshDisposeObserver",I)}}_onDispose(p){this._cancelPendingTasks(p),p._removePendingBlock(this)}_cancelPendingTasks(p){const _=p._getExecutionVariable(this,"mesh"),E=p._getExecutionVariable(this,"meshPickObserver"),I=p._getExecutionVariable(this,"meshDisposeObserver");_.getScene().onPointerObservable.remove(E),_.onDisposeObservable.remove(I),p._deleteExecutionVariable(this,"mesh"),p._deleteExecutionVariable(this,"meshPickObserver"),p._deleteExecutionVariable(this,"meshDisposeObserver")}getClassName(){return Xu.ClassName}serialize(p){super.serialize(p),p.config.path=this.config.path}}Xu.ClassName="FGMeshPickEventBlock",Gs(Xu.ClassName,Xu);var $c;(function(pe){pe[pe.Stopped=0]="Stopped",pe[pe.Started=1]="Started"})($c||($c={}));class Yu{constructor(p){this._eventBlocks=[],this._executionContexts=[],this.state=$c.Stopped,this._scene=p.scene,this._coordinator=p.coordinator,this._sceneDisposeObserver=this._scene.onDisposeObservable.add(()=>this.dispose())}createContext(){const p=new ry({scene:this._scene,coordinator:this._coordinator});return this._executionContexts.push(p),p}getContext(p){return this._executionContexts[p]}addEventBlock(p){this._eventBlocks.push(p)}start(){if(this.state!==$c.Started){this.state=$c.Started,this._executionContexts.length===0&&this.createContext();for(const p of this._executionContexts){const _=this._getContextualOrder();for(const E of _)E._startPendingTasks(p)}}}_getContextualOrder(){const p=[];for(const _ of this._eventBlocks)if(_.getClassName()===Xu.ClassName){const E=_._getReferencedMesh();let I=0;for(;I<p.length;I++){const re=p[I]._getReferencedMesh();if(E&&re&&ny(E,re))break}p.splice(I,0,_)}else p.push(_);return p}dispose(){if(this.state!==$c.Stopped){this.state=$c.Stopped;for(const p of this._executionContexts)p._clearPendingBlocks();this._executionContexts.length=0,this._eventBlocks.length=0,this._scene.onDisposeObservable.remove(this._sceneDisposeObserver),this._sceneDisposeObserver=null}}visitAllBlocks(p){const _=[],E=new Set;for(const I of this._eventBlocks)_.push(I),E.add(I.uniqueId);for(;_.length>0;){const I=_.pop();p(I);for(const Z of I.dataInputs)for(const re of Z._connectedPoint)E.has(re._ownerBlock.uniqueId)||(_.push(re._ownerBlock),E.add(re._ownerBlock.uniqueId));if(I instanceof Hu)for(const Z of I.signalOutputs)for(const re of Z._connectedPoint)E.has(re._ownerBlock.uniqueId)||(_.push(re._ownerBlock),E.add(re._ownerBlock.uniqueId))}}serialize(p={},_){p.allBlocks=[],this.visitAllBlocks(E=>{const I={};E.serialize(I),p.allBlocks.push(I)}),p.executionContexts=[];for(const E of this._executionContexts){const I={};E.serialize(I,_),p.executionContexts.push(I)}}static GetDataOutConnectionByUniqueId(p,_){for(const E of p)for(const I of E.dataOutputs)if(I.uniqueId===_)return I;throw new Error("Could not find data out connection with unique id "+_)}static GetSignalInConnectionByUniqueId(p,_){for(const E of p)if(E instanceof Hu){for(const I of E.signalInputs)if(I.uniqueId===_)return I}throw new Error("Could not find signal in connection with unique id "+_)}static Parse(p,_){const E=_.coordinator.createGraph(),I=[],Z=_.valueParseFunction??pg;for(const re of p.allBlocks){const ae=xm.Parse(re,{scene:_.coordinator.config.scene,pathConverter:_.pathConverter,valueParseFunction:Z});I.push(ae),ae instanceof lm&&E.addEventBlock(ae)}for(const re of I){for(const ae of re.dataInputs)for(const he of ae.connectedPointIds){const _e=Yu.GetDataOutConnectionByUniqueId(I,he);ae.connectTo(_e)}if(re instanceof Hu)for(const ae of re.signalOutputs)for(const he of ae.connectedPointIds){const _e=Yu.GetSignalInConnectionByUniqueId(I,he);ae.connectTo(_e)}}for(const re of p.executionContexts)ry.Parse(re,{graph:E,valueParseFunction:Z});return E}}class Ku{constructor(p){this.config=p,this._flowGraphs=[],this._customEventsMap=new Map,this.config.scene.onDisposeObservable.add(()=>{this.dispose()}),(Ku.SceneCoordinators.get(this.config.scene)??[]).push(this)}createGraph(){const p=new Yu({scene:this.config.scene,coordinator:this});return this._flowGraphs.push(p),p}removeGraph(p){const _=this._flowGraphs.indexOf(p);_!==-1&&(p.dispose(),this._flowGraphs.splice(_,1))}start(){this._flowGraphs.forEach(p=>p.start())}dispose(){this._flowGraphs.forEach(E=>E.dispose()),this._flowGraphs.length=0;const p=Ku.SceneCoordinators.get(this.config.scene)??[],_=p.indexOf(this);_!==-1&&p.splice(_,1)}serialize(p,_){p._flowGraphs=[],this._flowGraphs.forEach(E=>{const I={};E.serialize(I,_),p._flowGraphs.push(I)})}static Parse(p,_){const E=_.valueParseFunction??pg,I=new Ku({scene:_.scene});return p._flowGraphs?.forEach(Z=>{Yu.Parse(Z,{coordinator:I,valueParseFunction:E,pathConverter:_.pathConverter})}),I}get flowGraphs(){return this._flowGraphs}getCustomEventObservable(p){let _=this._customEventsMap.get(p);return _||(_=new Ri,this._customEventsMap.set(p,_)),_}notifyCustomEvent(p,_){const E=this._customEventsMap.get(p);E&&E.notifyObservers(_)}}Ku.SceneCoordinators=new Map;class hm extends lm{_preparePendingTasks(p){if(!p._getExecutionVariable(this,"sceneReadyObserver")){const E=p.configuration.scene.onReadyObservable.add(()=>{this._execute(p)});p._setExecutionVariable(this,"sceneReadyObserver",E)}}_cancelPendingTasks(p){const _=p._getExecutionVariable(this,"sceneReadyObserver");p.configuration.scene.onReadyObservable.remove(_),p._deleteExecutionVariable(this,"sceneReadyObserver")}getClassName(){return hm.ClassName}}hm.ClassName="FGSceneReadyEventBlock",Gs("FGSceneReadyEventBlock",hm);class ju extends lm{_preparePendingTasks(p){if(!p._getExecutionVariable(this,"sceneBeforeRender")){const E=p.configuration.scene.onBeforeRenderObservable.add(()=>{this._execute(p)});p._setExecutionVariable(this,"sceneBeforeRender",E)}}_cancelPendingTasks(p){const _=p._getExecutionVariable(this,"sceneBeforeRender");p.configuration.scene.onBeforeRenderObservable.remove(_),p._deleteExecutionVariable(this,"sceneBeforeRender")}getClassName(){return ju.ClassName}}ju.ClassName="FGSceneTickEventBlock",Gs(ju.ClassName,ju);class qu extends Hu{constructor(p){super(p),this.out=this._registerSignalOutput("out")}}class $u extends qu{constructor(p){super(p),this.message=this.registerDataInput("message",zs)}_execute(p){const _=this.message.getValue(p);Ti.Log(_),this.out._activateSignal(p)}getClassName(){return $u.ClassName}}$u.ClassName="FGConsoleLogBlock",Gs($u.ClassName,$u);var ru;(function(pe){pe[pe.INIT=0]="INIT",pe[pe.STARTED=1]="STARTED",pe[pe.ENDED=2]="ENDED"})(ru||(ru={}));function _5(pe){let p=0;const _=Date.now();pe.observableParameters=pe.observableParameters??{};const E=pe.contextObservable.add(I=>{const Z=Date.now();p=Z-_;const re={startTime:_,currentTime:Z,deltaTime:p,completeRate:p/pe.timeout,payload:I};pe.onTick&&pe.onTick(re),pe.breakCondition&&pe.breakCondition()&&(pe.contextObservable.remove(E),pe.onAborted&&pe.onAborted(re)),p>=pe.timeout&&(pe.contextObservable.remove(E),pe.onEnded&&pe.onEnded(re))},pe.observableParameters.mask,pe.observableParameters.insertFirst,pe.observableParameters.scope);return E}class lL{constructor(p){this.onEachCountObservable=new Ri,this.onTimerAbortedObservable=new Ri,this.onTimerEndedObservable=new Ri,this.onStateChangedObservable=new Ri,this._observer=null,this._breakOnNextTick=!1,this._tick=_=>{const E=Date.now();this._timer=E-this._startTime;const I={startTime:this._startTime,currentTime:E,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:_},Z=this._breakOnNextTick||this._breakCondition(I);Z||this._timer>=this._timeToEnd?this._stop(I,Z):this.onEachCountObservable.notifyObservers(I)},this._setState(ru.INIT),this._contextObservable=p.contextObservable,this._observableParameters=p.observableParameters??{},this._breakCondition=p.breakCondition??(()=>!1),this._timeToEnd=p.timeout,p.onEnded&&this.onTimerEndedObservable.add(p.onEnded),p.onTick&&this.onEachCountObservable.add(p.onTick),p.onAborted&&this.onTimerAbortedObservable.add(p.onAborted)}set breakCondition(p){this._breakCondition=p}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(p=this._timeToEnd){if(this._state===ru.STARTED)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=p,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(ru.STARTED)}stop(){this._state===ru.STARTED&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(p){this._state=p,this.onStateChangedObservable.notifyObservers(this._state)}_stop(p,_=!1){this._contextObservable.remove(this._observer),this._setState(ru.ENDED),_?this.onTimerAbortedObservable.notifyObservers(p):this.onTimerEndedObservable.notifyObservers(p)}}class cm extends hM{constructor(p){super(p),this.timeout=this.registerDataInput("timeout",M0)}_preparePendingTasks(p){const _=this.timeout.getValue(p);if(_!==void 0&&_>=0){const E=p._getExecutionVariable(this,"runningTimers")||[],I=p.configuration.scene,Z=new lL({timeout:_,contextObservable:I.onBeforeRenderObservable,onEnded:()=>this._onEnded(Z,p)});Z.start(),E.push(Z),p._setExecutionVariable(this,"runningTimers",E)}}_execute(p){this._startPendingTasks(p),this.out._activateSignal(p)}_onEnded(p,_){const E=_._getExecutionVariable(this,"runningTimers")||[],I=E.indexOf(p);I!==-1?E.splice(I,1):lt.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),_._removePendingBlock(this),this.done._activateSignal(_)}_cancelPendingTasks(p){const _=p._getExecutionVariable(this,"runningTimers")||[];for(const E of _)E.dispose();p._deleteExecutionVariable(this,"runningTimers")}getClassName(){return cm.ClassName}}cm.ClassName="FGTimerBlock",Gs("FGTimerBlock",cm);class um extends qu{constructor(p){super(p),this.config=p;for(let _=0;_<this.config.eventData.length;_++){const E=this.config.eventData[_];this.registerDataInput(E,zs)}}_execute(p){const _=this.config.eventId,E=this.dataInputs.map(I=>I.getValue(p));p.configuration.coordinator.notifyCustomEvent(_,E),this.out._activateSignal(p)}getClassName(){return um.ClassName}}um.ClassName="FGSendCustomEventBlock",Gs("FGSendCustomEventBlock",um);class rd extends lm{constructor(p){super(p),this.config=p;for(let _=0;_<this.config.eventData.length;_++){const E=this.config.eventData[_];this.registerDataOutput(E,zs)}}_preparePendingTasks(p){const _=p.configuration.coordinator.getCustomEventObservable(this.config.eventId);this._eventObserver=_.add(E=>{for(let I=0;I<E.length;I++)this.dataOutputs[I].setValue(E[I],p);this._execute(p)})}_cancelPendingTasks(p){const _=p.configuration.coordinator.getCustomEventObservable(this.config.eventId);_?_.remove(this._eventObserver):lt.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`)}getClassName(){return rd.ClassName}serialize(p){super.serialize(p),p.eventId=this.config.eventId,p.eventData=this.config.eventData}}rd.ClassName="FGReceiveCustomEventBlock",Gs(rd.ClassName,rd);class nd extends Hu{constructor(p){super(p),this.config=p,this.outFlows=[];for(let _=0;_<this.config.numberOutputFlows;_++)this.outFlows.push(this._registerSignalOutput(`${_}`))}_execute(p){for(let _=0;_<this.config.numberOutputFlows;_++)this.outFlows[_]._activateSignal(p)}getClassName(){return nd.ClassName}}nd.ClassName="FGSequenceBlock",Gs(nd.ClassName,nd);const cM=new RegExp(/\{(\w+)\}/g);class uM{constructor(p,_){this.path=p,this.ownerBlock=_,this.templatedInputs=[];let E=cM.exec(p);for(;E;){const[,I]=E;this.templatedInputs.push(_.registerDataInput(I,Xa)),E=cM.exec(p)}}getAccessor(p,_){let E=this.path;for(const I of this.templatedInputs){const Z=I.getValue(_).value;E=E.replace(`{${I.name}}`,Z.toString())}return p.convert(E)}}class ad extends xm{constructor(p){super(p),this.config=p,this.value=this.registerDataOutput("value",zs),this.templateComponent=new uM(p.path,this)}_updateOutputs(p){const _=this.templateComponent.getAccessor(this.config.pathConverter,p),E=_.info.get(_.object);this.value.setValue(E,p)}getClassName(){return ad.ClassName}serialize(p={}){super.serialize(p),p.config.path=this.config.path}}ad.ClassName="FGGetPropertyBlock",Gs(ad.ClassName,ad);class _m extends qu{constructor(p){super(p),this.config=p,this.a=this.registerDataInput("a",zs),this.templateComponent=new uM(p.path,this)}_execute(p){const _=this.a.getValue(p),E=this.templateComponent.getAccessor(this.config.pathConverter,p);E.info.set(_,E.object),this.out._activateSignal(p)}serialize(p={}){super.serialize(p),p.config.path=this.config.path}getClassName(){return _m.ClassName}}_m.ClassName="FGSetPropertyBlock",Gs("FGSetPropertyBlock",_m);const pM="cachedOperationValue",_M="cachedExecutionId";class _g extends xm{constructor(p,_){super(_),this.value=this.registerDataOutput("value",p)}_updateOutputs(p){const _=p._getExecutionVariable(this,_M),E=p._getExecutionVariable(this,pM);if(E!==void 0&&_===p.executionId)this.value.setValue(E,p);else{const I=this._doOperation(p);p._setExecutionVariable(this,pM,I),p._setExecutionVariable(this,_M,p.executionId),this.value.setValue(I,p)}}}class w0 extends _g{constructor(p,_,E,I,Z,re){super(E,re),this._operation=I,this._className=Z,this.a=this.registerDataInput("a",p),this.b=this.registerDataInput("b",_)}_doOperation(p){return this._operation(this.a.getValue(p),this.b.getValue(p))}getClassName(){return this._className}}class Tm extends _g{constructor(p,_,E,I){super(p,I),this._operation=_,this._className=E}_doOperation(p){return this._operation()}getClassName(){return this._className}}class Xn extends _g{constructor(p,_,E,I,Z){super(_,Z),this._operation=E,this._className=I,this.a=this.registerDataInput("a",p)}_doOperation(p){return this._operation(this.a.getValue(p))}getClassName(){return this._className}}class ay extends _g{constructor(p,_,E,I,Z,re,ae){super(I,ae),this._operation=Z,this._className=re,this.a=this.registerDataInput("a",p),this.b=this.registerDataInput("b",_),this.c=this.registerDataInput("c",E)}_doOperation(p){return this._operation(this.a.getValue(p),this.b.getValue(p),this.c.getValue(p))}getClassName(){return this._className}}function ax(pe){return pe.getClassName?pe.getClassName():""}function vm(pe,p){return pe==="Vector2"&&p==="Vector2"||pe==="Vector3"&&p==="Vector3"||pe==="Vector4"&&p==="Vector4"}function Rm(pe,p){return pe==="Matrix"&&p==="Matrix"}function Mm(pe,p){return pe==="FlowGraphInteger"&&p==="FlowGraphInteger"}class xd extends w0{constructor(p){super(zs,zs,zs,(_,E)=>this._polymorphicAdd(_,E),xd.ClassName,p)}_polymorphicAdd(p,_){const E=ax(p),I=ax(_);return vm(E,I)||Rm(E,I)||Mm(E,I)?p.add(_):p+_}}xd.ClassName="FGAddBlock",Gs(xd.ClassName,xd);class ld extends w0{constructor(p){super(zs,zs,zs,(_,E)=>this._polymorphicAdd(_,E),ld.ClassName,p)}_polymorphicAdd(p,_){const E=ax(p),I=ax(_);return vm(E,I)||Mm(E,I)?p.subtract(_):Rm(E,I)?p.add(_.scale(-1)):p-_}}ld.ClassName="FGSubBlock",Gs(ld.ClassName,ld);class hd extends w0{constructor(p){super(zs,zs,zs,(_,E)=>this._polymorphicMultiply(_,E),hd.ClassName,p)}_polymorphicMultiply(p,_){const E=ax(p),I=ax(_);return vm(E,I)||Mm(E,I)?p.multiply(_):Rm(E,I)?jt.FromValues(p.m[0]*_.m[0],p.m[4]*_.m[4],p.m[8]*_.m[8],p.m[12]*_.m[12],p.m[1]*_.m[1],p.m[5]*_.m[5],p.m[9]*_.m[9],p.m[13]*_.m[13],p.m[2]*_.m[2],p.m[6]*_.m[6],p.m[10]*_.m[10],p.m[14]*_.m[14],p.m[3]*_.m[3],p.m[7]*_.m[7],p.m[11]*_.m[11],p.m[15]*_.m[15]):p*_}}hd.ClassName="FGMultiplyBlock",Gs(hd.ClassName,hd);class cd extends w0{constructor(p){super(zs,zs,zs,(_,E)=>this._polymorphicDivide(_,E),cd.ClassName,p)}_polymorphicDivide(p,_){const E=ax(p),I=ax(_);return vm(E,I)||Mm(E,I)?p.divide(_):Rm(E,I)?jt.FromValues(p.m[0]/_.m[0],p.m[4]/_.m[4],p.m[8]/_.m[8],p.m[12]/_.m[12],p.m[1]/_.m[1],p.m[5]/_.m[5],p.m[9]/_.m[9],p.m[13]/_.m[13],p.m[2]/_.m[2],p.m[6]/_.m[6],p.m[10]/_.m[10],p.m[14]/_.m[14],p.m[3]/_.m[3],p.m[7]/_.m[7],p.m[11]/_.m[11],p.m[15]/_.m[15]):p/_}}cd.ClassName="FGDivideBlock",Gs(cd.ClassName,cd);class ud extends Tm{constructor(p){super(M0,()=>Math.random(),ud.ClassName,p)}}ud.ClassName="FGRandomBlock",Gs(ud.ClassName,ud);class pd extends w0{constructor(p){super(zs,zs,M0,(_,E)=>this._polymorphicDot(_,E),pd.ClassName,p)}_polymorphicDot(p,_){switch(ax(p)){case"Vector2":return xr.Dot(p,_);case"Vector3":return at.Dot(p,_);case"Vector4":return Lr.Dot(p,_);default:throw new Error(`Cannot get dot product of ${p} and ${_}`)}}}pd.ClassName="FGDotBlock",Gs(pd.ClassName,pd);class _d extends Tm{constructor(p){super(M0,()=>Math.E,_d.ClassName,p)}}_d.ClassName="FGEBlock",Gs(_d.ClassName,_d);class Td extends Tm{constructor(p){super(M0,()=>Math.PI,Td.ClassName,p)}}Td.ClassName="FGPIBlock",Gs(Td.ClassName,Td);class vd extends Tm{constructor(p){super(M0,()=>Number.POSITIVE_INFINITY,vd.ClassName,p)}}vd.ClassName="FGInfBlock",Gs(vd.ClassName,vd);class Rd extends Tm{constructor(p){super(M0,()=>Number.NaN,Rd.ClassName,p)}}Rd.ClassName="FGNaNBlock",Gs(Rd.ClassName,Rd);function za(pe,p){switch(ax(pe)){case"FlowGraphInteger":return new qa(p(pe.value));case"Vector2":return new xr(p(pe.x),p(pe.y));case"Vector3":return new at(p(pe.x),p(pe.y),p(pe.z));case"Vector4":return new Lr(p(pe.x),p(pe.y),p(pe.z),p(pe.w));case"Matrix":return jt.FromValues(p(pe.m[0]),p(pe.m[4]),p(pe.m[8]),p(pe.m[12]),p(pe.m[1]),p(pe.m[5]),p(pe.m[9]),p(pe.m[13]),p(pe.m[2]),p(pe.m[6]),p(pe.m[10]),p(pe.m[14]),p(pe.m[3]),p(pe.m[7]),p(pe.m[11]),p(pe.m[15]));default:return p(pe)}}class Md extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicAbs(_),Md.ClassName,p)}_polymorphicAbs(p){return za(p,Math.abs)}}Md.ClassName="FGAbsBlock",Gs(Md.ClassName,Md);class wd extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicSign(_),wd.ClassName,p)}_polymorphicSign(p){return za(p,Math.sign)}}wd.ClassName="FGSignBlock",Gs(wd.ClassName,wd);class Ld extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicTrunc(_),Ld.ClassName,p)}_polymorphicTrunc(p){return za(p,Math.trunc)}}Ld.ClassName="FGTruncBlock",Gs(Ld.ClassName,Ld);class kd extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicFloor(_),kd.ClassName,p)}_polymorphicFloor(p){return za(p,Math.floor)}}kd.ClassName="FGFloorBlock",Gs(kd.ClassName,kd);class Ud extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicCeiling(_),Ud.ClassName,p)}_polymorphicCeiling(p){return za(p,Math.ceil)}}Ud.ClassName="FGCeilBlock",Gs(Ud.ClassName,Ud);class Gd extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicFract(_),Gd.ClassName,p)}_polymorphicFract(p){return za(p,_=>_-Math.floor(_))}}Gd.ClassName="FGFractBlock",Gs(Gd.ClassName,Gd);class zd extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicNeg(_),zd.ClassName,p)}_polymorphicNeg(p){return za(p,_=>-_)}}zd.ClassName="FGNegBlock",Gs(zd.ClassName,zd);function wm(pe,p,_){switch(ax(pe)){case"FlowGraphInteger":return new qa(_(pe.value,p.value));case"Vector2":return new xr(_(pe.x,p.x),_(pe.y,p.y));case"Vector3":return new at(_(pe.x,p.x),_(pe.y,p.y),_(pe.z,p.z));case"Vector4":return new Lr(_(pe.x,p.x),_(pe.y,p.y),_(pe.z,p.z),_(pe.w,p.w));case"Matrix":return jt.FromValues(_(pe.m[0],p.m[0]),_(pe.m[4],p.m[4]),_(pe.m[8],p.m[8]),_(pe.m[12],p.m[12]),_(pe.m[1],p.m[1]),_(pe.m[5],p.m[5]),_(pe.m[9],p.m[9]),_(pe.m[13],p.m[13]),_(pe.m[2],p.m[2]),_(pe.m[6],p.m[6]),_(pe.m[10],p.m[10]),_(pe.m[14],p.m[14]),_(pe.m[3],p.m[3]),_(pe.m[7],p.m[7]),_(pe.m[11],p.m[11]),_(pe.m[15],p.m[15]));default:return _(pe,p)}}class Wd extends w0{constructor(p){super(zs,zs,zs,(_,E)=>this._polymorphicRemainder(_,E),Wd.ClassName,p)}_polymorphicRemainder(p,_){return wm(p,_,(E,I)=>E%I)}}Wd.ClassName="FGRemainderBlock",Gs(Wd.ClassName,Wd);class Hd extends w0{constructor(p){super(zs,zs,zs,(_,E)=>this._polymorphicMin(_,E),Hd.ClassName,p)}_polymorphicMin(p,_){return wm(p,_,Math.min)}}Hd.ClassName="FGMinBlock",Gs(Hd.ClassName,Hd);class Xd extends w0{constructor(p){super(zs,zs,zs,(_,E)=>this._polymorphicMax(_,E),Xd.ClassName,p)}_polymorphicMax(p,_){return wm(p,_,Math.max)}}Xd.ClassName="FGMaxBlock",Gs(Xd.ClassName,Xd);function hL(pe,p,_){return Math.min(Math.max(pe,Math.min(p,_)),Math.max(p,_))}function TM(pe,p,_,E){switch(ax(pe)){case"FlowGraphInteger":return new qa(E(pe.value,p.value,_.value));case"Vector2":return new xr(E(pe.x,p.x,_.x),E(pe.y,p.y,_.y));case"Vector3":return new at(E(pe.x,p.x,_.x),E(pe.y,p.y,_.y),E(pe.z,p.z,_.z));case"Vector4":return new Lr(E(pe.x,p.x,_.x),E(pe.y,p.y,_.y),E(pe.z,p.z,_.z),E(pe.w,p.w,_.w));case"Matrix":return jt.FromValues(E(pe.m[0],p.m[0],_.m[0]),E(pe.m[4],p.m[4],_.m[4]),E(pe.m[8],p.m[8],_.m[8]),E(pe.m[12],p.m[12],_.m[12]),E(pe.m[1],p.m[1],_.m[1]),E(pe.m[5],p.m[5],_.m[5]),E(pe.m[9],p.m[9],_.m[9]),E(pe.m[13],p.m[13],_.m[13]),E(pe.m[2],p.m[2],_.m[2]),E(pe.m[6],p.m[6],_.m[6]),E(pe.m[10],p.m[10],_.m[10]),E(pe.m[14],p.m[14],_.m[14]),E(pe.m[3],p.m[3],_.m[3]),E(pe.m[7],p.m[7],_.m[7]),E(pe.m[11],p.m[11],_.m[11]),E(pe.m[15],p.m[15],_.m[15]));default:return E(pe,p,_)}}class Yd extends ay{constructor(p){super(zs,zs,zs,zs,(_,E,I)=>this._polymorphicClamp(_,E,I),Yd.ClassName,p)}_polymorphicClamp(p,_,E){return TM(p,_,E,hL)}}Yd.ClassName="FGClampBlock",Gs(Yd.ClassName,Yd);function cL(pe){return Math.min(Math.max(pe,0),1)}class Kd extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicSaturate(_),Kd.ClassName,p)}_polymorphicSaturate(p){return za(p,cL)}}Kd.ClassName="FGSaturateBlock",Gs(Kd.ClassName,Kd);class jd extends ay{constructor(p){super(zs,zs,zs,zs,(_,E,I)=>this._polymorphicInterpolate(_,E,I),jd.ClassName,p)}_interpolate(p,_,E){return(1-E)*p+E*_}_polymorphicInterpolate(p,_,E){return TM(p,_,E,this._interpolate)}}jd.ClassName="FGInterpolateBlock",Gs(jd.ClassName,jd);class qd extends w0{constructor(p){super(zs,zs,ch,(_,E)=>this._polymorphicEq(_,E),qd.ClassName,p)}_polymorphicEq(p,_){const E=ax(p),I=ax(_);return vm(E,I)||Rm(E,I)||Mm(E,I)?p.equals(_):p===_}}qd.ClassName="FGEqBlock",Gs(qd.ClassName,qd);function Tg(pe,p,_){const E=ax(pe),I=ax(p);if(E===I){if(E==="")return _(pe,p);if(E==="FlowGraphInteger")return _(pe.value,p.value);throw new Error(`Cannot compare ${pe} and ${p}`)}throw new Error(`${pe} and ${p} are of different types.`)}class $d extends w0{constructor(p){super(zs,zs,ch,(_,E)=>this._polymorphicLessThan(_,E),$d.ClassName,p)}_polymorphicLessThan(p,_){return Tg(p,_,(E,I)=>E<I)}}$d.ClassName="FGLessThanBlock",Gs($d.ClassName,$d);class vg extends w0{constructor(p){super(zs,zs,ch,(_,E)=>this._polymorphicLessThanOrEqual(_,E),vg.ClassName,p)}_polymorphicLessThanOrEqual(p,_){return Tg(p,_,(E,I)=>E<=I)}}vg.ClassName="FGLessThanOrEqualBlock";class rf extends w0{constructor(p){super(zs,zs,ch,(_,E)=>this._polymorphicGreaterThan(_,E),rf.ClassName,p)}_polymorphicGreaterThan(p,_){return Tg(p,_,(E,I)=>E>I)}}rf.ClassName="FGGreaterThanBlock",Gs(rf.ClassName,rf);class nf extends w0{constructor(p){super(zs,zs,ch,(_,E)=>this._polymorphicGreaterThanOrEqual(_,E),nf.ClassName,p)}_polymorphicGreaterThanOrEqual(p,_){return Tg(p,_,(E,I)=>E>=I)}}nf.ClassName="FGGreaterThanOrEqualBlock",Gs(nf.ClassName,nf);class af extends Xn{constructor(p){super(zs,ch,_=>this._polymorphicIsNan(_),af.ClassName,p)}_polymorphicIsNan(p){const _=ax(p);if(_==="")return isNaN(p);if(_==="FlowGraphInteger")return isNaN(p.value);throw new Error(`Cannot get NaN of ${p}`)}}af.ClassName="FGIsNanBlock",Gs(af.ClassName,af);class Rg extends Xn{constructor(p){super(zs,ch,_=>this._polymorphicIsInf(_),Rg.ClassName,p)}_polymorphicIsInf(p){const _=ax(p);if(_==="")return!isFinite(p);if(_==="FlowGraphInteger")return!isFinite(p.value);throw new Error(`Cannot get isInf of ${p}`)}}Rg.ClassName="FGIsInfBlock";class xf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicDegToRad(_),xf.ClassName,p)}_degToRad(p){return p*Math.PI/180}_polymorphicDegToRad(p){return za(p,this._degToRad)}}xf.ClassName="FGDegToRadBlock",Gs(xf.ClassName,xf);class lf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicRadToDeg(_),lf.ClassName,p)}_radToDeg(p){return p*180/Math.PI}_polymorphicRadToDeg(p){return za(p,this._radToDeg)}}lf.ClassName="FGRadToDegBlock",Gs(lf.ClassName,lf);class hf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicSin(_),hf.ClassName,p)}_polymorphicSin(p){return za(p,Math.sin)}}hf.ClassName="FGSinBlock",Gs(hf.ClassName,hf);class cf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicCos(_),cf.ClassName,p)}_polymorphicCos(p){return za(p,Math.cos)}}cf.ClassName="FGCosBlock",Gs(cf.ClassName,cf);class uf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicTan(_),uf.ClassName,p)}_polymorphicTan(p){return za(p,Math.tan)}}uf.ClassName="FGTanBlock",Gs(uf.ClassName,uf);class pf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicAsin(_),pf.ClassName,p)}_polymorphicAsin(p){return za(p,Math.asin)}}pf.ClassName="FGAsinBlock",Gs(pf.ClassName,pf);class _f extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicAcos(_),_f.ClassName,p)}_polymorphicAcos(p){return za(p,Math.acos)}}_f.ClassName="FGAcosBlock",Gs(_f.ClassName,_f);class Tf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicAtan(_),Tf.ClassName,p)}_polymorphicAtan(p){return za(p,Math.atan)}}Tf.ClassName="FGAtanBlock",Gs(Tf.ClassName,Tf);class vf extends w0{constructor(p){super(zs,zs,zs,(_,E)=>this._polymorphicAtan2(_,E),vf.ClassName,p)}_polymorphicAtan2(p,_){return wm(p,_,Math.atan2)}}vf.ClassName="FGAtan2Block",Gs(vf.ClassName,vf);class Rf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicSinh(_),Rf.ClassName,p)}_polymorphicSinh(p){return za(p,Math.sinh)}}Rf.ClassName="FGSinhBlock",Gs(Rf.ClassName,Rf);class Mf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicCosh(_),Mf.ClassName,p)}_polymorphicCosh(p){return za(p,Math.cosh)}}Mf.ClassName="FGCoshBlock",Gs(Mf.ClassName,Mf);class wf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicTanh(_),wf.ClassName,p)}_polymorphicTanh(p){return za(p,Math.tanh)}}wf.ClassName="FGTanhBlock",Gs(wf.ClassName,wf);class Lf extends Xn{constructor(p){super(zs,M0,_=>this._polymorphicAsinh(_),Lf.ClassName,p)}_polymorphicAsinh(p){return za(p,Math.asinh)}}Lf.ClassName="FGAsinhBlock",Gs(Lf.ClassName,Lf);class kf extends Xn{constructor(p){super(zs,M0,_=>this._polymorphicAcosh(_),kf.ClassName,p)}_polymorphicAcosh(p){return za(p,Math.acosh)}}kf.ClassName="FGAcoshBlock",Gs(kf.ClassName,kf);class Uf extends Xn{constructor(p){super(zs,M0,_=>this._polymorphicAtanh(_),Uf.ClassName,p)}_polymorphicAtanh(p){return za(p,Math.atanh)}}Uf.ClassName="FGAtanhBlock",Gs(Uf.ClassName,Uf);class Gf extends Xn{constructor(p){super(zs,M0,_=>this._polymorphicExp(_),Gf.ClassName,p)}_polymorphicExp(p){return za(p,Math.exp)}}Gf.ClassName="FGExpBlock",Gs(Gf.ClassName,Gf);class zf extends Xn{constructor(p){super(zs,M0,_=>this._polymorphicLog(_),zf.ClassName,p)}_polymorphicLog(p){return za(p,Math.log)}}zf.ClassName="FGLogBlock",Gs(zf.ClassName,zf);class Wf extends Xn{constructor(p){super(zs,M0,_=>this._polymorphicLog2(_),Wf.ClassName,p)}_polymorphicLog2(p){return za(p,Math.log2)}}Wf.ClassName="FGLog2Block",Gs(Wf.ClassName,Wf);class Hf extends Xn{constructor(p){super(zs,M0,_=>this._polymorphicLog10(_),Hf.ClassName,p)}_polymorphicLog10(p){return za(p,Math.log10)}}Hf.ClassName="FGLog10Block",Gs(Hf.ClassName,Hf);class Xf extends Xn{constructor(p){super(zs,M0,_=>this._polymorphicSqrt(_),Xf.ClassName,p)}_polymorphicSqrt(p){return za(p,Math.sqrt)}}Xf.ClassName="FGSqrtBlock",Gs(Xf.ClassName,Xf);class Yf extends Xn{constructor(p){super(zs,M0,_=>this._polymorphicCubeRoot(_),Yf.ClassName,p)}_polymorphicCubeRoot(p){return za(p,Math.cbrt)}}Yf.ClassName="FGCubeRootBlock",Gs(Yf.ClassName,Yf);class Kf extends w0{constructor(p){super(zs,M0,M0,(_,E)=>this._polymorphicPow(_,E),Kf.ClassName,p)}_polymorphicPow(p,_){return wm(p,_,Math.pow)}}Kf.ClassName="FGPowBlock",Gs(Kf.ClassName,Kf);class jf extends Xn{constructor(p){super(zs,M0,_=>this._polymorphicLength(_),jf.ClassName,p)}_polymorphicLength(p){switch(ax(p)){case"Vector2":case"Vector3":case"Vector4":return p.length();default:throw new Error(`Cannot compute length of value ${p}`)}}}jf.ClassName="FGLengthBlock",Gs(jf.ClassName,jf);class qf extends Xn{constructor(p){super(zs,zs,_=>this._polymorphicNormalize(_),qf.ClassName,p)}_polymorphicNormalize(p){switch(ax(p)){case"Vector2":case"Vector3":case"Vector4":return p.normalize();default:throw new Error(`Cannot normalize value ${p}`)}}}qf.ClassName="FGNormalizeBlock",Gs(qf.ClassName,qf);class $f extends w0{constructor(p){super(qc,qc,qc,(_,E)=>at.Cross(_,E),$f.ClassName,p)}}$f.ClassName="FGCrossBlock",Gs($f.ClassName,$f);class rp extends w0{constructor(p){super(Z_,M0,Z_,(_,E)=>xr.Transform(_,jt.RotationZ(E)),rp.ClassName,p)}}rp.ClassName="FGRotate2DBlock",Gs(rp.ClassName,rp);class np extends ay{constructor(p){super(qc,qc,M0,qc,(_,E,I)=>at.TransformCoordinates(_,jt.RotationAxis(E,I)),np.ClassName,p)}}np.ClassName="FGRotate3DBlock",Gs(np.ClassName,np);class ap extends Xn{constructor(p){super(nc,nc,_=>jt.Transpose(_),ap.ClassName,p)}}ap.ClassName="FGTransposeBlock",Gs(ap.ClassName,ap);class xp extends Xn{constructor(p){super(nc,M0,_=>_.determinant(),xp.ClassName,p)}}xp.ClassName="FGDeterminantBlock",Gs(xp.ClassName,xp);class op extends Xn{constructor(p){super(nc,nc,_=>jt.Invert(_),op.ClassName,p)}}op.ClassName="FGInvertMatrixBlock",Gs(op.ClassName,op);class lp extends w0{constructor(p){super(nc,nc,nc,(_,E)=>E.multiply(_),lp.ClassName,p)}}lp.ClassName="FGMatMulBlock",Gs(lp.ClassName,lp);class hp extends Xn{constructor(p){super(Xa,Xa,_=>new qa(~_.value),hp.ClassName,p)}}hp.ClassName="FGBitwiseNotBlock",Gs(hp.ClassName,hp);class cp extends w0{constructor(p){super(Xa,Xa,Xa,(_,E)=>new qa(_.value&E.value),cp.ClassName,p)}}cp.ClassName="FGBitwiseAndBlock",Gs(cp.ClassName,cp);class up extends w0{constructor(p){super(Xa,Xa,Xa,(_,E)=>new qa(_.value|E.value),up.ClassName,p)}}up.ClassName="FGBitwiseOrBlock",Gs(up.ClassName,up);class pp extends w0{constructor(p){super(Xa,Xa,Xa,(_,E)=>new qa(_.value^E.value),pp.ClassName,p)}}pp.ClassName="FGBitwiseXorBlock",Gs(pp.ClassName,pp);class _p extends w0{constructor(p){super(Xa,Xa,Xa,(_,E)=>new qa(_.value<<E.value),_p.ClassName,p)}}_p.ClassName="FGBitwiseLeftShiftBlock",Gs(_p.ClassName,_p);class Tp extends w0{constructor(p){super(Xa,Xa,Xa,(_,E)=>new qa(_.value>>E.value),Tp.ClassName,p)}}Tp.ClassName="FGBitwiseRightShiftBlock",Gs(Tp.ClassName,Tp);class vp extends Xn{constructor(p){super(Xa,Xa,_=>new qa(Math.clz32(_.value)),vp.ClassName,p)}}vp.ClassName="FGCountLeadingZerosBlock",Gs(vp.ClassName,vp);class Rp extends Xn{constructor(p){super(Xa,Xa,_=>new qa(_.value?31-Math.clz32(_.value&-_.value):32),Rp.ClassName,p)}}Rp.ClassName="FGCountTrailingZerosBlock",Gs(Rp.ClassName,Rp);function uL(pe){let p=0;for(;pe;)p+=pe&1,pe>>=1;return p}class Mp extends Xn{constructor(p){super(Xa,Xa,_=>new qa(uL(_.value)),Mp.ClassName,p)}}Mp.ClassName="FGCountOneBitsBlock",Gs(Mp.ClassName,Mp);class wp extends qu{constructor(p={startIndex:new qa(0)}){super(p),this.config=p,this.reset=this._registerSignalInput("reset"),this.n=this.registerDataInput("n",Xa),this.value=this.registerDataOutput("value",Xa)}_execute(p,_){if(_===this.reset)this.value.setValue(this.config.startIndex,p);else{const E=this.value.getValue(p);E.value<this.n.getValue(p).value&&(this.value.setValue(new qa(E.value+1),p),this.out._activateSignal(p))}}getClassName(){return wp.ClassName}}wp.ClassName="FGDoNBlock",Gs(wp.ClassName,wp);class Lp extends xm{constructor(p){super(p),this.config=p,this.output=this.registerDataOutput(p.variableName,zs)}_updateOutputs(p){const _=this.config.variableName;p.hasVariable(_)&&this.output.setValue(p.getVariable(_),p)}getClassName(){return Lp.ClassName}serialize(p){super.serialize(p),p.config.variableName=this.config.variableName}}Lp.ClassName="FGGetVariableBlock",Gs(Lp.ClassName,Lp);class kp extends qu{constructor(p){super(p),this.config=p,this.input=this.registerDataInput(p.variableName,zs)}_execute(p){const _=this.config.variableName,E=this.input.getValue(p);p.setVariable(_,E),this.out._activateSignal(p)}getClassName(){return kp.ClassName}}kp.ClassName="FGSetVariableBlock",Gs(kp.ClassName,kp);class Up extends qu{constructor(p){super(p),this.config=p,this.condition=this.registerDataInput("condition",ch),this.loopBody=this._registerSignalOutput("loopBody")}_execute(p,_){let E=this.condition.getValue(p);for(this.config?.isDo&&!E&&this.loopBody._activateSignal(p);E;)this.loopBody._activateSignal(p),E=this.condition.getValue(p);this.out._activateSignal(p)}getClassName(){return Up.ClassName}serialize(p){super.serialize(p),p.isDo=this.config?.isDo}}Up.ClassName="FGWhileLoopBlock",Gs(Up.ClassName,Up);const pL={"lifecycle/onStart":hm.ClassName,"lifecycle/onTick":ju.ClassName,log:$u.ClassName,"flow/delay":cm.ClassName,"customEvent/send":um.ClassName,"customEvent/receive":rd.ClassName,"flow/sequence":nd.ClassName,"world/get":ad.ClassName,"world/set":_m.ClassName,"flow/doN":wp.ClassName,"variable/get":Lp.ClassName,"variable/set":kp.ClassName,"flow/whileLoop":Up.ClassName,"math/random":ud.ClassName,"math/e":_d.ClassName,"math/pi":Td.ClassName,"math/inf":vd.ClassName,"math/nan":Rd.ClassName,"math/abs":Md.ClassName,"math/sign":wd.ClassName,"math/trunc":Ld.ClassName,"math/floor":kd.ClassName,"math/ceil":Ud.ClassName,"math/fract":Gd.ClassName,"math/neg":zd.ClassName,"math/add":xd.ClassName,"math/sub":ld.ClassName,"math/mul":hd.ClassName,"math/div":cd.ClassName,"math/rem":Wd.ClassName,"math/min":Hd.ClassName,"math/max":Xd.ClassName,"math/clamp":Yd.ClassName,"math/saturate":Kd.ClassName,"math/mix":jd.ClassName,"math/eq":qd.ClassName,"math/lt":$d.ClassName,"math/le":vg.ClassName,"math/gt":rf.ClassName,"math/ge":nf.ClassName,"math/isnan":af.ClassName,"math/isinf":Rg.ClassName,"math/rad":xf.ClassName,"math/deg":lf.ClassName,"math/sin":hf.ClassName,"math/cos":cf.ClassName,"math/tan":uf.ClassName,"math/asin":pf.ClassName,"math/acos":_f.ClassName,"math/atan":Tf.ClassName,"math/atan2":vf.ClassName,"math/sinh":Rf.ClassName,"math/cosh":Mf.ClassName,"math/tanh":wf.ClassName,"math/asinh":Lf.ClassName,"math/acosh":kf.ClassName,"math/atanh":Uf.ClassName,"math/exp":Gf.ClassName,"math/log":zf.ClassName,"math/log2":Wf.ClassName,"math/log10":Hf.ClassName,"math/sqrt":Xf.ClassName,"math/cbrt":Yf.ClassName,"math/pow":Kf.ClassName,"math/length":jf.ClassName,"math/normalize":qf.ClassName,"math/dot":pd.ClassName,"math/cross":$f.ClassName,"math/rotate2d":rp.ClassName,"math/rotate3d":np.ClassName,"math/transpose":ap.ClassName,"math/determinant":xp.ClassName,"math/inverse":op.ClassName,"math/matmul":lp.ClassName,"math/not":hp.ClassName,"math/and":cp.ClassName,"math/or":up.ClassName,"math/xor":pp.ClassName,"math/asr":Tp.ClassName,"math/lsl":_p.ClassName,"math/clz":vp.ClassName,"math/ctz":Rp.ClassName,"math/popcnt":Mp.ClassName},_L={float2:"Vector2",float3:"Vector3",float4:"Vector4",float4x4:"Matrix",int:"FlowGraphInteger"};function xy(pe,p,_){if(pe.type!==void 0){const E=p.types&&p.types[pe.type];if(!E)throw new Error(`${_}: Unknown type: ${pe.type}`);const I=E.signature;if(!I)throw new Error(`${_}: Type ${pe.type} has no signature`);const Z=_L[I];return{value:pe.value,className:Z}}else return pe.value}function TL(pe,p,_){const E={},I=pe.configuration??[];for(const Z of I)if(Z.id==="customEvent"){const re=p.customEvents&&p.customEvents[Z.value];if(!re)throw new Error(`/extensions/KHR_interactivity/nodes/${_}: Unknown custom event: ${Z.value}`);E.eventId=re.id,E.eventData=re.values.map(ae=>ae.id)}else if(Z.id==="variable"){const re=p.variables&&p.variables[Z.value];if(!re)throw new Error(`/extensions/KHR_interactivity/nodes/${_}: Unknown variable: ${Z.value}`);E.variableName=re.id}else if(Z.id==="path"){const re=Z.value;E.path=re}else E[Z.id]=xy(Z,p,`/extensions/KHR_interactivity/nodes/${_}`);return E}function vL(pe,p,_){const E=pL[p.type];if(!E)throw new Error(`/extensions/KHR_interactivity/nodes/${pe}: Unknown block type: ${p.type}`);const I=pe.toString(),Z=TL(p,_,I),re=p.metadata;return{className:E,config:Z,uniqueId:I,metadata:re,dataInputs:[],dataOutputs:[],signalInputs:[],signalOutputs:[]}}function RL(pe){const p={uniqueId:Y0(),_userVariables:{},_connectionValues:{}},_=[p],E=[];for(let Z=0;Z<pe.nodes.length;Z++){const re=pe.nodes[Z],ae=vL(Z,re,pe);E.push(ae)}for(let Z=0;Z<pe.nodes.length;Z++){const re=pe.nodes[Z],ae=E[Z],he=re.flows??[];for(const ve of he){const Le=ve.id,ze={uniqueId:Y0(),name:Le,_connectionType:To.Output,connectedPointIds:[]};ae.signalOutputs.push(ze);const He=ve.node,xt=ve.socket,rt=E[He];if(!rt)throw new Error(`/extensions/KHR_interactivity/nodes/${Z}: Could not find node with id ${He} that connects its input with with node ${Z}'s output ${Le}`);let Tt=rt.signalInputs.find(Lt=>Lt.name===xt);Tt||(Tt={uniqueId:Y0(),name:xt,_connectionType:To.Input,connectedPointIds:[]},rt.signalInputs.push(Tt)),Tt.connectedPointIds.push(ze.uniqueId),ze.connectedPointIds.push(Tt.uniqueId)}const _e=re.values??[];for(const ve of _e){const Le=ve.id,ze={uniqueId:Y0(),name:Le,_connectionType:To.Input,connectedPointIds:[]};if(ae.dataInputs.push(ze),ve.value!==void 0){const He=xy(ve,pe,`/extensions/KHR_interactivity/nodes/${Z}`);p._connectionValues[ze.uniqueId]=He}else if(ve.node!==void 0&&ve.socket!==void 0){const He=ve.node,xt=ve.socket,rt=E[He];if(!rt)throw new Error(`/extensions/KHR_interactivity/nodes/${Z}: Could not find node with id ${He} that connects its output with node${Z}'s input ${Le}`);let Tt=rt.dataOutputs.find(Lt=>Lt.name===xt);Tt||(Tt={uniqueId:Y0(),name:xt,_connectionType:To.Output,connectedPointIds:[]},rt.dataOutputs.push(Tt)),ze.connectedPointIds.push(Tt.uniqueId),Tt.connectedPointIds.push(ze.uniqueId)}else throw new Error(`/extensions/KHR_interactivity/nodes/${Z}: Invalid socket ${Le} in node ${Z}`)}}const I=pe.variables??[];for(let Z=0;Z<I.length;Z++){const re=I[Z],ae=re.id;p._userVariables[ae]=xy(re,pe,`/extensions/KHR_interactivity/variables/${Z}`)}return{allBlocks:E,executionContexts:_}}class ML extends nM{constructor(p){super(p,wL)}}const wL={nodes:{__array__:{__target__:!0,translation:{type:"Vector3",get:pe=>pe._babylonTransformNode.position,set:(pe,p)=>{const _=p._babylonTransformNode;_.position=pe},getObject(pe){return pe._babylonTransformNode}}}}},ly="KHR_interactivity";class LL{constructor(p){this._loader=p,this.name=ly,this.enabled=this._loader.isExtensionUsed(ly),this._pathConverter=new ML(this._loader.gltf)}dispose(){this._loader=null,delete this._pathConverter}onReady(){if(!this._loader.babylonScene||!this._pathConverter)return;const p=this._loader.babylonScene,_=this._loader.gltf.extensions?.KHR_interactivity,E=RL(_),I=new Ku({scene:p});Yu.Parse(E,{coordinator:I,pathConverter:this._pathConverter}),I.start()}}js.RegisterExtension(ly,pe=>new LL(pe));const vM="ExtrasAsMetadata";class kL{_assignExtras(p,_){if(_.extras&&Object.keys(_.extras).length>0){const E=p.metadata=p.metadata||{},I=E.gltf=E.gltf||{};I.extras=_.extras}}constructor(p){this.name=vM,this.enabled=!0,this._loader=p}dispose(){this._loader=null}loadNodeAsync(p,_,E){return this._loader.loadNodeAsync(p,_,I=>{this._assignExtras(I,_),E(I)})}loadCameraAsync(p,_,E){return this._loader.loadCameraAsync(p,_,I=>{this._assignExtras(I,_),E(I)})}createMaterial(p,_,E){const I=this._loader.createMaterial(p,_,E);return this._assignExtras(I,_),I}}js.RegisterExtension(vM,pe=>new kL(pe));class UL extends qP{constructor(p,_,E,I="watch.glb"){super(p,_,E),this.url=I,this.points=[],this.aligner=new jw,this.addPlugin(this.aligner)}async load(){const{scene:p}=this;if(this.loaded||!p)return;p.environmentTexture=new Rx("environment.env",p);const _=new W2("directional",new at(.5,.5,-2),p);return await this.setModel(this.url),super.load()}async setModel(p){if(this.aligner.setNode(),this.model?.dispose(!1,!0),delete this.model,this.url=p,!this.url)return;const _=await wn.LoadAssetContainerAsync("",p,this.scene,void 0,".glb");if(this.model=_.meshes.find(I=>I.id==="__root__"),!this.model)return;this.aligner.setNode(this.model),_.addAllToScene(),_.meshes.filter(I=>/Body/.test(I.name)).forEach(I=>{I.material=new zT("Occluder",this.scene)})}}const Mg=new h0,GL="5zUXNTvrFMDtqB0rox5FlQf8Vg1jxtbe",zL="iV6ssLqhZ4zTG6CXXRa28gNZOwvHje_E",RM=location.hostname==="localhost"?GL:zL,MM=new URLSearchParams(window.location.search),wM=MM.has("rear");async function WL(pe){const p=document.getElementById("root");if(!p){console.error("Root container not found.");return}const _=new UL(p,"crop",!wM,pe);try{if(!RM)throw new Error("Token is not defined.");await Promise.all([Mg.addRenderer(_),Mg.init({token:RM})]),await Mg.setup({size:{width:1920,height:1080},rear:wM}),await Mg.start()}catch(E){console.error("Error initializing the engine:",E)}}const LM=MM.get("watch");LM&&WL(LM)})()})();
